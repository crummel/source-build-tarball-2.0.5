<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind an dieser Stelle für Typabkürzungen nicht zulässig.</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Die statische Verknüpfung darf keine EXE-Datei einschließen.</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>Die {0}-Eigenschaft ist nicht lesbar.</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Use-Bindungen müssen das Format "use &lt;var&gt; = &lt;Ausdruck&gt;" aufweisen.</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler, Version {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Auf das Datensatz-, Struktur- oder Klassenfeld "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Ungültiger Member '{0}' für Anbietertyp '{1}'. Die angegebenen Typmember müssen öffentlich, nicht jedoch generisch, virtuell oder abstrakt sein.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>"{{ }}" ist kein gültiger Ausdruck. Datensätze müssen mindestens ein Feld umfassen. Leere Sequenzen werden mit "Seq.empty" oder einer leeren Liste "[]" angegeben.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Der dynamische Aufruf von {0} wird nicht unterstützt.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralEquality-Attribut versehen, aber der Typparameter "{1}" erfüllt die equality-Einschränkung nicht. Fügen Sie dem Typparameter die equality-Einschränkung hinzu.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralEquality-Attribut versehen, aber der Komponententyp "{1}" erfüllt die equality-Einschränkung nicht.</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Verwenden Sie stattdessen einen separaten Datensatztyp.</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>Die Adresse der Variablen "{0}" kann an dieser Stelle nicht verwendet werden. Eine Methode oder Funktion gibt ggf. nicht die Adresse dieses lokalen Werts zurück.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Assembly "{0}" kann nicht gelesen werden.</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Für ein generisches Konstrukt muss der Typ "{0}" ein CLI- oder F#-Strukturtyp sein.</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Typanbieter '{0}' hat von GetInvokerExpression NULL zurückgegeben.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Mehrere Verweise auf "{0}.dll" sind nicht zulässig</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Anführungszeichen-Operatorname stimmt nicht überein, beginnt mit "{0}".</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Gibt eine Methode an, die entweder im Typ, in dem sie deklariert wird, über keine Implementierung verfügt oder die virtuell ist und über eine Standardimplementierung verfügt.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Eine statische Verknüpfung darf eine gemischte verwaltete/nicht verwaltete DLL nicht einschließen.</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Beschränkt den Zugriff eines Element auf Code im gleichen Typ oder Modul.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Der Typ "{0}" ist mit keinem der Typen "{1}" kompatibel; dies ist die Folge der Verwendung einer printf-Formatzeichenfolge.</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Erweiterungsmember können keine Operatorüberladungen bereitstellen. Definieren Sie den Operator stattdessen als Teil der Typdefinition.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung der Variablen "{0}" ist ungültig.</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>"{0}" darf nur für Konstruktobjekttypen verwendet werden.</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Unerwartetes Token "{0}" oder unvollständiger Ausdruck</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' kann nicht als Feldname verwendet werden</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Für den Getter oder Setter der Eigenschaft wurden mehrere Zugriffsebenen angegeben.</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Konstruktoren müssen auf Argumente angewendet werden und dürfen nicht als Werte der ersten Klasse verwendet werden. Verwenden Sie bei Bedarf eine anonyme Funktion "(fun arg1 ... argN -&gt; new Type(arg1,...,argN))".</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Ungültige Versionsdatei "{0}".</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Rekursive Bindungen mit Memberspezifikationen dürfen nur als direkte Augmentation eines Typs auftreten.</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Ungültiger rekursiver Verweis auf einen abstrakten Umsetzungsplatz.</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Anführungszeichen dürfen keinen Inlineassemblycode oder Mustervergleich für Arrays enthalten.</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Objekte müssen von einem Objektkonstruktionsausdruck initialisiert werden, der einen geerbten Objektkonstruktor aufruft und jedem Feld einen Wert zuweist.</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Argumente für Abfrageoperatoren erfordern möglicherweise Klammern, z. B. 'where (x &gt; y)' oder 'groupBy (x.Length / 10)'.</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Warnstufe (0-5) bestimmen</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Diesen Hilfetext anzeigen (Kurzform: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>System.Runtime.InteropServices-Assembly erfordert Verwendung von UnknownWrapper\DispatchWrapper-Klassen.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>Modul</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Ungültiger Ausdruck auf der linken Seite der Zuweisung.</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Ungültige Inlinespezifikation</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Begrenzt ein typisiertes Codezitat.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet wird nur in Analysestrukturen erwartet.</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problem mit Dateinamen '{0}': Ungültige Zeichen im Pfad.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(Die Beschreibung wird geladen…)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die comparison-Einschränkung nicht, weil es sich um einen Datensatz, eine Union oder Struktur mit mindestens einem Strukturelementtyp handelt, der die comparison-Einschränkung nicht unterstützt. Verwenden Sie entweder keinen Vergleich in Verbindung mit diesem Typ, oder fügen Sie dem Typ das StructuralComparison-Attribut hinzu, um festzustellen, von welchem Feldtyp der Vergleich nicht unterstützt wird.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die comparison-Einschränkung nicht. Beispielsweise unterstützt er die System.IComparable-Schnittstelle nicht.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die comparison-Einschränkung nicht, weil er das NoComparison-Attribut aufweist.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>Das Attribut "System.Diagnostics.ConditionalAttribute" ist nur bei Methoden oder Attributklassen gültig.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil die CLI-Darstellungen unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Syntaxfehler in Typargument mit Bezeichnung.</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Eine Eigenschaft darf keine expliziten Typparameter aufweisen. Verwenden Sie stattdessen eine Methode.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Ausgabemeldungen in UTF-8-Codierung</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Ein Modul und eine Typdefinition namens "{0}" erscheinen im Namespace "{1}" in zwei Teilen dieser Assembly.</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Der Name "{0}" ist im Musterkontext nicht gebunden.</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Der Typanbieterkonstruktor hat eine Ausnahme ausgelöst: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Unbekannte Art des statischen Arguments "{0}" beim Auflösen eines Verweises zum angegebenen Typ oder zur angegebenen Methode "{1}".</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>Für die Definition des benutzerdefinierten Operatoren '{0}' wird keine gültige Kombination von Attributflags verwendet.</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} wurde als statische Methode dargestellt, war aber kein geeigneter lambda-Ausdruck.</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 8-Bit-Integer ohne Vorzeichen.</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Attribute wurden in diesem Konstrukt ignoriert.</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' muss von 'in' gefolgt werden. Verwendung: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IEquatable&lt;_&gt;-Schnittstelle explizit. Wenden Sie das CustomEquality-Attribut auf den Typ an, und stellen Sie eine einheitliche Implementierung der nicht generischen System.Object.Equals(obj)-Überschreibung bereit.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Die Quelldatei ist zu groß, um in eine portable PDB eingebettet zu werden.</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Ein Objektkonstruktor erfordert ein Argument.</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Fehler beim Lesen/Schreiben von Metadaten für die kompilierte F#-DLL "{0}". Wurde die DLL mit einer früheren Version des F#-Compilers kompiliert? (Fehler: "{1}").</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Schnittstellen dürfen keine Definitionen von Memberüberschreibungen enthalten.</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Für diesen Bezeichner wurden mehrere Sichtbarkeitsattribute angegeben.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil es sich bei der Signatur um eine abstrakte Klasse handelt, bei der Implementierung hingegen nicht. Fügen Sie der Implementierung ggf. das [&lt;AbstractClass&gt;]-Attribut hinzu.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Der angegebene Typ '{0}' verfügt über einen Member '{1}' mit dem deklarierenden Typ '{2}'. Es wurde als deklarierender Typ derselbe wie der angegebene Typ erwartet.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Keine Entsprechung für "class", "interface" oder "struct".</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Wird verwendet, um einen Namen einer Gruppe zugehöriger Typen und Module zuzuordnen, um ihn logisch von anderem Code zu trennen.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>Der Namespace oder das Modul "{0}" ist nicht definiert.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Dieser Union-Fall akzeptiert ein Argument.</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Unerwartete moduleDefn-Liste mit leerem Typ.</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Wird für boolesche Bedingungen (when-Klausel) bei Musterabgleichen sowie zum Einführen einer Einschränkungsklausel für einen generischen Typparameterparameter verwendet.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Wird zusammen mit dem Vergleichsschlüsselwort in Musterabgleichsausdrücken verwendet. Wird auch in Objektausdrücken, Datensatzkopierausdrücken und Typerweiterungen verwendet, um Memberdefinitionen und Ausnahmehandler bereitzustellen.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Gibt den .NET-void-Typ an. Wird bei der Interaktion mit anderen .NET-Sprachen verwendet.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Wird in Bedingungsausdrücken verwendet. Wird auch verwendet, um nach der Objektkonstruktion Nebeneffekte auszuführen.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Wird verwendet, um Klassen, Datensätze, Strukturen, Unterscheidungs-Unions, Enumerationstypen, Maßeinheiten oder Typenabkürzungen zu deklarieren.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Wird verwendet, um den Inhalt eines Namespace oder Moduls ohne Qualifizierung verfügbar zu machen.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Gibt die Abwesenheit eines Objekts an. Wird auch in generischen Parameterbeschränkungen verwendet.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Konvertiert einen Typ in einen Typen, der in der Hierarchie höher ist.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Wird als Name des Basisklassenobjekts verwendet.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Wird verwendet, um eine Berechnung festzulegen, die nur ausgeführt wird, wenn ein Ergebnis erforderlich ist.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Wird in Verzweigungskonstrukten verwendet.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Wird in Verzweigungskonstrukten verwendet. Eine Kurzform von "else if".</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>Gibt in ausführlicher Syntax das Ende eines Codeblocks in einem Schleifenausdruck an.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Ein Verweis auf die DLL "{0}" ist für die Assembly "{1}" erforderlich. Der importierte Typ "{2}" befindet sich in der ersten Assembly und konnte nicht aufgelöst werden.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Gleitkommastellen.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Typdefinitionen dürfen nur eine inherit-Angabe aufweisen, und diese muss die erste Deklaration sein.</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Literalwerte dürfen keine generischen Parameter aufweisen.</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Unerwarteter Anführungszeichen-Operator '&lt;@' in der Typdefinition. Wenn eine ausführliche Zeichenfolge als statisches Argument an einen Typanbieter übergeben werden soll, fügen Sie zwischen den Zeichen '&lt;' und '@' eine Leerstelle ein.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Implementieren Sie zum Definieren der überladenen Vergleichssemantik für einen bestimmten Typ die System.IComparable-Schnittstelle in der Definition dieses Typs.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Methoden mit Curry-Argumenten dürfen keine out-, ParamArray-, optional-, ReflectedDefinition-, byref-, CallerLineNumber-, CallerMemberName- oder CallerFilePath-Argumente deklarieren.</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>Die Option "--pdb" macht die Verwendung der Option "--debug" erforderlich.</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>Der Wert "{0}" war als inline markiert, aber nicht in der Optimierungsumgebung gebunden.</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>Die {0}-Eigenschaft ist statisch.</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist strukturell nicht vergleichbar, weil der Typparameter "{1}" die comparison-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoComparison-Attribut hinzu, um eindeutig anzugeben, dass der Typ nicht verglichen werden kann.</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist strukturell nicht vergleichbar, weil der Typ "{1}" die comparison-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoComparison-Attribut hinzu, um eindeutig anzugeben, dass der Typ nicht verglichen werden kann.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Implementierung eine Struktur definiert ist, in der Signatur hingegen ein Typ mit einer verborgenen Darstellung.</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Hinweis: Auf Lambda-Lifting-Optimierungen wurde verzichtet, weil diese lokal eingeschränkte generische Funktion als Wert der ersten Klasse verwendet wird. Durch Hinzufügen von Typeinschränkungen lässt sich diese Bedingung möglicherweise auflösen.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>Die Verwendung von "let! x = coll" in Sequenzausdrücken ist nicht zulässig. Verwenden Sie stattdessen "for x in coll".</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie mutable-Modifizierer sind unterschiedlich.</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>Der Name der MDB-Datei muss &lt;assembly-datei-name&gt;.mdb lauten. Die --pdb-Option wird ignoriert.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie kompilierte Darstellung dieser Methode ist ein statischer Member, laut Signatur ist sie aber eine kompilierte Darstellung als Instanzmember.</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Das DllImport-Attribut konnte nicht decodiert werden.</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung des Schlüsselworts "base" ist ungültig. Base-Aufrufe können nicht in Abschlüssen verwendet werden. Verwenden Sie einen privaten Member für base-Aufrufe.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>"new" muss für einen benannten Typ verwendet werden.</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Für diese Typabkürzung ist mindestens ein Typparameter deklariert, der in dem abgekürzten Typ nicht erscheint. Typabkürzungen müssen alle deklarierten Typparameter im abgekürzten Typ verwenden. Entfernen Sie mindestens einen Typparameter, oder verwenden Sie eine konkrete Typdefinition, die einen zugrundeliegenden Typ umschließt, z.B. "type C&lt;'a&gt; = C of ...".</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Der Antwortdateiname "{0}" ist leer, enthält ungültige Zeichen, weist eine Laufwerkspezifikation ohne einen absoluten Pfad auf oder ist zu lang.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Signatur eine höhere Zugreifbarkeit angegeben ist als in der Implementierung.</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Es wurde kein abstrakte Eigenschaft gefunden, die dieser Überschreibung entspricht.</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Fehler beim Analysieren der eingebetteten IL.</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>DLLImport-Stubs können nicht inline gesetzt werden.</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Unzulässiges Muster.</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>An dieser Stelle ist ein einfacher Methodenname erforderlich.</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>'member val'-Definitionen sind nur in Typen mit einem primären Konstruktor zulässig. Möglicherweise sollten Sie Ihrer Typdefinition Argumente hinzufügen, z. B. 'type X(args) = ...'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>{0}-Flag doppelt festgelegt.</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Objektausdrücke enthalten.</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Ein als "inline" markierter Wert hat einen unerwarteten Wert.</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>'match'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>Die Eigenschaft "{0}" hat denselben Namen wie eine andere Eigenschaft im Typ "{1}", allerdings akzeptiert eine Eigenschaft Indexerargumente und die andere nicht. Möglicherweise fehlt ein Indexerargument für eine der Eigenschaften.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Bezeichner, auf die "{0}" folgt, sind für die zukünftige Verwendung reserviert.</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Explizite Typparameter dürfen nur für Modul- oder Memberbindungen verwendet werden.</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanWrite=false festgelegt, GetSetMethod() hat jedoch eine Methode zurückgegeben.</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Debugginginformationen in Anführungszeichen ausgeben</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Win32-Standardmanifest nicht einschließen</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>aktive Erkennung</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Das CompiledName-Attribut kann nicht mit diesem Sprachelement verwendet werden.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Wird verwendet, um eine Variable zu deklarieren, d. h. einen veränderlichen Wert.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Für Datei oder Modul "{0}" wurde bereits eine Signatur angegeben.</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die Union-Fallfelder festlegen.</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Diese Typdefinition umfasst einen sofortigen zyklischen Verweis über eine Abkürzung.</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Ungültiger Wert "{0}" für "--targetprofile", gültige Werte sind "mscorlib", "netcore" oder "netstandard".</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>use-Bindungen sind in primären Konstruktoren unzulässig.</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Strukturen dürfen einen this-Parameter nur in Memberdeklarationen binden.</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Alle Enumerationsfelder müssen Werte erhalten.</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>Weder die Definition 'member val' noch die Definition 'override val' ist in Objektausdrücken zulässig.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmeabkürzung von der Signatur verdeckt wird. Die Abkürzung muss für andere CLI-Sprachen sichtbar sein. Sorgen Sie dafür, dass die Abkürzung in der Signatur sichtbar ist. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Wird zusammen mit "try" verwendet, um einen Codeblock bereitzustellen, der unabhängig davon ausgeführt wird, ob eine Ausnahme auftritt.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Benutzerdefinierte Marshaller dürfen im F#-Code nicht angegeben werden. Verwenden Sie eine C#-Hilfsfunktion.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Keine Implementierung von "{0}" wies die richtige Anzahl von Argumenten und Typparametern auf. Die erforderliche Signatur lautet "{1}".</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Methodenüberschreibungen und Schnittstellenimplementierungen sind an dieser Stelle nicht zulässig.</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Das FieldOffset-Attribut konnte nicht decodiert werden.</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Für die Signaturdatei "{0}" ist keine entsprechende Implementierungsdatei vorhanden. Falls eine Implementierungsdatei existiert, stellen Sie sicher, dass die module- und namespace-Deklarationen in der Signatur- und der Implementierungsdatei übereinstimmen.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Der {0}-Operator kann nicht umdefiniert werden. Verwenden Sie einen anderen Operatornamen.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Signatur eine Abkürzung enthält, die Implementierung hingegen nicht.</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Der Typparameter "{0}" ist nicht definiert.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Wird verwendet, um eine Basisklasse oder Basisschnittstelle festzulegen.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Möglicherweise falscher Einzug: Dieses Token ist gegenüber dem bei Position {0} beginnenden Kontext verschoben. Erhöhen Sie den Einzug für dieses Token, oder verwenden Sie die standardmäßigen Formatierungskonventionen.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Modul "{0}" enthält\n    {1},    \ndoch die Signatur gibt\n    {2}    an.\nDie Anzeigenamen unterscheiden sich</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Dieser literale Ausdruck oder dieses Attributargument führt zu einem arithmetischen Überlauf.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Optionale Argumente dürfen nicht für benutzerdefinierte Attribute verwendet werden.</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Die angegebene Assembly und alle davon abhängigen DLLs, auf die verwiesen wird, statisch verknüpfen. Hierfür ist ein Assemblyname wie "mylib" zu verwenden, kein DLL-Name.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Dateiende in einer in den Kommentar eingebetteten ausführlichen Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Werte und/oder Attribute der literalen Konstanten sind unterschiedlich.</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Diese Unicode-Codierung ist nur für Zeichenfolgenliterale zulässig.</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>"{0}" kann nur auf optionale Argumente angewendet werden.</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Bei diesem Vorgang wird die Adresse eines Werts "{0}" übernommen, der durch eine lokale Variable oder eine andere Spezialdarstellung dargestellt wird. Dies ist unzulässig.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Standardmäßig nicht auf die CLI-Standardassemblys verweisen</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>Die Datei "{0}" wurde nicht neben "FSharp.Core" gefunden. Die Datei wurde in {1} erwartet. Erwägen Sie ein Upgrade auf eine aktuellere Version von "FSharp.Core", in der die Datei nicht mehr erforderlich ist.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Signatur NULL als Darstellung verwenden darf, laut Implementierung aber nicht.</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Dateiende in einem Kommentar, der an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" enthält kein Argument und keine festlegbare Rückgabeeigenschaft "{1}". {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Nicht unterstützter Konstantentyp "{0}". Vom Typanbieter bereitgestellte Quotations dürfen nur einfache Konstanten enthalten. Die Implementierung des Typanbieters muss unter Umständen angepasst werden, indem ein Wert, der außerhalb eines bereitgestellten Quotation-Literals daklariert wird, mittels Verschieben in eine let-Bindung innerhalb eines Quotation-Literals umgewandelt wird.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Teilweise aktive Muster können nur ein Ergebnis erzeugen.</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Auf den Typ "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Dieser Listenausdruck übersteigt die maximale Größe für Listenliterale. Verwenden Sie für umfangreichere Literale ein Array, und rufen Sie "Array.ToList" auf.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der Implementierungstyp versiegelt ist, laut Signatur aber nicht versiegelt sein sollte. Fügen Sie der Signatur ggf. das [&lt;Sealed&gt;]-Attribut hinzu.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>Das benannte Argument "{0}" stimmt mit keinem Argument und keiner änderbaren Eigenschaft überein.</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Ungültige Einschränkung: Der für diese Einschränkung verwendete Typ ist versiegelt; das bedeutet, die Einschränkung wurde von höchstens einer Projektmappe erfüllt.</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Unerwartetes Zeichen "{0}".</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil eine CLI-Ausnahmezuordnung von einer Signatur verdeckt wird. Die Ausnahmezuordnung muss für andere Module sichtbar sein. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Attribute für Modulabkürzung werden ignoriert.</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Ein Typ wurde erwartet, keine Maßeinheit.</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Der Typ "{0}" implementiert "System.IComparable" explizit, stellt aber keine entsprechende Überschreibung für "Object.Equals" bereit. Eine Implementierung von "Object.Equals" wurde automatisch über "System.IComparable" bereitgestellt. Implementieren Sie die Überschreibung "Object.Equals" explizit.</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Die für "{1}" erforderliche Assembly "{0}" konnte nicht aufgelöst werden.</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Ungültige Mutation eines konstanten Ausdrucks. Kopieren Sie den Ausdruck in eine änderbare lokale Variable, z.B. "let mutable x = ...".</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Bestimmte Warnungen als Fehler melden</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>Die Konvertierung aus {0} in {1} ist ein sicherer Ausdruck zur Umwandlung in eine Basisklasse zur Kompilierungszeit und kein Ausdruck zur Umwandlung in eine abgeleitet Klasse. Verwenden Sie ggf. "upcast" anstelle von "downcast".</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>Der Bezeichner "{0}" ist für die zukünftige Verwendung durch F# reserviert.</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Dateien in Bibliotheken oder Anwendungen mit mehreren Dateien müssen mit einer Namespace- oder Moduldeklaration beginnen. Beispiel: "namespace SomeNamespace.SubNamespace" oder "module SomeNamespace.SomeModule". Nur in der letzten Quelldatei einer Anwendung darf eine solche Deklaration ausgelassen werden.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Eine Bindung kann nicht gleichzeitig als "use" und "rec" markiert werden.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Unerwartetes Eingabeende in den Typargumenten</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine virtuelle Angabe steht einer nicht virtuellen gegenüber.</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Diese Indexernotation wurde aus der Programmiersprache F# entfernt.</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung des Typs "{0}" ist ungültig. Ein Wert vor "{1}" hat einen per Rückschluss abgeleiteten Typ mit "{2}"; dies ist ein ungültiger Vorwärtsverweis.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Doppelte Methode. Die Methode "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Methode im Typ "{1}", nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Interner Fehler oder falsch formatierte Metadaten: Während des Imports befanden sich nicht genügend Typparameter im Bereich.</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Fehlerhafte Anzahl von Typargumenten für lokalen Aufruf.</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>Die Syntax "module ... : sig .. end" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "module ... = begin .. end".</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Ein Schnittstellentyp wurde erwartet.</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>Der Name "({0})" sollte nicht als Membername verwendet werden, weil in der F#-Bibliothek eine Standarddefinition für feste Typen dafür vergeben wird.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Unerwartetes Eingabeende in der Typdefinition</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Ungültiger Wert für Maßeinheitenparameter '{0}'</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Ungültiger Wert '{0}' für Maßeinheitenparameter '{1}'</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Ungültiges Format für einen Eigenschaftengetter. Mindestens ein ()-Argument ist bei Verwendung der expliziten Syntax erforderlich.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Beim Setup des angegebenen Typs ist mindestens ein Fehler aufgetreten.</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Konstruktorausdrücke für Schnittstellen akzeptieren keine Argumente.</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Ungültige Warnstufe "{0}".</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Der Union-Fall mit dem Namen '{0}' befindet sich in einem Konflikt mit dem generierten Typ '{1}'.</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Der Member "{0}" entspricht keiner abstrakten oder virtuellen Methode, die zum Überschreiben oder Implementieren zur Verfügung steht.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Ungültige Datensatzkonstruktion.</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Typen der Felder sind unterschiedlich.</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Bezeichnung "{0}" nicht gefunden.</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Das aktive Muster "{0}" besitzt einen Ergebnistyp mit Typvariablen, die nicht von der Eingabe bestimmt werden. Häufige Ursache: Es ist kein Ergebnisfall angegeben. Beispiel: "let (|A|B|) (x:int) = A x". Dieses Problem kann mithilfe einer Typeinschränkung behoben werden. Beispiel: "let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x"</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e), erhält hier aber {2} unbenannte(s) und {3} benannte(s) Argument(e). Die erforderliche Signatur lautet "{4}".</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Der Typ bzw. das Modul "{0}" ist kein konkretes Modul bzw. kein konkreter Typ.</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- AUSGABEDATEIEN -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Die verfügbaren Überladungen werden im Folgenden angezeigt (oder im Fenster "Fehlerliste").</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' wird mit einer unzulässigen Anzahl von Argumenten verwendet. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck. {1} Argument(e) erwartet, jedoch {2} erhalten.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} ist keine Instanzmethode.</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Dieses Format eines Objektausdrucks wird in F# nicht verwendet. Verwenden Sie "member this.MemberName ... = ...", um Memberimplementierungen in Objektausdrücken zu definieren.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Unerwarteter Ausdruck bei rekursivem Rückschlusspunkt.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der abstrakte Member "{2}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde.</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>Der Methode oder Funktion "{0}" sollten keine expliziten Typargumente zugewiesen werden, weil sie ihre Typparameter nicht explizit deklariert.</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Der Typ "{0}" besitzt eine Inlineassembly-Codedarstellung.</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Rekursive Werte können dem nicht änderbaren Feld "{0}" vom Typ "{1}" innerhalb einer rekursiven Bindung nicht direkt zugewiesen werden. Verwenden Sie stattdessen ein änderbares Feld.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>ML-Kompatibilitätswarnungen ignorieren</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Infix-Operatormember "{0}" weist keine Argumente auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Schnittstellen dürfen keine Definitionen konkreter Member enthalten. Sie müssen ggf. einen Konstruktor für den Typ definieren, um anzugeben, dass es sich bei dem Typ um eine Klasse handelt.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Fehlende Qualifikation nach ".".</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Die Instanziierung des generischen Typs "{0}" fehlt und kann nicht per Rückschluss von den Argumenten oder dem Rückgabetyp dieses Members abgeleitet werden. Stellen Sie beim Zugriff auf diesen Typ eine Typinstanziierung bereit, z.B. "{1}".</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Schreibweisenbezeichner für das aktive Muster müssen mit einem Großbuchstaben beginnen.</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>Die Angabe von "h" oder "H" ist in diesem Formatbezeichner nicht erforderlich. Sie können stattdessen %d, %x, %o oder %u verwenden. Diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integertypen.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>Das Ausdrucksformat 'expr then expr' darf nur als Teil eines expliziten Objektkonstruktors verwendet werden.</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>base-Werte dürfen nur für direkte Aufrufe der Basisimplementierungen von überschriebenen Membern verwendet werden.</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Dies ist kein gültiger konstanter Ausdruck oder benutzerdefinierter Attributwert.</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Diese rekursive Bindung verwendet eine unzulässige Mischung von rekursiven Formaten.</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IComparable&lt;_&gt;-Schnittstelle explizit. Sie müssen das CustomComparison-Attribut auf den Typ anwenden und sollten außerdem eine einheitliche Implementierung der nicht generischen System.IComparable-Schnittstelle bereitstellen.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Ungültige Zuweisung.</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Dateiende in einer Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Der Typ einer Funktion erster Klasse darf keine Byrefs enthalten.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil es sich um einen Funktionstyp handelt.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil es sich um einen Datensatz, eine Union oder Struktur mit mindestens einem Strukturelementtyp handelt, der die equality-Einschränkung nicht unterstützt. Verwenden Sie entweder keine Gleichheit in Verbindung mit diesem Typ, oder fügen Sie dem Typ das StructuralEquality-Attribut hinzu, um festzustellen, von welchem Feldtyp die Gleichheit nicht unterstützt wird.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die equality-Einschränkung nicht, weil er das NoEquality-Attribut aufweist.</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'use!' eingezogen werden.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Die Verwendung der Typsyntax "int C" und "C  &lt;int&gt;" ist an dieser Stelle nicht zulässig. Passen Sie die Typangabe im Format "C&lt;int&gt;" an.</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Präfixflag (" " oder "+") doppelt festgelegt.</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Von AssemblyFolders-Registrierungsschlüssel gefunden</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Dieses Konstrukt darf nur innerhalb von Sequenz- oder Berechnungsausdrücken verwendet werden.</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Fehler beim Analysieren des eingebetteten IL-Typs.</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Ein Literalwert kann nicht mit den Attributen "[&lt;ThreadStatic&gt;]" oder "[&lt;ContextStatic&gt;]" versehen werden.</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>Assembly '{0}' verfügt über ein TypeProviderAssembly-Attribut mit dem ungültigen Wert '{1}'. Beim Wert sollte es sich um einen gültigen Assemblynamen handeln.</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Dieser Funktionswert dient zum Erstellen eines Delegattyps, dessen Signatur ein Byref-Argument umfasst. Sie müssen einen expliziten lambda-Ausdruck mit {0} Argumenten verwenden.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Abkürzungen für Common IL-Ausnahmen können keine Argumente akzeptieren.</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Beim Typ '{0}' handelt es sich nicht um einen gültigen Enumeratortyp, d. h. er verfügt über keine 'MoveNext()'-Methode, die einen booleschen Wert zurückgibt, und keine 'Current'-Eigenschaft.</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Dateiende in einer Direktive, die an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>Das Format "{0}" unterstützt keine Genauigkeitsangaben.</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Konstruktoren für den Typ "{0}" müssen den impliziten Objektkonstruktor direkt oder indirekt aufrufen. Verwenden Sie den Aufruf des impliziten Objektkonstruktors anstelle eines Datensatzausdrucks.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' wird nicht ordnungsgemäß verwendet. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Keine Entsprechung für '[&lt;'. Schließendes '&gt;]' erwartet</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Ungültige Verwendung von "fixed". "fixed" darf ausschließlich in einer Deklaration der Form "use x = fixed expr" verwendet werden. Dabei ist der Ausdruck ein Array, die Adresse eines Felds, die Adresse eines Arrayelements oder eine Zeichenfolge.</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Das Zeichen '{0}' ist im angegebenen Typnamen '{1}' nicht zulässig.</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Der statische Parameter "{0}" vom angegebenen Typ oder der angegebenen Methode "{1}" benötigt einen Wert. Statische Parameter zu Typanbietern können optional mithilfe von benannten Argumenten angegeben werden, z. B. "{2}&lt;{3}=...&gt;".</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Unerwartetes SynMeasure.Anon</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>"assert" darf nicht als Wert der ersten Klasse verwendet werden. Verwenden Sie stattdessen "assert &lt;Ausdruck&gt;".</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Von einem Variablentyp kann nicht geerbt werden.</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Auf die Union-Fälle oder Felder des Typs "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Änderbare Funktionswerte sollten im Format "let mutable f = (fun args -&gt; ...)" angegeben werden.</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Nur Klassentypen können Wertargumente akzeptieren.</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Ungültige Warnungsnummer "{0}".</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Der Typ "{0}" hat einen nicht standardmäßigen Delegattyp.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Der Member "{0}" akzeptiert nicht die richtige Anzahl von Argumenten. {1} Argumente werden erwartet, es wurden aber {2} Argumente angegeben. Die erforderliche Signatur ist "{3}".{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine finale Angabe steht einer nicht finalen gegenüber.</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Delegaten dürfen keine Currysignaturen aufweisen.</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Schränken Sie ein, auf welchen Plattformen dieser Code ausgeführt werden kann: "x86", "Itanium", "x64", "anycpu32bitpreferred" oder "anycpu". Der Standard ist "anycpu".</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Eine Maßeinheit wurde erwartet, kein Typ.</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Win32-Ressourcendatei (.res) angeben</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Lokale Klassenbindungen können nicht als "inline" markiert werden. Entfernen Sie die Definition aus der Klasse, oder markieren Sie sie nicht als "inline".</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(Die Beschreibung ist nicht verfügbar...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Der Typ "{0}" ist nicht in "{1}" definiert.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Bezeichner erwartet.</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Unerwartetes Token "{0}" im Präprozessorausdruck.</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Genauigkeitsangaben nach dem "." fehlen.</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Eine Quotation darf keine Zuweisung zu einer erfassten lokalen Variable enthalten oder deren Adresse übernehmen</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>Die Befehlszeilenoption "{0}" ist ausschließlich für Testzwecke bestimmt.</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Verwenden Sie ggf. "yield!" anstelle von "yield".</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Der geerbte Typ ist kein Objektmodelltyp.</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Das Hauptmodul des Programms ist leer: Beim Ausführen erfolgt keinerlei Aktion.</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>{0} hat Version "{1}" angegeben, dieser Wert ist jedoch ein Platzhalter, und Sie haben einen deterministischen Build angefordert. Zwischen diesen besteht ein Konflikt.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Das Übergeben einer RESX-Datei ({0}) als Quelldatei an den Compiler ist veraltet. Verwenden Sie "resgen.exe", um die RESX-Datei in eine RESOURCES-Datei zu transformieren, um eine --resource-Option zu übergeben. Bei der Verwendung von MSBuild kann dies über ein &lt;EmbeddedResource&gt;-Element in der .fsproj-Projektdatei erfolgen.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Der Pfad "{0}" ist ein Namespace. Eine Modulabkürzung darf nicht zum Abkürzen von Namespaces verwendet werden.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Einer Deklaration kann nur dann ein Wert in einer Signatur zugewiesen werden, wenn die Deklaration mit dem [&lt;Literal&gt;]-Attribut versehen ist.</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Beim Zugreifen auf '{0}' eines angegebenen Typs ist eine Ausnahme aufgetreten: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Wird verwendet, um festzulegen, dass ein Member innerhalb einer Assembly sichtbar ist, außerhalb jedoch nicht.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Kein #endif für #if oder #else gefunden.</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Ungültige Membersignatur aufgrund eines früheren Fehlers.</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Das Feld mit dem Namen '{0}' steht in Konflikt mit dem automatisch generierten Namen für ein anonymes Feld.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Ungültige Direktive. Erwartet wurde "#time", "#time \"on\"" oder '#time \"off\"".</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind an dieser Stelle für Enumerationstypen nicht zulässig.</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Attribute sind an dieser Stelle nicht zulässig.</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- SPRACHE -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Unbekannter Debugtyp "{0}", "pdbonly" oder "full" wurde erwartet.</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>Bei der Verwendung von 'into' muss der Rest der Berechnung folgen.</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Die Verwendung der reraise-Funktion in der ersten Klasse ist nicht zulässig.</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Keine Entsprechung für '&lt;'. Schließendes '&gt;' erwartet</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht den Wert "{2}".</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Die generische Funktion "{0}" muss explizite Typargumente erhalten.</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanRead=true festgelegt, es gab jedoch keinen Wert von GetGetMethod().</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Ein Methodenrückgabetyp würde Byrefs enthalten; das ist nicht zulässig.</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>Das {0}-Ereignis ist statisch.</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Dieses Token ist für die zukünftige Verwendung reserviert.</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>In einer rekursiven Deklarationsgruppe müssen open-Deklarationen in jedem Modul an erster Stelle auftreten.</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Der angegebene Typ '{0}' hat einen Member mit einem NULL- oder leeren Membernamen zurückgegeben.</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Ungültiger Formatbezeichner (nach l oder L): Erwartet wurde ld, li, lo, lu, lx oder lX. In F#-Code können Sie stattdessen %d, %x, %o oder %u verwenden; diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integer-Typen.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Ungültiger angegebener Literalwert '{0}'</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Schnittstellentypen dürfen nicht versiegelt sein.</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Das Literal in Kleinbuchstaben '{0}' verursacht einen Konflikt mit einem neuen Muster mit dem gleichen Namen. Nur Literale in Großbuchstaben und Literale mit Modulpräfix können als benannte Muster verwendet werden.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Nicht definierter Wert "{0}".</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Dieses Konstrukt darf nur innerhalb von Listen-, Array- und Sequenzausdrücken verwendet werden, also Ausdrücken im Format "seq {{ ... }}", "[ ... ]" oder "[| ... |]". Bei diesen wird zum Erzeugen von Elementen die Syntax "for ... in ... do ... yield..." verwendet.</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Ein benutzerdefiniertes Attribut muss ein Verweistyp sein.</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Ein statisches Feld wurde an einer Stelle verwendet, an der ein Instanzfeld erwartet wurde.</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Keine Entsprechung für "(".</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Eine eindeutige Überladung für Methode '{0}' konnte nicht auf Basis von Typinformationen vor diesem Programmpunkt bestimmt werden. Unter Umständen ist eine Typanmerkung erforderlich.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" ist nicht {1}.</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Debuginformationen ausgeben (Kurzform: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>Die Option '--keyfile' überschreibt das Attribut 'System.Reflection.AssemblyKeyFileAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Antwortdatei lesen, um weitere Optionen zu ermitteln</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Keine Entsprechung für "{{".</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Keine Entsprechung für "begin".</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Diese 'let'-Definition darf in einer Abfrage nicht verwendet werden. In Abfragen dürfen nur einfache Wertdefinitionen verwendet werden.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Entweder wird ein geschützter Member aufgerufen oder "base" verwendet. Dies ist nur bei der direkten Implementierung von Membern zulässig, da diese ihren Objektbereich mit Escapevorgängen außer Kraft setzen könnten.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Typargumente müssen direkt neben dem Typnamen platziert werden. Beispiel: \"C&lt;'T&gt;\", nicht \"C  &lt;'T&gt;\".</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Typparameter müssen direkt neben dem Typnamen platziert werden, z.B. \"type C&lt;'T&gt;\", nicht     type \"C   &lt;'T&gt;\".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Die inhärente Mehrdeutigkeit bei der Verwendung einer printf-Formatzeichenfolge konnte nicht aufgelöst werden.</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Fehler im Rückgabeausdruck für dieses "let". Möglicherweise falscher Einzug.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Die implizite Instanziierung eines generischen Konstrukts an diesem Punkt oder in dessen Umgebung konnte nicht aufgelöst werden, weil sie zu mehreren unzusammenhängenden Typen aufgelöst werden könnte, z.B. "{0}" und "{1}". Verwenden Sie Typanmerkungen, um die Mehrdeutigkeit aufzulösen.</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Optionale Argumente müssen am Ende der Argumentliste stehen, ggf. nach den nicht optionalen Argumenten.</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Versuchte Analyse als Operatornamen, jedoch Analysefehler</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Auf eine Assembly verweisen (Kurzform: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Von AssemblyFoldersEx-Registrierungsschlüssel gefunden</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>"get", "set" oder "get,set" erforderlich.</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>"{0}" ist kein gültiges Gleitkommaargument.</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Die Befehlszeilenoption "{0}" ist veraltet. Verwenden Sie stattdessen "{1}".</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Ein Typ mit dem CustomEquality-Attribut erfordert die explizite Implementierung von "Object.Equals(obj)", "System.IEquatable&lt;_&gt;" und/oder "System.Collections.IStructuralEquatable".</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Unerwartetes {0} in Typenausdruck.</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Unbekanntes Attributziel. Gültige Attributziele sind "assembly", "module", "type", "method", "property", "return", "param", "field", "event", "constructor".</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Fehlender Funktionsrumpf.</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Zugriffsmodifizierer sind an dieser Stelle nicht zulässig, "{0}" wurde jedoch angegeben.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Typen dürfen keine geschachtelten Typdefinitionen enthalten.</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Warnungen und Fehlermeldungen farbig ausgeben</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Unzulässige Verwendung eines Typnamens.</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Für diesen Wert ist kein gültiger Eigenschaftensettertyp vorhanden.</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Das Suchverzeichnis "{0}" ist ungültig.</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Angegebene Ressource mit dieser Assembly verknüpfen; Resinfo-Format: &lt;Datei&gt;[,&lt;Zeichenfolgenname&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Nenner darf in der Maßeinheit des Exponenten nicht 0 sein</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>"inherit" kann nicht für Schnittstellentypen verwendet werden. Implementieren Sie die Schnittstelle stattdessen mit "interface ... with ... end".</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Unerwartetes Integer-Literal in Maßeinheitenausdruck.</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>"{0}" darf nur für benannte Typen verwendet werden.</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur lautet "{3}".</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>Standardaugmentation des Union-Falls</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Dieser Wert ist keine Funktion und kann nicht angewendet werden.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Fehlender Formatbezeichner.</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Eine Indexereigenschaft muss mindestens ein Argument erhalten.</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Unbekanntes Ziel "{0}", "exe", "winexe", "library" oder "module" wurde erwartet.</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>Fehlendes 'do' in 'while'-Ausdruck. Es wurde 'while &lt;expr&gt; do &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Unerwartetes Eingabeende im Text des lambda-Ausdrucks. Es wurde 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Die Dokumentationsdatei weist kein XML-Suffix auf.</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>Die Verwendung von "-&gt;" in Sequenz- und Berechnungsausdrücken ist auf das Format "for pat in expr -&gt; expr" beschränkt. Verwenden Sie die Syntax "for ... in ... do ... yield...", um Elemente in komplexeren Sequenzausdrücken zu generieren.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Eine Getter-Eigenschaft muss eine Funktion sein, z.B. "get() = ..." oder "get(index) = ...".</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Anführungszeichen stimmen nicht überein, beginnt mit "{0}".</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 64-Bit-Integer ohne Vorzeichen.</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" wurde in Typ "{2} von Assembly "{3}" nicht gefunden. Mögliche Ursache ist eine Versionsinkompatibilität. Möglicherweise müssen Sie die richtige Version dieser Assembly explizit referenzieren, damit alle referenzierten Komponenten die richtige Version benutzen können.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie generischen Parameter in der Signatur und in der Implementierung haben einen unterschiedlichen Typ. Möglicherweise fehlt ein [&lt;Measure&gt;]-Attribut.</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Dieser Typ kann nicht für ein Literalfeld verwendet werden.</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Endeaufrufe aktivieren oder deaktivieren</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Copy-and-Update-Datensatzausdrücke müssen mindestens ein Feld enthalten.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Dateiende in einer in den Kommentar eingebetteten Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Für '{0}' ist ein benutzerdefinierter Abfragevorgang erforderlich, der jedoch nicht angegeben wurde.</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Ungültiges Literal im Typ</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Der Member "{0}" entspricht mehreren Überladungen der gleichen Methode.\nBeschränken Sie ihn auf eine der folgenden Optionen: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Wenn ein Union-Typ mehrere case-Anweisungen aufweist und eine Struktur ist, müssen für alle Felder im Union-Typ eindeutige Namen angegeben werden.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>Die '{0}'-Eigenschaft des angegebenen Typs '{1}' kann weder gelesen noch geschrieben werden, da sie auf CanRead=false und CanWrite=false festgelegt ist.</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>Generierte Eigenschaft</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Statische 'val'-Felder in Typen müssen änderbar und privat sein und mit dem '[&lt;DefaultValue&gt;]'-Attribut versehen werden. Sie werden mit dem NULL- oder 0-Wert für ihren Typ initialisiert. Verwenden Sie ggf. zusätzlich eine "static let mutable"-Bindung in einem Klassentyp.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Diese Methode erwartet an dieser Position den CLI-Parameter "params". Mit "params" kann in Programmiersprachen wie C# eine variable Zahl von Argumenten an eine Methode übergeben werden. Übergeben Sie ein Array für dieses Argument.</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Nicht initialisierte val-Felder müssen änderbar sein und mit dem [&lt;DefaultValue&gt;]-Attribut versehen werden. Verwenden Sie eine let-Bindung anstelle eines val-Felds.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Für den angegebenen Typ '{0}' ist 'IsGenericType' auf true festgelegt, es werden jedoch keine generischen Typen unterstützt.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Alle Rechte vorbehalten.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die Felder in Ausnahmewerten festlegen.</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Dieses Bytearrayliteral enthält Zeichen, die sich nicht als einzelnes Byte codieren lassen.</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Attribute sollten vor "val" platziert werden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Implementierung {2} "{3}" definiert ist, in der Signatur aber nicht (oder nicht in der gleichen Reihenfolge).</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Anonyme Maßeinheiten können nicht innerhalb eines anderen Maßeinheitenausdrucks geschachtelt werden.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>Die Signatur und die Implementierung sind nicht kompatibel, da die Deklaration des Typparameters "{0}" eine Einschränkung im Format "{1}" erfordert.</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>Typ oder Modul</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Die geschachtelten angegebenen Typen akzeptieren keine statischen Argumente oder generische Parameter.</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Unerwartetes Eingabeende im Ausdruck</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Diese Deklaration öffnet das Modul "{0}", das als "RequireQualifiedAccess" markiert ist. Passen Sie den Code an, indem Sie stattdessen qualifizierte Verweise auf die Modulelemente verwenden. Beispiel: "List.map" anstelle von "map". Durch diese Änderung stellen Sie sicher, dass der Code auch dann stabil bleibt, wenn die Bibliotheken um neue Konstrukte ergänzt werden.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Dieses Deklarationselement ist in einer Augmentation nicht zulässig.</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Der Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur ist "{3}".</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Dieser neue Member verbirgt den abstrakten Member "{0}". Benennen Sie den Member um, oder verwenden Sie stattdessen "override".</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Der von den Attributen angegebene Typ stimmt nicht mit der von der Definition implizierten Art überein.</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Fehler beim Schreiben der Binärdatei '{0}': {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Nicht primitive numerische Literalkonstanten können nicht für Mustervergleiche verwendet werden, weil sie mithilfe eines NumericLiteral-Moduls mehreren verschiedenen Typen zugeordnet werden können. Ersetzen Sie sie durch eine Variable, und verwenden Sie am Ende der Vergleichsklausel "&lt;Variable&gt; = &lt;Konstante&gt;".</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>Die Signatur und die Implementierung sind nicht kompatibel, da der Typparameter in der Klasse/Signatur eine andere Kompilierzeitanforderung stellt als der Member bzw. die Implementierung.</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Redundante Argumente werden in der Funktion '{0}' ignoriert. Erwartet wurden {1} Argumente, abgerufen jedoch {2} Argumente.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Ein benutzerdefiniertes Attribut muss einen Objektkonstruktor aufrufen.</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>Die Syntax "expr.id" darf nur für Datensatzbezeichnungen, Eigenschaften und Felder verwendet werden.</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Nach diesem Punkt wurde ein Typ erwartet.</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Das ReferenceEquality-Attribut darf nicht für Strukturen verwendet werden. Verwenden Sie stattdessen das StructuralEquality-Attribut, oder implementieren Sie eine Überschreibung für "System.Object.Equals(obj)".</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>Die Überschreibung "{0}" implementiert mehr als einen abstrakten Umsetzungsplatz, z.B. "{1}" und "{2}".</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Der Member "{0}" akzeptiert nicht die richtige Anzahl von Argumenten. Eine Überladung akzeptiert {1} Argumente, es wurden aber {2} Argumente angegeben. Die erforderliche Signatur ist "{3}".{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Ein Modulname muss ein einfacher Name sein, kein Pfad.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Um anzugeben, dass diese Eigenschaft festgelegt werden kann, verwenden Sie "'member val PropertyName = expr with get,set".</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>"FSharp.Core.dll" wurde im Verzeichnis des Compilers nicht gefunden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Typen unterschiedliche Basistypen aufweisen.</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Keine passenden Überladungen für die Methode '{0}' vorhanden.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Dies ist kein Konstruktor oder Literal, oder ein Konstruktor wird nicht ordnungsgemäß verwendet.</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Nur Typen, die Maßeinheiten darstellen, dürfen das Measure-Attribut erhalten.</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Argumente für einen Instanzmember wurden erwartet.</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Dieser Code ist weniger generisch, als dies laut Anmerkungen erforderlich ist, weil die explizite Typvariable "{0}" nicht generalisiert werden konnte. Einschränkung auf "{1}".</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Überschreiben Sie zum Definieren der Gleichheitssemantik für einen Typ den Object.Equals-Member in der Definition dieses Typs.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Ein Typ mit dem ReferenceEquality-Attribut darf keine explizite Implementierung von "Object.Equals(obj)", "System.IEquatable&lt;_&gt;" und/oder "System.Collections.IStructuralEquatable" aufweisen.</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>Das UseNullAsTrueValue-Attributflag darf nur für Union-Typen verwendet werden, die einen nullären Fall und mindestens einen nicht nullären Fall aufweisen.</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Keine Entsprechung für "begin" oder "struct".</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Weist einen Wert einer Variablen zu.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Dateiende in einem #if-Abschnitt, der an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Der Abgleich von Zeichenbereichen wurde in F# entfernt. Verwenden Sie stattdessen einen when-Musterwächter.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! kann nur als erste Zeile zu Beginn einer Datei angezeigt werden.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Konstruktoren können nicht in Ausnahmeaugmentationen angegeben werden.</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Für den angegebenen Typ '{0}' ist 'IsArray' auf true festgelegt, es werden jedoch keine Arraytypen unterstützt.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Doppelte Eigenschaft. Die Eigenschaft "{0}" hat denselben Namen und dieselbe Signatur wie in eine andere Eigenschaft im Typ "{1}", nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht das Modul bzw. den Namespace "{2}".</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Im F#-Code wird das Deklarationsformat "let ... and ..." für nicht rekursive Bindungen nicht verwendet. Verwenden Sie eine Reihe aus let-Bindungen.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.GetHashCode" oder "Object.Equals". Sie müssen das CustomEquality-Attribut auf den Typ anwenden.</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Unzulässige Verwendung eines Delegatkonstruktors. Verwenden Sie die Syntax "new Type(args)" oder einfach nur "Type(args)".</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>Die Signatur und die Implementierung sind nicht kompatibel, da der Typparameter "{0}" eine Einschränkung im Format "{1}" aufweist, die Implementierung aber nicht. Entfernen Sie diese Einschränkung entweder aus der Signatur, oder fügen Sie sie der Implementierung hinzu.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Die referenzierte Assembly '{0}' verfügt über das Attribut '{1}' auf Assemblyebene, es wurden jedoch keine öffentlichen Typanbieterklassen gefunden.</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Alle Warnungen als Fehler melden</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>Tabulatorzeichen sind in F#-Code nur zulässig, wenn die Option "#indent \"off\"" verwendet wird.</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Ungültiges statisches Argument für angegebenen Typ. Es wurde ein Argument der Art '{0}' erwartet.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Änderbare Werte können nicht als "inline" markiert werden.</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>"{0}" wird von mehr als einer Überschreibung implementiert.</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Instanzen dieses Typs können nicht erstellt werden, da er als "abstract" markiert wurde oder nicht für alle Methoden Implementierungen vorhanden sind. Verwenden Sie stattdessen einen Objektausdruck "{{ new ... with ... }}".</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>In einer rekursiven Deklarationsgruppe müssen Modulabkürzungen nach allen open-Deklarationen und vor anderen Deklarationen auftreten.</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Wird als kürzere Alternative zum fun-Schlüsselwort und einen Vergleichsausdruck in einem Lambdaausdruck verwendet, der über Musterabgleich für ein einzelnes Argument verfügt.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1},    \n doch die Signatur gibt\n    {2}    an.\nDie kompilierten Namen unterscheiden sich</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Dies ist kein gültiger Objektkonstruktionsausdruck. Explizite Objektkonstruktoren müssen entweder einen alternativen Konstruktor aufrufen oder alle Felder des Objekts initialisieren und einen Aufruf an einen übergeordneten Klassenkonstruktor angegeben.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Unbekannte Plattform "{0}", gültige Werte sind "x86", "x64", "Itanium", "anycpu32bitpreferred" und "anycpu".</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>"new" kann nicht für Schnittstellentypen verwendet werden. Verwenden Sie stattdessen einen Objektausdruck "{{ new ... with ... }}".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine Abkürzung von einer Signatur verdeckt wird. Die Abkürzung muss für andere CLI-Sprachen sichtbar sein. Sorgen Sie dafür, dass die Abkürzung in der Signatur sichtbar ist.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Ungültiges Format für einen Eigenschaftensetter. Mindestens ein Argument ist erforderlich.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Die 'let!'-, 'use!'- und 'do!'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Dateiende in einer ausführlichen Zeichenfolge, die an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Dieses Feld ist schreibgeschützt.</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Das StructLayout-Attribut konnte nicht decodiert werden.</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Der Typ "{0}" ist kein CLI-Delegattyp.</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Dieser Ausdruck ist keine Funktion und kann nicht angewendet werden. Wollten Sie auf den Indexer stattdessen über "expr.[index]" zugreifen?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Durch "{0}" ersetzen</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Auf das Struktur- oder Klassenfeld "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Wird in einem Berechnungsausdruck zum Anhängen des Ergebnisses eines bestimmten Berechnungsausdrucks für eine Ergebnissammlung für den enthaltenden Berechnungsausdruck verwendet.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Ungültiger Ausdruck "{0}".</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Dieser Typparameter kann nicht auf "Nullable" instanziiert werden. Diese Einschränkung soll sicherstellen, dass die Bedeutung von NULL in manchen CLI-Sprachen in Verbindung mit Nullable-Werten nicht verwirrend ist.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Eine Implementierung der Datei oder des Moduls "{0}" wurde bereits angegeben.</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat einen Konstruktor bereitgestellt, der nicht zu den Konstruktoren des deklarierten Typs '{1}' gehört</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Von anderen Schnittstellen geerbte Schnittstellen müssen mit "inherit ..." (und nicht mit "interface ...") deklariert werden.</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Eine Funktion mit dem EntryPointAttribute-Attribut muss die letzte Deklaration in der letzten Datei der Kompilierungssequenz sein.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Der Datensatztyp "{0}" enthält keine Bezeichnung "{1}".</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Nicht geschlossener Block.</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Diese Eigenschaft bzw. dieses Feld wurde in diesem benutzerdefinierten Attributtyp nicht gefunden.</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Ein Namespace und ein Modul namens "{0}" sind beide in zwei Teilen dieser Assembly vorhanden.</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Geben Sie das Profil des Zielframeworks dieser Assembly an. Gültige Werte sind mscorlib, netcore oder netstandard. Standard – mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>Ab F# 4.1 wird die Zugreifbarkeit von Typabkürzungen zur Kompilierzeit überprüft. Sie sollten die Zugreifbarkeit der Typabkürzung ggf. ändern. Das Ignorieren dieser Warnung führt möglicherweise zu Laufzeitfehlern.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>Die #endif-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Ungültige RSAParameters-Struktur – "{{0}}" wurde erwartet.</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" unterstützt keine strukturelle Gleichheit, weil der Typparameter "{1}" die equality-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoEquality-Attribut hinzu, um eindeutig anzugeben, dass der Typ keine strukturelle Gleichheit unterstützt.</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" unterstützt keine strukturelle Gleichheit, weil der Typ "{1}" die equality-Einschränkung nicht erfüllt. Fügen Sie dem Typ "{2}" das NoEquality-Attribut hinzu, um eindeutig anzugeben, dass der Typ keine strukturelle Gleichheit unterstützt.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Dieses Attribut ist für dieses Sprachelement nicht gültig. Assemblyattribute sollten an eine "do ()"-Deklaration angefügt werden, falls notwendig innerhalb eines F#-Moduls.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Threadstatische und kontextstatische Variablen müssen statisch sein und mit dem [&lt;DefaultValue&gt;]-Attribut versehen werden, um anzugeben, dass der Wert bei jedem neuen Thread mit dem Standardwert initialisiert wird.</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Die Adresse eines Arrayelements kann an diesem Punkt nicht verwendet werden.</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Syntaxfehler: Unerwartete Typparameterangabe.</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Das DefaultAugmentation-Attribut konnte nicht decodiert werden.</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Der Typ eines Felds mit dem DefaultValue-Attribut muss die Standardinitialisierung zulassen, also NULL als eigenen Wert aufweisen oder ein Strukturtyp sein, dessen Felder alle die Standardinitialisierung zulassen. Mit "DefaultValue(false)" können Sie diese Prüfung deaktivieren.</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Wird verwendet, um eine Version einer abstrakten oder virtuellen Methode zu implementieren, die sich von der Basisversion unterscheidet.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Unerwartete Ausnahme vom angegebenen Typ '{0}' Member '{1}': {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Eine Typvariable wurde durch mehrere unterschiedliche Klassentypen eingeschränkt. Eine Typvariable weist möglicherweise nur eine Klasseneinschränkung auf.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Diese angegebene Methode erfordert statische Parameter.</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Der Konstruktor, das Modul oder der Namespace "{0}" ist nicht definiert.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Auf diesen Typ kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Die Attribute dieses Typs geben mehrere Arten für den Typ an.</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Bei diesem Vorgang wird auf eine nicht unterstützte Weise auf einen nicht änderbaren Wert der obersten Ebene zugegriffen, der in einer anderen Assembly definiert ist. Der Zugriff auf den Wert über seine Adresse ist nicht möglich. Kopieren Sie den Ausdruck in eine änderbare lokale Variable, z.B. "let mutable x = ...", und weisen Sie den Wert ggf. im Anschluss an diesen Vorgang erneut zu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Unerwartetes Eingabeende im 'try'-Ausdruck. Es wurde 'try &lt;expr&gt; with &lt;rules&gt;' or 'try &lt;expr&gt; finally &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Unerwartetes Eingabeende im 'for'-Ausdruck. Es wurde 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Darstellungen unterschiedlich sind.</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Anführungszeichen dürfen diese Art von Mustervergleich nicht enthalten.</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Unerwartetes Typende. Nach diesem Punkt wurde ein Name erwartet.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat einen Fehler gemeldet: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Fehler bei der MDB-Generierung. Kompatibler Member {0} wurde nicht gefunden.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Typabkürzungen dürfen keine Schnittstellendeklarationen aufweisen.</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>Das StructuralEquality-Attribut muss in Verbindung mit den Attributen "NoComparison" oder "StructuralComparison" verwendet werden.</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Splice-Operatoren für Ausdrücke dürfen nur in Anführungszeichen verwendet werden.</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>Kein passendes #if für #endif vorhanden.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Dieses Attribut ist für dieses Sprachelement nicht gültig.</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Überlaufprüfungen generieren</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Kostenlose Verteilung im Rahmen der MIT-Open Source-Lizenz. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Argument(e) nicht. Eine Überladung wurde gefunden, die {2} Argumente akzeptiert.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Das Assemblyattribut '{0}' bezieht sich auf eine Designerassembly '{1}', die entweder nicht geladen werden kann oder nicht vorhanden ist. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Unerwartete Ausnahme von Member '{0}' des angegebenen Typs '{1}' von Member '{2}': {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Von einem Typanbieter wurde "GetStaticParametersForMethod" implementiert, aber "ApplyStaticArgumentsForMethod" wurde nicht implementiert oder war ungültig.</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RESSOURCEN -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Der Code in dieser Assembly verwendet Quotation-Literale. Statische Verknüpfungen schließen unter Umständen Komponenten nicht ein, die Quotation-Literale verwenden, sofern nicht alle Assemblys mindestens mit F# kompiliert sind.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' muss auf eine 'for'-Auswahlklausel folgen und vom Rest der Abfrage gefolgt werden. Syntax: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>Die Option '--delaysign' überschreibt das Attribut 'System.Reflection.AssemblyDelaySignAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Das Übernehmen der Adresse eines Literalfelds ist unzulässig.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Integer mit Vorzeichen.</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Keine Entsprechung für "[|".</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" ist nicht {1}. Auf private Member darf nur innerhalb des deklarierenden Typs zugegriffen werden. Auf geschützte Member darf nur von einem erweiternden Typ zugegriffen werden; der Zugriff von inneren lambda-Ausdrücken ist nicht zulässig.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Methode oder Objektkonstruktor "{0}" ist nicht statisch.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>Der Code in der Assembly "{0}" verwendet Quotation-Literale. Statische Verknüpfungen schließen unter Umständen Komponenten nicht ein, die Quotation-Literale verwenden, sofern nicht alle Assemblys mindestens mit F# 4.0 kompiliert sind.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>"{0}" ist kein gültiger Dateiname.</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Assembly mithilfe nur des öffentlichen Teils des Schlüssels für einen starken Namen öffentlich signieren und als signiert markieren</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 16-Bit-Integer ohne Vorzeichen.</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat von 'ApplyStaticArguments' einen ungültigen Typ zurückgegeben. Es wurde ein Typ mit dem Namen '{1}' erwartet, es wurde jedoch ein Typ mit dem Namen '{2}' zurückgegeben.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Die änderbare lokale Variable "{0}" ist implizit als Verweiszelle zugewiesen, da sie von einem Abschluss erfasst wurde. Diese Warnung dient nur zur Information und soll auf die Ausführungsorte impliziter Zuweisungen hinweisen.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>Im F#-Code kann "expr.[expr]" verwendet werden. Möglicherweise ist eine Typanmerkung erforderlich, um den ersten Ausdruck in einem Array anzugeben.</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Schnittstellen dürfen keine Definitionen von Objektkonstruktoren enthalten.</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Ungültige Version '{0}' für '--subsystemversion'. Die Version muss 4.00 oder höher sein.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Benannte Argumente müssen nach allen anderen Argumenten aufgeführt werden.</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>Die Variable "{0}" ist in Anführungszeichen gebunden, wird aber in einem Splice-Ausdruck verwendet. Dies ist nicht zulässig, da dadurch der Bereich mittels Escapevorgängen außer Kraft gesetzt werden kann.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer enum-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Kein Signaturverzeichnis</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Unerwarteter infix-Operator in Maßeinheitenausdruck. Zulässige Operatoren sind "*", "/" und "^".</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>Eigenschaft</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Von einem versiegelten Typ kann nicht geerbt werden.</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Dieses Konstrukt ist als Teil eines Sequenzausdrucks nicht eindeutig. Geschachtelte Ausdrücke können mit "let _ = (...)", geschachtelte Sequenzen mit "yield! seq {{... }}" ausgedrückt werden.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IStructuralEquatable-Schnittstelle explizit. Wenden Sie das CustomEquality-Attribut auf den Typ an.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Dieser Member ist in einer Objektimplementierung unzulässig.</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Eine importierte Assembly verwendet den Typ "{0}"; dieser Typ ist aber nicht öffentlich.</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- VERSCHIEDENES -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Das Modul bzw. der Namespace "{0}" aus der Kompilierungseinheit "{1}" enthielt nicht den Namespace, das Modul oder den Typ "{2}".</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Der residente Kompilierungsdienst wurde nicht verwendet, da bei der Kommunikation mit dem Server ein Problem aufgetreten ist.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Eine Feld/Wert-Deklaration ist an dieser Stelle nicht zulässig.</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>New-Einschränkungen müssen ein Argument vom Typ "unit" annehmen und den konstruierten Typ zurückgeben.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Verwenden Sie einen residenten Hintergrundkompilierungsdienst, um die Startzeiten des Compilers zu verbessern.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Ungültige Einschränkung.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Implementierung NULL als Darstellung verwenden darf, laut Signatur aber nicht.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Fehler beim Anwenden der statischen Argumente auf eine angegebene Methode.</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Angegebene verwaltete Ressource einbetten</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Die Methode "System.Runtime.CompilerServices.OffsetToStringData" wurde beim Erstellen des fixed-Ausdrucks in den Verweisen nicht gefunden.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Ein Member und eine lokale Klassenbindung haben beide den Namen "{0}".</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' muss von einem Variablennamen gefolgt werden. Verwendung: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Dieser Typetest mit dem angegeben Typ '{0}' ist nicht zulässig, da dieser angegebene Typ zur Laufzeit in '{1}' gelöscht wird.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil es sich bei der Implementierung um eine abstrakte Klasse handelt, bei der Signatur hingegen nicht. Fügen Sie der Signatur ggf. das [&lt;AbstractClass&gt;]-Attribut hinzu.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Argumentlänge stimmt nicht überein.</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Dieser Wert ist keine Funktion und kann nicht angewendet werden. Wurde möglicherweise eine Deklaration nicht abgeschlossen?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Der Member "{0}" kann nicht zur Implementierung von "{1}" verwendet werden. Die erforderliche Signatur lautet "{2}".</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Dieser Typ implementiert dieselbe Schnittstelle mit den unterschiedlichen generischen Instanziierungen "{0}" und "{1}". Dies ist in dieser Version von F# nicht zulässig.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>Die Option '--keycontainer' überschreibt das Attribut 'System.Reflection.AssemblyNameAttribute', das in einer Quelldatei oder einem hinzugefügten Modul angegeben wurde.</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Der Systemtyp "{0}" war erforderlich, aber in keiner referenzierten System-DLL vorhanden.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Wird verwendet, um einen Berechnungsausdruck anzugeben, der bei der Auswertung das Ergebnis ausgibt, welches den Berechnungsausdruck enthält.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Infix-Operatormember "{0}" weist zusätzliche Curryargumente auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Dieser Member ist in einer Schnittstellenimplementierung unzulässig.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Infix-Operatormember '{0}' weist {1} anfängliche(s) Argument(e) auf. Erwartet wurde ein Tupel mit 3 Argumenten</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>Das FieldOffset-Attribut kann nur für Member des mit "StructLayout(LayoutKind.Explicit)" markierten Typs festgelegt werden.</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Ein Konstruktor darf keine expliziten Typparameter aufweisen. Verwenden Sie stattdessen eine statische Konstruktionsmethode.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanRead=false festgelegt, GetGetMethod() hat jedoch eine Methode zurückgegeben.</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>In Abfragen muss '{0}' ein einfaches Muster verwenden.</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Unerwartetes "Const_bytearray".</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Unerwartetes Expr.TyChoose</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Unerwartetes Eingabeende in Objektmembern</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>Die Methode "{0}" enthält Curryargumente, hat aber denselben Namen wie eine andere Methode im Typ "{1}". Methoden mit Curryargumenten dürfen nicht überladen werden. Verwenden Sie ggf. eine Methode, die Tupelargumente akzeptiert.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Ein {0} gab Version '{1}' an, dieser Wert ist jedoch ungültig und wurde ignoriert.</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Der Typparameter kann nicht als Typkonstruktor verwendet werden.</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Änderbare Variablen können ihre Methode nicht mit Escapevorgängen außer Kraft setzen.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Maßeinheitendeklarationen dürfen nur statische Member enthalten.</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Der {0}-Operator sollte normalerweise nicht umdefiniert werden. Verwenden Sie einen anderen Operatornamen.</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Der Wert "{0}" vom Typ "byref" kann an diesem Punkt nicht verwendet werden.</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Das Suchverzeichnis "{0}" wurde nicht gefunden.</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Dieses Konstrukt ist als Teil eines Berechnungsausdrucks nicht eindeutig. Geschachtelte Ausdrücke können mit "let _ = (...)", geschachtelte Berechnungen mit "let! res = builder {{ ... }}" ausgedrückt werden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil in der Signatur {2} "{3}" definiert ist, in der Implementierung aber nicht (oder nicht in der gleichen Reihenfolge).</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Vollständiger Name</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Ausgabemeldungen mit vollqualifiziertem Pfad</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur.</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>"FSharp.Core.dll" nicht zusammen mit den generierten Binärdateien kopieren</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Für ein generisches Konstrukt muss es sich beim Typ "{0}" um einen nicht verwalteten Typ handeln.</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.Equals". Implementieren Sie eine entsprechende Überschreibung für "Object.GetHashCode()".</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Explizite Typdeklarationen für Konstruktoren müssen im Format "ty1 * ... * tyN -&gt; resTy" angegeben werden. Möglicherweise muss "resTy" in Klammern gesetzt werden.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Wird verwendet, um anzugeben, dass eine Funktion rekursiv ist.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Wird in einer Signatur verwendet, um einen Wert anzugeben, oder in wenigen Situationen in einem Typ, um einen Member zu deklarieren.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Wird anstelle von "let" für Werte verwendet, bei denen die "Dispose" zum Freigeben von Ressourcen erforderlich ist.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Wird verwendet, um einen Codeblock einzuführen, der unter Umständen eine Ausnahme generiert. Wird zusammen mit "with" oder "finally" verwendet.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Wird verwendet, um einen Konstruktor zu deklarieren, definieren oder aufzurufen, der ein Objekt erstellt oder erstellen kann. Wird auch in generischen Parameterbeschränkungen verwendet, um anzugeben, dass ein Typ über einen bestimmten Konstruktor verfügen muss.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Kein tatsächliches Schlüsselwort. "not struct" wird in Kombination als generische Parametereinschränkung verwendet.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Wird verwendet, um einen Namen einem Wert oder einer Funktion zuzuordnen oder daran zu binden.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Wird in Lambdaausdrücken verwendet, auch als anonyme Funktionen bekannt.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Wird in Schleifenkonstrukten verwendet.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Gibt in Typendefinitionen und Typerweiterungen das Ende eines Abschnitts von Memberdefinitionen an. Wird in ausführlicher Syntax verwendet, um das Ende eines Codeblocks festzulegen, der mit dem Anfangsschlüsselwort beginnt.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Getter und Setter einer Eigenschaft müssen denselben Typ aufweisen. Eigenschaft '{0}' hat einen Getter vom Typ '{1}', jedoch einen Setter vom Typ '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Die Anzahl der Typargumente stimmte nicht überein: Es wurde {1} erwartet, jedoch {0} ausgegeben. Dies kann mit einem zuvor gemeldeten Fehler zusammenhängen.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Für dieses Feld ist ein Name erforderlich.</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>Generierter Typ</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Ungültige Versionszeichenfolge "{0}".</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Typargumente können an dieser Stelle nicht angegeben werden.</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für native Integer mit Vorzeichen.</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Mit diesem Typtest oder der Typumwandlung wird der angegebene Typ '{0}' in den Typ '{1}' geändert.</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Deklarationen vom Typ 'inherit' dürfen keine as-Bindungen aufweisen. Für den Zugriff auf Member der Basisklasse beim Überschreiben einer Methode kann die Syntax 'base.SomeMember' verwendet werden; 'base' ist ein Schlüsselwort. Entfernen Sie diese as-Bindung.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Wird verwendet, um einen Delegaten zu deklarieren.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Methode oder Objektkonstruktor "{0}" wurde nicht gefunden.</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Unzulässige Breite in Formatbezeichner.</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Typen mit dem AllowNullLiteral-Attribut können nur von Typen erben bzw. diese implementieren, die die Verwendung des NULL-Literals ebenfalls zulassen.</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Ein statischer Initialisierer erfordert ein Argument.</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Syntaxfehler - unerwartetes Symbol "?".</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Unzulässige Verwendung eines Schnittstellentyps.</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Aufeinanderfolgende Muster sollten durch Leerzeichen getrennt oder als Tupel angegeben werden.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>Die erforderliche Signatur ist {0}.</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit war nicht vorhanden.</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Statische bedingte Optimierungsausdrücke sind nur für die Verwendung innerhalb der F#-Bibliothek vorgesehen.</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Alle Elemente eines Arraykonstruktorausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Der deklarierte Typparameter "{0}" kann an dieser Stelle nicht verwendet werden, weil der Typparameter zur Kompilierzeit nicht aufgelöst werden kann.</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>"{0}" ist kein gültiger Assemblyname.</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Dies ist kein gültiger Name für ein aktives Muster.</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>Dem if-Ausdruck fehlt ein else-Branch. Der then-Branch weist den Typ "{0}" auf. Da "if" ein Ausdruck und keine Anweisung ist, fügen Sie einen else-Branch hinzu, der einen Wert des gleichen Typs zurückgibt.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Unerwartetes Eingabeende in der Typsignatur</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Doppelte Methode. Die Methode "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Methode im Typ "{1}".</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Diese Methode ist durch ihre Typparameter übermäßig eingeschränkt.</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Fehlende Variable "{0}".</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für Inlineassembly-Codetypen nicht zulässig.</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Reflektierte Definitionen dürfen keinen Präfix-Splice-Operator "%" enthalten.</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Maßeinheiten dürfen nicht als Präfixargumente für einen Typ verwendet werden. Ändern Sie sie in Postfixargumente in spitzen Klammern.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Die Einschränkungen "struct" und "not struct" sind nicht konsistent.</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Dieses Literalmuster nimmt keine Argumente an.</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Ungültige Deklarationssyntax.</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Der Operator '{1}' wird von keinem der Typen '{0}' unterstützt</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Delegattypen sind immer versiegelt.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Nach diesem Punkt wurde ein Ausdruck erwartet.</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Der Typ "{0}" ist weniger zugreifbar als der Wert, Member oder Typ "{1}", in dem er verwendet wird.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Deterministische Assembly erstellen (einschließlich Modulversions-GUID und Zeitstempel)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Unerwarteter NULL-Rückgabewert vom angegebenen Typ '{0}' Member '{1}':</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>"Dispose" für "IDisposable" wurde nicht gefunden oder war überladen.</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Unbekannte Datenschutzeinstellung "{0}" für verwaltete Ressource; gültige Optionen sind "public" und "private".</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Ein als "inline" markierter Wert konnte nicht inline gestellt werden.</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Für ein generisches Konstrukt muss der Typ "{0}" einen öffentlichen Standardkonstruktor aufweisen.</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} ist kein Instanzmember.</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Anführungszeichen dürfen diese Art von Konstante nicht enthalten.</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat in ParameterExpression einen ungültigen Parameter verwendet: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Der generische Member "{0}" wurde bei einer nicht einheitlichen Instanziierung vor diesem Programmpunkt verwendet. Ordnen Sie die Member ggf. neu an, damit dieser Member zuerst angezeigt wird. Sie können auch explizit den vollständigen Typ des Members angeben, einschließlich Argumenttypen, des Rückgabetyps und aller zusätzlichen generischen Parametern und Einschränkungen.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>In einem Typ würde ein Wert vom Typ "byref" gespeichert werden. Dies ist mit der Common IL nicht zulässig.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Es wurden keine Implementierungsdateien angegeben.</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie inline-Flags sind unterschiedlich.</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Ungültiger Namespace-, Modul-, Typ- oder Union-Fallname.</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Typabkürzungen dürfen keine Member aufweisen.</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>"rec" für dieses Modul wird implizit durch eine äußere rec-Deklaration angegeben und daher ignoriert.</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Dieser Typ ist kein Datensatztyp. Werte von Klassen- und Strukturtypen müssen mithilfe von Aufrufen an Objektkonstruktoren erstellt werden.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Ein unterstützender Typ für den Operator "{0}" wurde erwartet, aber ein Funktionstyp wurde empfangen. Möglicherweise fehlt ein Argument für eine Funktion.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Namespaces dürfen keine Werte enthalten. Verwenden Sie ein eigenes Modul für Ihre Wertdeklarationen.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Es wurden keine Invoke-Methoden für den Delegattyp gefunden.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Unvollständiger bedingter Ausdruck. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Ein benutzerdefinierter Vorgang darf in diesem Berechnungsausdruck nicht in Verbindung mit den Operatoren 'use', 'try/with', 'try/finally', 'if/then/else' oder 'match' verwendet werden.</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>Das StructuralComparison-Attribut muss in Verbindung mit dem StructuralEquality-Attribut verwendet werden.</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Ungültige Verwendung des Schlüsselworts "rec".</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Enumerationen dürfen keine Member aufweisen.</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>Die Datensatzbezeichnung oder der Namespace "{0}" ist nicht definiert.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Anführungszeichen dürfen keine generischen Ausdrücke enthalten.</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Die Befehlszeilenoption "{0}" ist veraltet.</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Wird in asynchronen Workflows verwendet, um einen Namen an das Ergebnis einer asynchronen Berechnung zu binden, oder in anderen Berechnungsausdrücken, um einen Namen an ein Ergebnis vom Berechnungstyp zu binden.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Aufrufe</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>Kein passendes #if für #else vorhanden.</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Dient zum Überschreiben des Speicherorts, an dem der Compiler nach "mscorlib.dll" und den Frameworkkomponenten sucht.</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" akzeptiert {1} Typargument(e), erhält hier aber {2}. Die erforderliche Signatur lautet "{3}".</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" wurde in Assembly "{2}" nicht gefunden. Mögliche Ursache ist eine Versionsinkompatibilität. Möglicherweise müssen Sie die richtige Version dieser Assembly explizit referenzieren, damit alle referenzierten Komponenten die richtige Version benutzen können.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Unzulässige Syntax in Typenausdruck.</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für diesen Integer-Typ.</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Das aktive Muster "{0}" ist keine Funktion.</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>Der Getter und der Setter der Eigenschaft "{0}" vom Typ "{1}" stimmen nicht überein. Wenn einer abstrakt ist, muss es der andere ebenfalls sein.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>Verwenden Sie in Abfragen die Form 'for x in n .. m do ...' für bereichsübergreifende Integer.</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Dateiende in einer Zeichenfolge mit dreifachen Anführungszeichen, die an oder vor dieser Stelle begonnen wurde</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Unerwartetes Eingabeende im Wert, der Funktion oder der Memberdefinition</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Der Objektkonstruktor "{0}" akzeptiert {1} Argument(e), erhält hier aber {2}. Die erforderliche Signatur ist "{3}". Wenn bestimmte Argumente Eigenschaften Werte zuordnen sollen, trennen Sie diese Argumente mit einem Komma (",").</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>"{0}" muss auf ein Argument vom Typ "{1}" angewendet werden, wurde aber auf ein Argument vom Typ "{2}" angewendet.</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Erweiterung eines versiegelten Typs kann nicht erstellt werden.</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Kein übereinstimmendes "in" für dieses "let" gefunden.</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Das Sichtbarkeitsattribut "{0}" ist für die Modulabkürzung nicht zulässig. Modulabkürzungen sind immer privat.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Ein Typ mit dem NoComparison-Attribut sollte in der Regel keine explizite Implementierung von "System.IComparable", "System.IComparable&lt;_&gt;" oder "System.Collections.IStructuralComparable" aufweisen. Deaktivieren Sie diese Warnung, wenn diese Implementierung aus Interoperabilitätsgründen beabsichtigt ist.</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Dieses Konstrukt darf nur innerhalb von Berechnungsausdrücken verwendet werden. Wenn ein Wert von einer normalen Funktion zurückgegeben werden soll, lassen Sie einfach "return" im Ausdruck weg.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Eigenschaftsdefinitionen können nicht änderbar deklariert werden. Um anzugeben, dass diese Eigenschaft festgelegt werden kann, verwenden Sie 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- ERWEITERT -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie static-Modifizierer sind unterschiedlich.</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>kompilierte Form des Union-Falls</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Fehler bei Assemblyauflösung an dieser Position oder in ihrer Nähe.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Reihenfolge der Felder in der Signatur und in der Implementierung unterschiedlich ist.</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Abstrakte Member sind in einer Augmentation nicht zulässig, sondern müssen als Teil des Typs selbst definiert werden.</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Unerwartetes Eingabeende in der 'then'-Verzweigung des bedingten Ausdrucks. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Unerwartetes Eingabeende im 'match'- oder 'try'-Ausdruck</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Unerwartetes Eingabeende in der 'else'-Verzweigung des bedingten Ausdrucks. Es wurde 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Beim Erstellen eines Datensatzwerts dürfen keine Argumente angegeben werden.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Bezeichner mit "@" sind für die F#-Codegenerierung reserviert.</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Dieses Lookup kann an dieser Stelle nicht verwendet werden.</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Member, die Schnittstellen-, Delegat- oder Enumerationstypen erweitern, müssen in einem von der Typdefinition getrennten eigenen Modul platziert werden. Dieses Modul muss entweder mit dem AutoOpen-Attribut versehen oder vom Clientcode explizit geöffnet werden, um die Erweiterungsmember in den Bereich einzubinden.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Schnittstellenimplementierungen dürfen nicht für Konstruktionsausdrücke verwendet werden.</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Dieser Code ist nicht generisch genug. Die Typvariable "{0}" konnte nicht generalisiert werden, weil sie sonst aus dem Bereich fallen würde.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Dateiende in einem IF-OCAML-Abschnitt, der an oder vor dieser Stelle begonnen wurde.</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Nur Klassen dürfen das AbstractClass-Attribut erhalten.</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>"System.Void" kann in F# nur als "typeof&lt;System.Void&gt;" verwendet werden.</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>Die Syntax "(typ,...,typ) ident" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "ident&lt;typ,...,typ&gt;".</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Strukturtypen dürfen keine abstrakten Member enthalten.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Dieser neue Member verbirgt den abstrakten Member "{0}", nachdem alle Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden. Benennen Sie den Member um, oder verwenden Sie stattdessen "override".</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Unerwartete Decodierung von InterfaceDataVersionAttribute.</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Die Trennregeln des |-Tokens für diesen Mustervergleich sind um eine Spalte verschoben. Richten Sie den Code neu aus, oder verwenden Sie weitere Einzüge.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nFür diesen Wert wurde keine Stelligkeit per Rückschluss abgeleitet.</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Unerwartete Eigenschaftenspezifikation auf Quellcodeebene in der Syntaxstruktur.</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Zusätzliche Felder haben Werte erhalten.</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Wird zum Konvertieren in einen Typ verwendet, der in Vererbungskette niedriger ist. </value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nEin Tupeltyp ist für mindestens ein Argument erforderlich. Schließen Sie die angegebenen Argumente ggf. in zusätzliche Klammern ein, oder überprüfen Sie die Definition der Schnittstelle.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Unerwartete große rationale Konstante.</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Ungültiges Bildformat.</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Leerer Namespace gefunden von Typanbieter '{0}'. Verwenden Sie für den globalen Namespace 'null'.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Namen sind unterschiedlich.</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0}-Variable in der Sammlung {1} (outerKey = innerKey). Nach "{2}" sind Klammern erforderlich.</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' oder '=' erwartet</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Unerwartete Decodierung von InternalsVisibleToAttribute.</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Unvollständiger Präprozessorausdruck.</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: verzögert</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Es ist kein direkter Verweis zum generierten Typ '{0}' zulässig. Verwenden Sie stattdessen eine Typdefinition, z. B. TypeAlias = &lt;path&gt;. Dies weist darauf hin, dass ein Typanbieter Ihrer Assembly generierte Typen hinzufügt.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Syntaxfehler. Falsches geschachteltes #endif, unerwartete Token davor.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Spezifische Warnungen aktivieren, die möglicherweise standardmäßig deaktiviert sind</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} ist ein aktives Muster und kann nicht als ein diskriminierter Union-Fall mit benannten Feldern behandelt werden.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Datensatztypen sind immer versiegelt.</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Ungültige Signatur für festgelegten Member.</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>'while'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Dies ist kein gültiges Zeichenliteral.</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Rückgabetypen dürfen keinen Namen aufweisen.</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Von einem gelöschten angegebenen Typ kann nicht geerbt werden.</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Der Anbieter "{0}" hat einen nicht generierten Typ "{1}" im Kontext einer Reihe von generierten Typen zurückgegeben. Ziehen Sie eine Anpassung des Typanbieters in Betracht, damit dieser nur generierte Typen zurückgibt.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Eine enum-Einschränkung muss das Format "enum&lt;Typ&gt;" aufweisen.</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine abstrakte Angabe steht einer nicht abstrakten gegenüber.</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>Der Name "({0})" sollte nicht als Membername verwendet werden. Überschreiben Sie zum Definieren der Gleichheitssemantik für einen Typ den Object.Equals-Member. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für Dezimalliterale.</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>Fehler beim Lesen der F#-Metadaten der Assembly "{0}". Ein reserviertes Konstrukt wurde verwendet. Möglicherweise müssen Sie Ihren F#-Compiler aktualisieren oder eine frühere Version der Assembly verwenden, die kein spezifisches Konstrukt einsetzt.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Zu viele statische Parameter. Es wurden höchstens {0} Parameter erwartet, zurückgegeben wurden jedoch {1} unbenannte und {2} benannte Parameter.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Auf eine namespace-Deklaration darf kein "="-Zeichen folgen.</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Die Typen "System.ValueType", "System.Enum", "System.Delegate", "System.MulticastDelegate" und "System.Array" dürfen nicht als übergeordnete Typen in einem Objektausdruck oder einer Klasse verwendet werden.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Diese Datei enthält mehrere Deklarationen im Format "module SomeNamespace.SomeModule". Pro Datei ist nur eine Deklaration in diesem Format zulässig. Verwenden Sie eine Namespacedeklaration am Dateianfang und/oder "module ModuleName = ..." zur Definition der Module.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Vom Schnittstellentyp kann nicht geerbt werden. Verwenden Sie stattdessen "interface ... with".</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Modulübergreifende Optimierungen aktivieren oder deaktivieren</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Wird in Abfrageausdrücken verwendet, um festzulegen, welche Felder oder Spalten extrahiert werden. Dies ist kontextabhängiges Schlüsselwort, d. h. es ist kein reserviertes Wort und funktioniert nur im entsprechenden Kontext als Schlüsselwort.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>Die Adresse des Felds "{0}" kann an diesem Punkt nicht verwendet werden.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer unmanaged-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Diese Typdefinition darf nicht über das 'CLIMutable'-Attribut verfügen. Nur Datensatztypen dürfen über dieses Attribut verfügen.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 64-Bit-Integer mit Vorzeichen.</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für Enumerationsfelder nicht zulässig.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die {2}-Anzahl unterschiedlich ist.</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Ungültige Typerweiterung.</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problem mit Dateinamen "{0}": {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif für #else erforderlich.</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Wird verwendet, um einen Strukturtyp zu deklarieren. Wird auch in generischen Parameterbeschränkungen verwendet. Wird für die OCaml-Kompatibilität in Moduldefinitionen verwendet.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Wird verwendet, um eine Methode oder Eigenschaft anzugeben, die ohne eine Instanz eines Typs aufgerufen werden kann, oder einen Wertemember, der für alle Instanzen eines Typs freigegeben wird.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>Das EntryPointAttribute-Attribut darf nur für Funktionsdefinitionen in Modulen verwendet werden.</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Der Standardwert hat nicht den gleichen Typ wie das Argument. Das DefaultParameterValue-Attribut sowie ggf. vorhandene optionale Attribute werden ignoriert. Hinweis: "null" muss mit dem richtigen Typ gekennzeichnet sein. Beispiel: DefaultParameterValue(null:obj).</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Fehlerhafte generische Instanziierung. Kein {0}-Member namens "{1}" akzeptiert {2} generische Argumente.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Namespaces dürfen Erweiterungsmember nur in der gleichen Datei und Namespace-Deklarationsgruppe enthalten, in denen der Typ definiert ist. Verwenden Sie ggf. ein eigenes Modul für Deklarationen von Erweiterungsmembern.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Wird verwendet, um einen Wert anzugeben, der als Ergebnis eines Berechnungsausdrucks auszugeben ist.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>Auf den Wert "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Der Einzug dieses in-Tokens ist im Hinblick auf das entsprechende "let" fehlerhaft.</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Der Typ "{0}" ist hier erforderlich, aber nicht verfügbar. Sie müssen einen Verweis auf Assembly "{1}" hinzufügen.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>Der Operator '{0}' lässt die Verwendung von 'into' nicht zu.</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} ist kein statischer Member.</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Anonyme Typvariablen sind in dieser Deklaration nicht zulässig.</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Dieser Datensatz enthält Felder aus inkonsistenten Typen.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>"let"- und "do"-Bindungen müssen in Typdefinitionen vor Member- und Schnittstellendefinitionen kommen.</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Direktiven innerhalb von Modulen werden ignoriert.</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 16-Bit-Integer mit Vorzeichen.</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problem mit Codepage "{0}": {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Attributausdrücke müssen Aufrufe von Objektkonstruktoren sein.</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Einem Delegatkonstruktor muss ein einzelner Funktionswert übergeben werden.</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Dieser Indexer erwartet {0} Argumente, erhält hier aber {1}.</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>Der if-Ausdruck muss Typ "{0}" aufweisen, damit die Kontexttypanforderungen erfüllt sind. Derzeit weist er Typ "{1}" auf.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Abgekürzte Typen können nicht mit dem Sealed-Attribut versehen werden.</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Optimierungen aktivieren (Kurzform: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Diese Überschreibung akzeptiert eine andere Anzahl von Argumenten als der entsprechende abstrakte Member. Die folgenden abstrakten Members wurden gefunden: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Keine Entsprechung für "[".</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Ein Literalwert kann nicht als "inline" markiert werden.</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>Das NoEquality-Attribut muss in Verbindung mit dem NoComparison-Attribut verwendet werden.</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die byref-Zeiger erfordern.</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Unerwarteter Schrägstrich ("/") im Typ.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Assemblycodetypen sind immer versiegelt.</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Keine Eingaben angegeben.</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Konstanten ungleich null dürfen keine generischen Einheiten aufweisen. Für eine generische Null schreiben Sie "0.0&lt;_&gt;".</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Ungültiger Getter oder Setter für Eigenschaft.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und Implementierung sind nicht kompatibel, weil in der Signatur "{2}", in der Implementierung hingegen "{3}" deklariert wird.</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Das Zeichen '{0}' ist im angegebenen Namespacenamen '{1}' nicht zulässig.</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Ungültige Direktive. Erwartet wurde "#I \"&lt;Pfad&gt;\"".</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 32-Bit-Integer ohne Vorzeichen.</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>Die Eigenschaft "{0}" hat denselben Namen wie eine Methode im Typ "{1}".</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>Ereignis</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>Feld</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Rekursiv definierte Werte können nicht direkt als Teil der Konstruktion eines Tupelwerts innerhalb einer rekursiven Bindung auftreten.</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Die Befehlszeilenoption "{0}" ist veraltet. Das Generieren von HTML-Dokumenten ist jetzt über das Tool "FsHtmlDoc.exe" Bestandteil des F# Power Packs.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Attribute sind für let-Bindungen in Ausdrücken nicht zulässig.</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Anzahl der entsprechenden Typparameter ist unterschiedlich.</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Dieser Member ist nicht generisch genug.</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Wird als boolesches Literal verwendet.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Anführungszeichen dürfen keine absteigenden For-Schleifen enthalten.</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Basisadresse für die zu erstellende Bibliothek</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problem beim Lesen von Assembly "{0}": {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat einen NULL-Member zurückgegeben.</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Ein Verweis auf den Typ "{0}" in Assembly "{1}" wurde gefunden, der Typ ist aber nicht in der Assembly vorhanden.</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Ein generischer Typparameter wurde auf eine Weise verwendet, durch die er immer "{0}" sein muss.</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist als Überschreibung markiert, die andere nicht.</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Es wurden {0} Ausdrücke erwartet, aber {1} empfangen.</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Mindestens ein deklarierter Typparameter für diese Typerweiterung verfügt über keine oder eine falsche Typeinschränkung, die nicht mit der ursprünglichen Typeinschränkung "{0}" übereinstimmt.</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>In mindestens einer Überschreibung ist der entsprechende abstrakte Member nicht korrekt implementiert.</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Das 'AssemblyVersionAttribute' wurde ignoriert, da eine Version mithilfe einer Befehlszeilenoption angegeben wurde.</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>Das DefaultValue-Attribut darf nur für val-Deklarationen verwendet werden.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Strukturtypen sind immer versiegelt.</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Typen können nicht von mehreren konkreten Typen erben.</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Unerwartete Typargumente.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Signatur erfordert, dass der Typ die {2}-Schnittstelle unterstützt; diese Schnittstelle ist aber nicht implementiert.</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- CODEGENERIERUNG -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Unerwartetes "Const_uint16array".</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung des Members "{0}" ist ungültig. Die Verwendung von "{1}" wurde vor der Definition von "{2}" per Rückschluss abgeleitet; dies ist ein ungültiger Vorwärtsverweis.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>ist</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Dieses Attribut kann in dieser Version von F# nicht verwendet werden.</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Attribute sind innerhalb von Mustern nicht zulässig.</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Der geerbte Member '{0}' kann nicht überschrieben werden, da er versiegelt ist.</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Dieser Typ enthält keine geschachtelten Typen.</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Der Dateiname '{0}' enthält das ungültige Zeichen '{1}'.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Das Feld, der Konstruktor oder der Member "{0}" ist nicht definiert.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>[&lt;ReflectedDefinition&gt;]-Begriffe dürfen keinen Präfix-Splice-Operator "%" enthalten.</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Typinstanziierungslänge stimmt nicht überein.</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Eine Setter-Eigenschaft darf maximal zwei Argumentgruppen aufweisen.</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Bestimmte Warnmeldungen deaktivieren</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Compiler-Copyrightmeldung unterdrücken</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Der Typ "{0}" wurde als Typ mit explizitem Layout markiert, das Feld "{1}" wurde jedoch nicht mit dem FieldOffset-Attribut versehen.</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Typen sind unterschiedlich.</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Die Verwendung des expression-splicing-Operators in der ersten Klasse ist nicht zulässig.</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Mit dieser Typumwandlung wird der angegebene Typ '{0}' in den Typ '{1}' geändert.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Der Typ {0} enthält den Member "{1}", entspricht aber keiner virtuellen oder abstrakten Methode, die zum Überschreiben oder Implementieren verfügbar ist.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>Das Attribut "{0}" ist sowohl in der Implementierung als auch in der Signatur enthalten, die Attributargumente unterscheiden sich jedoch. In den kompilierten Code wird nur das Attribut aus der Signatur eingefügt.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Der Operator '{0}' konnte nicht aufgelöst werden. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Unbekannte Option: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>Erweiterung</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil das Feld "{0}" in der Implementierung vorhanden war, aber nicht in der Signatur. Das Modul enthält die Ausnahmedefinition\n    {1}    \nDie Signatur gibt aber Folgendes an:\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Der Typ "{0}" enthält die {1}-Methode (vollständiger Name "{2}"), die Methode ist aber nicht statisch.</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Aufrufe von "reraise" dürfen nicht direkt in einem Handler für "try-with" auftreten.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Enumerationstypen sind immer versiegelt.</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Argumenttypen stimmen nicht überein.</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Die Angabe von "l" oder "L" ist in diesem Formatbezeichner nicht erforderlich. In F#-Code können Sie stattdessen %d, %x, %o oder %u verwenden; diese Bezeichner sind überladen und funktionieren mit allen grundlegenden Integer-Typen.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Lässt von einer Position außerhalb des Typs den Zugriff auf ein Member zu.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>Der Typ '{0}' weist nicht NULL als eigenen Wert auf. Zum Erstellen eines NULL-Werts für einen Typ, der NULL-Werte zulässt, 'System.Nullable()' verwenden.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Rekursiver ValValue "{0}"</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Typ '{0}' ist unzulässig, da T in byref&lt;T&gt; keine byref-Typen enthalten darf.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Bedingte Kompilierungssymbole definieren (Kurzform: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Attribute sind für inherit-Deklarationen nicht zulässig.</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>Die '{0}'-Eigenschaft des angegebenen Typs '{1}' ist auf CanWrite=true festgelegt, es gab jedoch keinen Wert von GetSetMethod().</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmedeklarationen unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>"FSharp.Core.sigdata" wurde nicht neben "FSharp.Core" gefunden. Die Datei wurde in {0} erwartet. Erwägen Sie ein Upgrade auf eine aktuellere Version von "FSharp.Core", in der die Datei nicht mehr erforderlich ist.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Einzeiliger Kommentar oder Zeilenende erwartet.</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Der Typanbieter hat NULL zurückgegeben, wobei es sich nicht um einen gültigen Rückgabewert von '{0}' handelt.</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>Auf die #if-Direktive sollte sofort ein Bezeichner folgen.</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Für "{0}" wurde keine Implementierung angegeben. Alle Schnittstellenmember müssen implementiert und unter einer entsprechenden interface-Deklaration aufgeführt werden, z.B. "interface ... with member ...".</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Der Block, der auf dieses {0}-Element folgt, ist unvollständig. Jeder Codeblock ist ein Ausdruck und muss ein Ergebnis besitzen. "{1}" kann nicht das letzte Codeelement in einem Block sein. Weisen Sie diesem Block ggf. ein explizites Ergebnis zu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Unerwartetes Eingabeende im 'while'-Ausdruck. Es wurde 'while &lt;expr&gt; do &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Maßeinheitendefinitionen dürfen keine Typparameter aufweisen.</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>Die kompilierte F#-DLL "{0}" muss erneut kompiliert werden, damit sie mit dieser Version von F# verwendet werden kann.</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Unerwartetes Eingabeende im 'match'-Ausdruck. Es wurde 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' erwartet.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Schnittstellentypen und Delegattypen dürfen keine Felder enthalten.</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Die Dateierweiterungen ".ml" und ".mli" dienen der ML-Kompatibilität.</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>Namespace</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e). Die erforderliche Signatur lautet "{2}".</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Maßeinheitendeklarationen dürfen nur statische Member enthalten: Konstruktoren sind nicht verfügbar.</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Schnittstellen dürfen keine Definitionen von statischen Initialisierern enthalten.</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>In Ausdrücken in Anführungszeichen sind innere generische Funktionen nicht zulässig. Fügen Sie Typeinschränkungen hinzu, bis diese Funktion nicht mehr generisch ist.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Unbekannt - Testargument: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problem beim Rückschluss von Typen ist zu komplex (maximale Iterationstiefe erreicht). Fügen Sie ggf. weitere Typanmerkungen hinzu.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>Der Wert, Namespace, Typ oder das Modul "{0}" ist nicht definiert.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie entsprechende Anzahl von Datenfeldern ist unterschiedlich.</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Strukturen dürfen keine do-Bindungen enthalten, da der Standardkonstruktor für Strukturen diese Bindungen nicht ausführen würde.</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Wird zum Konvertieren in einen Typ verwendet, der in Vererbungskette höher ist. </value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0}-Variable in der Sammlung {1} (outerKey = innerKey) in der Gruppe. Nach "{2}" sind Klammern erforderlich.</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Der mit null initialisierte Standardkonstruktor eines Strukturtyps darf nur verwendet werden, wenn alle Felder des Strukturtyps die Standardinitialisierung zulassen.</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Generische Typen können nicht mit dem StructLayout-Attribut versehen werden.</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Ein expliziter Objektkonstruktor sollte die Syntax "new(args) = expr" verwenden.</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Begrenzt ein nicht typisiertes Codezitat.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Strukturen dürfen keine Wertdefinitionen enthalten, da der Standardkonstruktor für Strukturen diese Bindungen nicht ausführt. Fügen Sie dem primären Konstruktor für diesen Typ ggf. zusätzliche Argumente hinzu.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für 8-Bit-Integer mit Vorzeichen.</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Ungültiger Member '{0}' für Anbietertyp '{1}'. Es sind nur Eigenschaften, Methoden und Konstruktoren zulässig.</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Keine Zuweisung für Feld "{0}" vom Typ "{1}" angegeben.</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Der Operator '{1}' wird vom Typ '{0}' nicht unterstützt</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>Die Adresse des statischen Felds "{0}" kann an diesem Punkt nicht verwendet werden.</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Mit dieser Deklaration wird der Namespace oder das Modul "{0}" über einen teilweise qualifizierten Pfad geöffnet. Passen Sie den Code an, und fügen Sie den vollständigen Pfad des Namespace hinzu. Durch diese Änderung bleibt der Code auch dann stabil, wenn die F#- und CLI-Bibliotheken um neue Konstrukte ergänzt werden.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>"do!" kann nicht in Sequenzausdrücken verwendet werden.</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Eine Implementierung der Datei oder des Moduls "{0}" wurde bereits angegeben. Die Kompilierungsreihenfolge ist in F# aufgrund des Typrückschlusses von Bedeutung. Möglicherweise müssen Sie die Reihenfolge der Dateien anpassen, um die Signaturdatei vor der Implementierung zu platzieren. In Visual Studio erfolgt die Typprüfung der Dateien in der Reihenfolge, in der sie in der Projektdatei aufgeführt sind; diese kann manuell bearbeitet oder im Projektmappen-Explorer angepasst werden.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>Ungültiger Namespace für den angegebenen Typ</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Diese Typdefinition umfasst einen sofortigen zyklischen Verweis über ein Strukturfeld oder eine Vererbungsbeziehung.</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Dieser Wert ist kein Literal und kann nicht als Muster verwendet werden.</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Jedes Argument des primären Konstruktors für eine Struktur muss einen Typ erhalten, z.B. "type S(x1:int, x2: int) = ...". Diese Argumente bestimmen die Felder der Struktur.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Änderbare Werte dürfen keine generischen Parameter aufweisen.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Die Mehrdeutigkeit bei der Verwendung eines generischen Konstrukts mit einer delegate-Einschränkung an dieser Position oder in ihrer Umgebung konnte nicht aufgelöst werden.</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Delegatspezifikationen müssen das Format "typ -&gt; typ" aufweisen.</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute kann nicht auf einen Instanzmember eines struct-Typs angewendet werden, da der Instanzmember einen impliziten 'this'-byref-Parameter akzeptiert.</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>"get" und/oder "set" erforderlich.</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>"{0}" unterstützt kein {1}-Präfixflag.</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Dieser Typparameter wurde auf eine Weise verwendet, durch die er immer "{0}" sein muss.</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Benannte Argumente dürfen nicht an Aufrufe für Membermerkmale übergeben werden.</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Die angegebene .NET Framework-Version "{0}" wird nicht unterstützt. Geben Sie einen Wert aus der Enumeration "Microsoft.Build.Utilities.TargetDotNetFrameworkVersion" an.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Eine Deklaration darf nur dann als [&lt;Literal&gt;]-Attribut verwendet werden, wenn auch ein Konstantenwert angegeben wird, z.B. "val x : int = 1".</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Die Dateierweiterung "{0}" wurde nicht erkannt. Quelldateien müssen die Erweiterung .fs, .fsi, .fsx, .fsscript, .ml oder .mli haben.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Diese inherit-Deklaration gibt zwar den geerbten Typ an, aber keine Argumente. Stellen Sie ggf. Argumente bereit, z.B. "inherit BaseType(args)".</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Ausgabedebugdatei benennen</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Verzeichnis für den Includepfad angeben, der zum Auflösen von Quelldateien und -assemblys verwendet wird (Kurzform: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Per Rückschluss abgeleitete Schnittstelle der Assembly in Datei ausgeben</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Modul erstellen, das einer anderen Assembly hinzugefügt werden kann</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Das Zeichen '|' ist nicht in Schreibweisenbezeichnern für das aktive Muster zulässig</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für diesen Member nicht zulässig. Abstrakte Umsetzungsplätze weisen immer die gleiche Sichtbarkeit auf wie der einschließende Typ.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Das Zeichen ";" wird verwendet, um Feldwerte in Datensätzen zu trennen. Ersetzen Sie "," ggf. durch ";".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Die inhärente Mehrdeutigkeit bei der Verwendung des {0}-Operators an diesem Programmpunkt oder in dessen Umgebung konnte nicht aufgelöst werden. Verwenden Sie Typanmerkungen, um die Mehrdeutigkeit aufzulösen.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Der Typ "{0}" ist nicht definiert.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Wird verwendet, um eine Funktion anzugeben, die direkt in den Code der aufrufenden Funktion integriert werden soll.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Dies ist kein gültiger Name für einen Enumerationsfall.</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Dieser Instanzmember erfordert einen Parameter, der das aufgerufene Objekt darstellt. Definieren Sie den Member als statisch, oder verwenden Sie die Notation "member x.Member(args) = ...".</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Es sind keine statische Parameter mit dem Namen '{0}' vorhanden.</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Ein Typ mit dem NoEquality-Attribut sollte in der Regel keine explizite Implementierung von "Object.Equals(obj)" aufweisen. Deaktivieren Sie diese Warnung, wenn diese Implementierung aus Interoperabilitätsgründen beabsichtigt ist.</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Dieser Wert wurde kopiert, damit das Original von diesem Vorgang nicht verändert wird.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Mindestens eine der expliziten Klassen- oder Funktionstypvariablen für diese Bindung konnte nicht generalisiert werden, weil eine Einschränkung für andere Typen vorlag.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Kandidaten: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Keine Entsprechung für "with" oder fehlerhaft formatierter with-Block.</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Alle Elemente eines Listenkonstruktorausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Explizite Typspezifikationen dürfen nicht für Ausnahmekonstruktoren verwendet werden.</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Der Datensatztyp für das Feld "{0}" wurde mit RequireQualifiedAccessAttribute definiert. Fügen Sie den Namen des Datensatztyps ("{1}") in den verwendeten Namen ein.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>Das entsprechende Formalargument ist nicht optional.</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Ungültiger Wert.</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>Die Argumentnamen in Signatur "{0}" und Implementierung "{1}" stimmen nicht überein. Der Argumentname aus der Signaturdatei wird verwendet. Dadurch kann es beim Debuggen oder bei der Profilerstellung zu Problemen kommen.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>Der Wert "{0}" wird nicht verwendet.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Option erfordert einen Parameter: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Ungültige Deklaration.</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für native Integer ohne Vorzeichen.</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Der Musterdiskriminator "{0}" ist nicht definiert.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Unerwartetes Ende der Eingabe</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Zwei Module namens "{0}" treten in zwei Teilen dieser Assembly auf.</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Es wurde mehr als eine Invoke-Methode für den Delegattyp gefunden.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Dieser Wert ist keine Funktion und kann nicht angewendet werden. Wollten Sie auf den Indexer stattdessen über "{0}.[index]" zugreifen?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Beim Parameter "{0}" wird angenommen, dass er über den byref-Typ verfügt. Für Parameter mit dem byref-Typ muss eine explizite Typanmerkung angegeben werden. Beispiel: "x1: byref&lt;int&gt;". Wenn er verwendet wird, wird ein byref-Parameter implizit dereferenziert.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Dieser statische Member sollte keinen this-Parameter aufweisen. Verwenden Sie die Notation "member Member(args) = ...".</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Für ein generisches Konstrukt muss der Typ "{0}" nicht abstrakt sein.</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Binden Sie nur Optimierungsinformationen ein, die für die Implementierung von Inlinekonstrukten unbedingt erforderlich sind. Dies verhindert zwar modulübergreifende Inlinekonstrukte, verbessert aber die Binärkompatibilität.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>Die Darstellung dieses Typs ist hinter der Signatur verborgen. Sie muss mit einem Attribut wie "[&lt;Sealed&gt;]", "[&lt;Class&gt;]" oder "[&lt;Interface&gt;]" versehen werden, um die Merkmale des Typs anzugeben.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>Das Format "{0}" unterstützt kein 0-Flag.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Ein Typrückschluss hat bewirkt, dass die Typvariable '{0}' ihren Bereich verlassen hat. Fügen Sie ggf. eine explizite Typparameterdeklaration hinzu, oder passen Sie Ihren Code so an, dass er weniger generisch ist.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Geben Sie den Debugtyp an: vollständig, portabel, eingebettet, pdbonly. ("{0}" ist der Standardwert, wenn kein Debugtyp angegeben wird, und ermöglicht das Anfügen eines Debuggers an ein aktuell ausgeführtes Programm. "Portabel" ist ein plattformübergreifendes Format, "eingebettet" ein plattformübergreifendes, in die Ausgabedatei eingebettetes Format).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Nur #-Compilerdirektiven dürfen vor der ersten namespace-Deklaration auftreten.</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Der lokale Wert "{0}" wurde während der Optimierung nicht gefunden.</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat eine Methode mit dem Namen '{1}' und dem Metadatentoken '{2}' angegeben, die nicht zu den Methoden des deklarierenden Typs '{3}' gehört</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Fehlerhafte Syntax für '{0}'. Verwendung: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Ungültige Gleitkommazahl.</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Konstruktoren sind als Erweiterungsmember unzulässig. Sie müssen als Teil der ursprünglichen Definition des Typs definiert werden.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Der Objektkonstruktor "{0}" besitzt kein Argument oder keine festlegbare Rückgabeeigenschaft "{1}". {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>Die Plattform 'anycpu32bitpreferred' kann nur mit EXE-Zielen verwendet werden. Stattdessen muss 'anycpu' verwendet werden.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie Namen sind unterschiedlich.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine statische Angabe steht einer nicht statischen gegenüber.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der Implementierungstyp nicht versiegelt ist, laut Signatur aber versiegelt sein sollte. Fügen Sie der Implementierung ggf. das [&lt;Sealed&gt;]-Attribut hinzu.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>'try'/'with' kann nicht in Sequenzausdrücken verwendet werden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil der abstrakte Member "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" umfasst eine explizite Implementierung von "Object.GetHashCode". Implementieren Sie eine entsprechende Überschreibung für "Object.Equals(obj)".</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Wird verwendet, um eine Eigenschaft oder Methode in einem Objekttypen zu deklarieren.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Wird verwendet, um einen Namen einer Gruppe zugehöriger Typen, Werte und Funktionen zuzuordnen, um ihn logisch von anderem Code zu trennen.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Typen sind unterschiedlich.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Anzahl der entsprechenden Typparameter unterschiedlich ist.</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Delegatspezifikationen dürfen keine Currytypen sein. Verwenden Sie "typ * ... * typ -&gt; typ" für Delegaten mit mehreren Argumenten und "typ -&gt; (typ -&gt; typ)" für Delegaten, die Funktionswerte zurückgeben.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>Der Wert "{0}" war als inline markiert, die Implementierung verwendet aber eine interne oder private Funktion, die keine ausreichende Zugreifbarkeit bietet.</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>Die {0}-Eigenschaft ist nicht statisch.</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Ungültiger Objekt-, Sequenz- oder Datensatzausdruck.</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Die für diesen Wert per Rückschluss abgeleiteten Typparameter sind beim Löschen von Typabkürzungen nicht stabil. Dies ist auf die Verwendung von Typabkürzungen zurückzuführen, die Typparameter löschen oder neu anordnen, z.B. \n\ttype taggedInt&lt;'a&gt; = int oder\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nDeklarieren Sie die Typparameter für diesen Wert explizit, z.B.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IStructuralComparable-Schnittstelle explizit. Wenden Sie das CustomComparison-Attribut auf den Typ an.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Syntaxfehler</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Ungültige Joinbeziehung in '{0}'. Es wurde 'expr &lt;op&gt; expr' erwartet, wobei &lt;op&gt; =, =?, ?= oder ?=? ist.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Feldbindungen müssen das Format "id = expr;" aufweisen.</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>Das {0}-Ereignis ist nicht statisch.</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0}-Variable in der Sammlung</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Wird in einem Sequenzausdruck zum Generieren eines Werts für eine Sequenz verwendet.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>'try/finally'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Objekte, die die IDisposable-Schnittstelle unterstützen, sollten mit der Syntax "new Type(args)" statt mit "Type(args)" oder "Type" als Funktionswert für den Konstruktor erstellt werden, um anzugeben, dass die Ressourcen sich möglicherweise im Besitz des generierten Werts befinden.</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Ein Literalwert kann nicht als "mutable" markiert werden.</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Führt ein Schleifenkonstrukt ein.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} ist keine statische Methode.</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Attribute sind für Schnittstellenimplementierungen nicht zulässig.</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Dieses Ausdrucksformat darf nur in Sequenz- und Berechnungsausdrücken verwendet werden.</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die Union-Fallindizes abrufen.</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>Gibt in ausführlicher Syntax den Beginn einer Klassendefinition an.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>Gibt in ausführlicher Syntax den Start eines Codeblocks an.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Aufrufe von Objektkonstruktoren auf Typparametern dürfen keine Argumente erhalten.</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Wird zum Verzweigen verwendet, indem ein Wert mit einem Muster verglichen wird.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Unerwartete Bedingung in importierter Assembly: Fehler beim Decodieren des AttributeUsage-Attributs.</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Dieser Union-Fall akzeptiert keine Argumente.</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Wird verwendet, um auf den .NET-Namespace der obersten Ebene zu verweisen.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Dieses Steuerkonstrukt darf nur verwendet werden, wenn vom Berechnungsausdrucks-Generator eine {0}-Methode definiert wird.</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Implizites Produktmaß nach "/".</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Ungültiges angegebenes Feld. Die angegebenen Felder von gelöschten angegebenen Typen müssen Literale sein.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Dies ist kein bekannter Abfrageoperator. Abfrageoperatoren sind Bezeichner wie z. B. 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' und 'averageBy', die mithilfe der entsprechenden Methoden für den Typ 'QueryBuilder' definiert werden.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente.</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Maßeinheiten werden nur für die Typen "float", "float32", "decimal" und "signed integer" unterstützt.</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Das Feld "{0}" ist nicht statisch.</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Dateien sollten mit einer Namespace- oder einer Moduldeklaration beginnen, z.B. "namespace SomeNamespace.SubNamespace" oder "module SomeNamespace.SomeModule", aber nicht mit beidem. Verwenden Sie "module SomeModule = ...", um ein Modul in einem Namespace zu definieren.</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>Die Signatur für diese externe Funktion enthält Typparameter. Schränken Sie das Argument und die Rückgabetypen ein, und geben Sie die Typen der entsprechenden C-Funktion an.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Alle Branches eines Musterabgleichsausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>Die {0}-Methode ist versiegelt und kann nicht überschrieben werden.</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Keine Entsprechung für "{0}".</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Hierbei handelt es sich nicht um eine Variable, Konstante, eine aktive Erkennung oder ein Literal.</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Das Feld "{0}" hat einen Wert erhalten, ist aber im Typ "{1}" nicht vorhanden.</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die statische Felder abrufen.</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Statische Wertdefinitionen dürfen nur in Typen mit einem primären Konstruktor verwendet werden. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Codeziel für dieses Attribut kann nicht gefunden werden. Möglicherweise ist der Code nach dem Attribut unvollständig.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Ungültiger Modul- oder Namespacename.</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>Benutzerdefinierter Vorgang</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Wird verwendet, um den Code während des Debuggens zu überprüfen.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Die Deklarationen in dieser Datei werden anhand des Dateinamens "{1}" im impliziten Modul "{0}" platziert. Dies ist jedoch kein gültiger F#-Bezeichner, sodass von anderen Dateien aus kein Zugriff auf die Inhalte möglich ist. Benennen Sie die Datei um, oder fügen Sie oben in der Datei eine module- oder namespace-Deklaration hinzu.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Die Schlüsseldatei '{0}' konnte nicht geöffnet werden.</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Anführungszeichen dürfen keinen Arraymustervergleich enthalten.</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Ein Tupeltyp ist ein Strukturtupel, der andere Typ ein Verweistupel.</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" erfordert {1} zusätzliche(s) Argument(e). Die erforderliche Signatur lautet "{2}". Einige fehlende Argumente sind {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" erfordert {1} Argument(e). Die erforderliche Signatur lautet "{2}". Einige fehlende Argumente sind {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Der Member oder Objektkonstruktor "{0}" erfordert {1} zusätzliche(s) Argument(e). Die erforderliche Signatur lautet "{2}".</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'let!' eingezogen werden.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Es wurde ein Typ- oder statisches Argument erwartet.</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Es wurden widersprüchliche Optionen angegeben: 'win32manifest' und 'win32res'. Nur eine dieser Optionen kann verwendet werden.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Doppelte Eigenschaft. Die Eigenschaft "{0}" hat denselben Namen und dieselbe Signatur wie eine andere Eigenschaft im Typ "{1}".</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Namen der bevorzugten Ausgabesprachenkultur angeben (z. B. "es-ES", "ja-JP")</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>In Sequenzausdrücken werden Ergebnisse mithilfe von "yield" erzeugt.</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Datei mit einem Schlüssel für einen starken Namen angeben</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Unerwarteter Bezeichner: '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Ungültige Zeilennummer: '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Optionale Argumente sind hier nicht zulässig.</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Dieses Konstrukt ist experimentell.</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Augmentationen sind für den Delegattyp "moduleDefns" nicht zulässig.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>"{0}" ist kein gültiges Integer-Argument.</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Wenn explizit auf "mscorlib.dll" oder "FSharp.Core.dll" verwiesen wird, muss auch die Option "{0}" übergeben werden.</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Typanmerkungen für Eigenschaftengetter und -setter müssen nach "get()" oder "set(v)" angegeben werden, z.B. "with get() : string = ...".</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Ausführbare Windows-Datei erstellen</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Name der Ausgabedatei (Kurzform: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Die Option "--sourcelink" wird nur bei der Ausgabe einer portablen PDB unterstützt (--debug:portable oder --debug:embedded).</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>Das auf den Parameter "{0}" angewendete CallerMemberNameAttribute besitzt keine Auswirkung. Es wird durch das CallerFilePathAttribute überschrieben.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Die benannten statischen Argumente müssen auf alle unbenannten statischen Argumente folgen.</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Ausführbare Konsolendatei erstellen</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Alle implementierten Schnittstellen sollten in der anfänglichen Deklaration des Typs deklariert werden.</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Unerwartete Eigenschaftenspezifikation auf Quellcodeebene.</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Ein abstrakter Basismember kann nicht aufgerufen werden: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>Das ConditionalAttribute-Attribut darf nur für Member verwendet werden.</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Ein Typ mit dem CustomComparison-Attribut erfordert die explizite Implementierung von "System.IComparable" und/oder "System.Collections.IStructuralComparable".</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie CLI-Membernamen sind unterschiedlich.</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Die von dieser Standardimplementierung implementierte Methode ist nicht eindeutig.</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# unterstützt einen Arrayrang zwischen 1 und 32. Der Wert {0} ist nicht zulässig.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Anführungszeichen dürfen diese Art von Typ nicht enthalten.</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Nur Überschreibungen von abstrakten und virtuellen Membern dürfen in Objektausdrücken angegeben werden.</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>XmlDoc der Assembly in angegebene Datei schreiben</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" in der Implementierung vorhanden war, nicht aber in der Signatur. Strukturtypen müssen jetzt ihre Felder in der Signatur für den Typ offen legen, auch wenn die Felder möglicherweise noch als "private" oder "internal" bezeichnet werden.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Auf den Union-Fall "{0}" kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Nur Datensatz-, Union-, Ausnahme- und Strukturtypen können mit den Attributen "ReferenceEquality", "StructuralEquality" und "StructuralComparison" augmentiert werden.</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Ungültige Signaturgröße.</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Win32-Manifestdatei angeben</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Ungültiger Indexerausdruck.</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Der Typname darf nicht leer sein.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Quelldatei "{0}" wurde nicht gefunden.</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Ein übergeordnetes Modul oder ein übergeordneter Namespace "{0}" wurde erwartet.</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>In Konstruktionsausdrücken dürfen nur einfache Bindungen im Format "id = expr" verwendet werden.</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Gibt an, dass ein deklariertes Programmelement in einem anderen Binär oder einer anderen Assembly definiert ist.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Die Datei mit Quelllinkinformationen, die in die portable PDB-Datei eingebettet werden soll</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>"new" darf nur für Objektkonstruktoren verwendet werden.</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Dieser Code ist weniger generisch, als aus seinen Anmerkungen hervorgeht. Eine mit "_" angegebene Maßeinheit ist "1", also ohne Dimension. Machen Sie den Code generisch, oder entfernen Sie "_".</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Dies ist kein gültiger literaler Ausdruck. Das [&lt;Literal&gt;]-Attribut wird ignoriert.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Signatur NULL als zusätzlichen Wert verwenden darf, laut Implementierung aber nicht.</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>'try/with'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>F#-Bibliothek und alle davon abhängigen DLLs, auf die verwiesen wird, statisch mit der generierten Assembly verknüpfen</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>Das AutoOpen(\"{0}\")-Attribut in der Assembly "{1}" verweist nicht auf ein gültiges Modul oder einen gültigen Namespace in der Assembly; es wird deshalb ignoriert.</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Dieses Feld ist nicht änderbar.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die Typen unterschiedlich sind.</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Enumerationen dürfen keine Schnittstellendeklarationen aufweisen.</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Bibliothek erstellen (Kurzform: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Assembly "{0}" konnte nicht aufgelöst werden.</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Auf einen Member oder Objektkonstruktor "{0}", der {1} Argumente akzeptiert, kann von dieser Position im Code nicht zugegriffen werden. Alle zugreifbaren Versionen der {2}-Methode nehmen {3} Argumente an.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Kurzform von "{0}"</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Es wurde bereits eine Standardimplementierung dieser Schnittstelle hinzugefügt, weil die explizite Implementierung der Schnittstelle nicht in der Typdefinition angegeben war.</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Das Feld mit dem Namen '{0}' wird mehrmals verwendet.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Deterministische Builds unterstützen nur portierbare PDbs ("--debug:portable" oder "--debug:embedded").</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Ungültiger Objektausdruck. Objekte ohne Überschreibungen oder Schnittstellen sollten das Ausdrucksformat "new Type(args)" ohne geschweifte Klammern verwenden.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>von {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Wird in einem for-Ausdruck beim Rückwährtszählen verwendet.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Dieser Typ ist kein Datensatztyp.</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke enthalten, die die Adresse eines Felds aufnehmen.</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" implementiert die System.IComparable-Schnittstelle explizit. Sie müssen das CustomComparison-Attribut auf den Typ anwenden.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>In Abfragen dürfen if/then/else-Ausdrücke nicht verwendet werden. Verwenden Sie stattdessen entweder einen if/then-Ausdruck oder einen Sequenzausdruck.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Der statische Parameter '{0}' verfügt bereits über einen Wert.</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Bestimmte Quelldateien in der portablen PDB-Datei einbetten</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung der Variablen "{0}" vom Typ "byref" ist ungültig. Byrefs können nicht von Abschlüssen erfasst oder an innere Funktionen übergeben werden.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Die {0}-Eigenschaft kann nicht festgelegt werden.</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Diese Eigenschaft kann nicht festgelegt werden.</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Die Verwendung der address-of-Operatoren in der ersten Klasse ist nicht zulässig.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist ein Konstruktor bzw. eine Eigenschaft, die andere nicht.</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Objektkonstruktionsausdrücke dürfen nur zur Implementierung von Konstruktoren in Klassentypen verwendet werden.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil das Feld "{0}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde. Das Modul enthält die Ausnahmedefinition\n    {1}    \nDie Signatur gibt aber Folgendes an:\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Für dieses numerische Literal muss sich das Modul "{0}" im Bereich befinden, das die Funktionen "FromZero", "FromOne", "FromInt32", "FromInt64" und "FromString" definiert.</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Für diesen Typ können keine Konstruktoren definiert werden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil das Feld "{2}" für die Signatur erforderlich war, in der Implementierung aber nicht angegeben wurde.</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Optionale Argumente sind nur für Typmember zulässig.</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>Einem Verweis auf einen angegebenen Typ fehlte ein Wert für den statischen Parameter '{0}'. Es müssen möglicherweise eine oder mehrere referenzierte Assemblys erneut kompiliert werden.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Alle Branches eines if-Ausdrucks müssen den gleichen Typ aufweisen. Es wurde erwartet, dass dieser Ausdruck den Typ "{0}" aufweist, hier liegt aber der Typ "{1}" vor.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Gelöscht zu</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Dieser Wert, dieser Typ oder diese Methode erwartet {0} Typparameter, es wurde(n) aber {1} übergeben.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil die Reihenfolge der Felder in der Signatur und in der Implementierung unterschiedlich ist. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Ein benutzerdefinierter Vorgang darf in einem anderen Teil dieses Berechnungsausdrucks nicht in Verbindung mit einem Nicht-Wert oder einer rekursiven 'let'-Bindung verwendet werden.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Der Member "{0}" weist nicht die richtige Anzahl von Methodentypparametern auf. Die erforderliche Signatur lautet "{1}".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine CLI-Typdarstellung von einer Signatur verdeckt wird.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralComparison-Attribut versehen, aber der Typparameter "{1}" erfüllt die comparison-Einschränkung nicht. Fügen Sie dem Typparameter die comparison-Einschränkung hinzu.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Der Struktur-, Datensatz- oder Union-Typ "{0}" ist mit dem StructuralComparison-Attribut versehen, aber der Komponententyp "{1}" erfüllt die comparison-Einschränkung nicht.</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>Die Adresse der Variablen "{0}" kann an diesem Punkt nicht verwendet werden.</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>Union-Fall</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Globaler Assemblycache</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Doppelte oder redundante Schnittstelle.</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Ungültige Antwortdatei "{0}" ("{1}").</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>'Use!'-Bindungen müssen das Format 'use! &lt;pat&gt; -&gt; &lt;expr&gt;' aufweisen.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil eine Typdarstellung von einer Signatur verdeckt wird.</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Ungültiger Datensatz-, Sequenz- oder Berechnungsausdruck. Sequenzausdrücke müssen das Format "seq {{ ... }}" besitzen.</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>Ereignis '{0}' des angegebenen Typs '{1}' verfügt nicht über einen Wert von GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Wird verwendet, um Schnittstellen zu deklarieren und implementieren.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist ein Erweiterungsmember, die andere nicht.</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Eigenschaftensetter müssen mit "set value = ", "set idx value = " oder "set (idx1,...,idxN) value = ... " definiert werden.</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Ungültiges Argument für parametrisierte Musterbezeichnung.</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Ungültige Bitlänge.</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>Die #if-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Es sind mehrere statische Parameter mit dem Namen '{0}' vorhanden.</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Flüchtige Felder müssen als "mutable" markiert werden und können nicht threadstatisch sein.</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Rückgabetypen von Union-Fällen müssen genau mit dem definierten Typ übereinstimmen, bis hin zu den Abkürzungen.</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für Überschreibungen oder Schnittstellenimplementierungen nicht zulässig.</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Verwenden Sie stattdessen eine Datei mit der Erweiterung ".ml" oder ".mli".</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Diese Eigenschaft überschreibt oder implementiert eine abstrakte Eigenschaft, aber für die abstrakte Eigenschaft ist kein(e) entsprechende(r/s) {0} vorhanden.</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Compilerfehler: unerwarteter nicht realisierter Wert.</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Ein Verweis auf einen angegebenen Typ hatte für einen statischen Parameter den ungültigen Wert '{0}'. Es müssen möglicherweise eine oder mehrere referenzierte Assemblys erneut kompiliert werden.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Die Ausnahmedefinitionen sind nicht kompatibel, weil die Ausnahmeabkürzungen in der Signatur und in der Implementierung unterschiedlich sind. Das Modul enthält die Ausnahmedefinition\n    {0}    \nDie Signatur gibt aber Folgendes an:\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Ungültiger benutzerdefinierter Attributwert (keine Konstante und kein Literal).</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Ausnahmeabkürzungen sollten keine Argumentlisten aufweisen.</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Diese Eigenschaft hat einen ungültigen Typ. Eigenschaften, die mehrere Indexerargumente akzeptieren, sollten Typen im Format "ty1 * ty2 -&gt; ty3" aufweisen. Eigenschaften, die Funktionen zurückgeben, sollten Typen im Format "(ty1 -&gt; ty2)" aufweisen.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Ein Wert vom Typ "byref" würde hier gespeichert werden. byref-Werte der obersten Ebene vom Typ "let-bound" sind nicht zulässig.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Für diesen Bezeichner wurden mehrere Sichtbarkeitsattribute angegeben. Bindungen vom Typ 'let' in Klassen sind immer privat, wie alle Bindungen vom Typ 'let' innerhalb von Ausdrücken.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Funktionsdefinitionen enthalten, die per Rückschluss abgeleitet sind oder als generisch deklariert werden. Fügen Sie Typeinschränkungen hinzu, damit dieser Ausdruck in Anführungszeichen gültig wird.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Unzulässige Genauigkeitsangaben in Formatbezeichner.</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Dieser Typ verfügt über keine zugreifbaren Objektkonstruktoren.</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Typ '{0}' von Typanbieter '{1}' verfügt über einen leeren Namespace. Verwenden Sie für den globalen Namespace 'null'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil dieser Typ laut Implementierung NULL als zusätzlichen Wert verwenden darf, laut Signatur aber nicht.</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Dieser Objektkonstruktor erfordert Argumente.</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für eine inherits-Deklaration nicht zulässig.</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Dieser Typ erfordert eine Definition.</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Literalfelder können nicht festgelegt werden.</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Wird in for-Schleifen zum Angeben eines Bereichs verwendet.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Wird mit booleschen Bedingungen als boolescher Wert oder Operator verwendet. Entspricht ||. Wird auch in Memberbeschränkungen verwendet.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Wird in Unterscheidungs-Unions verwenden, um den Typ der Wertekategorien anzugeben, sowie in Delegaten und Ausnahmedeklarationen.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Wird in bedingten Verzweigungskonstrukten verwendet.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Wird für Sequenzausdrücke und in ausführlicher Syntax zum Trennen von Ausdrücken aus Bindungen verwendet.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Wird verwendet, um für das aktuelle Klassenobjekt einen Objektnamen zu vergeben. Wird auch verwendet, um für ein gesamtes Muster innerhalb eines Musterabgleichs einen Namen zu vergeben.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Wird in Schleifenkonstrukten oder zum Ausführen von imperativem Code verwendet.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Änderbarkeitsattribute sind unterschiedlich.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Abkürzungen für Common IL-Ausnahmetypen müssen einen entsprechenden Objektkonstruktor aufweisen.</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Dies ist kein gültiges numerisches Literal. Die folgenden numerischen Literale sind z. B. gültig: 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>Das CustomEquality-Attribut muss in Verbindung mit den Attributen "NoComparison" oder "CustomComparison" verwendet werden.</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Eine Getter-Eigenschaft darf maximal eine Argumentgruppe aufweisen.</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Diese Member-, Funktions- oder der Wertdeklaration darf nicht mit 'inline' deklariert werden.</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Ungültiger Präfixoperator</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>An dieser Stelle wird kein Semikolon erwartet.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' wird nicht ordnungsgemäß verwendet. Verwendung: {1}. Hierbei handelt es sich um einen benutzerdefinierten Vorgang in dieser Abfrage oder im Berechnungsausdruck.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>Die Überschreibung für "{0}" war mehrdeutig.</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Container mit einem Schlüssel für einen starken Namen angeben</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Der expr.[idx]-Operator hat auf Grundlage von Informationen vor diesem Programmpunkt ein Objekt unbestimmten Typs verwendet. Fügen Sie ggf. weitere Typeinschränkungen hinzu.</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- FEHLER UND WARNUNGEN -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Assemblyverweise mithilfe von verzeichnisbasierten Regeln anstelle von MSBuild-Auflösung auflösen</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Doppelte Methode. Die abstrakte {0}-Methode hat denselben Namen und dieselbe Signatur wie in eine abstrakte Methode in einem geerbten Typ, nachdem Tupel, Funktionen, Maßeinheiten und/oder angegebene Typen gelöscht wurden.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Eine Maßeinheit kann nicht in einer Typkonstruktoranwendung verwendet werden.</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Objektkonstruktionsausdrücke (also Datensatzausdrücke mit Vererbungsspezifikationen) dürfen nur zur Implementierung von Konstruktoren in Objektmodelltypen verwendet werden. Verwenden Sie "new ObjectType(args)", um Instanzen von Objektmodelltypen außerhalb von Konstruktoren zu erstellen.</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>"{0}" darf nicht in Operatornamen verwendet werden und ist für eine zukünftige Verwendung reserviert.</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>'use'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Der Typ "{0}" ist kein Typ, dessen Werte mit dieser Syntax aufgelistet werden können, er ist daher weder mit "seq&lt;_&gt;" noch mit "IEnumerable&lt;_&gt;" oder "IEnumerable" kompatibel und verfügt über keine GetEnumerator-Methode.</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Unerwarteter leerer langer Bezeichner.</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Ungültige Direktive. Erwartet wurde "#r \"&lt;Datei-oder-Assembly&gt;\"".</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Ein Typrückschluss hat bewirkt, dass eine Variable vom Rückschlusstyp ihren Bereich verlassen hat. Fügen Sie ggf. Typanmerkungen hinzu, damit Ihr Code weniger generisch ist.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Der Typ "{0}" unterstützt die Konvertierung in den Typ "{1}" nicht.</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Die Befehlszeilenoption "--cliroot" ist veraltet. Verwenden Sie stattdessen einen expliziten Verweis auf eine bestimmte Kopie von "mscorlib.dll".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Die {0} Definitionen in der Signatur und in der Implementierung sind nicht kompatibel, weil die Namen unterschiedlich sind. Der Typ heißt "{1}" in der Signaturdatei, aber "{2}" in der Implementierung.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Ungültiges Argument für 'methodhandleof' bei der Codegenerierung</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Unerwartetes Symbol "=" im Ausdruck. Wollten Sie stattdessen "for x in y .. z do" verwenden?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Für den Typ "{0}" sind keine Konstruktoren verfügbar.</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Doppelte Schnittstellenspezifikation.</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Assembly '{0}' wurde im Abhängigkeitssatz der Zielbinärdatei nicht gefunden. Statistisch verknüpfte Stämme müssen mithilfe eines Assemblynamen angegeben werden, ohne DLL- oder EXE-Erweiterung. Wenn explizit auf diese Assembly verwiesen wurde, ist es möglich, dass die Assembly nicht wirklich für die erzeugte Binärdatei erforderlich war. In diesem Fall sollte sie nicht statisch verknüpft sein.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Der Typ "{0}" implementiert "System.IComparable". Sie sollten ebenfalls eine explizite Überschreibung für "Object.Equals" hinzufügen.</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Wird in gegenseitig rekursiven Bindungen, in Eigenschaftendeklarationen und bei mehreren Beschränkungen in Bezug auf generische Parameter verwendet.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Dies ist kein gültiger konstanter Ausdruck.</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Die Antwortdatei "{0}" wurde in "{1}" nicht gefunden.</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>Der Namespace "{0}" ist nicht definiert.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Der Operator '{1}' wird von keinem der Typen '{0}' unterstützt. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für "do"-Bindungen nicht zulässig, "{0}" wurde jedoch angegeben.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Unerwartetes Zeichen "{0}" im Präprozessorausdruck.</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Es ist maximal eine with-Augmentation zulässig.</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Ein Parameter mit Attributen muss auch einen Namen erhalten, z.B. "[&lt;Attribut&gt;] Name : Type".</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Anhand der Feldbezeichnungen und des erwarteten Typs dieses Datensatzausdrucks oder Musters lässt sich kein eindeutiger Datensatztyp bestimmen.</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Nur aktive Muster, die genau ein Ergebnis zurückgeben, dürfen Argumente akzeptieren.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Infix-Operatormember "{0}" weist {1} anfängliche(s) Argument(e) auf. Erwartet wurde ein Tupel mit 2 Argumenten, z.B. statischer Member (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>Argument</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Dieses Konstrukt dient der ML-Kompatibilität. {0}. Die Warnung lässt sich mit "--mlcompatibility" oder "--nowarn:62" deaktivieren.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Der #-Formatierungsmodifizierer ist in F# ungültig.</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Assembly nur mit dem öffentlichen Teil des Schlüssels für einen starken Namen verzögert signieren</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Wird verwendet, um einen Ausnahmetyp zu deklarieren.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Mindestens eine der Überladungen dieser Methode besitzt Curryargumente. Definieren Sie diese Member so um, dass sie Argumente als Tupel akzeptieren.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>"global" darf nur als erster Name in einem qualifizierten Pfad verwendet werden.</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Literalenumerationen müssen den Typ "int", "uint", "int16", "uint16", "int64", "uint64", "byte", "sbyte" oder "char" aufweisen.</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Beim Lesen des F#-Metadatenknotens an Position {0} in Tabelle "{1}" von Assembly "{2}" ist ein Fehler aufgetreten. Der Knoten besaß keine übereinstimmende Deklarierung. Melden Sie diese Warnung. Sie müssen die von Ihnen verwendete F#-Assembly möglicherweise neu kompilieren.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Fehler beim Öffnen der Binärdatei "{0}": {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Ungültiger Membername. Member dürfen nicht die Namen '.ctor' oder '.cctor' haben.</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Ungültiger Formatbezeichner: '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Dieses Feld ist kein Literal und kann nicht als Muster verwendet werden.</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Nur Datensatzfelder und einfache, nicht rekursive let-Bindungen dürfen als "mutable" markiert werden.</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Ungültige Direktive. Erwartet wurde "#load \"&lt;Datei&gt;\" ... \"&lt;Datei&gt;\"".</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Der Typ "{0}" enthält die {1}-Methode (vollständiger Name "{2}"), die Methode ist aber statisch.</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Es wurde keine abstrakter Member und kein Schnittstellenmember gefunden, der dieser Überschreibung entspricht.</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Dies ist kein gültiges Muster.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>Fehlendes 'do' in 'for'-Ausdruck. Es wurde 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' erwartet.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Sie müssen entweder alle Typparameter oder keinen Typparameter explizit deklarieren, wenn Sie eine generische abstrakte Methode überschreiben.</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Nicht unterstützter Ausdruck '{0}' des Typanbieters. Wenn Sie der Autor dieses Typanbieters sind, sollten Sie ihn möglicherweise so anpassen, dass ein anderer unterstützter Ausdruck bereitgestellt wird.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Subsystemversion für diese Assembly festlegen</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Unerwartete Verwendung einer Variablen vom Typ "byref".</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Der als "inline" markierte Wert "{0}" konnte nicht inline gestellt werden, möglicherweise, weil ein rekursiver Wert als "inline" markiert war.</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>Begrenzt Argumente und Rückgabewerte in Funktionstypen. Ergibt einen Ausdruck (in Sequenzausdrücken); entspricht dem Yield-Schlüsselwort. Wird in Vergleichsausdrücken verwendet.</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Strukturen dürfen keinen Objektkonstruktor ohne Argumente aufweisen. Diese Einschränkung gilt für alle CLI-Sprachen, da Strukturen automatisch einen Standardkonstruktor unterstützen.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Ungültige "algId" – "Exponent" wurde erwartet.</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Verwenden Sie ggf. "return!" anstelle von "return".</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>Der Operator "!" wird zum Dereferenzieren einer Verweiszelle verwendet. Verwenden Sie hier ggf. "not expr".</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Der generierten Assembly mit F#-spezifischen Metadaten keine Ressource hinzufügen</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Unerwarteter infix-Operator in Typenausdruck.</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Die Option "--embed" wird nur bei der Ausgabe einer portablen PDB unterstützt (--debug:portable oder --debug:embedded).</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Ungültige Operatordefinition. Für Präfixoperatordefinitionen muss ein gültiger Präfixoperatorname verwendet werden.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Die unbenannten Argumente bilden kein Präfix der Argumente der aufgerufenen Methode.</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>Ungültiger vollständiger Name für den angegebenen Typ</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>Die #else-Direktive muss das erste Zeichen in einer Zeile sein, das keine Leerstelle ist.</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Feld für Union-Fall/Ausnahme '{0}' kann nicht mehrmals verwendet werden.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für Union-Fälle nicht zulässig. Verwenden Sie "type U = internal ..." oder "type U = private ...", um die Zugreifbarkeit für die vollständige Darstellung anzugeben.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Eine Typinstanziierung enthält einen byref-Typ. Dies ist nach den Regeln der Common IL nicht zulässig.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Unbekannter Union-Fall.</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>Der Name "({0})" sollte nicht als Membername verwendet werden. Implementieren Sie zum Definieren der Vergleichssemantik für einen Typ die System.IComparable-Schnittstelle. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Typabkürzungen dürfen keine Augmentationen aufweisen.</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Das Modul enthält den Konstruktor\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nIn der Signatur ist eine höhere Zugreifbarkeit angegeben als in der Implementierung.</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Stelligkeit in der Signatur und in der Implementierung ist unterschiedlich. Laut Signatur ist "{3}" eine Funktionsdefinition oder ein lambda-Ausdruck, die bzw. der mindestens {4} Argument(e) akzeptiert, bei der Implementierung handelt es sich allerdings um einen berechneten Funktionswert. Um einen berechneten Funktionswert als zulässige Implementierung zu deklarieren, setzen Sie den Typ in der Signatur einfach in Klammern, z.B.\n\tval {5}: int -&gt; (int -&gt; int)\nanstatt\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>und {0} weitere Überladungen</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Der Typ "{0}" ist kein CLI-Enumerationstyp.</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Eine Modulabkürzung muss ein einfacher Name sein, kein Pfad.</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Rekursive Werte können nicht direkt als Konstruktion vom Typ "{0}" innerhalb einer rekursiven Bindung auftreten. Diese Funktion wurde aus der Programmiersprache F# entfernt. Verwenden Sie stattdessen einen Datensatz.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>F# Compiler für F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Einem benannten Argument wurde mehr als ein Wert zugewiesen.</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Die gemischte verwaltete/nicht verwaltete Assembly '{0}' wird während der statischen Verknüpfung ignoriert.</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Nur Strukturen und Klassen ohne primäre Konstruktoren dürfen das StructLayout-Attribut erhalten.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Ein Typparameter wurde erwartet, kein Maßeinheitenparameter.</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Gibt eine Implementierung einer abstrakten Methode an; wird gemeinsam mit einer abstrakten Methodendeklaration zum Erstellen einer virtuellen Methode verwendet.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Dateiende in einer in den Kommentar eingebetteten Zeichenfolge mit dreifachen Anführungszeichen, die an oder vor dieser Stelle begonnen wurde</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>ASLR mit hoher Entropie aktivieren</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Ein privater Schlüssel wurde erwartet.</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>aktives Musterergebnis</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Diese Deklaration wird in rekursiven Deklarationsgruppen nicht unterstützt.</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Fehlendes Token "{0}" im Präprozessorausdruck.</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Der Vorgang wird aufgrund zu vieler Fehler beendet.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Der Member "{0}" weist nicht die richtige Anzahl von Argumenten auf. Die erforderliche Signatur lautet "{1}".</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Dieser Typ verwendet eine unzulässige Kombination der Attribute "NoEquality", "ReferenceEquality", "StructuralEquality", "NoComparison" und "StructuralComparison".</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Diese Definition kann nur in einem Typ mit einem primären Konstruktor verwendet werden. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Für den Attributtyp "{0}" ist "AllowMultiple=false" festgelegt. Mehrere Instanzen dieses Attributs können nicht einem einzigen Sprachelement angefügt werden.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>In Sequenzausdrücken werden mehrere Ergebnisse mithilfe von "yield!" erzeugt.</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Der Operator '{1}' wird vom Typ '{0}' nicht unterstützt. Möglicherweise sollte das Modul 'Microsoft.FSharp.Linq.NullableOperators' geöffnet werden.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Strukturen, Schnittstellen, Enumerationen und Delegaten können nicht von anderen Typen erben.</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Ungültige Anzahl generischer Argumente für Typ '{0}' im angegebenen Typ. Es wurden '{1}' Argumente erwartet, jedoch '{2}' ausgegeben.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Auf die {0}-Methode kann von dieser Position im Code nicht zugegriffen werden.</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Ungültiger Magic-Wert im CLR-Header.</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Ungültige optionale Zuweisung zu einer Eigenschaft oder einem Feld.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente. Das benannte Argument "{3}" entspricht keinem Argument und keiner festlegbaren Rückgabeeigenschaft für eine Überladung.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Kein {0}-Member oder -Objektkonstruktor namens "{1}" akzeptiert {2} Argumente. Beachten Sie, dass ein Aufruf dieses Members ebenfalls {3} benannte Argumente bereitstellt.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Ungültige Feldbezeichnung.</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Das MarshalAs-Attribut konnte nicht decodiert werden.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind nicht kompatibel, weil die IL-Darstellungen unterschiedlich sind.</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Der nicht generische Typ "{0}" erwartet keine Typargumente; hier wird/werden jedoch {1} Typargument(e) übergeben.</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>Der Wert, Konstruktor, Namespace oder Typ "{0}" ist nicht definiert.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>Namespace/Modul</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Rekursive Klassenhierarchie in Typ "{0}".</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Der rekursive Objektverweis "{0}" wird nicht verwendet. Ist ein rekursiver Objektverweis vorhanden, werden Membern in diesem Typ und in abgeleiteten Typen Laufzeitinitialisierungsprüfungen hinzugefügt. Entfernen Sie diesen rekursiven Objektverweis.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Ein Typ darf nicht gleichzeitig das ReferenceEquality-Attribut und die Attribute "StructuralEquality" oder "StructuralComparison" aufweisen.</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Dieses Konstrukt darf nur innerhalb von Berechnungsausdrücken verwendet werden.</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Ein Wert muss änderbar sein, um die Inhalte eines Werttyps zu mutieren oder seine Adresse zu übernehmen, z.B. "let mutable x = ...".</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Ausnahmeabkürzungen müssen auf vorhandene Ausnahmen oder F#-Typen verweisen, die von "System.Exception" abgeleitet sind.</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Alle Quelldateien in der portablen PDB-Datei einbetten</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>In "let rec"-Konstrukten können nur einfache Variablenmuster gebunden werden.</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Aufeinanderfolgende Argumente sollten durch Leerzeichen getrennt oder als Tupel angegeben werden, und Argumente mit Funktions- oder Methodenanwendungen sollten in Klammern gesetzt werden.</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Keine Ausnahme.</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Interner Fehler. Ungültiger Index für aktives Musterarray.</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Auf die Assembly '{0}' wurde transitiv verwiesen, und sie konnte nicht automatisch aufgelöst werden. Bei einer statischen Verknüpfung wird davon ausgegangen, dass diese DLL keine Abhängigkeiten in der F#-Bibliothek oder anderen statisch verknüpften DLLs aufweist. Fügen Sie dieser DLL einen expliziten Verweis hinzu.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Fehler beim Ausgeben des 'System.Reflection.AssemblyCultureAttribute'-Attributs -- "Ausführbare Dateien können keine Satellitenassemblys sein, Kulturen sollten immer leer sein".</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Schnittstellen weisen immer die gleiche Sichtbarkeit auf wie der einschließende Typ.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nEine Angabe ist eine Typfunktion, die andere nicht. Die Signatur erfordert explizite Typparameter, falls diese in der Implementierung vorhanden sind.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>Die Syntax "module ... = struct .. end" wird im F#-Code nicht verwendet. Verwenden Sie stattdessen "module ... = begin .. end".</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>Das VolatileField-Attribut kann nur für let-Bindungen in Klassen verwendet werden.</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Das Modul enthält das Feld\n    {0}    \nDie Signatur gibt aber Folgendes an:\n    {1}    \nDie literal-Modifizierer sind unterschiedlich.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Die {0} Definitionen für den Typ "{1}" in der Signatur und in der Implementierung sind aufgrund unterschiedlicher Abkürzungen nicht kompatibel: {2} und {3}.</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Ein expliziter statischer Initialisierer sollte die Syntax "static new(args) = expr" verwenden.</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Nur Funktionen dürfen als "inline" markiert werden.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Dieser Typ ist kein Schnittstellentyp.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Der Typ "{0}" ist kein Schnittstellentyp.</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Objektkonstruktoren dürfen "try/with" und "try/finally" vor der Initialisierung des Objekts nicht direkt verwenden. Dies umfasst Konstrukte wie "for x in ...", bei denen diese Konstrukte u.U. verwendet werden. Dies ist eine Einschränkung der Common IL.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return'- und 'return!'-Ausdrücke dürfen in Abfragen nicht verwendet werden.</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Zugriffsmodifizierer sind für Datensatzfelder nicht zulässig. Verwenden Sie "type R = internal ..." oder "type R = private ...", um die Zugreifbarkeit für die vollständige Darstellung anzugeben.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Wird anstelle von "let!" in asynchronen Workflows und anderen Berechnungsausdrücken für Werte verwendet, bei denen die "Dispose" zum Freigeben von Ressourcen erforderlich ist.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Eine Vererbungsdeklaration ist an dieser Stelle nicht zulässig.</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>Die Memberinformationen '{1}' des angegebenen Typs '{0}' verfügen über einen NULL-Deklarierungstyp.</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Der Typanbieter "{0}" hat von "ApplyStaticArgumentsForMethod" eine ungültige Methode zurückgegeben. Es wurde eine Methode mit dem Namen "{1}" erwartet, es wurde jedoch eine Methode mit dem Namen "{2}" zurückgegeben.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} ist keine gültige Unicode-Zeichen-Escapesequenz</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Es sind mehrere Typen mit dem Namen "{0}" vorhanden, die eine unterschiedliche Anzahl von generischen Parametern akzeptieren. Stellen Sie eine Typinstanziierung bereit, um eine eindeutige Typauflösung zu ermöglichen, z.B. "{1}".</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Die Namespace- oder Modulattribute sind in Signatur und Implementierung unterschiedlich.</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>Die {0}-Schnittstelle ist in mehreren explizit implementierten Schnittstellentypen enthalten. Fügen Sie eine explizite Implementierung dieser Schnittstelle hinzu.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>Das {0}-Ereignis hat einen nicht standardmäßigen Typ. Falls dieses Ereignis in einer anderen CLI-Sprache deklariert wurde, müssen Sie ggf. mithilfe der expliziten {1}- und {2}-Methoden für das Ereignis darauf zugreifen. Falls das Ereignis in F# deklariert wurde, definieren Sie den Ereignistyp als Instanziierung von "IDelegateEvent&lt;_&gt;" oder "IEvent&lt;_,_&gt;".</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>Die Syntax "type X with ..." ist für Augmentationen reserviert. Typen, deren Darstellung verborgen ist, die aber Member aufweisen, werden jetzt mithilfe von "type X = ..." in Signaturen deklariert. Möglicherweise müssen Sie der Typdefinition in der Signatur auch das [&lt;Sealed&gt;]-Attribut hinzufügen.</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Vielleicht möchten Sie eine der folgenden Bezeichnungen verwenden:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>Die Datensatzbezeichnung "{0}" ist nicht definiert.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Bei diesem Typtest oder der Typumwandlung wird die Maßeinheit '{0}' ignoriert.</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Ungültiger öffentlicher Schlüssel-BLOB.</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Statische Verknüpfungen dürfen beim Generieren einer Assembly mit Verweis auf System.Runtime (z. B. eine .NET Core- oder eine portierbare Assembly) nicht für eine Assembly verwendet werden, die auf mscorlib verweist (z. B. eine .NET Framework-Assembly).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Anzahl der generischen Parameter in der Signatur und in der Implementierung ist unterschiedlich (in der Signatur werden {3} deklariert, in der Implementierung {4}).</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Der Member "{0}" weist nicht die richtigen Arten von generischen Parametern auf. Die erforderliche Signatur lautet "{1}".</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>Die Signatur und die Implementierung sind nicht kompatibel, da die Anzahl der entsprechenden Typparameter unterschiedlich ist.</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>Typ, Ausnahme oder Modul</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Dieser Listen- oder Arrayausdruck enthält ein Element im Format "if ... then ... else". Setzen Sie diesen Ausdruck in Klammern, um ihn als einzelnes Element der Liste oder des Arrays zu kenntlich zu machen und den Ausdruck von einer Liste zu unterscheiden, die mithilfe eines Sequenzausdrucks erzeugt wurde.</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Der Typ "{0}" weist nicht NULL als eigenen Wert auf.</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Zugriffsmodifizierer sollten unmittelbar vor dem Bezeichner eines Konstrukts aufgeführt sein.</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Unvollständige Wertdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'use' eingezogen werden.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Unvollständiger Wert oder unvollständige Funktionsdefinition. Wenn es sich hierbei um einen Ausdruck handelt, muss der Text des Ausdrucks in dieselbe Spalte wie das Schlüsselwort 'let' eingezogen werden.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Union-Fall/Ausnahme '{0}' verfügt nicht über ein Feld mit dem Namen '{1}'.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>Der Name "({0})" sollte nicht als Membername verwendet werden. Verwenden Sie zum Definieren eines statischen Members für die Verwendung durch andere CLI-Sprachen stattdessen den Namen "{1}".</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Der Typanbieter verfügt über keinen gültigen Konstruktor. Es wurde ein Konstruktor erwartet, der entweder keine Argumente oder ein Argument des Typs 'TypeProviderConfig' akzeptiert.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Datensatz, Union-, Abkürzungs- und Strukturtypen dürfen nicht das AllowNullLiteral-Attribut aufweisen.</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>Das Ausdrucksformat {{ expr with ... }} darf nur für Datensatztypen verwendet werden. Verwenden Sie zum Erstellen von Objekttypen {{ new Type(...) with ... }}.</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Für "{0}" wurde keine Implementierung angegeben.</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Dieser Union-Fall erwartet {0} Argumente als Tupel.</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Zwei Typdefinitionen namens "{0}" erscheinen im Namespace "{1}" in zwei Teilen dieser Assembly.</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Ungültiger Modulname.</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>Die Konvertierung aus {0} in {1} ist ein sicherer Ausdruck zur Umwandlung in eine Basisklasse zur Kompilierungszeit und kein Ausdruck zur Umwandlung in eine abgeleitet Klasse. Verwenden Sie ggf. den Operator :&gt; (Ausdruck zur Umwandlung in eine Basisklasse) anstelle des Operators :?&gt; (Ausdruck zur Umwandlung in eine abgeleitet Klasse).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Positionsspezifizierer sind in Formatzeichenfolgen nicht zulässig.</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>Der benutzerdefinierte Vorgang '{0}' bezieht sich auf eine überladene Methode. Die Implementierungen der benutzerdefinierten Vorgänge sind möglicherweise nicht überladen.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>use-Bindungen sind in Modulen nicht zulässig und werden als let-Bindungen behandelt.</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Codepage zum Lesen von Quelldateien angeben</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Die Behandlung dieses Operators erfolgt jetzt direkt durch den F#-Compiler; die Bedeutung kann nicht mehr geändert werden.</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Konvertiert einen Typ in einen Typen, der in der Hierarchie niedriger ist.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Version konnte nicht aus "mscorlib.dll" gelesen werden.</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Der Typanbieter '{0}' hat einen Fehler im Kontext des angegebenen Typs '{1}', Member '{2}' gemeldet. Fehler: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Fehler beim Anwenden des statischen Arguments auf einen angegebenen Typ.</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- EINGABEDATEIEN -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Eine Integer-for-Schleife muss einen einfachen Bezeichner verwenden.</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Diese Zahl liegt außerhalb des zulässigen Bereichs für hexadezimale 8-Bit-Integer mit Vorzeichen.</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Ein Musterübereinstimmungswächter muss den Typ "bool" aufweisen, dieser when-Ausdruck hat hingegen den Typ "{0}".</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Eine Typdefinition erfordert mindestens eine Member- oder andere Deklaration. Wenn Sie eine leere Klasse, Struktur oder Schnittstelle definieren möchten, sollten Sie stattdessen "type ... = class end", "interface end" oder "struct end" verwenden.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Für ein generisches Konstrukt muss der Typ "{0}" Verweissemantik aufweisen; dies ist aber nicht der Fall, es handelt sich also um eine Struktur.</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie Namen sind unterschiedlich.</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>Die Typabkürzung enthält Byrefs. Dies ist in F# nicht zulässig.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Es können keine MDB-Debuginformationen generiert werden. Fehler beim Laden des Typs 'MonoSymbolWriter' aus der 'Mono.CompilerServices.SymbolWriter.dll'-Assembly.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Unerwarteter Fehler beim Erstellen der Debuginformationsdatei "{0}".</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Ein Maßeinheitenparameter wurde erwartet, kein Typparameter. Explizite Maßeinheitenparameter müssen mit dem [&lt;Measure&gt;]-Attribut markiert werden.</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Formatzeichenfolge "{0}" kann nicht analysiert werden.</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Unerwartete Decodierung von AutoOpenAttribute.</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Anführungszeichen dürfen keine Ausdrücke, die Membereinschränkungsaufrufe durchführen, oder Operatorverwendungen enthalten, die implizit in einen Membereinschränkungsaufruf aufgelöst werden.</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Dateien in Bibliotheken oder Anwendungen mit mehreren Dateien müssen mit einem Namespace oder einer Moduldeklaration beginnen. Wenn eine Moduldeklaration am Anfang einer Datei verwendet wird, ist das Zeichen "=" unzulässig. Wenn es sich um ein Modul der obersten Ebene handelt, sollten Sie ggf. das Zeichen "=" entfernen, um diesen Fehler zu beheben.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Das Feld "{0}" ist in diesem Datensatzausdruck oder Muster zweimal vorhanden.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Es wurde ein angegebener Type mit dem Namen '{0}' erwartet, der angegebene Typ verfügt jedoch über 'Name' mit dem Wert '{1}'</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Es wurde ein angegebener Type mit dem Pfad '{0}' erwartet, der angegebene Typ verfügt jedoch über den Pfad '{1}'.</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Die Anzahl der Argumente für ein benutzerdefiniertes Attribut stimmt nicht mit der erwarteten Argumentzahl für den Attributkonstruktor überein.</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Die Verwendung des Members "{0}" ist ungültig. Die Verwendung von "{1}" wurde vor der Definition bei oder in der Nähe von "{2}" per Rückschluss abgeleitet. Dies ist ein ungültiger Vorwärtsverweis.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>Ereignis '{0}' des angegebenen Typs '{1}' verfügt nicht über einen Wert von GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Ein RSA-Schlüssel wurde erwartet.</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Alle Datensatz-, Union- und Strukturtypen in "FSharp.Core.dll" müssen explizit mit "StructuralComparison" oder "NoComparison" bezeichnet werden.</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Der Union-Typ für Union-Fall "{0}" wurde mit RequireQualifiedAccessAttribute definiert. Fügen Sie den Union-Typnamen ("{1}") in den verwendeten Namen ein.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Aktive Muster können maximal 7 Möglichkeiten zurückgeben.</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>Der Wert oder Konstruktor "{0}" ist nicht definiert.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Diese "inherit"-Daklaration hat Argumente, ist jedoch nicht in einem Typ mit einem primären Konstruktor. Ziehen Sie in Betracht, Argumente zur Typdefinition hinzuzufügen, z. B. "type X(args) = ...".</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Diskriminierte Union-Typen sind immer versiegelt.</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Unerwartete GetSet-Anmerkung für eine Eigenschaft.</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Dies ist kein gültiger Wert für ein Enumerationsliteral.</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Ungültiges Modul bzw. ungültiger Ausdruck/Typ.</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} Überladungen</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 Überladung</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Ein unterstützender Typ für den Operator '{0}' wurde erwartet, aber ein Tupeltyp wurde empfangen</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>Die Assembly '{0}' ist an der Befehlszeile aufgeführt. Auf Assemblys muss mithilfe eines Befehlszeilenflags wie '-r' verwiesen werden.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>'{0}' eines angegebenen Typs war NULL oder leer.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Doppelte Methode. Die abstrakte {0}-Methode hat denselben Namen und dieselbe Signatur wie eine abstrakte Methode in einem geerbten Typ.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>ebenfalls von {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Die Arraymethode '{0}' wird von der Laufzeit bereitgestellt und kann nicht direkt in Code verwendet werden. Ziehen Sie bei Vorgängen mit Arrayelementen die Familie der GetArray/SetArray-Funktionen aus dem LanguagePrimitives.IntrinsicFunctions-Modul in Erwägung.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Das Zugriffsattribut "{0}" ist für die Modulabkürzung nicht zulässig. Modulabkürzungen sind immer privat.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Die angegebenen Typen, die durch diese Verwendung eines Typanbieters generiert wurden, können von anderen F#-Assemblys nicht verwendet werden und sollten als intern oder privat markiert werden. Verwenden Sie stattdessen 'type internal TypeName = ...' oder 'type private TypeName = ...'.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Fügen Sie . für Indexerzugriff hinzu.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Bei DLLImport-Bindungen muss es sich um statische Member von Klassen- oder Funktionsdefinitionen eines Moduls handeln.</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>Die Funktion oder der Member '{0}' wird auf eine Weise verwendet, die in den Definitionen zusätzliche Typanmerkungen erfordert, um die Konsistenz der abgeleiteten Typen sicherzustellen. Die abgeleitete Signatur lautet '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Für diese Methode ist bereits eine Standardimplementierung vorhanden.</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Das Modul "{0}" enthält\n    {1}    \nDie Signatur gibt aber Folgendes an:\n    {2}    \nDie kompilierte Darstellung dieser Methode ist ein Instanzmember, laut Signatur ist sie aber eine kompilierte Darstellung als statischer Member.</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Dies ist kein gültiges Byteliteral.</value>
  </data>
</root>