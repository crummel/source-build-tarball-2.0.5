<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in questa posizione per le abbreviazioni di tipo</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Il collegamento statico non può includere un .EXE</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>La proprietà '{0}' non è leggibile</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Il formato dei binding 'use' deve essere 'use &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Compilatore Microsoft (R) F# versione {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Il campo di classe, record o struct '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Membro '{0}' non valido nel tipo fornito '{1}'. I membri dei tipi forniti devono essere pubblici e non generici, virtuali o astratti.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' non è un'espressione valida. I record devono includere almeno un campo. Le sequenze vuote vengono specificate mediante Seq.empty o un elenco vuoto '[]'.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Chiamata dinamica di {0} non supportata</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralEquality' ma il parametro di tipo '{1}' non soddisfa il vincolo 'equality'. Provare ad aggiungere il vincolo 'equality' al parametro di tipo</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralEquality' ma il tipo di componente '{1}' non soddisfa il vincolo 'equality'</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Provare invece a utilizzare un tipo di record separato</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>In questo punto non è possibile usare l'indirizzo della variabile '{0}'. Un metodo o una funzione potrebbero non restituire l'indirizzo di questo valore di variabile locale.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Non è possibile leggere l'assembly '{0}'</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Per i costrutti generici è necessario che il tipo '{0}' sia un tipo di struct CLI o F#</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Valore Null restituito da GetInvokerExpression dal provider di tipi '{0}'.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Non sono consentiti più riferimenti a '{0}.dll'</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Nome operatore di quotation non corrispondente con '{0}' iniziale</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Indica un metodo per il quale non esiste alcuna implementazione nel tipo in cui viene dichiarato oppure che è virtuale e per il quale esiste un'implementazione predefinita.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Il collegamento dinamico non può includere una DLL mista gestita/non gestita</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Limita l'accesso al codice a un membro nello stesso tipo o modulo.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Il tipo '{0}' non è compatibile con alcuno dei tipi {1}, derivanti dall'utilizzo di una stringa di formato printf-style</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>I membri di estensione non possono fornire overload di operatori. Provare a definire l'operatore come parte della definizione del tipo.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>La variabile '{0}' è usata in modo non valido</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' è utilizzabile solo per costruire tipi di oggetto</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Token imprevisto '{0}' o espressione incompleta</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>Non è possibile usare '_' come nome di campo</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Sono state assegnate più accessibilità per il getter o il setter della proprietà</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>I costruttori devono essere applicati ad argomenti e non possono essere utilizzati come valori di prima classe. Se necessario, utilizzare una funzione anonima '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>File di versione '{0}' non valido</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>I binding ricorsivi che includono specifiche di membro possono rappresentare solo un aumento diretto di un tipo</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Riferimento ricorsivo non valido a uno slot astratto</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Le quotation non possono contenere codice assembly inline o criteri di ricerca in matrici</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Gli oggetti devono essere inizializzati da un'espressione di costruzione degli oggetti che chiama un costruttore di oggetto ereditato e assegna un valore a ogni campo</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Gli argomenti negli operatori di query possono richiedere le parentesi, ad esempio 'where (x &gt; y)' o 'groupBy (x.Length / 10)'</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Imposta un livello di avviso (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Visualizza questo messaggio relativo all'uso (forma breve: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>L'assembly System.Runtime.InteropServices è necessario per usare le classi UnknownWrapper\DispatchWrapper.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>modulo</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Espressione non valida a sinistra dell'assegnazione</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Specifica inline non valida</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Delimita una quotation di codice tipizzato.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet previsto solo in strutture ad albero di analisi</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problema con il nome file '{0}': caratteri non validi nel percorso.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(caricamento descrizione...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'comparison' perché è un record, un'unione o uno struct con uno o più tipi di elementi strutturali che non supportano il vincolo 'comparison'. Evitare l'uso del confronto con questo tipo oppure aggiungere l'attributo 'StructuralComparison' al tipo per determinare quale tipo di campo non supporta il confronto</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'comparison'. Non supporta ad esempio l'interfaccia 'System.IComparable'</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'comparison' perché contiene l'attributo 'NoComparison'</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>L'attributo 'System.Diagnostics.ConditionalAttribute' è valido solo in classi di attributi o metodi</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché le rappresentazioni CLI sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Errore di sintassi in argomento tipo con etichetta</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Una proprietà non può avere parametri di tipo esplicito. Provare a utilizzare invece un metodo.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Genera messaggi con codifica UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Modulo e definizione di tipo con nome '{0}' nello spazio dei nomi '{1}' presenti in due parti dell'assembly</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Nome '{0}' non associato nel contesto dei criteri</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Eccezione generata dal costruttore del provider di tipi: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Tipo di argomento statico '{0}' sconosciuto durante la risoluzione di un riferimento a un tipo o a un metodo fornito '{1}'</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>Nella definizione dell'operatore personalizzato '{0}' non viene usata una combinazione valida di flag di attributo</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} è rappresentato come metodo statico, ma non è un'espressione lambda appropriata</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi senza segno a 8 bit</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Attributi ignorati nel costrutto</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' deve essere seguito da 'in'. Utilizzo: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IEquatable&lt;_&gt;' in modo esplicito. Applicare l'attributo 'CustomEquality' al tipo e fornire un'implementazione coerente dell'override non generico 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Le dimensioni del file di origine sono eccessive per consentirne l'incorporamento in un PDB portatile</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Un costruttore di oggetto richiede un argomento</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Errore durante la lettura/scrittura di metadati per la DLL F# compilata '{0}'. Verificare se la DLL è stata compilata con una versione precedente del compilatore F#. Errore: '{1}'.</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Le interfacce non possono contenere definizioni di override di membri</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Più attributi di visibilità specificati per l'identificatore</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza dell'implementazione, la firma è una classe astratta. Provare ad aggiungere l'attributo [&lt;AbstractClass&gt;] all'implementazione.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Il tipo fornito '{0}' contiene il membro '{1}' con il tipo dichiarante '{2}'. Il tipo dichiarante previsto deve essere dello stesso tipo di quello fornito.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class', 'interface' o 'struct' senza corrispondenza</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Usata per associare un nome a un gruppo di moduli e tipi correlati allo scopo di separare il gruppo in modo logico da altro codice.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>Lo spazio dei nomi o il modulo '{0}' non è definito.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Questo case di unione accetta un argomento</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Elenco moduleDefn di tipo vuoto non previsto</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Usata per le condizioni booleane (when guards) nei criteri di ricerca e per introdurre una clausola di vincolo per un parametro di tipo generico.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Usata insieme alla parola chiave match nelle espressioni di criteri di ricerca. Usata anche in espressioni di oggetti, espressioni di copia di record e in estensioni dei tipi per introdurre definizioni di membro, nonché per introdurre gestori di eccezioni.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Indica il tipo void .NET. Usata in caso di interoperatività con altri linguaggi .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Usata nelle espressioni condizionali. Usata anche per ottenere effetti collaterali dopo la costruzione di oggetti.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Usata per dichiarare una classe, un record, una struttura, un'unione discriminata, un tipo di enumerazione, un'unità di misura o un'abbreviazione di un tipo.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Usata per rendere disponibile il contenuto di uno spazio dei nomi o di un modulo senza qualificazione.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Indica l'assenza di un oggetto. Usata anche nei vincoli di parametri generici.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Converte un tipo nel tipo che occupa una posizione più alta nella gerarchia.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Usata come nome dell'oggetto classe di base.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Usata per specificare un calcolo che deve essere eseguito solo quando è necessario un risultato.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Usata nella diramazione condizionale.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Usata nella diramazione condizionale. Forma abbreviata di else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>Nella sintassi dettagliata indica la fine di un blocco di codice in un'espressione di ciclo.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>È necessario un riferimento alla DLL {0} per l'assembly {1}. Il tipo importato {2} si trova nel primo assembly e non è stato possibile risolverlo.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per valori float a 32 bit</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Le definizioni di tipo possono avere solo una specifica 'inherit' nella prima dichiarazione</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>I valori letterali non possono avere parametri generici</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Operatore di quotation '&lt;@' imprevisto nella definizione di tipo. Se si desidera passare una stringa verbatim come argomento statico a un provider di tipi, mettere uno spazio tra i caratteri '&lt;' e '@'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>In genere, l'operatore '{0}' non deve essere ridefinito. Per definire semantica di confronto con overload per un determinato tipo, implementare l'interfaccia 'System.IComparable' nella definizione del tipo stesso.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>I metodi con argomenti sottoposti a currying non possono dichiarare argomenti 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' o 'CallerFilePath'</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>L'opzione '--pdb' richiede l'utilizzo dell'opzione '--debug'</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>Il valore '{0}' è stato contrassegnato come inline, tuttavia non è stato associato nell'ambiente di ottimizzazione</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>La proprietà '{0}' è statica</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' non è confrontabile a livello di struttura perché il parametro di tipo {1} non soddisfa il vincolo 'comparison'. Provare ad aggiungere l'attributo 'NoComparison' al tipo '{2}' per chiarire che il tipo non è confrontabile</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' non è confrontabile a livello di struttura perché il tipo '{1}' non soddisfa il vincolo 'comparison'. Provare ad aggiungere l'attributo 'NoComparison' al tipo '{2}' per chiarire che il tipo non è confrontabile</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'implementazione definisce uno struct, ma la firma definisce un tipo con una rappresentazione nascosta</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Nota: le ottimizzazioni lifted lambda non sono state applicate a causa dell'utilizzo di questa funzione generica vincolata locale come valore di prima classe. Questa condizione potrebbe essere risolta con l'aggiunta di vincoli di tipo.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>L'utilizzo di 'let! x = coll' in espressioni sequenza non è consentito. Utilizzare invece 'for x in coll'.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'mutable' sono diversi</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>Il nome del file MDB deve essere &lt;nome-file-assembly&gt;.mdb. L'opzione --pdb verrà ignorata.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nLa rappresentazione compilata di questo metodo è un membro statico, tuttavia la firma indica che essa è un membro di istanza</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Non è stato possibile decodificare l'attributo DllImport</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Parola chiave 'base' utilizzata in modo non valido. Le chiamate di base non possono essere utilizzate nelle chiusure. Provare a utilizzare un membro privato per effettuare le chiamate di base.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' deve essere utilizzato con un tipo denominato</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Questa abbreviazione di tipo ha uno o più parametri di tipo dichiarati non inclusi nel tipo da abbreviare. Le abbreviazioni di tipo devono utilizzare tutti i parametri di tipo dichiarati nel tipo da abbreviare. Provare a rimuovere uno o più parametri di tipo oppure a utilizzare una definizione di tipo concreto che esegue il wrapping di un tipo sottostante, ad esempio 'type C&lt;'a&gt; = C of ...'.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Il nome del file di risposta '{0}' è vuoto, contiene caratteri non validi, include una specifica di unità senza percorso assoluto oppure è troppo lungo</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Nessuna proprietà astratta trovata corrispondente all'override</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Errore durante l'analisi di IL incorporato</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Non è possibile impostare come inline gli stub DLLImport</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Criterio non valido</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>In questa posizione è necessario un nome di metodo semplice</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Le definizioni 'member val' sono consentite solo nei tipi con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>Flag '{0}' impostato due volte</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni di oggetto</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Valore imprevisto contrassegnato come 'inline'</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>Le espressioni 'match' non possono essere utilizzate nelle query</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>Il nome della proprietà '{0}' corrisponde a quello di un'altra proprietà nel tipo '{1}', tuttavia una accetta argomenti di indicizzatore e l'altra no. È possibile che in una delle proprietà manchi un argomento di indicizzatore.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Gli identificatori seguiti da '{0}' sono riservati per utilizzi futuri</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>I parametri di tipo esplicito possono essere usati solo in binding di membri o moduli</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>La proprietà '{0}' nel tipo fornito '{1}' contiene CanWrite=false ma GetSetMethod() ha restituito un metodo</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Crea informazioni di debug in quotation</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Non includere il manifesto Win32 predefinito</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>riconoscimento attivo</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Non è possibile usare l'attributo 'CompiledName' con questo elemento del linguaggio</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Usata per dichiarare una variabile, ovvero un valore che può essere modificato.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>È già stata specificata una firma per il file o modulo '{0}'</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che impostano campi di case di unione</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Questa definizione di tipo prevede un riferimento ciclico immediato tramite un'abbreviazione</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Valore '{0}' non valido per '--targetprofile'. I valori validi sono 'mscorlib', 'netcore' o 'netstandard'.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>Binding 'use' non consentiti in costruttori primari</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Gli struct possono eseguire il binding solo di un parametro 'this' in dichiarazioni di membro</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>È necessario assegnare valori a tutti i campi di enumerazione</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>Le definizioni 'member val' e 'override val' non sono consentite nelle espressioni dell'oggetto.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché l'abbreviazione dell'eccezione è nascosta dalla firma. L'abbreviazione deve essere visibile ad altri linguaggi CLI. Provare a rendere visibile l'abbreviazione nella firma. Il modulo contiene la definizione di eccezione \n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Usata insieme a try per introdurre un blocco di codice che viene eseguito indipendentemente dal fatto che si verifichi un'eccezione.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Non è possibile specificare gestori del marshalling personalizzati nel codice F#. Provare a usare una funzione helper C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Nessuna implementazione di '{0}' dispone del numero di argomenti e parametri di tipo corretto. La firma necessaria è '{1}'.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Override di metodo e implementazioni di interfaccia non consentiti in questa posizione</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Non è stato possibile decodificare l'attributo FieldOffset</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Il file di firma '{0}' non dispone di un file di implementazione corrispondente. Se è disponibile un file di implementazione, verificare che le dichiarazioni 'module' e 'namespace' nei file di firma e di implementazione corrispondano.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Non è possibile ridefinire l'operatore '{0}'. Provare a usare un altro nome di operatore</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza dell'implementazione, la firma contiene un'abbreviazione</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Il parametro di tipo '{0}' non è definito.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Usata per specificare una classe di base o un'interfaccia di base.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Possibile rientro non corretto: il token si trova oltre il limite del contesto iniziato alla posizione {0}. Provare ad applicare un ulteriore rientro al token oppure a utilizzare convenzioni di formattazione standard.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi visualizzati sono diversi</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>L'espressione letterale o l'argomento dell'attributo restituisce un overflow aritmetico.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Non è possibile usare argomenti facoltativi in attributi personalizzati</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Collega in modo statico l'assembly specificato e tutte le DLL da questo dipendenti a cui viene fatto riferimento. Usare un nome di assembly, ad esempio lib, non un nome di DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>La fine del file nella stringa verbatim incorporata nel commento inizia in questa posizione o prima di essa</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI valori costanti letterali e/o gli attributi sono diversi</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Questa codifica Unicode è valida solo in valori letterali stringa</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' può essere applicato solo ad argomenti facoltativi</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Questa operazione prevede l'uso dell'indirizzo di un valore '{0}' rappresentato mediante una variabile locale o altra rappresentazione speciale. Questo comportamento non è valido.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Per impostazione predefinita, non fa riferimento agli assembly CLI predefiniti</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>Il file '{0}' non è stato trovato con FSharp.Core. Il file deve trovarsi in {1}. Provare a eseguire l'aggiornamento a una versione più recente di FSharp.Core, in cui questo file non è più obbligatorio.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base alla firma questo tipo e non l'implementazione può usare come rappresentazione valori Null</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>La fine del file nel commento inizia in questa posizione o prima di essa</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' non dispone di un argomento o di una proprietà restituita impostabile '{1}'. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Il tipo di costante '{0}' non è supportato. Le quotation fornite da provider di tipi possono contenere solo costanti semplici. Potrebbe essere necessario modificare l'implementazione del provider di tipi spostando un valore dichiarato all'esterno di un valore letterale di tipo quotation in modo che sia un binding 'let' all'interno del valore letterale di tipo quotation.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Criteri attivi parziali possono generare un solo risultato</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Il tipo '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Questa espressione elenco supera la dimensione massima per i valori letterali di elenco. Usare una matrice per valori letterali più grandi e chiamare Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il tipo di implementazione è sealed ma la firma implica che non lo sia. Provare ad aggiungere l'attributo [&lt;Sealed&gt;] alla firma.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>L'argomento denominato '{0}' non corrisponde ad alcuna proprietà modificabile o argomento</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Vincolo non valido: il tipo utilizzato per il vincolo è Sealed, il che significa che il vincolo può essere soddisfatto al massimo da una soluzione</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Il carattere '{0}' è imprevisto</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché un mapping delle eccezioni CLI è nascosto da una firma. Il mapping delle eccezioni deve essere visibile ad altri moduli. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Gli attributi nell'abbreviazione del modulo verranno ignorati</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>È previsto un tipo, non un'unità di misura</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Il tipo '{0}' implementa 'System.IComparable' in modo esplicito, tuttavia non fornisce l'override corrispondente per 'Object.Equals'. È stata specificata automaticamente un'implementazione di 'Object.Equals', eseguita tramite 'System.IComparable'. Provare a implementare l'override di 'Object.Equals' in modo esplicito</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Non è stato possibile risolvere l'assembly '{0}' richiesto da '{1}'</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Modifica non valida di un'espressione costante. Provare a copiare l'espressione in un locale modificabile, ad esempio 'let mutable x = ...'.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Segnala determinati avvisi come errori</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>La conversione da {0} a {1} è un'espressione upcast sicura della fase di compilazione e non di downcast. Provare a usare 'upcast' invece di 'downcast'.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>L'identificatore '{0}' è riservato per utilizzi futuri in F#</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>I file delle librerie o delle applicazioni con più file devono iniziare con una dichiarazione di spazio dei nomi o di modulo, ad esempio 'namespace SomeNamespace.SubNamespace' o 'module SomeNamespace.SomeModule'. Solo l'ultimo file di origine di un'applicazione può omettere tale dichiarazione.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Un binding non può essere contrassegnato sia con 'use' che con 'rec'</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Fine dell'input imprevista negli argomenti tipo</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è virtuale, l'altro no</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Notazione indicizzatore rimossa dal linguaggio F#</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Il tipo '{0}' è utilizzato in modo non valido. Un valore prima di '{1}' ha un tipo dedotto che prevede '{2}', il che costituisce un riferimento in avanti non valido.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Metodo duplicato. Il nome e la firma del metodo '{0}' corrispondono a quelli di un altro metodo nel tipo '{1}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Errore interno o metadati in formato non valido: parametri di tipo insufficienti nell'ambito durante l'importazione</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Numero di argomenti tipo non corretto per la chiamata locale</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>La sintassi 'module ... : sig .. end' non è utilizzata nel codice F#. Provare a utilizzare 'module ... = begin .. end'</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Previsto tipo di interfaccia</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>Il nome '({0})' non può essere usato come nome di membro perché è associato a una definizione standard nella libreria F# sui tipi fissi</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Fine dell'input imprevista nella definizione di tipo</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Valore non valido per il parametro di unità di misura '{0}'</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Valore '{0}' non valido per il parametro di unità di misura '{1}'</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Formato non valido per un getter di proprietà. Quando si usa la sintassi esplicita, è necessario almeno un argomento '()'.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Uno o più errori visualizzati durante l'impostazione del tipo fornito</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Le espressioni dei costruttori per le interfacce non utilizzano argomenti</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Livello di avviso '{0}' non valido</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Il case di unione denominato '{0}' è in conflitto con il tipo generato '{1}'</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Il membro '{0}' non corrisponde ad alcun metodo astratto o virtuale disponibile per l'override o l'implementazione.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Costruzione record non valida</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI tipi dei campi sono diversi</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Etichetta {0} non trovata</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>I criteri attivi '{0}' hanno un tipo di risultati contenente variabili di tipo che non sono determinate dall'input. Probabilmente il case di risultato non è menzionato, ad esempio 'let (|A|B|) (x:int) = A x'. Il problema può essere risolto con un vincolo di tipo, ad esempio 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i, tuttavia sono specificati {2} argomento/i non denominato/i e {3} argomento/i denominato/i. La firma necessaria è '{4}'.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Il tipo/modulo '{0}' non è un modulo o un tipo concreto</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- FILE DI OUTPUT -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Gli overload disponibili sono indicati di seguito (oppure nella finestra Elenco errori).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' è utilizzato con un numero di argomenti non corretto. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente. Previsti {1} argomenti, ma specificati {2}.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} non è un metodo di istanza</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Questo formato di espressione di oggetto non è utilizzato in F#. Utilizzare 'member this.MemberName... = ...' per definire implementazioni di membro in espressioni di oggetto.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Espressione non prevista in punto di inferenza ricorsiva</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché per la firma è necessario il membro astratto '{2}', che però non è stato specificato dall'implementazione</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>Al metodo o funzione '{0}' non devono essere assegnati argomenti tipo espliciti perché i relativi parametri di tipo non vengono dichiarati in modo esplicito</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Il tipo '{0}' contiene una rappresentazione di codice assembly inline</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>I valori ricorsivi non possono essere assegnati direttamente al campo non modificabile '{0}' del tipo '{1}' in un binding ricorsivo. Provare a usare un campo modificabile.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignora avvisi di compatibilità ML</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Il membro dell'operatore infisso '{0}' non ha argomenti. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Le interfacce non possono contenere definizioni di membri concreti. Potrebbe essere necessario definire un costruttore nel tipo utilizzato per indicare che il tipo è una classe.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Qualificazione mancante dopo '.'</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>La creazione dell'istanza del tipo generico '{0}' non è presente e non può essere dedotta dagli argomenti o dal tipo restituito di questo membro. Provare a fornire una creazione dell'istanza del tipo all'accesso al tipo, ad esempio '{1}'.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Gli identificatori di distinzione tra maiuscole e minuscole nei criteri di ricerca attivi devono iniziare con una lettera maiuscola</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>'h' o 'H' non è necessario nell'identificatore di formato. È possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>Il formato di espressione 'expr then expr' può essere utilizzato solo all'interno di un costruttore di oggetto esplicito</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>I valori 'base' possono essere utilizzati esclusivamente per effettuare chiamate dirette alle implementazioni di base dei membri sottoposti a override</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>L'elemento non è un'espressione costante o un valore di attributo personalizzato valido</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Questo binding ricorsivo usa una combinazione non valida di formati ricorsivi</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IComparable&lt;_&gt;' in modo esplicito. È necessario applicare l'attributo 'CustomComparison' al tipo, nonché fornire un'implementazione coerente dell'interfaccia non generica System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Assegnazione non valida</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>La fine del file nella stringa inizia in questa posizione o prima di essa</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Il tipo di una funzione di prima classe non può contenere byref</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'equality' perché si tratta di un tipo di funzione</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'equality' perché è un record, un'unione o uno struct con uno o più tipi di elementi strutturali che non supportano il vincolo 'equality'. Evitare l'uso dell'uguaglianza con questo tipo oppure aggiungere l'attributo 'StructuralEquality' al tipo per determinare quale tipo di campo non supporta l'uguaglianza</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Il tipo '{0}' non supporta il vincolo 'equality' perché contiene l'attributo 'NoEquality'</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'use!'.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Uso della sintassi di tipo 'int C' e 'C  &lt;int&gt;' non consentito in questa posizione. Provare a modificare il tipo in modo che sia scritto nel formato 'C&lt;int&gt;'</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Flag di prefisso (' ' o '+') impostato due volte</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Trovata mediante la chiave del Registro di sistema AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Questo costrutto può essere utilizzato solo in espressioni sequenza o di calcolo</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Errore durante l'analisi del tipo IL incorporato</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Non è possibile assegnare gli attributi [&lt;ThreadStatic&gt;] o [&lt;ContextStatic&gt;] a un valore letterale</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>Valore '{1}' non valido dell'attributo TypeProviderAssembly nell'assembly '{0}'. Il valore deve essere un nome di assembly valido.</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Questo valore di funzione è utilizzato per costruire un tipo delegato la cui firma include un argomento byref. È necessario utilizzare un'espressione lambda esplicita con {0} argomenti.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Le abbreviazioni per le eccezioni di IL comune non accettano argomenti</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Il tipo '{0}' non è un tipo di enumeratore valido, ad esempio non contiene un metodo 'MoveNext()' che restituisce un valore bool e una proprietà 'Current'</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>La fine del file nella direttiva inizia in questa posizione o prima di essa</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>Il formato '{0}' non supporta la precisione</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>I costruttori per il tipo '{0}' devono chiamare direttamente o indirettamente il relativo costruttore di oggetto implicito. Utilizzare una chiamata al costruttore di oggetto implicito invece di un'espressione di record.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' non è utilizzato correttamente. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>'[&lt;' non corrispondente. Previsto '&gt;]' di chiusura</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Uso non valido di 'fixed'. 'fixed' può essere usato solo in una dichiarazione in formato 'use x = fixed expr', in cui l'espressione è una matrice, l'indirizzo di un campo, l'indirizzo di un elemento di matrice oppure una stringa</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Il carattere '{0}' non è consentito nel nome del tipo fornito '{1}'</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Il parametro statico '{0}' del tipo o del metodo specificato '{1}' richiede un valore. I parametri statici per i provider di tipi possono essere specificati facoltativamente mediante argomenti denominati, ad esempio '{2}&lt;{3}=...&gt;'.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>SynMeasure.Anon imprevisto</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>Non è più possibile utilizzare 'assert' come valore di prima classe. Utilizzare invece 'assert &lt;expr&gt;'.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Non è possibile ereditare da un tipo di variabile</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>I campi o i case di unione del tipo '{0}' non sono accessibili da questa posizione di codice</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>I valori di funzione modificabili devono essere scritti come 'let mutable f = (fun args -&gt; ...)'</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Gli argomenti value possono essere usati solo da tipi di classe</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Numero di avviso '{0}' non valido</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Il tipo '{0}' dispone di un tipo delegato non standard</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Il membro '{0}' non accetta il numero corretto di argomenti. Sono previsti {1} argomenti, ma ne sono stati specificati {2}. La firma richiesta è '{3}'.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è finale, l'altro no</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>I delegati non possono disporre di firme sottoposte a currying</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Limita le piattaforme in cui è possibile eseguire il codice: x86, Itanium, x64, anycpu32bitpreferred o anycpu. Il valore predefinito è anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>È prevista un'unità di misura, non un tipo</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Specifica un file di risorse Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>I binding di classe locali non possono essere contrassegnati come inline. Provare a spostare la definizione fuori della classe oppure non contrassegnarla come inline.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(descrizione non disponibile...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Il tipo '{0}' non è definito in '{1}'.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>È previsto un identificatore</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Il token '{0}' non è previsto nell'espressione per il preprocessore</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Precisione mancante dopo '.'</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Una quotation non può comportare un'assegnazione a una variabile locale acquisita o l'utilizzo dell'indirizzo di una variabile locale acquisita</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>L'opzione della riga di comando '{0}' deve essere usata solo per i test</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Provare a usare 'yield!' invece di 'yield'.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Il tipo ereditato non è un tipo di modello a oggetti</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Il modulo principale del programma è vuoto. L'esecuzione non produrrà alcun effetto</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Il passaggio di un file con estensione resx ({0}) come file di origine al compilatore è deprecato. Utilizzare resgen.exe per trasformare il file con estensione resx in un file con estensione resources da passare come opzione --resource. Se si utilizza MSBuild, tale operazione può esser eseguita mediante un elemento &lt;EmbeddedResource&gt; nel file di progetto con estensione fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Il percorso '{0}' è uno spazio dei nomi. L'abbreviazione del modulo non può abbreviare uno spazio dei nomi.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>In una firma è possibile assegnare solo un valore a una dichiarazione se quest'ultima contiene l'attributo [&lt;Literal&gt;]</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Eccezione durante l'accesso all'oggetto '{0}' di un tipo fornito: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Usata per specificare che un membro è visibile all'interno ma non all'esterno di un assembly.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Nessun #endif trovato per #if o #else</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Rilevata firma di membro non valida a causa di un errore precedente</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Il campo denominato '{0}' è in conflitto con il nome generato automaticamente per il campo anonimo.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Direttiva non valida. Previsto '#time', '#time \"on\"' o '#time \"off\"'.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in questa posizione per tipi di enumerazione</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Gli attributi non sono consentiti in questa posizione</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- LINGUAGGIO -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Tipo debug '{0}' non riconosciuto. Previsto 'pdbonly' o 'full'</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>L'uso di 'into' deve essere seguito dal resto del calcolo</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Utilizzi di prima classe della funzione 'reraise' non consentiti</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;' non corrispondente. Previsto '&gt;' di chiusura</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene il valore '{2}'</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Alla funzione generica '{0}' devono essere assegnati uno o più argomenti tipo espliciti</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>La proprietà '{0}' nel tipo fornito '{1}' contiene CanRead=true ma non era presente alcun valore da GetGetMethod()</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Il tipo restituito di un metodo conterrebbe byref, il che non è consentito</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>L'evento '{0}' è statico</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Token riservato per utilizzi futuri</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>In un gruppo di dichiarazioni ricorsive le dichiarazioni 'open' devono essere inserite per prime in ogni modulo</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Membro con nome Null o vuoto restituito dal tipo fornito '{0}'</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Identificatore di formato non valido (dopo l o L): è previsto ld,li,lo,lu,lx o lX. Nel codice F# è invece possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Valore letterale fornito '{0}' non valido</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>I tipi di interfaccia non possono essere Sealed</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Il valore letterale '{0}' verrà nascosto da un nuovo criterio con lo stesso nome. Come criteri denominati è possibile usare solo valori letterali in maiuscolo e che includono un modulo come prefisso.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Valore non definito '{0}'</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Il costrutto può essere utilizzato solo in espressioni sequenza, elenco e matrice, ad esempio espressioni nel formato 'seq {{ ... }}', '[ ... ]' o '[| ... |]'. Viene utilizzata la sintassi 'for ... in ... do ... yield...' per generare elementi</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Un attributo personalizzato deve essere un tipo di riferimento</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>È stato utilizzato un campo statico in una posizione in cui era previsto un campo di istanza</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'(' senza corrispondenza</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Non è stato possibile determinare un overload univoco per il metodo '{0}' in base alle informazioni sui tipi prima di questo punto del programma. Potrebbe essere necessaria un'annotazione di tipo.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' non è {1}</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Crea informazioni di debug (forma breve: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>L'opzione '--keyfile' esegue l'override dell'attributo 'System.Reflection.AssemblyKeyFileAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Legge il file di risposta per ulteriori opzioni</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{' senza corrispondenza</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin' senza corrispondenza</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>La definizione 'let' non può essere utilizzata in una query. Nelle query è possibile utilizzare solo definizioni di valore semplici.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>È presente una chiamata a un membro protetto oppure viene usata la parola chiave 'base'. Ciò è consentito solo nell'implementazione diretta di membri perché questi ultimi potrebbero uscire dal relativo ambito di oggetto.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Gli argomenti tipo devono trovarsi immediatamente accanto al nome del tipo, ad esempio \"C&lt;'T&gt;\", non \"C  &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>I parametri di tipo devono trovarsi immediatamente accanto al nome del tipo, ad esempio \"type C&lt;'T&gt;\", non type \"C   &lt;'T&gt;\"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Non è stato possibile risolvere l'ambiguità relativa all'uso della stringa di formato di stile 'printf'</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Errore nell'espressione restituita per 'let'. Il rientro potrebbe non essere corretto.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Non è stato possibile risolvere la creazione di istanza implicita di un costrutto generico in questo punto o in prossimità di esso perché la risoluzione potrebbe restituire più tipi non correlati, ad esempio '{0}' e '{1}'. Provare a usare annotazioni di tipo per risolvere l'ambiguità</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Gli argomenti facoltativi devono essere aggiungi alla fine dell'elenco degli argomenti, dopo quelli obbligatori</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Si è tentato di analizzare questo elemento come nome operatore, ma l'operazione non è riuscita</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Fa riferimento a un assembly (forma breve: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Trovata mediante chiave del Registro di sistema AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>Necessari 'get', 'set' o 'get,set'</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' non è un argomento a virgola mobile valido</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Opzione della riga di comando '{0}' deprecata. Al suo posto usare '{1}'.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Un tipo con attributo 'CustomEquality' deve avere un'implementazione esplicita di almeno uno degli elementi 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Elemento {0} non previsto in espressione di tipo</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Destinazione attributo non riconosciuta. Le destinazioni valide sono 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Corpo funzione mancante</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>I modificatori di accessibilità non sono consentiti in questa posizione, ma è stato specificato '{0}'.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>I tipi non possono contenere definizioni di tipo annidate</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Visualizzare messaggi di errore e di avviso a colori</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Uso non valido di un nome di tipo</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Questo valore non contiene un tipo di setter di proprietà valido</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Directory di ricerca '{0}' non valida</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Collega la risorsa specificata all'assembly in cui il formato di resinfo è &lt;file&gt;[,&lt;nome stringa&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Il denominatore non deve essere 0 nell'esponente dell'unità di misura</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Non è possibile usare 'inherit' in tipi di interfaccia. Provare invece a implementare l'interfaccia mediante 'interface ... with ... end'.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Valore letterale Integer non previsto in espressione di unità di misura</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' è utilizzabile solo con tipi denominati</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' utilizza {1} argomento/i, tuttavia il numero di argomenti specificati è pari a {2}. La firma necessaria è '{3}'.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>aumento predefinito del case di unione</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Questo valore non è una funzione e non può essere applicato.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Identificatore di formato mancante</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>A una proprietà di indicizzatore deve essere assegnato almeno un argomento</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Destinazione '{0}' non riconosciuta. Previsto 'exe', 'winexe', 'library' o 'module'</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'do' mancante nell'espressione 'while'. Previsto 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Fine dell'input imprevista nel corpo dell'espressione lambda. Previsto 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Il file della documentazione non ha suffisso .xml</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>L'utilizzo di '-&gt;' in espressioni sequenza e di calcolo è limitato al formato 'for crit in expr -&gt; expr'. Utilizzare la sintassi 'for ... in ... do ... yield...' per generare elementi in espressioni sequenza più complesse.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Un proprietà di getter deve essere una funzione, ad esempio 'get() = ...' oppure 'get(index) = ...'</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Quotation non corrispondente con '{0}' iniziale</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi senza segno a 64 bit</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>L'elemento {0} '{1}' non è stato trovato nel tipo '{2}' dell'assembly '{3}'. Il problema potrebbe essere causato da versioni incompatibili. Per consentire a tutti i componenti di riferimento di usare la versione corretta, potrebbe essere necessario fare riferimento alla versione corretta.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI parametri generici nella firma e nell'implementazione sono di tipo diverso. È possibile che manchi l'attributo [&lt;Measure&gt;].</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Non è possibile usare questo tipo per un campo di valore letterale</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Abilita o disabilita le chiamate tail</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Le espressioni del record Copia e aggiorna devono includere almeno un campo.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>La fine del file nella stringa incorporata nel commento inizia in questa posizione o prima di essa</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Un'operazione di query personalizzata per '{0}' è obbligatoria ma non è stata specificata</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Valore letterale non valido nel tipo</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Il membro '{0}' corrisponde a più overload dello stesso metodo.\nLimitarlo a uno dei seguenti:{1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Se un tipo di unione contiene più di un case ed è una struttura, è necessario assegnare nomi univoci a tutti i campi all'interno del tipo di unione.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>La proprietà '{0}' nel tipo fornito '{1}' non è né leggibile né scrivibile perché contiene CanRead=false e CanWrite=false</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>proprietà generata</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>I campi 'val' statici nei tipi devono essere modificabili, privati e contrassegnati con l'attributo '[&lt;DefaultValue&gt;]'. Tali campi vengono inizializzati sul valore 'Null' o 'zero' per il relativo tipo. Provare inoltre a usare un binding 'static let mutable' in un tipo di classe.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Questo metodo prevede un parametro CLI 'params' in questa posizione. Il parametro 'params' rappresenta un modo per passare un numero di argomenti variabile a un metodo in linguaggi quali C#. Provare a passare una matrice per questo argomento</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>I campi 'val' non inizializzati devono essere modificabili e contrassegnati con l'attributo '[&lt;DefaultValue&gt;]'. Provare a usare un binding 'let' invece di un campo 'val'.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Nel tipo fornito '{0}' 'IsGenericType' è impostato su true, ma i tipi generici non sono supportati.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Tutti i diritti riservati.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che impostano campi in valori di eccezione</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Questo valore letterale della matrice di byte contiene caratteri non codificabili come singoli byte</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Gli attributi devono trovarsi prima di 'val'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'implementazione definisce l'elemento {2} '{3}', il quale non è definito oppure è definito in un ordine diverso nella firma</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Non è possibile annidare unità di misura anonime all'interno di un'altra espressione di unità di misura</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>La firma e l'implementazione non sono compatibili perché la dichiarazione del parametro di tipo '{0}' richiede un vincolo nel formato {1}</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>tipo o modulo</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>I tipi forniti annidati non accettano argomenti statici né parametrici generici</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>La dichiarazione apre il modulo '{0}' che è contrassegnato come 'RequireQualifiedAccess'. Modificare il codice in modo da utilizzare riferimenti qualificati agli elementi del modulo, ad esempio 'List.map' invece di 'map'. Questa modifica assicurerà l'affidabilità del codice quando verranno aggiunti nuovi costrutti alle librerie.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Elemento di dichiarazione non consentito in un aumento</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Il costruttore di oggetti '{0}' accetta {1} argomento/i, ma ne sono stati specificati {2}. La firma obbligatoria è '{3}'.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Il nuovo membro nasconde il membro astratto '{0}'. Rinominare il membro o utilizzare 'override'.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Il genere di tipo specificato dai relativi attributi non corrisponde a quello che implica la sua definizione</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Si è verificato un problema durante la scrittura del binario '{0}': {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Le costanti letterali numeriche non primitive non possono essere usate in criteri di ricerca perché è possibile mapparle a più tipi diversi tramite un modulo NumericLiteral. Provare a sostituire con una variabile e usare 'when &lt;variabile&gt; = &lt;costante&gt;' alla fine della clausola di ricerca.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>La firma e l'implementazione non sono compatibili perché il parametro di tipo nella classe/firma ha un requisito della fase di compilazione diverso rispetto a quello nel membro/implementazione</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Gli argomenti ridondanti verranno ignorati nella funzione '{0}'. Erano previsti {1} argomenti, ma ne sono stati ottenuti {2}.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Un attributo personalizzato deve richiamare un costruttore di oggetto</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>La sintassi 'expr.id' è utilizzabile solo con campi, proprietà ed etichette di record</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Previsto un tipo dopo questa posizione</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Non è possibile usare l'attributo 'ReferenceEquality' in struct. Provare a usare invece l'attributo 'StructuralEquality' oppure a implementare un override per 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>L'override '{0}' implementa più slot astratti, ad esempio '{1}' e '{2}'</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Il membro '{0}' non accetta il numero corretto di argomenti. Un overload accetta {1} argomenti, ma ne sono stati specificati {2}. La firma richiesta è '{3}'.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Il nome di un modulo deve essere un nome semplice, non un percorso</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Per indicare che questa proprietà può essere impostata, utilizzare 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Il file FSharp.Core.dll non è stato trovato nella directory del compilatore</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i tipi hanno tipi di base diversi</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Nessun overload corrispondente per il metodo '{0}'.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Questo elemento non è un costruttore o un valore letterale oppure un costruttore è utilizzato in modo non corretto</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>L'attributo 'Measure' può essere assegnato solo a tipi che rappresentano un'unità di misura</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Argomenti previsti in un membro di istanza</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Il codice è meno generico di quanto richiesto dalle relative annotazioni perché non è possibile generalizzare la variabile di tipo esplicito '{0}'. Sono presenti vincoli per i quali essa deve essere '{1}'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>In genere, l'operatore '{0}' non deve essere ridefinito. Per definire semantica di uguaglianza per un tipo, eseguire l'override del membro 'Object.Equals' nella definizione del tipo stesso.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Un tipo con attributo 'ReferenceEquality' non può avere un'implementazione esplicita di 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>Il flag di attributo 'UseNullAsTrueValue' può essere utilizzato solo con tipi di unione che hanno un case nullary e almeno un case non nullary</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' o 'struct' senza corrispondenza</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Assegna un valore a una variabile.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>La fine del file nella sezione #if inizia in questa posizione o dopo di essa</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Corrispondenze dell'intervallo di caratteri rimosse in F#. Provare a utilizzare invece un'espressione guard con criterio 'when'.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! è ammesso solo come prima riga all'inizio di un file.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>I costruttori non possono essere specificati in aumenti di eccezione</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Nel tipo fornito '{0}' 'IsArray' è impostato su true, ma i tipi matrice non sono supportati.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Proprietà duplicata. Il nome e la firma della proprietà '{0}' corrispondono a quelli di un'altra proprietà nel tipo '{1}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene il modulo/spazio dei nomi '{2}'</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Il formato di dichiarazione 'let ... and ...' per binding non ricorsivi non è usato nel codice F#. Provare a usare una sequenza di binding 'let'</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.GetHashCode' o 'Object.Equals'. È necessario applicare l'attributo 'CustomEquality' al tipo</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Utilizzo non valido di un costruttore di delegato. Utilizzare la sintassi 'new Type(args)' o semplicemente 'Type(args)'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>La firma e l'implementazione non sono compatibili perché il parametro di tipo '{0}' ha un vincolo nel formato {1} non presente tuttavia nell'implementazione. Rimuovere il vincolo dalla firma oppure aggiungerlo all'implementazione.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>L'assembly '{0}' a cui viene fatto riferimento contiene l'attributo a livello di assembly '{1}' ma non è stata trovata alcuna classe di provider di tipi pubblica</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Segnala tutti gli avvisi come errori</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>I caratteri di tabulazione non sono consentiti nel codice F# a meno che non si utilizzi l'opzione #indent \"off\"</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Argomento statico non valido nel tipo fornito. È previsto un argomento di tipo '{0}'.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Non è possibile contrassegnare valori modificabili come 'inline'</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Più override implementano '{0}'</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Non è possibile creare istanze di questo tipo perché è stato contrassegnato come astratto oppure non a tutti i metodi sono state assegnate implementazioni. Provare a usare invece un'espressione di oggetto '{{ new ... with ... }}'.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>In un gruppo di dichiarazioni ricorsive le abbreviazioni dei moduli devono essere inserite dopo tutte le dichiarazioni 'open' e prima di altre dichiarazioni</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Usata come alternativa più breve alla parola chiave fun e a un'espressione match in un'espressione lambda con criteri di ricerca su un singolo argomento.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi compilati sono diversi</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la firma specifica\n    {2}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Espressione di costruzione di oggetto non valida. I costruttori di oggetto espliciti devono chiamare un costruttore alternativo o inizializzare tutti i campi dell'oggetto e specificare una chiamata al costruttore di super classe.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Piattaforma '{0}' non riconosciuta. I valori validi sono 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' e 'anycpu'</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Non è possibile usare 'new' in tipi di interfaccia. Provare a usare invece un'espressione di oggetto '{{ new ... with ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché un'abbreviazione è nascosta da una firma. L'abbreviazione deve essere visibile ad altri linguaggi CLI. Provare a rendere visibile l'abbreviazione nella firma.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Formato non valido per un setter di proprietà. È necessario almeno un argomento.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Le espressioni 'let!', 'use!' e 'do!' non possono essere utilizzate nelle query</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>La fine del file nella stringa verbatim inizia in questa posizione o prima di essa</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Il campo è di sola lettura</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Non è stato possibile decodificare l'attributo StructLayout</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Il tipo '{0}' non è un tipo delegato CLI</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Questa espressione non è una funzione e non può essere applicata. Si intendeva accedere all'indicizzatore tramite la sintassi espressione.[indice]?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Sostituisci con '{0}'</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Il campo di classe o struct '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Usata in un'espressione di calcolo per aggiungere il risultato di un'espressione di calcolo specificata a una raccolta di risultati per l'espressione di calcolo contenitore.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Espressione '{0}' non valida</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Non è possibile creare un'istanza di questo parametro di tipo come 'Nullable'. Si tratta di una limitazione imposta per assicurare che il significato di 'null' in alcuni linguaggi CLI non venga confuso se usato in combinazione con valori 'Nullable'.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>È già stata specificata un'implementazione del file o modulo '{0}'</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Il costruttore fornito dal provider di tipi '{0}' non è riportato tra i costruttori del tipo dichiarante '{1}'</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Le interfacce ereditate da altre interfacce devono essere dichiarate tramite 'inherit ...' anziché 'interface ...'</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Una funzione con l'attributo 'EntryPointAttribute' come etichetta deve essere l'ultima dichiarazione nell'ultimo file della sequenza di compilazione.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Il tipo di record '{0}' non contiene un'etichetta '{1}'.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Blocco non risolto</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>La proprietà o il campo non è stato trovato in questo tipo di attributo personalizzato</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>In due parti di questo assembly sono presenti uno spazio dei nomi e un modulo entrambi denominati '{0}'</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Consente di specificare il profilo del framework di destinazione di questo assembly. I valori validi sono mscorlib, netcore o netstandard. Impostazione predefinita: mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>A partire da F# 4.1, l'accessibilità delle abbreviazioni dei tipi viene verificata in fase di compilazione. Provare a modificare l'accessibilità dell'abbreviazione dei tipi. Se si ignora questo avviso, potrebbero verificarsi errori di runtime.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>La direttiva #endif deve trovarsi all'inizio di una riga</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>La struttura RSAParameters non è valida. È previsto '{{0}}'</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' non supporta l'uguaglianza strutturale perché il parametro di tipo {1} non soddisfa il vincolo 'equality'. Provare ad aggiungere l'attributo 'NoEquality' al tipo '{2}' per chiarire che il tipo non supporta l'uguaglianza strutturale</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' non supporta l'uguaglianza strutturale perché il tipo '{1}' non soddisfa il vincolo 'equality'. Provare ad aggiungere l'attributo 'NoEquality' al tipo '{2}' per chiarire che il tipo non supporta l'uguaglianza strutturale</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Attributo non valido per l'utilizzo in questo elemento del linguaggio. Gli attributi degli assembly devono essere collegati a una dichiarazione 'do ()', se necessario all'interno di un modulo F#.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Le variabili statiche a livello di thread e a livello di contesto devono essere statiche e associate all'attributo [&lt;DefaultValue&gt;] per indicare che il valore viene inizializzato sul valore predefinito in ogni nuovo thread</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Non è possibile usare l'indirizzo di un elemento di matrice in questo punto</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Errore di sintassi: specifica di parametro di tipo non prevista</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Non è stato possibile decodificare l'attributo DefaultAugmentation</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Il tipo di un campo che utilizza l'attributo 'DefaultValue' deve accettare l'inizializzazione predefinita, ovvero deve prevedere 'null' come valore valido oppure essere un tipo di struct i cui campi accettano tutti l'inizializzazione predefinita. È possibile utilizzare 'DefaultValue(false)' per disabilitare questa verifica</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Usata per implementare una versione di un metodo astratto o virtuale diversa dalla versione di base.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Eccezione imprevista dal tipo fornito '{0}' membro '{1}': {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Una variabile di tipo è stata vincolata da più tipi di classe differenti. Una variabile di tipo può disporre di un solo vincolo di classe.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Con il metodo specificato sono richiesti parametri statici</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Il costruttore, il modulo o lo spazio dei nomi '{0}' non è definito.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Questo tipo non è accessibile da questa posizione di codice</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Gli attributi di questo tipo specificano più generi per il tipo</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Questa operazione accede a un valore di livello superiore modificabile definito in un altro assembly in un modo non supportato. Non è possibile accedere al valore tramite il relativo indirizzo. Provare a copiare l'espressione in un valore locale modificabile, ad esempio 'let mutable x = ...' e, se necessario, ad assegnare nuovamente il valore dopo il completamento dell'operazione</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione 'try'. Previsto 'try &lt;expr&gt; with &lt;rules&gt;' o 'try &lt;expr&gt; finally &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione 'for'. Previsto 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le rappresentazioni sono diverse</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Le quotation non possono contenere questo tipo di carattere jolly</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Fine del tipo imprevista. Previsto un nome dopo questa posizione.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Errore segnalato dal provider di tipi '{0}': {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>La generazione del file MDB non è riuscita. Il membro compatibile {0} non è stato trovato</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Le abbreviazioni di tipo non possono avere dichiarazioni di interfaccia</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>L'attributo 'StructuralEquality' deve essere utilizzato insieme agli attributi 'NoComparison' o 'StructuralComparison'</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Gli operatori di splicing delle espressioni possono essere utilizzati solo in quotation</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif senza #if corrispondente</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Attributo non valido per l'utilizzo in questo elemento del linguaggio</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Genera controlli dell'overflow</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Distribuito gratuitamente in conformità ai termini della licenza Open Source di Apache 2.0</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' non utilizza {1} argomento/i. Trovato overload con {2} argomenti.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>L'attributo di assembly '{0}' fa riferimento a un assembly della finestra di progettazione '{1}' che non è stato caricato o non esiste. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Eccezione imprevista dal membro '{0}' del tipo fornito '{1}' membro '{2}': {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Un provider di tipi ha implementato GetStaticParametersForMethod, ma ApplyStaticArgumentsForMethod non è stato implementato oppure non è valido</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RISORSE -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Il codice in questo assembly usa valori letterali di quotation. Il collegamento statico non può includere componenti che usano valori letterali di quotation a meno che tutti gli assembly non siano compilati con almeno F# 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' deve essere preceduto da una clausola di selezione 'for' e seguito dal resto della query. Sintassi: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>L'opzione '--delaysign' esegue l'override dell'attributo 'System.Reflection.AssemblyDelaySignAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>L'utilizzo dell'indirizzo di un campo del valore letterale non è valido</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno a 32 bit</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|' senza corrispondenza</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' non è {1}. È possibile accedere ai membri privati solo dall'interno del tipo dichiarante. I membri privati sono invece accessibili solo da un tipo di estensione e non da espressioni lambda interne.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Il costruttore di oggetto o metodo '{0}' non è statico</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>Il codice nell'assembly '{0}' usa valori letterali di quotation. Il collegamento statico non può includere componenti che usano valori letterali di quotation a meno che tutti gli assembly non siano compilati con almeno F# 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' non è un nome di file valido</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Firma pubblicamente l'assembly usando solo la parte pubblica della chiave con nome sicuro e contrassegna l'assembly come firmato.</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi senza segno a 16 bit</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Tipo non valido restituito da 'ApplyStaticArguments' dal provider di tipi '{0}'. Era previsto un tipo con nome '{1}', mentre è stato restituito un tipo con nome '{2}'.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Il valore locale modificabile '{0}' è allocato implicitamente come cella di riferimento perché è stato acquisito da una chiusura. Questo avviso viene visualizzato a solo scopo informativo per indicare il punto in cui vengono eseguite allocazioni implicite.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>È invece possibile utilizzare 'espr.[espr]'. Per indicare la prima espressione in una matrice potrebbe essere necessaria un'annotazione di tipo</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Le interfacce non possono contenere definizioni di costruttori di oggetto</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Versione '{0}' non valida per '--subsystemversion'. La versione deve essere 4.00 o successiva.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Gli argomenti denominati devono essere aggiunti dopo tutti gli altri argomenti</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>La variabile '{0}' è associata in una quotation ma viene usata come parte di un'espressione sottoposta a splicing. Ciò non è consentito perché la variabile potrebbe uscire dal relativo ambito.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'enum' in questa posizione o in prossimità di essa</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Non esiste alcuna directory delle firme</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Operatore infisso non previsto in espressione di unità di misura. Operatori validi: '*', '/' e '^'.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>proprietà</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Non è possibile ereditare un tipo Sealed</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Questo costrutto è ambiguo all'interno di un'espressione sequenza. È possibile scrivere le espressioni annidate con 'let _ = (...)' e le sequenze annidate con 'yield! seq {{... }}'.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IStructuralEquatable' in modo esplicito. Applicare l'attributo 'CustomEquality' al tipo.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Membro non consentito in un'implementazione di oggetto</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Un assembly importato usa il tipo '{0}', il quale tuttavia non è pubblico</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- VARIE -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Il modulo/spazio dei nomi '{0}' dell'unità di compilazione '{1}' non contiene lo spazio dei nomi, il modulo o il tipo '{2}'</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Il servizio di compilazione residente non è stato usato perché si è verificato un problema nella comunicazione con il server.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Dichiarazione di campo/valore non consentita in questa posizione</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>I vincoli 'new' devono usare un argomento di tipo 'unit' e restituire il tipo costruito</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Utilizzare un servizio di compilazione residente in background per migliorare i tempi di avvio del compilatore.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Vincolo non valido</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base all'implementazione questo tipo e non la firma può usare come rappresentazione valori Null</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Si è verificato un errore durante l'applicazione degli argomenti statici a un metodo fornito</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Incorpora la risorsa gestita specificata</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Il metodo System.Runtime.CompilerServices.OffsetToStringData non è stato trovato nei riferimenti durante la compilazione dell'espressione 'fixed'.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Un binding di una classe locale e un membro non possono avere entrambi il nome '{0}'</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' deve essere seguito da un nome di variabile. Utilizzo: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Questo test di tipo con un tipo fornito '{0}' non è consentito perché il tipo fornito verrà cancellato in '{1}' in fase di esecuzione.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché, a differenza della firma, l'implementazione è una classe astratta. Provare ad aggiungere l'attributo [&lt;AbstractClass&gt;] alla firma.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Lunghezza argomenti non corrispondente</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Questo valore non è una funzione e non può essere applicato. Potrebbe essere presente una dichiarazione non terminata.</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Il membro '{0}' non può essere utilizzato per implementare '{1}'. La firma necessaria è '{2}'.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Questo tipo implementa la stessa interfaccia in creazioni di istanze generiche diverse '{0}' e '{1}'. Ciò non è consentito in questa versione di F#.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>L'opzione '--keycontainer' esegue l'override dell'attributo 'System.Reflection.AssemblyNameAttribute' specificato in un file di codice sorgente o in un modulo aggiunto</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>È richiesto il tipo di sistema '{0}', ma nessuna DLL di sistema di riferimento contiene questo tipo</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Usata per indicare un'espressione di calcolo che, una volta valutata, fornisce il risultato dell'espressione di calcolo contenitore.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Il membro dell'operatore infisso '{0}' contiene argomenti sottoposti a currying aggiuntivi. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Membro non consentito in un'implementazione di interfaccia</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Il membro dell'operatore infisso '{0}' ha {1} argomento/i iniziale/i. Prevista una tupla di 3 argomenti</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>L'attributo FieldOffset può essere usato solo in membri di tipo contrassegnati con StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Un costruttore non può avere parametri di tipo esplicito. Provare a utilizzare invece un metodo di costruzione statico.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>La proprietà '{0}' nel tipo fornito '{1}' contiene CanRead=false ma GetGetMethod() ha restituito un metodo</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>Nelle query '{0}' deve essere un modello semplice</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Const_bytearray non previsto</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Expr.TyChoose imprevisto</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Fine dell'input imprevista nei membri di oggetti</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>Il nome del metodo '{0}' con argomenti sottoposti a currying corrisponde a quello di un altro metodo nel tipo '{1}'. Non è possibile eseguire l'overload di metodi con argomenti sottoposti a currying. Provare a usare un metodo che usa argomenti di tupla.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Un oggetto {0} ha specificato la versione '{1}', ma questo valore non è valido ed è stato ignorato</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Non è possibile usare un parametro di tipo come costruttore di tipo</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Le variabili modificabili non possono uscire dal relativo metodo</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Le dichiarazioni di misura possono avere solo membri statici</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>In genere, l'operatore '{0}' non deve essere ridefinito. Provare a utilizzare un altro nome di operatore</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Non è possibile usare il valore di tipo byref '{0}' in questo punto</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>La directory di ricerca '{0}' non è stata trovata</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Questo costrutto è ambiguo all'interno di un'espressione di calcolo. È possibile scrivere le espressioni annidate con 'let _ = (...)' e i calcoli annidati con 'let! res = builder {{ ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma definisce l'elemento {2} '{3}', il quale non è definito oppure è definito in un ordine diverso nell'implementazione</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Nome completo</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Messaggi di output con percorsi completi</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il campo {2} è presente nell'implementazione ma non nella firma</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Non copia FSharp.Core.dll con i file binari prodotti</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Un costruttore generico richiede che il tipo '{0}' sia un tipo non gestito</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.Equals'. Provare a implementare un override corrispondente per 'Object.GetHashCode()'</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Le dichiarazioni di tipo esplicito per i costruttori devono essere nel formato 'ty1 * ... * tyN -&gt; resTy'. Potrebbe essere necessario racchiudere 'resTy' tra parentesi</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Usata per indicare che una funzione è ricorsiva.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Usata in una firma per indicare un valore oppure in un tipo per dichiarare un membro, in situazioni limitate.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Usata al posto di let per valori con i quali è necessario chiamare Dispose per liberare risorse.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Usata per introdurre un blocco di codice che potrebbe generare un'eccezione. Usata insieme a with o finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Usata per dichiarare, definire o richiamare un costruttore che crea o che è in grado di creare un oggetto. Usata anche nei vincoli di parametri generici per indicare che un tipo deve contenere un determinato costruttore.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Non è una vera e propria parola chiave. In combinazione con not struct viene tuttavia usata come vincolo di parametro generico.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Usata per associare o eseguire il binding di un nome a un valore o a una funzione.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Usata nelle espressioni lambda, note anche come funzioni anonime.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Usata in costrutti di ciclo.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Nelle definizioni dei tipi e nelle estensioni dei tipi indica la fine di una sezione di definizioni dei membri. Nella sintassi dettagliata viene usata per specificare la fine di un blocco di codice che inizia con la parola chiave begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Il getter e il setter di una proprietà devono essere dello stesso tipo. Il getter della proprietà '{0}' è di tipo '{1}', mentre il setter è di tipo '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Il numero di argomenti tipo non corrisponde: '{0}' specificati, '{1}' previsti. Tale condizione potrebbe essere correlata a un errore segnalato in precedenza.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Per questo campo è necessario un nome</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>tipo generato</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Stringa di versione '{0}' non valida</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Non è possibile specificare argomenti tipo in questa posizione</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno nativi</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Questo test di tipo o downcast cancellerà il tipo fornito '{0}' nel tipo '{1}'</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Le dichiarazioni 'inherit' non possono contenere binding 'as'. Per accedere ai membri della classe di base quando si esegue l'override di un metodo, è possibile usare la sintassi 'base.SomeMember' dove 'base' è una parola chiave. Rimuovere il binding 'as'.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Usata per dichiarare un delegato.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Costruttore di oggetti o metodo '{0}' non trovato</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Larghezza non valida in identificatore di formato</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>I tipi con attributo 'AllowNullLiteral' possono solo implementare o ereditare da tipi che consentono anche l'utilizzo di valori letterali Null</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Un inizializzatore statico richiede un argomento</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Errore di sintassi: previsto simbolo '?'</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Uso non valido di un tipo di interfaccia</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>I criteri successivi devono essere separati da spazi o inclusi in tuple</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>La firma obbligatoria è {0}</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit inesistente</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Le istruzioni condizionali di ottimizzazione statiche sono solo per l'utilizzo all'interno della libreria F#</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Il tipo di tutti gli elementi di un'espressione di costruttore di matrice deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Non è possibile usare il parametro di tipo dichiarato '{0}' in questa posizione perché non può essere risolto in fase di compilazione</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' non è un nome di assembly valido</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Il nome non è valido per un criterio attivo</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>Nell'espressione 'if' manca un ramo 'else'. Il tipo del ramo 'then' è '{0}'. Dal momento che 'if' è un'espressione e non un'istruzione, aggiungere un ramo 'else' che restituisca un valore dello stesso tipo.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Fine dell'input imprevista nella firma del tipo</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Metodo duplicato. Il nome e la firma del metodo '{0}' corrispondono a quelli di un altro metodo nel tipo '{1}'.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Questo metodo contiene troppi vincoli nei relativi parametri di tipo</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Variabile '{0}' mancante</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in tipi di codice assembly inline</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Le definizioni riflesse non possono contenere utilizzi dell'operatore di splicing del prefisso '%'</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Non è possibile usare l'unità di misura come argomenti di prefisso per un tipo. Riscrivere come argomenti di suffisso tra parentesi quadre.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>I vincoli 'struct' e 'not struct' sono incoerenti</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Questo criterio di valore letterale non accetta argomenti</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Sintassi di dichiarazione non valida</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Nessuno dei tipi '{0}' supporta l'operatore '{1}'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>I tipi delegati sono sempre Sealed</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Prevista un'espressione dopo questa posizione</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Il tipo '{0}' è meno accessibile del valore, del membro o del tipo '{1}' in cui viene usato.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Produce un assembly (che include GUID e timestamp della versione del modulo)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Valore restituito 'null' imprevisto dal tipo fornito '{0}' membro '{1}'</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Dispose non è stato trovato in IDisposable oppure si è verificato un overload</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Impostazione di privacy '{0}' non riconosciuta per una risorsa gestita. Le opzioni valide sono 'public' e 'private'</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Non è stato possibile impostare come inline un valore contrassegnato come 'inline'</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Per i costrutti generici è necessario che il tipo '{0}' disponga di un costruttore predefinito pubblico</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} non è un membro di istanza</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Le quotation non possono contenere questo tipo di costante</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Parametro non valido utilizzato dal provider di tipi '{0}' in ParameterExpression: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Il membro generico '{0}' è stato utilizzato in una creazione di istanza non uniforme prima di questo punto del programma. Provare a riordinare i membri in modo che questo si trovi prima. In alternativa, specificare il tipo completo del membro in modo esplicito, con tipi di argomento, tipo restituito ed eventuali vincoli e parametri generici aggiuntivi.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Un valore di tipo byref verrebbe archiviato in un tipo. Ciò non è consentito dall'IL comune.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Nessun file di implementazione specificato</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI flag inline sono diversi</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Nome di case di unione, tipo, modulo o spazio dei nomi non valido</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Le abbreviazioni di tipo non possono avere membri</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>La dichiarazione 'rec' in questo modulo è specificata implicitamente da una dichiarazione 'rec' esterna e verrà ignorata</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Questo tipo non è un tipo di record. I valori di tipi di struct e classi devono essere creati mediante chiamate a costruttori di oggetto.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>È previsto un tipo che supporti l'operatore '{0}', tuttavia è specificato un tipo di funzione. Probabilmente manca un argomento in una funzione.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Gli spazi dei nomi non possono contenere valori. Provare a utilizzare un modulo che contenga le dichiarazioni dei valori.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Nessun metodo Invoke trovato per il tipo delegato</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Espressione condizionale incompleta. Previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Un'operazione personalizzata non può essere utilizzata insieme agli operatori 'use', 'try/with', 'try/finally', 'if/then/else' o 'match' all'interno dell'espressione di calcolo corrente</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>L'attributo 'StructuralComparison' deve essere utilizzato insieme all'attributo 'StructuralEquality'</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Uso non valido della parola chiave 'rec'</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Le enumerazione non possono avere membri</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>L'etichetta record o lo spazio dei nomi '{0}' non è definito.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Le quotation non possono contenere utilizzi di espressioni generiche</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Opzione della riga di comando '{0}' deprecata</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Usata nei flussi di lavoro asincroni per eseguire il binding di un nome al risultato di un calcolo asincrono, o, in altre espressioni di calcolo, usata per eseguire il binding di un nome a un risultato, che corrisponde al tipo di calcolo.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Chiamate</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else senza #if corrispondente</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Da utilizzare per eseguire l'override nella posizione in cui il compilatore cerca mscorlib.dll e i componenti del framework</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' utilizza {1} argomento/i di tipo, tuttavia il numero di argomenti specificati è pari a {2}. La firma necessaria è '{3}'.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>L'elemento {0} '{1}' non è stato trovato nell'assembly '{2}'. Il problema potrebbe essere causato da versioni incompatibili. Per consentire a tutti i componenti di riferimento di usare la versione corretta, potrebbe essere necessario fare riferimento alla versione corretta.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Sintassi non valida in espressione di tipo</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per questo tipo di Integer</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>I criteri attivi '{0}' non sono una funzione</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>La proprietà '{0}' di tipo '{1}' contiene un getter e un setter che non corrispondono. Se uno di essi è astratto, è necessario che lo sia anche l'altro.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>Nelle query utilizzare il formato 'for x in n .. m do ...' per gestire interi</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>La fine del file nella stringa con virgolette triple inizia in questa posizione o prima di essa</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Fine dell'input imprevista nella definizione di membro, funzione o valore</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Il costruttore di oggetti '{0}' accetta {1} argomento/i, ma ne sono stati specificati {2}. La firma obbligatoria è '{3}'. Se alcuni degli argomenti vengono usati per assegnare valori alle proprietà, provare a delimitarli con una virgola (',').</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' deve essere applicato a un argomento di tipo '{1}', ma è stato applicato a un argomento di tipo '{2}'</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Non è possibile creare un'estensione di tipo Sealed</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Nessun 'in' corrispondente trovato per 'let'</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>L'attributo di visibilità '{0}' non è consentito nell'abbreviazione del modulo. Le abbreviazioni dei moduli sono sempre private.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Un tipo con attributo 'NoComparison' non deve avere in genere un'implementazione esplicita di 'System.IComparable', 'System.IComparable&lt;_&gt;' o 'System.Collections.IStructuralComparable'. Disabilitare questo avviso se ciò è intenzionale a fini di interoperabilità</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Questo costrutto può essere utilizzato solo in espressioni di calcolo. Per restituire un valore da una funzione ordinaria, è sufficiente scrivere l'espressione senza 'return'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Le definizioni di proprietà non possono essere dichiarate modificabili. Per indicare che questa proprietà può essere impostata, utilizzare 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- AVANZATE -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'static' sono diversi</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>form compilato del case di unione</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Errore di risoluzione assembly in questa posizione o in prossimità di essa</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché l'ordine dei campi nella firma e nell'implementazione è diverso</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Membri astratti non consentiti in un aumento. È necessario definirli come parte del tipo stesso</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Fine dell'input imprevista nel ramo 'then' dell'espressione condizionale. È previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione 'match' o 'try'</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Fine dell'input imprevista nel ramo 'else' dell'espressione condizionale. È previsto 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Non è possibile specificare argomenti durante la costruzione di un valore di record</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Gli identificatori contenenti '@' sono riservati per l'utilizzo nella generazione di codice F#</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Non è possibile usare questa ricerca in questa posizione</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>I membri che estendono tipi delegati, di interfaccia o di enumerazione devono trovarsi in un modulo separato rispetto alla definizione del tipo. Il modulo deve avere l'attributo AutoOpen oppure essere aperto in modo esplicito dal codice client in modo da portare i membri di estensione nell'ambito.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Non è possibile specificare implementazioni di interfaccia in espressioni di costruzione</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Questo codice non è sufficientemente generico. Non è stato possibile generalizzare la variabile di tipo {0} perché non sarebbe compresa nel relativo ambito.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>La fine del file nella sezione IF-OCAML inizia in questa posizione o prima di essa</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>L'attributo 'AbstractClass' può essere assegnato solo a classi</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void' può essere utilizzato solo come 'typeof&lt;System.Void&gt;' in F#</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>La sintassi '(typ,...,typ) ident' non è utilizzata nel codice F#. Provare a utilizzare invece 'ident&lt;typ,...,typ&gt;'</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>I tipi di struct non possono contenere membri astratti</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Il nuovo membro nasconde il membro astratto '{0}' dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti. Rinominare il membro o utilizzare 'override'.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Decodifica non prevista di InterfaceDataVersionAttribute</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Le regole di separazione dei token '|' di questi criteri di ricerca sono disallineate di una colonna. Provare a riallineare il codice o a utilizzare ulteriore rientro.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nNon è stato dedotto un grado per questo valore</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Specifica di proprietà a livello di origine non prevista nella struttura ad albero della sintassi</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Sono stati assegnati valori a campi estranei</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Usata per eseguire la conversione in un tipo che occupa una posizione più bassa nella catena di ereditarietà.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nPer uno o più argomenti è necessario un tipo di tupla. Provare a racchiudere gli argomenti specificati tra parentesi aggiuntive o a rivedere la definizione dell'interfaccia.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Costante razionale grande non prevista</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Il formato dell'immagine non è valido</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Spazio dei nomi vuoto trovato nel provider di tipi '{0}'. Utilizzare 'null' per lo spazio dei nomi globale.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI nomi sono diversi</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} var nella raccolta {1} (outerKey = innerKey). Si noti che dopo '{2}' le parentesi sono obbligatorie</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>Previsto 'in' o '='</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Decodifica non prevista di InternalsVisibleToAttribute</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>L'espressione per il preprocessore non è valida</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: con ritardo</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Un riferimento diretto al tipo generato '{0}' non è consentito. Utilizzare invece una definizione di tipo, ad esempio 'type TypeAlias = &lt;path&gt;'. Questa definizione indica che un provider di tipi aggiunge tipi generati all'assembly utilizzato.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Errore di sintassi. Direttiva #endif annidata non corretta, preceduta da token non previsti.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Abilita avvisi specifici che possono essere disattivati per impostazione predefinita</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} è un criterio attivo e non può essere considerato come un case di unione discriminato con campi denominati.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>I tipi di record sono sempre Sealed</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Firma non valida per membro set</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>Le espressioni 'while' non possono essere utilizzate nelle query</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Valore letterale carattere non valido</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>I valori restituiti non possono avere nomi</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Non è possibile ereditare dal tipo fornito cancellato</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Il provider '{0}' ha restituito un tipo non generato '{1}' nel contesto di un set di tipi generati. Provare a modificare il provider di tipi in modo che restituisca solo tipi generati.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Il formato di un vincolo 'enum' deve essere 'enum&lt;tipo&gt;'</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è astratto, l'altro no</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>Il nome '({0})' non può essere utilizzato come nome di membro. Per definire semantica di uguaglianza per un tipo, eseguire l'override del membro 'Object.Equals'. Se si definisce un membro statico per l'utilizzo da parte di altri linguaggi CLI, utilizzare il nome '{1}'.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per valori letterali decimali</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Troppi parametri statici. Previsti al massimo {0} parametri, mentre sono stati ottenuti {1} parametri senza nome e {2} parametri denominati.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>La dichiarazione 'namespace' non deve essere seguita da simboli '='</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>I tipi System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate e System.Array non possono essere utilizzati come tipi super in una classe o un'espressione di oggetto</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Il file contiene più dichiarazioni nel formato 'module SpazioNomi.Modulo'. In un file è consentita una sola dichiarazione di questo tipo. Modificare il file in modo che utilizzi una dichiarazione di spazio dei nomi iniziale e/o 'module NomeModulo = ...' per definire i moduli.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Non è possibile ereditare da un tipo di interfaccia. Usare invece interface ... with.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Abilita o disabilita le ottimizzazioni tra i moduli</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Usata nelle espressioni di query per specificare i campi o le colonne da estrarre. Si noti che questa è una parola chiave contestuale, pertanto non è in realtà una parola riservata e funge solo da parola chiave nel contesto appropriato.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>Non è possibile usare l'indirizzo del campo '{0}' in questo punto</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'unmanaged' in questa posizione o in prossimità di essa</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Questa definizione di tipo non può contenere l'attributo 'CLIMutable'. Solo i tipi di record possono contenere tale attributo.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno a 64 bit</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in campi di enumerazione</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il numero di elementi {2} è diverso</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Estensione di tipo non valido</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problema con il nome di file '{0}': {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif necessario per #else</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Usata per dichiarare un tipo di struttura. Usata anche nei vincoli di parametri generici. Usata per garantire la compatibilità con OCaml nelle definizioni di moduli.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Usata per indicare un metodo o una proprietà che è possibile chiamare senza un'istanza di un tipo oppure un membro valore condiviso tra tutte le istanze di un tipo.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>L'attributo 'EntryPointAttribute' può essere utilizzato solo in definizioni di funzioni nei moduli</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Il tipo del valore predefinito non è uguale a quello dell'argomento. L'attributo DefaultParameterValue e l'eventuale attributo Optional verranno ignorati. Nota: 'null' deve essere annotato con il tipo corretto, ad esempio 'DefaultParameterValue(null:obj)'.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Creazione di istanza generica non corretta. Nessun membro {0} denominato '{1}' utilizza {2} argomenti generici.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Gli spazi dei nomi non possono contenere membri di estensione, tranne che nello stesso gruppo di dichiarazione di file e spazio dei nomi in cui è definito il tipo. Provare a usare un modulo che contenga le dichiarazioni dei membri di estensione.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Usata per indicare un valore da fornire come risultato di un'espressione di calcolo.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>Il valore '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Il rientro di questo token 'in' non è corretto rispetto al 'let' corrispondente</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>In questa posizione è necessario il tipo '{0}', il quale non è disponibile. Aggiungere un riferimento all'assembly '{1}'.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>L'operatore '{0}' non accetta l'utilizzo di 'into'</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} non è un membro statico</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Variabili di tipo anonime non consentite in questa dichiarazione</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Questo record contiene campi di tipi incoerenti</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>I binding 'let' e 'do' devono precedere le definizioni di membro e interfaccia nelle definizioni di tipo</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Le direttive all'interno dei moduli vengono ignorate</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno a 16 bit</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problema con la tabella codici '{0}': {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Le espressioni attributo devono costituire chiamate a costruttori di oggetto</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>A un costruttore di delegato deve essere passato un singolo valore di funzione</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>L'indicizzatore prevede {0} argomenti, tuttavia ne è stato rilevato un numero pari a {1}</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>Per soddisfare i requisiti relativi al tipo di contesto, il tipo dell'espressione 'if' deve essere '{0}', ma è attualmente '{1}'.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Non è possibile assegnare l'attributo 'Sealed' a tipi abbreviati</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Abilita le ottimizzazioni (forma breve: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Questo override accetta un numero di argomenti diverso rispetto al membro astratto corrispondente. Sono stati trovati i membri astratti seguenti: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'[' senza corrispondenza</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Non è possibile contrassegnare un valore letterale come 'inline'</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>L'attributo 'NoEquality' deve essere utilizzato insieme all'attributo 'NoComparison'</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che richiedono puntatori byref</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>/ non previsto in tipo</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>I tipi di codice assembly sono sempre Sealed</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Nessun input specificato</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Le costanti non zero non possono avere unità generiche. Per lo zero generico, scrivere 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Getter o setter della proprietà non valido</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma dichiara {2} mentre l'implementazione dichiara {3}</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Il carattere '{0}' non è consentito nel nome dello spazio dei nomi fornito '{1}'</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Direttiva non valida. Previsto '#I \"&lt;percorso&gt;\"'.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi senza segno a 32 bit</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>Il nome della proprietà '{0}' corrisponde a quello di un metodo nel tipo '{1}'.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>evento</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>campo</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>I valori definiti in modo ricorsivo non possono rappresentare direttamente parte della costruzione di un valore di tupla in un binding ricorsivo</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Opzione della riga di comando '{0}' deprecata. La generazione di documenti HTML è ora inclusa in F# Power Pack, tramite lo strumento FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Attributi non consentiti in binding 'let' nelle espressioni</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI rispettivi conteggi di parametri di tipo sono diversi</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Questo membro non è sufficientemente generico</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Usata come valore letterale booleano.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Le quotation non possono contenere elementi di ordinamento decrescente per i cicli</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Indirizzo di base della libreria da compilare</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problema durante la lettura dell'assembly '{0}': {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Membro Null restituito dal tipo fornito '{0}'</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Nell'assembly '{1}' è stato trovato un riferimento al tipo '{0}', ma non è stato trovato il tipo</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Un parametro di tipo generico è utilizzato in modo da dovere essere sempre '{0}'</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è contrassegnato come override, l'altro no</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Previste {0} espressioni, ottenute {1}</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Uno o più parametri di tipo dichiarati per questa estensione del tipo contengono un vincolo di tipo mancante o errato non corrispondente ai vincoli di tipo originali in '{0}'</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Almeno un override non implementa correttamente il membro astratto corrispondente</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>'AssemblyVersionAttribute' ignorato. È stata specificata una versione mediante un'opzione della riga di comando</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>L'attributo 'DefaultValue' può essere utilizzato solo in dichiarazioni 'val'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>I tipi di struct sono sempre Sealed</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>I tipo non possono ereditare da più tipi concreti</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Argomenti tipo non previsti</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché la firma richiede che il tipo supporti l'interfaccia {2}, ma quest'ultima non è stata implementata</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GENERAZIONE CODICE -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Const_uint16array non previsto</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Il membro '{0}' è utilizzato in modo non valido. Uso di '{1}' dedotto prima della definizione di '{2}', il che costituisce un riferimento in avanti non valido.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>è</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Non è possibile usare questo attributo in questa versione di F#</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Attributi non consentiti all'interno di criteri</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Non è possibile eseguire l'override del membro ereditato '{0}' perché è sealed</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Questo tipo non dispone di tipi annidati</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Il nome file '{0}' contiene il carattere non valido '{1}'</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Il campo, il costruttore o il membro '{0}' non è definito.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>I termini [&lt;ReflectedDefinition&gt;] non possono contenere utilizzi dell'operatore di splicing del prefisso '%'</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Lunghezza creazione dell'istanza del tipo non corrispondente</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Una proprietà di setter può contenere al massimo due gruppi di argomenti</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Disabilita messaggi di avviso specifici</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Non visualizza il messaggio di copyright del compilatore</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Il tipo '{0}' è stato contrassegnato con il layout esplicito, ma il campo '{1}' non è stato contrassegnato con l'attributo 'FieldOffset'</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI tipi sono diversi</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Utilizzi di prima classe dell'operatore di splicing delle espressioni non consentiti</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Questo downcast cancellerà il tipo fornito '{0}' nel tipo '{1}'.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Il tipo {0} contiene il membro '{1}', ma non è un metodo virtuale o astratto disponibile per l'override o l'implementazione.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>L'attributo '{0}' è presente nell'implementazione e nella firma, ma gli argomenti degli attributi differiscono. Nel codice compilato verrà incluso solo l'attributo della firma.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Non è possibile risolvere l'operatore '{0}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Opzione non riconosciuta: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>estensione</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché il campo '{0}' è presente nell'implementazione ma non nella firma. Il modulo contiene la definizione di eccezione\n    {1}    \ntuttavia la relativa firma specifica\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Il tipo '{0}' ha un metodo '{1}' (nome completo '{2}'), tuttavia il metodo non è statico</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Le chiamate a 'reraise' possono essere presenti solo direttamente all'interno di un gestore di un'espressione try-with</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>I tipi di enumerazione sono sempre Sealed</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Tipi di argomento non corrispondenti</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>'l' o 'L' non è necessario nell'identificatore di formato. Nel codice F# è invece possibile usare %d, %x, %o o %u, di cui viene eseguito l'overload affinché funzionino con tutti i tipi di Integer di base.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Consente l'accesso a un membro dall'esterno del tipo.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>Il tipo '{0}' non prevede 'null' come valore valido. Per creare un valore null per un tipo Nullable utilizzare 'System.Nullable()'.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>ValValue ricorsivo {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Il tipo '{0}' non è valido perché in byref&lt;T&gt; T non può contenere tipi byref.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Definisce simboli di compilazione condizionale (forma breve: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Gli attributi non sono consentiti in dichiarazioni 'inherit'</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>La proprietà '{0}' nel tipo fornito '{1}' contiene CanWrite=true ma non era presente alcun valore da GetSetMethod()</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché le dichiarazioni di eccezione sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>Il file FSharp.Core.sigdata non è stato trovato con FSharp.Core. Il file deve trovarsi in {0}. Provare a eseguire l'aggiornamento a una versione più recente di FSharp.Core, in cui questo file non è più obbligatorio.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>È previsto un commento a riga singola o la fine della riga</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Il provider di tipi ha restituito 'null', che non è un valore restituito valido per '{0}'</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>La direttiva #if deve essere immediatamente seguita da un identificatore</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Nessuna implementazione specificata per '{0}'. Si noti che tutti i membri dell'interfaccia devono essere implementati ed elencati in una dichiarazione 'interface' appropriata, ad esempio 'interface ... with member ...'.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Il blocco che segue questo elemento '{0}' non contiene un elemento finale. Ogni blocco di codice è un'espressione e deve includere un risultato. '{1}' non può essere l'elemento di codice finale di un blocco. Provare ad assegnare un risultato esplicito a questo blocco.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione 'while'. Previsto 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Le definizioni di misura non possono avere parametri di tipo</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>È necessario ricompilare la DLL compilata in F# '{0}' per poterla utilizzare con questa versione di F#</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Fine dell'input imprevista nell'espressione 'match'. Previsto 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>I tipi di interfaccia e i tipi delegati non possono contenere campi</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Le estensioni di file '.ml' e '.mli' sono per la compatibilità ML</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>spazio dei nomi</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i. La firma necessaria è '{2}'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Le dichiarazioni di misura possono avere solo membri statici: costruttori non disponibili</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Le interfacce non possono contenere definizioni di inizializzatori statici</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Nelle espressioni in quotation non sono consentite funzioni generiche interne. Provare ad aggiungere alcuni vincoli di tipo in modo che la funzione non sia più generica.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Argomento --test sconosciuto: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problema di inferenza del tipo troppo complesso (raggiunta profondità di iterazione massima). Provare ad aggiungere ulteriori annotazioni di tipo.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>Il valore, lo spazio dei nomi, il tipo o il modulo '{0}' non è definito.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI rispettivi numeri di campi dati sono diversi</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Gli struct non possono contenere binding 'do' perché il costruttore predefinito per gli struct non è in grado di eseguire tali binding</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Usata per eseguire la conversione in un tipo che occupa una posizione più alta nella catena di ereditarietà.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} var nella raccolta {1} (outerKey = innerKey) nel gruppo. Si noti che dopo '{2}' le parentesi sono obbligatorie</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Il costruttore di inizializzazione zero predefinito di un tipo di struct può essere utilizzato solo se tutti i campi del tipo di struct accettano l'inizializzazione predefinita</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Non è possibile assegnare l'attributo 'StructLayout' a tipi generici</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Un costruttore di oggetto esplicito deve usare la sintassi 'new(args) = expr'</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Delimita una quotation di codice non tipizzato.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Gli struct non possono contenere definizioni di valore perché il costruttore predefinito per gli struct non è in grado di eseguire tali binding. Provare ad aggiungere altri argomenti al costruttore primario per il tipo.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno a 8 bit</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Membro '{0}' non valido nel tipo fornito '{1}'. Sono consentiti solo costruttori, metodi e proprietà.</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Nessuna assegnazione specificata per il campo '{0}' di tipo '{1}'</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Il tipo '{0}' non supporta l'operatore '{1}'</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>Non è possibile usare l'indirizzo del campo statico '{0}' in questo punto</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Questa dichiarazione apre lo spazio dei nomi o modulo '{0}' tramite un percorso parziale. Modificare il codice in modo da utilizzare il percorso completo dello spazio dei nomi. Questa modifica renderà il codice più affidabile in caso di aggiunta di nuovi costrutti alle librerie F# e CLI.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!' non può essere utilizzato in espressioni sequenza</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>È già stata specificata un'implementazione del file o modulo '{0}'. In F# l'ordine di compilazione è significativo a causa dell'inferenza del tipo. Potrebbe essere necessario modificare l'ordine dei file per inserire il file di firma prima dell'implementazione. In Visual Studio il controllo del tipo viene eseguito nei file nell'ordine in cui questi ultimi sono inclusi nel file di progetto. Tale ordine può essere modificato manualmente oppure tramite Esplora soluzioni.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>spazio dei nomi non valido per il tipo fornito</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Questa definizione di tipo prevede un riferimento ciclico immediato tramite un campo struct o una relazione di ereditarietà</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Questo valore non è un valore letterale e non è possibile utilizzarlo in un criterio</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>A ogni argomento del costruttore primario per uno struct deve essere assegnato un tipo, ad esempio 'type S(x1:int, x2: int) = ...'. Tali argomenti determinano i campi dello struct.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>I valori modificabili non possono avere parametri generici</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Non è stato possibile risolvere l'ambiguità relativa all'uso di un costrutto generico con un vincolo 'delegate' in questa posizione o in prossimità di essa</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Il formato delle specifiche di delegato deve essere 'tip -&gt; tip'</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute non può essere applicato a un membro di istanza in un tipo di struct perché il membro di istanza accetta un parametro byref implicito 'this'</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>Necessari 'get' e/o 'set'</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' non supporta il flag '{1}' del prefisso</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Questo parametro di tipo è stato utilizzato in modo da dover essere sempre '{0}'</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Non è possibile assegnare argomenti denominati a chiamate di tratti del membro</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>La versione di .NET Framework '{0}' specificata non è supportata. Specificare un valore dall'enumerazione Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Una dichiarazione può essere solo l'attributo [&lt;Literal&gt;] se è specificato anche un valore costante, ad esempio 'val x : int = 1'</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Estensione di file di '{0}' non riconosciuta. I file di origine devono avere estensione .fs, .fsi, .fsx, .fsscript, .ml o .mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>La dichiarazione 'inherit' specifica il tipo ereditato, ma senza argomenti. Provare a specificare argomenti, ad esempio 'inherit BaseType(args)'.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Nome del file di debug di output</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Specifica una directory per il percorso di inclusione utilizzato per risolvere assembly e file di origine (forma breve: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Stampa l'interfaccia dedotta dell'assembly in un file</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Compila un modulo che può essere aggiunto ad altro assembly</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Il carattere '|' non è consentito in identificatori di distinzione tra maiuscole e minuscole di criteri attivi</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in questo membro. Gli slot astratti hanno sempre la stessa visibilità del tipo di inclusione.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Per separare i valori di campo nei record si usa il punto e virgola (';'). Provare a sostituire la virgola (',') con il punto e virgola (';').</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Non è stato possibile risolvere l'ambiguità relativa all'uso dell'operatore '{0}' in questo punto del programma o in prossimità di esso. Provare invece a risolvere l'ambiguità usando annotazioni di tipo.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Il tipo '{0}' non è definito.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Usata per indicare una funzione che deve essere integrata direttamente nel codice del chiamante.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Nome non valido per un case di enumerazione</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>In questo membro di istanza è necessario un parametro per rappresentare l'oggetto richiamato. Rendere il membro statico oppure utilizzare la notazione 'member x.Member(args) = ...'.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Non sono presenti parametri statici denominati '{0}'</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Un tipo con attributo 'NoEquality' non deve avere in genere un'implementazione esplicita di 'Object.Equals(obj)'. Disabilitare questo avviso se ciò è intenzionale a fini di interoperabilità</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Il valore è stato copiato per assicurare che durante l'operazione l'originale non venga modificato</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Non è stato possibile generalizzare una o più variabili di tipi di funzione o classi esplicite per questo binding perché sono state vincolate ad altri tipi</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Candidati: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>'with' senza corrispondenza o blocco 'with' in formato non valido</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Il tipo di tutti gli elementi di un'espressione di costruttore di elenco deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Le specifiche di tipo esplicito possono essere utilizzate per i costruttori di eccezione</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Il tipo di record per il campo di record '{0}' è stato definito con RequireQualifiedAccessAttribute. Includere il nome del tipo di record ('{1}') nel nome da usare.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>L'argomento formale corrispondente non è facoltativo</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Valore non valido</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>Valore '{0}' non utilizzato</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Parametro necessario per l'opzione: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Dichiarazione non valida</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi senza segno nativi</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Il discriminatore di criteri '{0}' non è definito.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Fine di input non prevista</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Due moduli con nome '{0}' sono presenti in due parti dell'assembly</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Trovati più metodi Invoke per il tipo delegato</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Questo valore non è una funzione e non può essere applicato. Si intendeva accedere all'indicizzatore tramite la sintassi {0}.[indice]?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Per il parametro '{0}' è stato dedotto il tipo byref. Ai parametri di tipo byref deve essere associata un'annotazione di tipo esplicita, ad esempio 'x1: byref&lt;int&gt;'. Se utilizzato, un parametro byref viene dereferenziato in modo implicito.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Questo membro statico non deve contenere un parametro 'this'. Provare a utilizzare la notazione 'member Member(args) = ...'.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Per i costrutti generici è necessario che il tipo '{0}' non sia astratto</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Include solo informazioni di ottimizzazione essenziali per l'implementazione dei costrutti inline. Impedisce l'incorporamento tra moduli ma migliora la compatibilità binaria.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>La rappresentazione di questo tipo è nascosta dalla firma. È necessario assegnare un attributo quale [&lt;Sealed&gt;], [&lt;Class&gt;] o [&lt;Interface&gt;] per indicare le caratteristiche del tipo.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>Il formato '{0}' non supporta il flag '0'</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>A seguito dell'inferenza del tipo, la variabile di tipo {0} non ha rispettato il proprio ambito. Provare ad aggiungere una dichiarazione di parametro di tipo esplicita oppure a modificare il codice in modo che sia meno generico.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Consente di specificare il tipo di debug: full, portable, embedded, pdbonly. '{0}' è l'impostazione predefinita se non viene specificato il tipo di debug e consente di associare un debugger a un programma in esecuzione. 'portable' è un formato multipiattaforma. 'embedded' è un formato multipiattaforma incorporato nel file di output.</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Prima della prima dichiarazione 'namespace' possono essere presenti solo direttive '#' del compilatore.</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Valore locale {0} non trovato durante l'ottimizzazione</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Il provider di tipi '{0}' ha fornito un metodo con nome '{1}' e token metadati '{2}' che non è indicato tra i metodi del tipo dichiarante '{3}'</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Sintassi non corretta per '{0}'. Utilizzo: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Numero a virgola mobile non valido</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>I costruttori non sono consentiti come membri di estensione. Devono essere definiti come parte della definizione originale del tipo</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Per il costruttore di oggetti '{0}' non esiste un argomento o una proprietà restituita impostabile '{1}'. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>La piattaforma 'anycpu32bitpreferred' può essere utilizzata solo con destinazioni EXE. Utilizzare invece 'anycpu'.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI nomi sono diversi</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è statico, l'altro no</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il tipo di implementazione non è sealed ma la firma implica che lo sia. Provare ad aggiungere l'attributo [&lt;Sealed&gt;] all'implementazione.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>Non è possibile usare 'try'/'with' in espressioni sequenza</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il membro astratto '{2}' è presente nell'implementazione ma non nella firma</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' ha un'implementazione esplicita di 'Object.GetHashCode'. Provare a implementare un override corrispondente per 'Object.Equals(obj)'</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Usata per dichiarare una proprietà o un metodo in un tipo di oggetto.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Usata per associare un nome a un gruppo di valori, funzioni e tipi correlati allo scopo di separare il gruppo in modo logico da altro codice.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI tipi sono diversi</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i rispettivi conteggi dei parametri di tipo sono diversi</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Le specifiche di delegato non devono essere tipi sottoposti a currying. Utilizzare 'typ * ... * typ -&gt; typ' per delegati con più argomenti e 'typ -&gt; (typ -&gt; typ)' per delegati che restituiscono valori di funzione.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>Il valore '{0}' è stato contrassegnato come inline, tuttavia la relativa implementazione utilizza una funzione interna o privata con accessibilità insufficiente</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>La proprietà '{0}' non è statica</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Espressione record, sequenza o oggetto non valida</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>I parametri di tipo dedotti per il valore non sono stabili nell'ambito della cancellazione di abbreviazioni di tipo. Questa condizione è dovuta all'utilizzo di abbreviazioni di tipo che eliminano o riordinano i parametri di tipo, ad esempio \n\ttype taggedInt&lt;'a&gt; = int o\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nProvare a dichiarare i parametri di tipo per questo valore in modo esplicito, ad esempio \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IStructuralComparable' in modo esplicito. Applicare l'attributo 'CustomComparison' al tipo.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Errore di sintassi</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Relazione join non valida in '{0}'. Previsto 'expr &lt;op&gt; expr', dove &lt;op&gt; è =, =?, ?= o ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Il formato dei binding di campi deve essere 'id = expr;'</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>L'evento '{0}' non è statico</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} var nella raccolta</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Usata in un'espressione di sequenza per produrre un valore per una sequenza.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>Le espressioni 'try/finally' non possono essere utilizzate nelle query</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Per indicare che le risorse possono essere di proprietà del valore generato, è consigliabile usare la sintassi 'new Type(args)', invece di 'Type(args)' o di 'Type' come valore della funzione che rappresenta il costruttore, per creare oggetti che supportano l'interfaccia IDisposable.</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Non è possibile contrassegnare un valore letterale come 'mutable'</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Introduce un costrutto di ciclo.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} non è un metodo statico</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Attributi non consentiti in implementazioni di interfaccia</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Questo formato di espressione può essere utilizzato solo in espressioni sequenza e di calcolo</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che recuperano indici di case di unione</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>Nella sintassi dettagliata indica l'inizio di una definizione di classe.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>Nella sintassi dettagliata indica l'inizio di un blocco di codice.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Non è possibile assegnare argomenti a chiamate a costruttori di oggetto in parametri di tipo</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Usata per creare un ramo confrontando un valore con un criterio.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Condizione imprevista in assembly importato: non è stato possibile decodificare l'attributo AttributeUsage</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Questo case di unione non accetta argomenti</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Usata per fare riferimento allo spazio dei nomi .NET di primo livello.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Questo costrutto di controllo può essere utilizzato solo se il generatore di espressioni di calcolo definisce un metodo '{0}'</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Prodotto di misure implicito dopo /</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Campo specificato non valido. I campi specificati dei tipi forniti cancellati devono essere valori letterali.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Operatore di query sconosciuto. Gli operatori di query sono identificatori come 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' e 'averageBy', definiti mediante i metodi corrispondenti nel tipo 'QueryBuilder'.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Nessun costruttore di oggetti o membro {0} denominato '{1}' utilizza {2} argomenti</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Unità di misura supportata solo in tipi float, float32, decimal e Integer con segno</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Il campo '{0}' non è statico</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>I file devono iniziare con una dichiarazione di modulo o di spazio dei nomi, ad esempio 'namespace SpazioNomi.SottoSpazioNomi' oppure 'module SpazioNomi.Modulo', ma non con entrambe. Per definire un modulo all'interno di uno spazio dei nomi utilizzare 'module Modulo = ...'</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>La firma per la funzione esterna contiene parametri di tipo. Vincolare l'argomento e i tipi restituiti per indicare i tipi della funzione C corrispondente.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Il tipo di tutti i rami di un'espressione di criteri di ricerca deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>Il metodo '{0}' è Sealed e non è possibile eseguirne l'override</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}' senza corrispondenza</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Questo elemento non è una variabile, una costante, un valore letterale o un riconoscimento attivo</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Al campo '{0}' è stato assegnato un valore, tuttavia non è presente nel tipo '{1}'</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che recuperano campi statici</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Le definizioni di valore statiche possono essere utilizzate solo nei tipi con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo, ad esempio 'type X(args) = ...'.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>La destinazione del codice per questo attributo non è stata trovata, probabilmente perché il codice dopo l'attributo è incompleto.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Nome di modulo o spazio dei nomi non valido</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>operazione personalizzata</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Usata per verificare il codice durante il debug.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Le dichiarazioni presenti in questo file verranno inserite in un modulo implicito '{0}' in base al nome di file '{1}'. Questo non è tuttavia un identificatore F# valido, pertanto i contenuti non saranno accessibili da altri file. Provare a rinominare il file o ad aggiungere una dichiarazione 'module' o 'namespace' all'inizio del file.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Non è stato possibile aprire il file di chiave '{0}'</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Le quotation non possono contenere caratteri jolly per identificare matrici</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Un tipo di tupla è una tupla di struttura, mentre l'altra è una tupla di riferimento</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i aggiuntivo/i. La firma necessaria è '{2}'. Alcuni nomi di argomenti mancanti sono {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i. La firma necessaria è '{2}'. Alcuni nomi di argomenti mancanti sono {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Il costruttore di oggetti o membro '{0}' richiede {1} argomento/i aggiuntivo/i. La firma necessaria è '{2}'.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'let!'.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Previsto argomento tipo o statico</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Specificate opzioni in conflitto: 'win32manifest' e 'win32res'. È possibile utilizzarne solo una.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Proprietà duplicata. Il nome e la firma della proprietà '{0}' corrispondono a quelli di un'altra proprietà nel tipo '{1}'.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Consente di specificare il nome delle impostazioni cultura di output preferite, ad esempio es-ES, it-IT</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>Nelle espressioni sequenza i risultati sono generati mediante 'yield'</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Specifica un file di chiave con nome sicuro</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Identificatore non previsto: '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Numero di riga non valido: '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>In questa posizione non sono consentiti argomenti facoltativi</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Questo costrutto è sperimentale</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Aumenti non consentiti in elementi moduleDefns di tipo delegato</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' non è un argomento Integer valido</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Quando si fa riferimento in modo esplicito a mscorlib.dll o FSharp.Core.dll è necessario passare anche l'opzione {0}</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Le annotazioni di tipo nei getter e setter di proprietà devono essere specificate dopo 'get()' o 'set(v)', ad esempio 'with get() : string = ...'</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Compila un file eseguibile Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Nome del file di output (forma breve: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Opzione --sourcelink supportata solo quando si crea un file PDB portatile (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>CallerMemberNameAttribute applicato al parametro '{0}' non avrà alcun effetto. CallerFilePathAttribute ne eseguirà l'override.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Gli argomenti statici denominati devono seguire tutti gli argomenti statici non denominati</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Compila un file eseguibile da console</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Tutte le interfacce implementate devono essere dichiarate nella dichiarazione iniziale del tipo</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Specifica di proprietà a livello di origine non prevista</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Impossibile chiamare un membro di base astratto: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>L'attributo 'ConditionalAttribute' può essere utilizzato solo nei membri</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Un tipo con attributo 'CustomComparison' deve avere un'implementazione esplicita di almeno uno degli elementi 'System.IComparable' o 'System.Collections.IStructuralComparable'</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi dei membri CLI sono diversi</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Il metodo implementato da questa implementazione predefinita è ambiguo</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# supporta dimensioni matrice comprese tra 1 e 32. Il valore {0} non è consentito.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Le quotation non possono contenere questo genere di tipo</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Nelle espressioni di oggetto possono essere specificati solo override di membri astratti e virtuali</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Scrive lo xmldoc dell'assembly nel file specificato</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché il campo '{2}' è presente nell'implementazione ma non nella firma. I tipi struct devono ora mostrare i relativi campi nella firma per il tipo, nonostante i campi possano comunque essere associati alle etichette 'private' o 'internal'.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Il case di unione '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Con gli attributi 'ReferenceEquality', 'StructuralEquality' e 'StructuralComparison' è possibile aumentare solo tipi di struct, record, unione ed eccezione</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Le dimensioni della firma non sono valide</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Specifica un file manifesto Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Espressione di indicizzatore non valida</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Il nome del tipo non può essere vuoto.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Il file di origine '{0}' non è stato trovato</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Previsto elemento padre di modulo o spazio dei nomi {0}</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Solo i binding semplici nel formato 'id = expr' possono essere usati in espressioni di costruzione</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Indica che un elemento dichiarato del programma è definito in un altro assembly o file binario.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>File di informazioni sul collegamento all'origine da incorporare nel file PDB portatile</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' può essere usato solo con costruttori di oggetto</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Il codice è meno generico di quanto indicato dalle relative annotazioni. Un'unità di misura specificata mediante '_' risulta essere '1', ovvero senza dimensione. Provare a rendere il codice generico oppure a rimuovere l'utilizzo di '_'.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Espressione letterale non valida. L'attributo [&lt;Literal&gt;] verrà ignorato.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base alla firma questo tipo e non l'implementazione può usare come valore aggiuntivo valori Null</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>Le espressioni 'try/with' non possono essere utilizzate nelle query</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Collega in modo statico la libreria F# e tutte le DLL da questa dipendenti a cui viene fatto riferimento nell'assembly in fase di generazione</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>L'attributo 'AutoOpen(\"{0}\")' nell'assembly '{1}' non fa riferimento a un modulo o a uno spazio dei nomi valido in tale assembly ed è stato pertanto ignorato</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Questo campo non è modificabile</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché i tipi sono di genere diverso</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Le enumerazioni non possono avere dichiarazioni di interfaccia</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Compila una libreria (forma breve: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Non è stato possibile risolvere l'assembly '{0}'</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Da questa posizione del codice non è possibile accedere a un costruttore di oggetti o membri '{0}' che accetta {1} argomenti. Tutte le versioni accessibili del metodo '{2}' accettano {3} argomenti.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Forma breve di '{0}'</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>È stata già aggiunta un'implementazione predefinita di questa interfaccia perché l'implementazione esplicita dell'interfaccia stessa non è specificata nella definizione del tipo</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Il campo denominato '{0}' viene utilizzato più di una volta.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Le compilazioni deterministiche supportano solo file PDB portatili (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Espressione oggetto non valida. Gli oggetti senza override o interfacce devono usare il formato di espressione 'new Type(args)' senza parentesi graffe.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>da {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Usata in un'espressione for per il conteggio in ordine inverso.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Questo tipo non è un tipo di record</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che utilizzano l'indirizzo di un campo</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Il tipo di struct, record o unione '{0}' implementa l'interfaccia 'System.IComparable' in modo esplicito. È necessario applicare l'attributo 'CustomComparison' al tipo.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Un'espressione if/then/else non può essere utilizzata nelle query. Provare a utilizzare un'espressione if/then o un'espressione sequenza.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Al parametro statico '{0}' è già stato assegnato un valore</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Incorpora file di origine specifici nel file PDB portatile</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>La variabile di tipo byref '{0}' è utilizzata in modo non valido. Le variabili di tipo byref non possono essere acquisite dalle chiusure o passate a funzioni interne.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Non è possibile impostare la proprietà '{0}'</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Non è possibile impostare questa proprietà</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Utilizzi di prima classe di operatori address-of non consentiti</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è un costruttore o una proprietà, l'altro no.</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Le espressioni di costruzione degli oggetti possono essere utilizzate solo per implementare costruttori in tipi di classe</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché il campo '{0}' è necessario per la firma ma non è stato specificato dall'implementazione. Il modulo contiene la definizione di eccezione\n    {1}    \ntuttavia la relativa firma specifica\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Il valore letterale numerico richiede che nell'ambito sia presente un modulo '{0}' che definisce funzioni FromZero, FromOne, FromInt32, FromInt64 e FromString</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Non è possibile definire costruttori per questo tipo</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché per la firma è necessario il campo {2}, che però non è stato specificato dall'implementazione</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Gli argomenti facoltativi sono consentiti solo in membri di tipo</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>In un riferimento a un tipo fornito manca un valore per il parametro statico '{0}'. Potrebbe essere necessario ricompilare uno o più assembly a cui viene fatto riferimento.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Il tipo di tutti i rami di un'espressione 'if' deve essere lo stesso. Il tipo previsto di questa espressione è '{0}', ma quello effettivo è '{1}'.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Cancellato in</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Questo valore, tipo o metodo prevede {0} parametro/i di tipo, tuttavia il numero di parametri specificati è pari a {1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché l'ordine dei campi nella firma e nell'implementazione è diverso. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Non è possibile usare un'operazione personalizzata unitamente a un non valore o a un binding 'let' ricorsivo in un'altra parte di questa espressione di calcolo</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Il membro '{0}' non dispone del numero corretto di parametri di tipo del metodo. La firma necessaria è '{1}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché una rappresentazione di tipo CLI è nascosta da una firma</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralComparison' ma il parametro di tipo '{1}' non soddisfa il vincolo 'comparison'. Provare ad aggiungere il vincolo 'comparison' al parametro di tipo</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Il tipo di unione, struct o record '{0}' contiene l'attributo 'StructuralComparison' ma il tipo di componente '{1}' non soddisfa il vincolo 'comparison'</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>Non è possibile usare l'indirizzo della variabile '{0}' in questo punto</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>case di unione</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Global Assembly Cache</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Interfaccia duplicata o ridondante</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>File di risposta '{0}' ('{1}') non valido</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Il formato dei binding 'use!' deve essere 'use! &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché una rappresentazione di tipo è nascosta da una firma</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Espressione di calcolo, sequenza o record non valida. Il formato delle espressioni sequenza deve essere 'seq {{ ... }}'</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>L'evento '{0}' nel tipo fornito '{1}' non contiene un valore di GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Usata per dichiarare e implementare interfacce.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è un membro di estensione, l'altro no</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>I setter di proprietà devono essere definiti con 'set value = ', 'set idx value = ' o 'set (idx1,...,idxN) value = ... '</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Argomento non valido per un'etichetta di criterio con parametri</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>La lunghezza in bit non è valida</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>La direttiva #if deve trovarsi all'inizio di una riga</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Esistono più parametri statici con il nome '{0}'</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>I campi volatili devono essere contrassegnati come 'mutable' e non possono essere statici a livello di thread</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>I tipi restituiti di case di unione devono essere identici al tipo in fase di definizione, fino alle abbreviazioni</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in implementazioni di interfaccia o override</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Provare a utilizzare un file con estensione '.ml' o '.mli'</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Questa proprietà esegue l'override o l'implementazione di una proprietà astratta, tuttavia quest'ultima non dispone di un elemento {0} corrispondente</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Errore compilatore: valore non realizzato imprevisto</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Un riferimento a un tipo fornito contiene un valore '{0}' non valido per un parametro statico. Potrebbe essere necessario ricompilare uno o più assembly a cui viene fatto riferimento.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Le definizioni di eccezione non sono compatibili perché le abbreviazioni delle eccezioni nella firma e nell'implementazione sono diverse. Il modulo contiene la definizione di eccezione\n    {0}    \ntuttavia la relativa firma specifica\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Valore di attributo personalizzato non valido (non è una costante o un valore letterale)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Le abbreviazioni di eccezioni non possono avere elenchi di argomenti</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>La proprietà contiene un tipo non valido. Le proprietà che utilizzano più argomenti di indicizzatore devono avere tipi nel formato 'ti1 * ti2 -&gt; ti3'. Le proprietà che restituiscono funzioni devono avere tipi nel formato '(ti1 -&gt; ti2)'.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>In questa posizione verrebbe archiviato un valore di tipo byref. Non sono consentiti valori byref associati a let di livello superiore.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Sono stati specificati più attributi di visibilità per l'identificatore. I binding 'let' nelle classi sono sempre privati, così come eventuali binding 'let' nelle espressioni.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Le quotation non possono contenere definizioni di funzioni dedotte o dichiarate in modo da essere generiche. Provare ad aggiungere alcuni vincoli di tipo per rendere l'espressione in quotation valida.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Precisione non valida in identificatore di formato</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Questo tipo non dispone di costruttori di oggetto accessibili</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Il tipo '{0}' nel provider di tipi '{1}' contiene uno spazio dei nomi vuoto. Usare 'null' per lo spazio dei nomi globale.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché in base all'implementazione questo tipo e non la firma può usare come valore aggiuntivo valori Null</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Argomenti necessari per il costruttore di oggetto</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in una dichiarazione 'inherits'</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Questo tipo richiede una definizione</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Non è possibile impostare campi di valori letterali</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Usata nei cicli for per indicare un intervallo.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Usata con le condizioni booleane come operatore or booleano. Equivalente a ||. Usata anche nei vincoli di membro.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Usata nelle unioni discriminate per indicare il tipo di categorie di valori, nonché nelle dichiarazioni di delegati ed eccezioni.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Usata nei costrutti di diramazione condizionale.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Usata per le espressioni di sequenza e, nella sintassi dettagliata, per separare le espressioni dai binding.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Usata per assegnare un nome di oggetto all'oggetto classe corrente. Usata inoltre per assegnare un nome a un intero criterio nell'ambito dei criteri di ricerca.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Usata in costrutti di ciclo oppure per eseguire codice imperativo.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nGli attributi di modificabilità sono diversi</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Le abbreviazioni dei tipi di eccezione di IL comune devono disporre di un costruttore di oggetto corrispondente</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Questo non è un valore letterale numerico valido. I valori letterali numerici validi includono 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>L'attributo 'CustomEquality' deve essere utilizzato insieme agli attributi 'NoComparison' o 'CustomComparison'</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Una proprietà di getter può contenere al massimo un gruppo di argomenti</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Questa dichiarazione di valore, funzione o membro non può essere dichiarata 'inline'</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Operatore prefisso non valido</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Punto e virgola non previsto in questo punto</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' non è utilizzato correttamente. Utilizzo: {1}. Si tratta di un'operazione personalizzata nella query o nell'espressione di calcolo corrente.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>L'override per '{0}' è ambiguo</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Specifica un contenitore di chiavi con nome sicuro</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>L'operatore 'expr.[idx]' è stato utilizzato in un oggetto di tipo non determinato in base alle informazioni precedenti a questo punto del programma. Provare ad aggiungere ulteriori vincoli di tipo</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ERRORI E AVVISI -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Risolvere i riferimenti ad assembly mediante regole basate su directory anziché mediante la risoluzione MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Metodo duplicato. Il nome e la firma del metodo astratto '{0}' corrispondono a quelli di un metodo astratto in un tipo ereditato dopo la cancellazione di tuple, funzioni, unità di misura e/o tipi forniti.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Non è possibile usare un'unità di misura in un'applicazione del costruttore di tipo</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Le espressioni di costruzione degli oggetti (ad esempio espressioni di record con specifiche di ereditarietà) possono essere utilizzate solo per implementare costruttori in tipi di modello a oggetti. Utilizzare 'new ObjectType(args)' per costruire istanze di tipi di modello a oggetti all'esterno di costruttori</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' non è consentito come carattere nei nomi degli operatori ed è riservato per utilizzi futuri</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>Le espressioni 'use' non possono essere utilizzate nelle query</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Il tipo '{0}' non è un tipo i cui valori possono essere enumerati con questa sintassi, ovvero non è compatibile con seq&lt;_&gt;, IEnumerable&lt;_&gt; o IEnumerable e non dispone di un metodo GetEnumerator</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Identificatore lungo vuoto imprevisto</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Direttiva non valida. Previsto '#r \"&lt;file-oppure-assembly&gt;\"'.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>A seguito dell'inferenza del tipo, una variabile di inferenza del tipo non ha rispettato il proprio ambito. Per rendere il codice meno generico, provare ad aggiungere annotazioni di tipo.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Il tipo '{0}' non supporta una conversione nel tipo '{1}'</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Opzione della riga di comando '--cliroot' deprecata. Al suo posto usare un riferimento esplicito a una copia specifica di mscorlib.dll.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Le definizioni di {0} nella firma e nell'implementazione non sono compatibili perché i nomi sono diversi. Il nome del tipo è '{1}' nel file della firma e '{2}' nell'implementazione.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Argomento non valido in 'methodhandleof' durante codegen</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Simbolo '=' imprevisto nell'espressione. Si intendeva usare 'for x in y .. z do'?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Nessun costruttore disponibile per il tipo '{0}'</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Specifica di un'interfaccia duplicata</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Assembly '{0}' non trovato nel set di dipendenze del file binario di destinazione. Le radici collegate in modo statico devono essere specificate mediante un nome di assembly, senza estensione dll o exe. Se viene fatto riferimento all'assembly in modo esplicito, è possibile che l'assembly non sia effettivamente necessario per il file binario generato. In tal caso, non deve essere collegato in modo statico.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Il tipo '{0}' implementa 'System.IComparable'. Provare inoltre ad aggiungere un override esplicito per 'Object.Equals'</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Usata in binding ricorsivi reciproci, dichiarazioni di proprietà e con più vincoli su parametri generici.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Espressione costante non valida</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Il file di risposta '{0}' non è stato trovato in '{1}'</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>Lo spazio dei nomi '{0}' non è definito.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Nessun tipo '{0}' supporta l'operatore '{1}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>I modificatori di accessibilità non sono consentiti nei binding 'do', ma è stato specificato '{0}'.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Il carattere '{0}' non è previsto nell'espressione per il preprocessore</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>È consentito al massimo un aumento 'with'</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>A un parametro con attributi deve essere inoltre assegnato un nome, ad esempio '[&lt;Attribute&gt;] Name : Type'</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Le etichette di campo e il tipo previsto di questo criterio o espressione del record non determinano in modo univoco un tipo di record corrispondente</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Solo i criteri attivi che restituiscono esattamente un risultato possono accettare argomenti</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Il membro dell'operatore infisso '{0}' ha {1} argomento/i iniziale/i. Prevista una tupla di 2 argomenti, ad esempio un membro statico (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argomento</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Il costruttore è per la compatibilità ML. {0}. È possibile disabilitare questo avviso tramite '--mlcompatibility' o '--nowarn:62'.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Il modificatore di formattazione # non è valido in F#</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Ritarda la firma dell'assembly utilizzando solo la parte pubblica della chiave con nome sicuro</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Usata per dichiarare un tipo di eccezione.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Uno o più overload del metodo hanno argomenti sottoposti a currying. Provare a riprogettare i membri in modo che accettino argomenti in tupla.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' può essere utilizzato solo come primo nome in un percorso completo</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Le enumerazioni di valori letterali devono avere tipo int, uint, int16, uint16, int64, uint64, byte, sbyte o char</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Si è verificato un errore durante la lettura del nodo dei metadati F# alla posizione {0} della tabella '{1}' dell'assembly '{2}'. Il nodo non include una dichiarazione corrispondente. Segnalare la visualizzazione di questo avviso. Potrebbe essere necessario ricompilare l'assembly F# in uso.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Errore durante l'apertura del file binario '{0}': {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Nome del membro non valido. I membri non possono avere '.ctor' o '.cctor' come nome.</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Identificatore di formato non valido: '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Questo campo non è un valore letterale e non è possibile utilizzarlo in un criterio</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Solo i campi di record e i binding 'let' semplici non ricorsivi possono essere contrassegnati come mutable</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Direttiva non valida. Previsto '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Il tipo '{0}' ha un metodo '{1}' (nome completo '{2}'), tuttavia il metodo è statico</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Nessun membro astratto o di interfaccia trovato corrispondente all'override</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Criterio non valido</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'do' mancante nell'espressione 'for'. Previsto 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>È necessario dichiarare in modo esplicito tutti o nessuno dei parametri di tipo quando si esegue l'override di un metodo astratto generico</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Espressione '{0}' non supportata dal provider di tipi. Se l'utente è l'autore di questo provider di tipi, provare a fornire un'espressione differente.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Specificare la versione del sottosistema di questo assembly</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Utilizzo non previsto di una variabile di tipo byref</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Non è stato possibile incorporare il valore '{0}' contrassegnato come 'inline', probabilmente a causa di un valore ricorsivo contrassegnato come 'inline'</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>Nei tipi di funzione delimita argomenti e valori restituiti. Produce un'espressione (nelle espressioni di sequenza); equivalente alla parola chiave yield. Usata nelle espressioni match</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Gli struct non possono avere un costruttore di oggetto senza argomenti. Si tratta di una limitazione imposta in tutti i linguaggi CLI perché gli struct supportano automaticamente un costruttore predefinito.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Il valore di algId non è valido. È previsto 'Exponent'</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Provare a usare 'return!' invece di 'return'.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>L'operatore '!' viene usato per dereferenziare una cella di riferimento. In questo punto provare a usare 'not expr'.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Non aggiunge una risorsa all'assembly generato contenente metadati specifici di F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Operatore infisso non previsto in espressione di tipo</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Opzione --embed supportata solo quando si crea un file PDB portatile (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Definizione di operatore non valida. Le definizioni di operatore prefisso devono utilizzare un nome di operatore prefisso valido.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Gli argomenti non denominati non costituiscono un prefisso degli argomenti del metodo chiamato</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>nome completo non valido per il tipo fornito</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>La direttiva #else deve trovarsi all'inizio di una riga</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Il campo case di unione/eccezione '{0}' non può essere utilizzato più di una volta.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>I modificatori di accessibilità non sono consentiti in casi di unione. Usare 'type U = internal ...' o 'type U = private ...' per assegnare un'accessibilità all'intera rappresentazione.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>La creazione dell'istanza di un tipo prevede un tipo byref. Ciò non è consentito dalle regole di IL comune.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Case di unione sconosciuto</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>Il nome '({0})' non può essere utilizzato come nome di membro. Per definire semantica di confronto per un tipo, implementare l'interfaccia 'System.IComparable'. Se si definisce un membro statico per l'utilizzo da parte di altri linguaggi CLI, utilizzare il nome '{1}'.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Le abbreviazioni di tipo non possono avere aumenti</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Il modulo contiene il costruttore\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nL'accessibilità specificata nella firma è maggiore rispetto a quella specificata nell'implementazione</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI gradi nella firma e nell'implementazione sono diversi. La firma specifica che '{3}' è una definizione di funzione o un'espressione lambda che accetta un numero di argomenti almeno pari a {4}, tuttavia l'implementazione è un valore di funzione calcolato. Per dichiarare che un valore di funzione calcolato è un'implementazione consentita, è sufficiente racchiudere in parentesi il relativo tipo nella firma, ad esempio\n\tval {5}: int -&gt; (int -&gt; int)\ninvece di\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>e altri {0} overload</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Il tipo '{0}' non è un tipo di enumerazione CLI</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>L'abbreviazione di un modulo deve essere un nome semplice, non un percorso</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>I valori ricorsivi non possono rappresentare direttamente una costruzione del tipo '{0}' in un binding ricorsivo. Questa funzionalità è stata rimossa dal linguaggio F#. Provare a usare un record.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Compilatore F# per F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>A un argomento denominato sono stati assegnati più valori</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>L'assembly misto gestito/non gestito '{0}' verrà ignorato durante il collegamento statico</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>L'attributo 'StructLayout' può essere assegnato solo a struct e classi senza costruttori primari</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>È previsto un parametro di tipo, non di unità di misura</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Indica un'implementazione di un metodo astratto. Usata insieme a una dichiarazione di metodo astratto per creare un metodo virtuale.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>La fine del file nella stringa con virgolette triple incorporata nel commento inizia in questa posizione o prima di essa</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Abilita ASLR a entropia elevata</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>È prevista la chiave privata</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>risultato criteri attivi</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Questa dichiarazione non è supportata nei gruppi di dichiarazioni ricorsive</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Nell'espressione per il preprocessore manca il token '{0}'</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Uscita in corso: troppi errori</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Il membro '{0}' non dispone del numero di argomenti corretto. La firma necessaria è '{1}'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Questo tipo usa una combinazione non valida degli attributi 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' e 'StructuralComparison'</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Questa definizione può essere utilizzata solo in un tipo con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Per il tipo di attributo '{0}' è specificato 'AllowMultiple=false'. Non è possibile collegare più istanze di questo attributo a un singolo elemento del linguaggio.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>Nelle espressioni sequenza più risultati sono generati mediante 'yield!'</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Il tipo '{0}' non supporta l'operatore '{1}'. Provare ad aprire il modulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Struct, interfacce, enumerazioni e delegati non possono ereditare da altri tipi</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Numero di argomenti generici non valido nel tipo '{0}' del tipo fornito. Previsti '{1}' argomenti, specificati '{2}'.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Il metodo '{0}' non è accessibile da questa posizione di codice</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Il valore di Magic non è valido nell'intestazione CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Assegnazione facoltativa non valida a proprietà o campo</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Nessun costruttore di oggetti o membro {0} denominato '{1}' utilizza {2} argomenti. L'argomento denominato '{3}' non corrisponde ad alcun argomento o proprietà restituita impostabile per alcun overload.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Nessun costruttore di oggetti o membro {0} denominato '{1}' accetta {2} argomenti. Si noti che la chiamata a questo membro fornisce inoltre {3} argomenti denominati.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Etichetta di campo non valida</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Non è stato possibile decodificare l'attributo MarshalAs</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le rappresentazioni IL sono diverse</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Il tipo non generico '{0}' non prevede alcun argomento tipo, tuttavia è stata rilevata la presenza di {1} argomento/i tipo</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>Il valore, il costruttore, lo spazio dei nomi o il tipo '{0}' non è definito.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>spazio dei nomi/modulo</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Gerarchia di classi ricorsiva nel tipo '{0}'</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Riferimento ricorsivo a oggetto '{0}' non usato. La presenza di un riferimento ricorsivo a un oggetto aggiunge verifiche di inizializzazione del runtime ai membri in questo tipo e nei relativi tipi derivati. Provare a rimuovere il riferimento ricorsivo all'oggetto.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Un tipo non può avere sia l'attributo 'ReferenceEquality' sia 'StructuralEquality' o 'StructuralComparison'</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Questo costrutto può essere utilizzato solo in espressioni di calcolo</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Un valore deve essere modificabile per poter modificare i contenuti oppure utilizzare l'indirizzo di un tipo di valore, ad esempio 'let mutable x = ...'</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Le abbreviazioni di eccezioni devono fare riferimento a eccezioni esistenti o a tipi F# derivanti da System.Exception</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Incorpora tutti i file di origine nel file PDB portatile</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Solo i criteri variabili semplici possono essere associati in costrutti 'let rec'</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Gli argomenti successivi devono essere separati da spazi o inclusi in tuple, mentre gli argomenti che prevedono applicazioni di metodi o funzioni devono essere racchiusi tra parentesi</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Non si tratta di un'eccezione</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Errore interno. Indice non valido nella matrice di criteri attivi</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>All'assembly '{0}' viene fatto riferimento in modo transitivo e non è stato possibile risolvere l'assembly automaticamente. Ai fini del collegamento statico si presuppone che la DLL non abbia dipendenze nella libreria F# o in altre DLL collegate in modo statico. Provare ad aggiungere un riferimento esplicito alla DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Errore durante la creazione dell'attributo 'System.Reflection.AssemblyCultureAttribute' -- Gli eseguibili non possono essere assembly satellite e Culture deve essere sempre vuoto'</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Le interfacce hanno sempre la stessa visibilità del tipo di inclusione</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nUno è una funzione di tipo, l'altro no. La firma richiede parametri di tipo esplicito se questi sono presenti nell'implementazione.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>La sintassi 'module ... = struct .. end' non è utilizzata nel codice F#. Provare a utilizzare 'module ... = begin .. end'</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>L'attributo 'VolatileField' può essere usato solo in binding 'let' nelle classi</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Il modulo contiene il campo\n    {0}    \ntuttavia la relativa firma specifica\n    {1}    \nI modificatori 'literal' sono diversi</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Le definizioni di {0} per il tipo '{1}' nella firma e nell'implementazione non sono compatibili perché le abbreviazioni sono diverse: {2} invece di {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Un inizializzatore statico esplicito deve utilizzare la sintassi 'static new(args) = expr'</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Solo le funzioni possono essere contrassegnate come 'inline'</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Questo tipo non è un tipo di interfaccia</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Il tipo '{0}' non è un tipo di interfaccia</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>I costruttori di oggetti non possono utilizzare direttamente try/with e try/finally prima dell'inizializzazione dell'oggetto. Ciò include costrutti quali 'for x in ...' che potrebbero essere elaborati negli utilizzi di tali costrutti. Si tratta di una limitazione imposta dall'IL comune.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' e 'return!' non possono essere usati nelle query</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificatori di accessibilità non consentiti in campi di record. Utilizzare 'type R = internal ...' o 'type R = private ...' per assegnare un'accessibilità all'intera rappresentazione.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Usata al posto di let! nei flussi di lavoro asincroni e altre espressioni di calcolo dei valori con i quali è necessario chiamare Dispose per liberare risorse.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Dichiarazione di ereditarietà non consentita in questa posizione</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>Le informazioni sul membro '{1}' del tipo fornito '{0}' contengono un tipo dichiarante Null</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Il provider di tipi '{0}' ha restituito un metodo non valido da 'ApplyStaticArgumentsForMethod'. Era previsto un metodo con nome '{1}', mentre ne è stato restituito uno con nome '{2}'.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} non è una sequenza di escape di caratteri Unicode valida</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Sono presenti più tipi chiamati '{0}', i quali utilizzano numeri diversi di parametri generici. Fornire una creazione dell'istanza del tipo per evitare ambiguità nella risoluzione del tipo, ad esempio '{1}'.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Gli attributi dello spazio dei nomi o del modulo sono diversi nella firma e nell'implementazione</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>L'interfaccia '{0}' è inclusa in più tipi di interfaccia implementati in modo esplicito. Aggiungere un'implementazione esplicita dell'interfaccia.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>L'evento '{0}' ha un tipo non standard. Se l'evento è dichiarato in un altro linguaggio CLI, potrebbe essere necessario accedere all'evento mediante i metodi espliciti {1} e {2} per l'evento stesso. Se l'evento è dichiarato in F#, rendere il tipo dell'evento una creazione di istanza di 'IDelegateEvent&lt;_&gt;' o 'IEvent&lt;_,_&gt;'.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>La sintassi 'type X with ...' è riservata agli aumenti. I tipi le cui rappresentazioni sono nascoste ma contenenti membri vengono ora dichiarati in firme mediante 'type X = ...'. Potrebbe essere inoltre necessario aggiungere l'attributo '[&lt;Sealed&gt;] alla definizione di tipo nella firma</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Si può specificare uno dei nomi seguenti:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>L'etichetta del record '{0}' non è definita.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Questo test di tipo o downcast ignorerà l'unità di misura '{0}'</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Il BLOB di chiave pubblica non è valido</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Non è possibile usare il collegamento statico in un assembly che fa riferimento a mscorlib (ad esempio un assembly .NET Framework) durante la generazione di un assembly che fa riferimento a System.Runtime (ad esempio un assembly .NET Core o Portable).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nIl numero di parametri generici nella firma e nell'implementazione è diverso (la firma dichiara {3}, mentre l'implementazione dichiara {4})</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Il membro '{0}' non dispone dei tipi di parametri generici corretti. La firma necessaria è '{1}'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>La firma e l'implementazione non sono compatibili perché i rispettivi conteggi di parametri di tipo sono diversi</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>tipo, eccezione o modulo</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Questa espressione elenco o matrice include un elemento nel formato 'if ... then ... else'. Racchiudere l'espressione in parentesi per indicare che si tratta di un elemento singolo dell'elenco o della matrice allo scopo di eliminare l'ambiguità rispetto a un elenco generato mediante un'espressione sequenza</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Il tipo '{0}' non prevede 'null' come valore valido</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>I modificatori di accessibilità devono trovarsi immediatamente prima dell'identificatore di denominazione di un costrutto</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Definizione di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'use'.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Definizione di funzione o di valore incompleta. Se presente in un'espressione, il corpo dell'espressione deve essere rientrato alla stessa colonna della parola chiave 'let'.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Il case di unione/eccezione '{0}' non contiene il campo denominato '{1}'.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>Il nome '({0})' non può essere usato come nome di membro. Se si definisce un membro statico per l'uso da parte di altri linguaggi CLI, usare il nome '{1}'.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Il provider di tipi non contiene un costruttore valido. Era previsto un costruttore che non accetta argomenti o che accetta un solo argomento di tipo 'TypeProviderConfig'.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Tipi di struct, record, unioni e abbreviazioni non possono avere l'attributo 'AllowNullLiteral'</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>Il formato di espressione {{ expr with ... }} può essere utilizzato solo con tipi di record. Per compilare tipi di oggetto utilizzare {{ new Type(...) with ... }}</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Nessuna implementazione specificata per '{0}'</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Questo case di unione prevede {0} argomenti sotto forma di tupla</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Due definizioni di tipo con nome '{0}' nello spazio dei nomi '{1}' sono presenti in due parti dell'assembly</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Nome modulo non valido</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>La conversione da {0} a {1} è un'espressione upcast sicura della fase di compilazione e non di downcast. Provare a usare l'operatore :&gt; (upcast) invece di quello :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Identificatori di posizione non consentiti in stringhe di formato</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>L'operazione personalizzata '{0}' fa riferimento a un metodo sottoposto a overload. Non è possibile eseguire l'overload delle implementazioni delle operazioni personalizzate.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>Binding 'use' non consentiti nei moduli e considerati come binding 'let'</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Specificare la tabella codici utilizzata per leggere i file di origine</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>La modalità di gestione di questo operatore dipende ora direttamente dal compilatore F# e non è possibile ridefinirne il significato</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Converte un tipo in un tipo che occupa una posizione più bassa nella gerarchia.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Non è stato possibile leggere la versione da mscorlib.dll</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Errore segnalato dal provider di tipi '{0}' nel contesto del tipo fornito '{1}', membro '{2}'. Errore: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Errore durante l'applicazione degli argomenti statici a un tipo fornito</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- FILE DI INPUT -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Un Integer per un ciclo deve usare un identificatore semplice</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Questo numero non è compreso nell'intervallo consentito per interi con segno a 8 bit esadecimali</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Il guard dei criteri di ricerca deve essere di tipo 'bool', ma questa espressione 'when' è di tipo '{0}'.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>In una definizione di tipo sono necessari uno o più membri oppure altre dichiarazioni. Se si desidera definire una classe, un'interfaccia o uno struct vuoto, utilizzare 'type ... = class end', 'interface end' o 'struct end'.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Per i costrutti generici è necessario che il tipo '{0}' disponga di semantica di riferimento, la quale è in questo caso assente, ovvero si tratta di uno struct</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nI nomi sono diversi</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>L'abbreviazione del tipo contiene byref. Ciò non è consentito da F#.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Non è possibile generare informazioni di debug MDB. Non è stato possibile caricare il tipo 'MonoSymbolWriter' dall'assembly 'Mono.CompilerServices.SymbolWriter.dll'.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Errore imprevisto durante la creazione del file di informazioni di debug '{0}'</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>È previsto un parametro di unità di misura, non di tipo. I parametri di unità di misura espliciti devono essere contrassegnati con l'attributo [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Non è possibile analizzare la stringa di formato '{0}'</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Decodifica non prevista di AutoOpenAttribute</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Le quotation non possono contenere espressioni che effettuano chiamate a vincoli di membro o utilizzi di operatori che vengono risolti in modo implicito in una chiamata a vincolo di membro</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>I file in librerie o in applicazioni con più file devono iniziare con una dichiarazione di modulo o di spazio dei nomi. Quando si usa una dichiarazione di modulo all'inizio del file, il segno '=' non è consentito. Se questo è un modulo di primo livello, provare a rimuovere il segno = per risolvere l'errore.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Il campo '{0}' è presente due volte nei criteri o nell'espressione del record</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Era previsto un tipo fornito denominato '{0}', mentre il tipo fornito contiene 'Name' con valore '{1}'</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Era previsto un tipo fornito con percorso '{0}', mentre il tipo fornito contiene il percorso '{1}'</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Il numero di argomenti per un attributo personalizzato non corrisponde al numero di argomenti previsti per il costruttore di attributo</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Il membro '{0}' è utilizzato in modo non valido. Un utilizzo di '{1}' è stato dedotto prima della relativa definizione in o in prossimità di '{2}'. Si tratta di un riferimento in avanti non valido.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>L'evento '{0}' nel tipo fornito '{1}' non contiene un valore di GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>È prevista la chiave RSA</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>A tutti i tipi di struct, record e unione in FSharp.Core.dll deve essere assegnata in modo esplicito l'etichetta 'StructuralComparison' o 'NoComparison'</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Il tipo di unione per il case di unione '{0}' è stato definito con RequireQualifiedAccessAttribute. Includere il nome del tipo di unione ('{1}') nel nome da usare.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>I criteri attivi non possono restituire più di 7 possibilità</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>Il valore o il costruttore '{0}' non è definito.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>La dichiarazione 'inherit' contiene argomenti ma non è in un tipo con un costruttore primario. Provare ad aggiungere argomenti alla definizione di tipo utilizzata, ad esempio 'type X(args) = ...'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>I tipi di unione discriminati sono sempre Sealed</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Annotazione GetSet imprevista in una proprietà</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Valore non valido per un valore letterale di enumerazione</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Modulo/espressione/tipo non valido</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} overload</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 overload</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>È previsto un tipo che supporti l'operatore '{0}', tuttavia è specificato un tipo di tuple</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>L'assembly '{0}' è elencato nella riga di comando. È necessario fare riferimento agli assembly utilizzando un flag della riga di comando quale '-r'.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>L'oggetto '{0}' di un tipo fornito è Null o vuoto.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Metodo duplicato. Il nome e la firma del metodo astratto '{0}' corrispondono a quelli di un metodo astratto in un tipo ereditato.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>anche da {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Il metodo di matrice '{0}' è fornito dal runtime e non può essere utilizzato direttamente nel codice. Per operazioni con elementi di matrice, considerare l'impiego della famiglia di funzioni GetArray/SetArray dal modulo LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>L'attributo di accessibilità '{0}' non è consentito nell'abbreviazione del modulo. Le abbreviazioni dei moduli sono sempre private.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>I tipi forniti generati da questo utilizzo di un provider di tipi potrebbero non essere utilizzati da altri assembly F# e devono essere contrassegnati come interni o privati. Provare a utilizzare 'type internal TypeName = ...' o 'type private TypeName = ...'.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Aggiunge . per l'accesso all'indicizzatore.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>I binding DLLImport devono essere membri statici in una classe o definizioni di funzione in un modulo</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>La funzione o il membro '{0}' viene usato in un modo che richiede ulteriori annotazioni di tipo in corrispondenza della relativa definizione per garantire la coerenza dei tipi dedotti. La firma dedotta è '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Questo metodo dispone già di un'implementazione predefinita</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Il modulo '{0}' contiene\n    {1}    \ntuttavia la relativa firma specifica\n    {2}    \nLa rappresentazione compilata di questo metodo è un membro di istanza, tuttavia la firma indica che essa è un membro statico</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Valore letterale byte non valido</value>
  </data>
</root>