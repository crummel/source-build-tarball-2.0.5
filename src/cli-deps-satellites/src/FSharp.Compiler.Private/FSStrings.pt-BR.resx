<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>símbolo '||'</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> em arquivo de implementação</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>O membro '{0}' não corresponde a um slot abstrato exclusivo baseado somente no nome e contagem do argumento</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value>. Interfaces múltiplas implementadas têm um membro com este nome e contagem de argumento</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value>. Considere implementar interfaces '{0}' e '{1}' explicitamente.</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value>. Anotações de tipo adicionais podem ser necessárias para indicar a substituição relevante. Este aviso pode ser desabilitado usando '#nowarn "70"' ou '--nowarn:70'.</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>falha de lex</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>símbolo '(*)'</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> em expressão lambda</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>símbolo '('</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>palavra-chave 'constructor'</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> em lista de atributo</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>Esse valor não é mutável. Considere usar a palavra-chave mutable, por exemplo, 'let mutable {0} = expression'.</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>operador pré-fixo</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>Este upcast é desnecessário - os tipos são idênticos</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>O resultado dessa expressão de igualdade é implicitamente descartado. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let resultado = expressão'.</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>'{0}' é associado duas vezes neste padrão</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>Identificadores de variáveis maiúsculas geralmente não devem ser usados nos padrões, podendo indicar um nome de padrão escrito incorretamente.</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> em declaração de caso união discriminada</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>palavra-chave 'to'</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>palavra-chave 'if'</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>palavra-chave 'in'</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>palavra-chave 'as'</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>palavra-chave 'or'</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>palavra-chave 'of'</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>palavra-chave 'do'</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>O resultado dessa expressão é ignorado implicitamente. Considere usar 'ignore' para descartar esse valor explicitamente, por exemplo, 'expr |&gt; ignore' ou 'let' para associar o resultado a um nome, por exemplo, 'let result = expr'.</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>palavra-chave 'interface'</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> em assinatura de módulo ou namespace</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>Diretivas #I só podem ocorrer em arquivos de script F# (extensões .fsx ou .fsscript). Mova este código para o arquivo de script e adicione uma opção de compilador '-I' para esta referência, ou então, delimite a diretiva com '#if INTERACTIVE'/'#endif'.</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>palavra-chave 'constraint'</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0} (Code={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> em definição de membro</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>palavra-chave 'finally'</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> em definição de exceção</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value>. {0}, {1}, {2} ou outro token são esperados.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>símbolo ':?'</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>O tipo implementa a interface '{0}' mas isto não é revelado pela assinatura. Você deveria listar a interface na assinatura, uma vez que a interface será detectável via conversões de tipo dinâmico e/ou reflexão.</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>palavra-chave 'public'</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>símbolo '::'</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value>. Consulte também {0}.</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>comentário de linha</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>O tipo recipiente pode usar 'null' como um valor de representação para seu caso união nulário. Chame um membro virtual ou abstrato, caso contrário, uma implementação de interface em um valor nulo levará a uma exceção. Se necessário, adicione um valor fictício ao construtor nulário para evitar que 'null' seja usado como uma representação para este tipo.</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>palavra-chave 'upcast'</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>palavra-chave 'override'</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>Correspondências de padrão incompletas presentes nesta expressão.</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> Por exemplo, o valor '{0}' pode indicar um caso que não é abrangido pelos padrões.</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> Por exemplo, o valor '{0}' pode indicar um caso não abrangido por tais padrões. Entretanto, uma regra de padrão com uma cláusula 'when' pode corresponder a este valor com êxito.</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> Elementos incompatíveis serão ignorados.</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>Uma definição a ser compilada como um evento .NET não tem a forma esperada. Apenas membros de propriedade podem ser compilados como eventos .NET.</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> em expressão if/then/else</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>literal de cadeia de caracteres</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>palavra-chave 'struct'</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>palavra-chave 'static'</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>símbolo ']'</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>símbolo '}'</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>símbolo '-&gt;'</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>símbolo ')'</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>final de cotação</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>Uma referência de assembly necessária está faltando. Você deve adicionar uma referência ao assembly '{0}'.</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>Implementações de interfaces devem ser dadas nas declarações de tipo iniciais.</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>palavra-chave 'inline'</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>Esta e outras referências recursivas dos objetos que estão sendo definidos passarão por verificação de solidez de inicialização em tempo de execução através do uso de uma referência atrasada. Isto porque você está definindo um ou mais objetos recursivos ao invés de funções recursivas. Este aviso pode ser suprimido com o uso de '#nowarn "40"' ou '--nowarn:40'.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>símbolo ':?&gt;'</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>Sobrecarga possível: '{0}'. {1}.</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>Este campo não é mutável</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>palavra-chave 'member'</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>palavra-chave 'module'</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> em assinatura de valor</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>símbolo '('</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>início de cotação</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>símbolo '&lt;-'</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>palavra-chave 'downcast'</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>símbolo '{'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>símbolo '['</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>Este valor não é local</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>Este teste de tipo ou coerção em tempo de execução do tipo\n    {0}    \n para \n    {1}    \nenvolve um tipo indeterminado com base na informação anterior a este ponto do programa. Testes de tipos em tempo de execução não são permitidos em alguns tipos. São necessárias novas anotações de tipo.</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>símbolo '|]'</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>Um parâmetro de tipo não possui uma restrição '{0}'</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>palavra-chave</value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> em padrão</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>palavra-chave 'assert'</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> em argumentos de tipo</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>O resultado dessa expressão de igualdade é implicitamente descartado. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let resultado = expressão'. Se você pretende alterar um valor, marque-o como 'mutable' e use o operador '&lt;-', por exemplo, '{0} &lt;-expressão'.</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>fim de entrada</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>O tipo '{0}' espera argumento(s) de tipo {1} mas é dado {2}</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>token fictício interno</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>Restrições de tipo incompatíveis ao aplicar o tipo padrão '{0}' para uma variável de inferência de tipo.</value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> Considerar adicionar novas restrições de tipo</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>palavra-chave 'delegate'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>palavra-chave 'extern'</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>símbolo '='</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>símbolo '..'</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>palavra-chave 'downto'</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>símbolo '$'</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>Teste de tipo ou coerção em tempo de execução inválido do tipo {0} para {1}\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>Tipos incompatíveis. Esperando um\n    '{0}'    \n, mas foi fornecido um\n    '{1}'    {2}\n</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>Esperava-se que esta expressão tivesse o tipo\n    '{1}'    \n, mas aqui ela tem o tipo\n    '{0}'    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>palavra-chave de fichário</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> em interação</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>início do constructo estruturado</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>Implementações de interface em aumentos agora são preteridas. Implementações de interface devem ser dadas nas declarações de tipo iniciais.</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>Este tipo de teste ou downcast sempre será mantido</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>O membro '{0}' não tem o tipo correto para substituir o método abstrato correspondente.</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> A assinatura requerida é '{0}'.</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>O membro '{0}' não tem um tipo correto para substituir qualquer método virtual dado</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>O membro '{0}' é especializado com 'unit', mas 'unit' não pode ser usado como um tipo de retorno de um método abstrato parametrizado no tipo de retorno.</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> em diretiva</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>palavra-chave 'global'</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> em assinatura de membro</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>operador pré-fixo</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>palavra-chave 'function'</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> em associação</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value>. {0} ou outro token são esperados.</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>palavra-chave 'interface'</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>símbolo ';;'</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (devido à sintaxe com reconhecimento de recuo)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>Associações podem ser executadas fora de ordem devido a esta referência de encaminhamento.</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>símbolo</value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>literal decimal</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>Este constructo foi preterido</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value>. {0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>palavra-chave 'default'</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> em expressão de registro</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>Pesquisa por um objeto de tipo indeterminado baseado em informações anteriores a este ponto do programa. Uma anotação de tipo pode ser necessária antes deste ponto do programa para restringir o tipo do objeto. Isto deverá permitir que a pesquisa seja resolvida.</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>Associações 'let' do thread estático e do contexto estático foram preteridas. Ao invés delas, utilize uma declaração da forma 'static val mutable &lt;ident&gt; : &lt;type&gt;' na classe. Adicione o atributo 'DefaultValue' a esta declaração para indicar que o valor é iniciado com o valor padrão a cada novo thread.</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>erro interno: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> em restrição de tipo</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>nome de operador</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>O tipo referenciado através de '{0}' é definido no assembly não referenciado. Você deve adicionar uma referência ao assembly '{1}'.</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}. Este aviso foi desabilitado com o uso de '--nowarn:57' ou '#nowarn "57"'.</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>erro interno: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>erro de análise</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>erro de análise: fim de arquivo inesperado</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>Arquivos carregados só podem ser arquivos de origem F# (extensão .fs). Este arquivo de script F# (.fsx ou .fsscript) será tratado como um arquivo de origem F#</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>Os tipos '{0}' e '{1}' não podem ser unificados.</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>O {0} '{1}' não pode ser definido porque o nome '{2}' conflita com {3} '{4}' neste tipo ou módulo</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>Definição duplicada de {0} '{1}'</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> em declaração aberta</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>O valor '{0}' será avaliado como parte de sua própria definição</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>Este valor será eventualmente avaliado como parte de sua própria definição. Talvez seja necessário tornar o valor ocioso ou transformá-lo em uma função. Valor '{0}'{1}.</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>literal gerado por compilador</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>Os campos a seguir requerem valores: {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>código inativo</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>O tipo '{0}' não é compatível com o tipo '{1}'{2}</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>palavra-chave 'abstract'</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>palavra-chave 'namespace'</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>constructo estruturado incompleto neste ponto ou antes dele</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>O resultado dessa expressão de igualdade é implicitamente descartado. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let resultado = expressão'. Se você pretende definir um valor de uma propriedade, use o operador '&lt;-', por exemplo, '{0}.{1} &lt;- expressão'.</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value>. {0}, {1} ou outro token são esperados.</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>símbolo '??'</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>Casos união discriminados e rótulos de exceção devem ser identificadores com maiúsculas</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>Os dois lados deste padrão 'or' vinculam diferentes conjuntos de variáveis</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>Não foi possível carregar o arquivo '{0}' porque ele não existe ou não está acessível</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>Esta expressão é um valor de função, isto é, faltam argumentos. Seu tipo é {0}.</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>símbolo'['</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>palavra-chave 'mutable'</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> em definição</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>símbolo '&gt;|]'</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>espaço em branco</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>palavra-chave 'private'</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>Diretivas #r só podem ocorrer em arquivos de script F# (extensões .fsx ou .fsscript). Mova este código para um arquivo de script ou substitua essa referência com a opção do compilador '-r'. Se essa diretiva estiver sendo executada como uma entrada do usuário, você poderá delimitá-lo com '#if INTERACTIVE'/'#endif'.</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>texto de cadeia de caracteres</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>inteiro..</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> em declaração de campo</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>O uso da função '{0}' não corresponde a um tipo inferido em outro local. O tipo inferido da função é\n    {1}.    \nO tipo da função necessária neste ponto de uso é\n    {2}    {3}\nEste erro pode ocorrer devido a limitações associadas à recursão genérica em uma coleção 'let rec' ou em um grupo de classes. Considere fornecer uma assinatura de tipo completo para os destinos de chamadas recursivas incluindo anotações de tipo para tipos de argumento e de retorno.</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>O tipo '{0}' não tem quaisquer subtipos adequados e não precisa ser usado como o destino de uma coerção estática</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> em expressão de início/fim</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>símbolo '{&lt;'</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>símbolo ':='</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>palavra-chave 'inherit'</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>palavra-chave 'try'</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>palavra-chave 'sig'</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>palavra-chave 'rec'</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>literal de inteiro</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>palavra-chave 'val'</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>palavra-chave 'asr'</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>palavra-chave 'and'</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>símbolo '&amp;'</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>palavra-chave 'do'</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>palavra-chave 'new'</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>palavra-chave 'end'</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>fim de entrada</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>símbolo '.'</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>símbolo '|'</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>palavra-chave 'fun'</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>palavra-chave 'for'</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>Esta construção faz com que o código seja menos genérico que o indicado por suas anotações de tipo. A variável de tipo implicada pelo uso de '#', '_' ou outra anotação de tipo em '{0}', ou próximo a ele, foi restrita a ser do tipo '{1}'.</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>Esta construção faz com que o código seja menos genérico que o indicado por suas anotações de tipo. A variável de tipo '{0} foi restringida a ser tipo '{1}'.</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>Esta construção faz com que o código seja menos genérico que o indicado por suas anotações de tipo. A variável de unidade de medida '{0} foi restringida para ser medida '{1}'.</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>comentário</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>Implementações de substituições foram preteridas em aumentos. Implementações de substituições devem ser dadas como parte da declaração inicial de um tipo.</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>Este uso recursivo passará por verificação de solidez de inicialização no tempo de execução. Este aviso normalmente é inofensivo e pode ser suprimido usando '#nowarn "21"' ou '--nowarn:21'.</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>Implementações de substituições devem ser dadas como parte de declaração inicial de um tipo.</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>O tipo de recipiente pode usar 'null' como um valor de representação para seu caso união nulário. Este membro será compilado como um membro estático.</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>Restrições de tipo incompatíveis. O tipo \n    '{0}'    \nnão é compatível com o tipo\n    '{1}'    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>Não foi possível encontrar o arquivo '{0}' em qualquer um dos\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>aplicação de tipo</value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>Esta diretiva só pode ser usada em arquivos de script F# (extensões .fsx ou .fsscript). Remova a diretiva e mova este código para um arquivo de script, ou então, delimite a diretiva com '#if INTERACTIVE'/'#endif'.</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>O tipo '{0}' não coincide com o tipo '{1}'</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>A unidade de medida '{0}' não coincide com a unidade de medida '{1}'</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>palavra-chave 'internal'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>símbolo '[&lt;'</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>símbolo '&gt;'</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>Este constructo foi preterido: ele somente pode ser usado na biblioteca F#</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>Restrição de valor. O valor '{0}' tem um tipo genérico\n    {1}    \nInsira '{2}' em uma função com argumentos explícitos ou, se você não desejar que ele seja genérico, adicione uma anotação de tipo.</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>Restrição de valor. Este membro foi inferido para ter um tipo genérico\n    {0}    \nConstrutores e getters/setters de propriedade não podem ser mais genéricos que o tipo de delimitador. Adicione uma anotação de tipo para indicar os tipos exatos envolvidos.</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>Restrição de valor. O valor '{0}' tem um tipo genérico\n    {1}    \nTorne os argumentos '{2}' explícitos ou, se sua intenção não for deixá-los genéricos, adicione uma anotação de tipo.</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>Restrição de valor. O valor '{0}' foi inferido para ter um tipo genérico\n    {1}    \nTorne os argumentos '{2}' explícitos ou, se sua intenção não for deixá-los genéricos, adicione uma anotação de tipo.</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>Restrição de valor. O valor '{0}' foi inferido para ter um tipo genérico\n    {1}    \nDefina '{2}' como um termo de dado simples e torne-o uma função com argumentos explícitos ou, se sua intenção for deixá-los genéricos, adicione uma anotação de tipo.</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> em correspondência padrão</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>Final da entrada inesperado</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> em definição de tipo</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> em assinatura de tipo</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> em arquivo de assinatura</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> em literal de cotação</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>O arquivo carregado possui um ou mais avisos.\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>O arquivo carregado possui um ou mais erros\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>O compilador de F# concedeu status especial às restrições de membros com o nome '{0}', pois certos tipos .NET são aumentados implicitamente com seus membros. Isto pode resultar em falhas em tempo de execução se você tentar chamar a restrição de membro de seu próprio código.</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> em associação</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>Definição duplicada de {0} '{1}'</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>Dois membros chamados '{0}' possuem a mesma assinatura</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>palavra-chave 'instance'</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>O uso de ponteiros nativos podem resultar em código .NET IL não verificável </value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>O tipo '{0}' não tem nenhum subtipo apropriado e não pode ser usado como a fonte de um teste de tipo ou coerção em tempo de execução.</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>O tipo '{0}' não pode ser usado como a fonte de um teste de tipo ou coerção de tempo de execução</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>palavra-chave 'do!'</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>símbolo '_'</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>Construtores de objetos implícitos para structs devem obter pelo menos um argumento</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>símbolo '{0}</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>palavra-chave reservada</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>símbolo 'splice'</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>Referências recursivas ao objeto que está sendo definido terão sua solidez de inicialização verificada no tempo de execução, por meio do uso de uma referência atrasada. Considere colocar autorreferências em membros ou em expressões à direita da forma '&lt;ctor-expr&gt; then &lt;expr&gt;'.</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>Referências recursivas ao objeto que está sendo definido terão sua solidez de inicialização verificada em tempo de execução, por meio do uso de uma referência atrasada. Considere colocar autorreferências em instruções 'do' após a última associação 'let' na sequência de construção.</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>símbolo ':&gt;'</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>Este construtor é aplicado aos argumentos {0}, mas espera {1}</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>palavra-chave 'function'</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>Este constructo foi preterido: {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>diretiva</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>Este tipo é 'abstract', uma vez que os membros abstratos não receberam uma implementação. Se esta for a intenção, adicione o atributo '[&lt;AbstractClass&gt;]' ao seu tipo.</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value> Um constructo com esse nome foi encontrado em FSharp.PowerPack.dll, que contém alguns módulos e tipos que foram referenciados implicitamente em alguma versão prévia de F#. Talvez seja necessário adicionar uma referência explícita a esse DLL para compilar seu código.</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>{0} inesperado</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>rendimento!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>rendimento</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>símbolo '?'</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>símbolo de cotação</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>Uma coerção no tipo de valor \n    {0}    \npara o tipo \n    {1}    \nenvolverá conversão boxing. Considere usar 'box' em vez disso</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>identificador</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>palavra-chave 'while'</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>palavra-chave 'match'</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>símbolo '-'</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>palavra-chave 'with'</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>palavra-chave 'then'</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>palavra-chave 'else'</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>símbolo ':'</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>símbolo ','</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>palavra-chave 'const'</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>palavra-chave 'class'</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>palavra-chave 'begin'</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>ponto flutuante literal</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>palavra-chave 'fixo'</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>palavra-chave 'false'</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>Constructo estruturado incompleto neste ponto ou antes dele</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>O módulo '{0}' requer um {1} '{2}'</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> em declaração externa</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> em tipo</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> em expressão</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> em caso união</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>literal de matriz de bytes</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> avaliará '{0}'</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>Esta regra nunca será correspondida</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \n{3}.</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\nMelhor sobrecarga possível: '{0}'.</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>símbolo '[|'</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>As tuplas tem comprimentos diferentes de {0} e {1}</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>palavra-chave 'type'</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>palavra-chave 'true'</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>símbolo '*'</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value>símbolo #</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>palavra-chave 'when'</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>palavra-chave 'with'</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>palavra-chave 'void'</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>símbolo '&lt;'</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>palavra-chave 'lazy'</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>palavra-chave 'open'</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>palavra-chave 'fun'</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>palavra-chave 'let' ou 'use'</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>palavra-chave 'null'</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>palavra-chave 'elif'</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>palavra-chave 'done'</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>literal de caractere</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>palavra-chave 'base'</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>A referência de assembly '{0}' não foi localizada ou é inválida</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>erro de sintaxe</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>Os campos '{0}' e '{1}' são de tipos diferentes</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> em nome de tipo</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>símbolo '&amp;&amp;'</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>Nome de assembly inválido '{0}' do atributo InternalsVisibleTo em {1}</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>Nome de assembly inválido '{0}' do atributo InternalsVisibleTo (o nome de arquivo de assembly não está disponível)</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>Esta função obtém muitos argumentos, ou é usada em um contexto onde uma função não é esperada</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>O resultado dessa expressão de igualdade é implicitamente descartado. Considere o uso de 'let' para associar o resultado a um nome, por exemplo, 'let resultado = expressão'. Se você pretende alterar um valor, use o operador '&lt;-', por exemplo, '{0} &lt;- expressão'.</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>A coerção estática do tipo\n    {0}    \npara \n    {1}    \n requer um tipo indeterminado baseado nas informações anteriores a este ponto do programa. Coerções estáticas não são permitidas em alguns tipos e são necessárias novas anotações de tipo.</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>O uso desse construto pode resultar na geração de código .NET IL não verificável. Este aviso pode ser desabilitado usando '--nowarn:9' ou '#nowarn "9"'.</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> em definições</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>símbolo ';'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>operador infixo</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> em expressão de objeto</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>símbolo '&gt;}'</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>símbolo '&gt;]'</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>palavra-chave 'exception'</value>
  </data>
</root>