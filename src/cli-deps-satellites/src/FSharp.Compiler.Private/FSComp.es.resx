<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en esta posición para abreviaciones de tipos.</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>La vinculación estática no puede incluir un archivo .EXE.</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>La propiedad '{0}' no se puede leer.</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Los enlaces 'use' deben tener el formato 'use &lt;var&gt; = &lt;expr&gt;'.</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Compilador de Microsoft (R) F#, versión {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>El campo de clase, registro o struct '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Miembro '{0}' no válido en el tipo '{1}' proporcionado. Los miembros de tipo proporcionados deben ser públicos y no genéricos, virtuales o abstractos.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' no es una expresión válida. Los registros deben incluir al menos un campo. Las secuencias vacías se especifican con Seq.empty o una lista vacía '[]'.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>No se admite la invocación dinámica de {0}.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene el atributo 'StructuralEquality', pero el parámetro de tipo '{1}' no satisface la restricción 'equality'. Considere agregar la restricción 'equality' al parámetro de tipo.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene el atributo 'StructuralEquality', pero el tipo de componente '{1}' no satisface la restricción 'equality'.</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Considere el uso de un tipo de registro diferente en su lugar.</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>La dirección de la variable '{0}' no se puede usar en este punto. Puede que el método o la función no devuelvan la dirección de este valor local.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>No se puede leer el ensamblado '{0}'.</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Una construcción genérica requiere que el tipo '{0}' sea un tipo struct de CLI o F#.</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>El proveedor de tipos '{0}' devolvió NULL de GetInvokerExpression.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>No se permiten varias referencias a '{0}.dll'.</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Falta el elemento de clausura en un nombre de operador de expresión de código delimitada que comienza con '{0}'.</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Indica un método que no tiene ninguna implementación en el tipo en el que se declara o un método que es virtual y tiene una implementación predeterminada.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>La vinculación estática no puede incluir un archivo DLL mixto administrado o no administrado.</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Restringe el acceso a un miembro a código del mismo tipo o módulo.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>El tipo '{0}' no es compatible con ninguno de los tipos {1}, producidos por el uso de una cadena de formato de tipo printf.</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Los miembros de extensión no pueden proporcionar sobrecargas de operador. En su lugar, considere definir el operador como parte de la definición de tipo.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>La variable '{0}' se usa de una forma no válida.</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' se puede usar sólo para construir tipos de objeto.</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Token '{0}' inesperado o expresión incompleta</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' no se puede usar como nombre de campo.</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Se proporcionaron varias accesibilidades para un captador o establecedor de propiedad.</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Los constructores deben aplicarse a argumentos y no pueden usarse como valores de primera clase. Si es necesario, use una función anónima '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Archivo de versión '{0}' no válido.</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Los enlaces recursivos que incluyen especificaciones de miembro pueden existir solo como aumento directo de un tipo.</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Referencia recursiva no válida a una ranura abstracta.</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener código de ensamblado alineado ni detección de patrones en matrices.</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Los objetos deben inicializarse con una expresión de construcción de objeto que llame a un constructor de objeto heredado y asigne un valor a cada campo.</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Los argumentos para operadores de consulta pueden requerir paréntesis; por ejemplo, 'where (x &gt; y)' o 'groupBy (x.Length / 10)'.</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Establecer un nivel de advertencia (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Muestra este mensaje de uso (forma corta: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>El ensamblado System.Runtime.InteropServices es necesario para usar clases UnknownWrapper\DispatchWrapper.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>módulo</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Expresión no válida en la parte izquierda de la asignación.</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Especificación inline no válida.</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Delimita una expresión de código con tipo.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet se espera solo en árboles de análisis.</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problema con el nombre de archivo '{0}': caracteres no válidos en la ruta de acceso.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(cargando descripción...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'comparison' porque es un registro, una unión o un struct con uno o varios tipos de elemento estructural que no admiten la restricción 'comparison'. Evite el uso de la comparación con este tipo o agregue el atributo 'StructuralComparison' al tipo para determinar el tipo de campo que no admite comparación.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'comparison'. Por ejemplo, no admite la interfaz 'System.IComparable'.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'comparison' porque tiene el atributo 'NoComparison'.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>El atributo 'System.Diagnostics.ConditionalAttribute' es válido sólo en métodos o clases de atributos.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque las representaciones de CLI difieren. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Error de sintaxis en argumento de tipo con etiqueta.</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Una propiedad no puede tener parámetros de tipo explícitos. Considere el uso de un método en su lugar.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Mensajes de salida con codificación UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Hay un módulo y una definición de tipo con el nombre '{0}' en el espacio de nombres '{1}' en dos partes de este ensamblado.</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>El nombre '{0}' no está enlazado en el contexto del patrón.</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>El constructor de proveedores de tipos produjo una excepción: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Tipo de argumento estático "{0}" desconocido al resolver una referencia a un tipo o un método "{1}" proporcionado</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>La definición del operador personalizado '{0}' no usa una combinación válida de marcas de atributo.</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} se representó como un método estático pero no era una expresión lambda apropiada.</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros no firmados de 8 bits.</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Se han omitido los atributos en esta construcción.</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' debe ir seguido de 'in'. Uso: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' implementa la interfaz 'System.IEquatable&lt;_&gt;' de forma explícita. Aplique el atributo 'CustomEquality' al tipo y proporcione una implementación coherente de la invalidación no genérica 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>El archivo de código fuente es demasiado grande para insertarlo en un archivo PDB portátil</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Un constructor de objeto requiere un argumento.</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Error al leer o escribir metadatos para el archivo DLL '{0}' compilado con F#. ¿Se había compilado el archivo DLL con una versión anterior del compilador de F#? (Error: '{1}').</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Las interfaces no pueden contener definiciones de invalidaciones de miembro.</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Se han especificado varios atributos de visibilidad para este identificador.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura es una clase abstracta pero la implementación no. Considere agregar el atributo [&lt;AbstractClass&gt;] a la implementación.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>El tipo '{0}' proporcionado tiene el miembro '{1}' con el tipo declarativo '{2}'. Se esperaba que el tipo declarativo coincidiera con el tipo proporcionado.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class', 'interface' o 'struct' desemparejado.</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Se usa para asociar un nombre a un grupo de módulos y tipos relacionados, a fin de separarlo de forma lógica del resto del código.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>El espacio de nombres o módulo "{0}" no está definido.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Este caso de unión toma un argumento.</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Lista inesperada de moduleDefn de tipos vacía.</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Se usa para condiciones booleanas (restricciones when) en coincidencias de patrones y para introducir una cláusula de restricción de un parámetro de tipo genérico.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Se usa junto con la palabra clave match en las expresiones de coincidencia de patrones. También se usa en las expresiones de objeto, expresiones de copia de registros y extensiones de tipo para incluir las definiciones de miembro y los controladores de excepciones.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Indica el tipo void de .NET. Se usa al interoperar con otros lenguajes .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Se usa en las expresiones condicionales y también para generar efectos secundarios después de la construcción de objetos.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Se usa para declarar una clase, un registro, una estructura, una unión discriminada, un tipo de enumeración, una unidad de medida o una abreviatura de tipo.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Se usa para que el contenido de un espacio de nombres o de un módulo esté disponible sin tener que especificar el nombre completo.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Indica la ausencia de un objeto. También se usa en las restricciones de parámetro genérico.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Convierte un tipo en otro de un nivel superior de la jerarquía.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Se usa como nombre del objeto de clase base.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Se usa para especificar un cálculo que debe realizarse únicamente cuando se necesita un resultado.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Se usa en la creación de ramas condicional.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Se usa en la creación de ramas condicional. Es una forma abreviada de else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>En la sintaxis detallada, indica el final de un bloque de código en una expresión de bucle.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>El ensamblado {1} requiere una referencia al archivo DLL {0}. El tipo {2} importado se encuentra en el primer ensamblado y no se pudo resolver.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para flotantes de 32 bits.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Las definiciones de tipo pueden tener solo una especificación 'inherit' y debe ser la primera declaración.</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Los valores literales no pueden tener parámetros genéricos.</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Operador de expresión de código delimitada '&lt;@' inesperado en la definición de tipo. Si desea pasar una cadena textual como argumento estático a un proveedor de tipos, incluya un espacio entre los caracteres '&lt;' y '@'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Normalmente, el operador '{0}' no se debe redefinir. Para definir semántica de comparación sobrecargada para un tipo concreto, implemente la interfaz 'System.IComparable' en la definición de ese tipo.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Los métodos con argumentos currificados no pueden declarar argumentos 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' o 'CallerFilePath'</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>La opción '--pdb' requiere el uso de la opción '--debug'.</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>El valor '{0}' estaba marcado como inline pero no estaba enlazado en el entorno de optimización.</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>La propiedad '{0}' es estática.</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' no es estructuralmente comparable porque el parámetro de tipo {1} no satisface la restricción 'comparison'. Considere agregar el atributo 'NoComparison' al tipo '{2}' para indicar que el tipo no es comparable.</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' no es estructuralmente comparable porque el tipo '{1}' no satisface la restricción 'comparison'. Considere agregar el atributo 'NoComparison' al tipo '{2}' para indicar que el tipo no es comparable.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la implementación define un struct pero la signatura define un tipo con una representación oculta</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Nota: no se han aplicado optimizaciones de elevación de expresiones lambda debido al uso de esta función genérica restringida local como valor de primera clase. Esta condición puede resolverse agregando restricciones de tipo.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>No se permite el uso de 'let! x = coll' en expresiones de secuencia. Use 'for x in coll' en su lugar.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLos modificadores 'mutable' difieren.</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>El nombre del archivo MDB debe ser &lt;ensamblado-archivo-nombre&gt;.mdb. La opción --pdb se omitirá.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLa representación compilada de este método es como un miembro estático, pero la signatura indica que su representación compilada es como un miembro de instancia.</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>No se pudo descodificar el atributo DllImport.</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>La palabra clave 'base' se usa de forma no válida. No se pueden usar llamadas base en clausuras. Considere el uso de un miembro privado para realizar llamadas base.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' debe usarse con un tipo con nombre.</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Esta abreviación de tipo tiene uno o varios parámetros de tipo declarados que no aparecen en el tipo que se va a abreviar. Las abreviaciones de tipo deben usar todos los parámetros de tipo declarados en el tipo que se va a abreviar. Considere quitar uno o varios parámetros de tipo o use una definición de tipo concreto que contenga un tipo subyacente, como 'type C&lt;'a&gt; = C of ...'.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>El nombre del archivo de respuesta '{0}' está vacío, contiene caracteres no válidos, tiene una especificación de unidad sin ruta de acceso absoluta o es demasiado largo.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la accesibilidad especificada en la signatura es superior a la especificada en la implementación</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>No se encontró ninguna propiedad abstracta que corresponda a esta invalidación.</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Error al analizar el código IL incrustado.</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Los códigos auxiliares DLLImport no se pueden establecer como inline.</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Patrón no válido.</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Aquí se requiere un nombre de método simple.</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Las definiciones 'member val' se permiten únicamente en tipos con un constructor principal. Considere agregar argumentos a la definición de tipo, por ejemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>Marca '{0}' establecida dos veces.</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones de objeto.</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Un valor marcado como 'inline' tiene un valor inesperado.</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>Las expresiones 'match' no se pueden usar en las consultas.</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>La propiedad "{0}" tiene el mismo nombre que otra propiedad del tipo "{1}", pero una toma argumentos de indizador y la otra no. Puede que falte un argumento de indizador en una de las propiedades.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Los identificadores seguidos de '{0}' están reservados para uso futuro.</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Los parámetros de tipo explícitos se pueden usar solo en enlaces de módulo o miembro.</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>La propiedad '{0}' del tipo '{1}' proporcionado tiene el valor CanWrite=false, pero GetSetMethod() devolvió un método.</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Emitir información de depuración en expresiones de código delimitadas</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>No incluir el manifiesto Win32 predeterminado</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>reconocedor activo</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>No se puede usar el atributo 'CompiledName' con este elemento de lenguaje.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Se usa para declarar una variable, es decir, un valor que se puede cambiar.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Ya se ha especificado una signatura para el archivo o módulo '{0}'.</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que establezcan campos de caso de unión.</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Esta definición de tipo implica una referencia cíclica inmediata a través de una abreviación.</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Valor "{0}" no válido para "--targetprofile", los valores válidos son "mscorlib", "netcore" o "netstandard".</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>No se permiten enlaces 'use' en constructores principales.</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Los structs solo pueden enlazar un parámetro 'this' en declaraciones de miembro.</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Deben proporcionarse valores a todos los campos de enumeración.</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>No se permiten las definiciones 'member val' ni 'override val' en las expresiones de objeto.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque la signatura oculta la abreviación de la excepción. La abreviación debe estar visible para otros lenguajes CLI. Considere hacer que la abreviación esté visible en la signatura. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Se usa junto con try para incluir un bloque de código que se ejecuta independientemente de que se produzca una excepción.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>En código de F#, no se pueden especificar los contadores de referencias personalizados. Considere el uso de una función auxiliar de C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Ninguna implementación de '{0}' tenía el número correcto de argumentos y parámetros de tipo. La signatura necesaria es '{1}'.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Aquí no se permiten invalidaciones de método ni implementaciones de interfaz.</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>No se pudo descodificar el atributo FieldOffset.</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>El archivo de signatura '{0}' no tiene un archivo de implementación correspondiente. Si existe un archivo de implementación, compruebe que coinciden las declaraciones 'module' y 'namespace' de los archivos de signatura e implementación.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>El operador '{0}' no se puede redefinir. Considere el uso de un nombre de operador diferente.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura tiene una abreviación y la implementación no</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>El parámetro de tipo "{0}" no está definido.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Se usa para especificar una clase base o una interfaz base.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Posible sangría incorrecta: este token está fuera del contexto iniciado en la posición {0}. Pruebe aplicando más sangría a este token o usando convenciones de formato estándar.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos nombres para mostrar difieren.</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Esta expresión literal o argumento de atributo da lugar a un desbordamiento aritmético.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>No se pueden usar argumentos opcionales en atributos personalizados.</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Vincular de forma estática el ensamblado dado y todos los archivos DLL a los que se hace referencia que dependen de este ensamblado. Use un nombre de ensamblado (por ejemplo, mylib), no un nombre de DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>El final del archivo en la cadena textual incrustada en el comentario comenzaba aquí o antes.</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos valores constantes de literal y/o los atributos difieren.</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Esta codificación Unicode es válida solo en literales de cadena.</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' solo puede aplicarse a argumentos opcionales</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Esta operación implica tomar la dirección de un valor '{0}' representado con una variable local u otra representación especial. Esto no es válido.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>No hacer referencia de forma predeterminada a los ensamblados de CLI predeterminados</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>No se encontró el archivo "{0}" junto con FSharp.Core. Archivo esperado en {1}. Considere la posibilidad de actualizar a una versión más reciente de FSharp.Core en la que ya no se requiere el archivo.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura indica que este tipo puede usar valores NULL como una representación pero la implementación no</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>El final del archivo en el comentario comenzaba aquí o antes.</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' no tiene ningún argumento o propiedad de valor devuelto '{1}' que se pueda establecer. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Tipo de constante '{0}' no admitido. Las expresiones de código delimitadas que los proveedores de tipos proporcionan solo pueden contener constantes simples. Puede que sea necesario mover un valor declarado fuera de un literal de expresión de código delimitada para ser un enlace "let" dentro del literal indicado y ajustar así la implementación del proveedor de tipos.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Los patrones activos parciales solo pueden generar un resultado.</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>El tipo '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>La expresión de lista supera el tamaño máximo para literales de lista. Use una matriz para literales de mayor tamaño y llame a Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el tipo de implementación está sellado y la signatura implica que no lo esté. Considere agregar el atributo [&lt;Sealed&gt;] a la signatura.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>El argumento con nombre '{0}' no coincidía con ningún argumento ni propiedad mutable.</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Restricción no válida: el tipo usado para la restricción está sellado, lo que significa que la restricción solo se podría satisfacer con una solución como máximo.</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Carácter '{0}' inesperado.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque una signatura oculta una asignación de excepción de CLI. La asignación de excepción debe estar visible para otros módulos. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Omitiendo los atributos en la abreviación de módulo.</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Se esperaba un tipo, no una unidad de medida.</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>El tipo '{0}' implementa 'System.IComparable' de forma explícita, pero no proporciona la correspondiente invalidación para 'Object.Equals'. Se ha proporcionado automáticamente una implementación de 'Object.Equals', implementado a través de 'System.IComparable'. Considere implementar la invalidación 'Object.Equals' de forma explícita.</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>No se pudo resolver el ensamblado '{0}' requerido por '{1}'.</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Mutación no válida de una expresión constante. Considere copiar la expresión en un local mutable; por ejemplo, 'let mutable x = ...'.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Notificar advertencias específicas como errores</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>La conversión de {0} a {1} es una conversión a tipo básico segura en tiempo de compilación, no una conversión a tipo heredado. Considere la posibilidad de usar "upcast" en lugar de "downcast".</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>El identificador '{0}' está reservado para uso futuro de F#.</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Los archivos en bibliotecas o aplicaciones de varios archivos deben comenzar con una declaración de espacio de nombres o de módulo; por ejemplo, 'namespace SomeNamespace.SubNamespace' o 'module SomeNamespace.SomeModule'. Solamente el último archivo de código fuente de una aplicación puede omitir tal declaración.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Un enlace no se puede marcar como 'use' y 'rec' a la vez.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Final de entrada inesperado en los argumentos de tipo.</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es virtual y el otro no.</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Esta notación de indizador se ha quitado del lenguaje F#.</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>El tipo '{0}' se usa de un modo no válido. Un valor anterior a '{1}' tiene un tipo inferido que implica '{2}', que es una referencia adelantada no válida.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Método duplicado. El método "{0}" tiene el mismo nombre y la misma signatura que otro método del tipo "{1}" una vez borradas las tuplas, funciones, unidades de medida o tipos proporcionados.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Error interno o metadatos mal formados: no había suficientes parámetros de tipo en el ámbito durante la importación.</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Número incorrecto de argumentos de tipo para una llamada local.</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>La sintaxis 'module ... : sig .. end' no se usa en el código de F#. Considere el uso de 'module ... = begin .. end'.</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Se esperaba un tipo de interfaz.</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>El nombre '({0})' no debe usarse como un nombre de miembro porque se le da una definición estándar en la biblioteca de F# sobre tipos fijos.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Final de entrada inesperado en la definición de tipo.</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Valor no válido del parámetro '{0}' de unidad de medida.</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Valor '{0}' no válido para el parámetro '{1}' de unidad de medida.</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Formato no válido para un captador de propiedad. Se necesita al menos un argumento '()' cuando se usa la sintaxis explícita.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Se encontraron uno o varios errores durante la configuración del tipo proporcionado.</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Las expresiones de constructor para interfaces no toman argumentos.</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Nivel de advertencia no válido: '{0}'.</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>El caso de unión denominado '{0}' entra en conflicto con el tipo generado '{1}'.</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>El miembro "{0}" no corresponde a ningún método abstracto o virtual disponible para invalidarlo o implementarlo.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Construcción de registro no válida.</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>El módulo contiene el constructor\n    {0}    \npero su signatura especifica\n    {1}    \nLos tipos de los campos difieren.</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>No se encontró la etiqueta {0}.</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>El patrón activo '{0}' tiene un tipo de resultado que contiene variables de tipo no determinadas por la entrada. La causa habitual es que no se menciona un caso de resultado; por ejemplo, 'let (|A|B|) (x:int) = A x'. Esto se puede corregir con una restricción de tipo; por ejemplo, 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' requiere {1} argumentos, pero aquí se le proporcionan {2} sin nombre y {3} argumentos con nombre. La signatura necesaria es '{4}'.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>El tipo o modelo '{0}' no es un modelo o un tipo concreto.</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- ARCHIVOS DE SALIDA -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Las sobrecargas disponibles se muestran a continuación (o en la ventana Lista de errores).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' se usa con un número de argumentos incorrecto. Esta es una operación personalizada de esta expresión de consulta o cómputo. Se esperaban {1} argumentos, pero se proporcionaron {2}.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} no es un método de instancia.</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Este formato de expresión de objeto no se usa en F#. Use 'member this.MemberName ... = ...' para definir implementaciones de miembro en expresiones de objeto.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Expresión inesperada en punto de inferencia recursiva.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" de la signatura y la implementación no son compatibles porque la signatura requería el miembro abstracto "{2}" pero la implementación no lo especificó</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>Al método o función '{0}' no se le deberían proporcionar argumentos de tipo explícitos porque no declara sus parámetros de tipo de forma explícita.</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>El tipo '{0}' tiene una representación de código de ensamblado alineado.</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Los valores recursivos no se pueden asignar directamente al campo inmutable '{0}' del tipo '{1}' en un enlace recursivo. Considere el uso de un campo mutable en su lugar.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Omitir las advertencias de compatibilidad con ML</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>El miembro de operador de infijo '{0}' no tiene argumentos. Se esperaba una tupla de 2 argumentos; por ejemplo, el miembro estático (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Las interfaces no pueden contener definiciones de miembros concretos. Puede ser necesario definir un constructor en el tipo para indicar que el tipo es una clase.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Falta una calificación después de '.'</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Falta la creación de instancia del tipo genérico '{0}' y no se puede inferir de los argumentos o del tipo de valor devuelto de este miembro. Considere proporcionar una creación de instancia de tipo al obtener acceso a este tipo; por ejemplo, '{1}'.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Los identificadores de patrón activo deben comenzar con una letra mayúscula.</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>La 'h' o 'H' en este especificador de formato es innecesaria. Puede usar %d, %x, %o o %u, que se sobrecargan para funcionar con todos los tipos de entero básicos.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>El formato de expresión 'expr then expr' se puede usar sólo como parte de un constructor de objeto explícito.</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Los valores 'base' se pueden usar solo para realizar llamadas directas a las implementaciones base de miembros invalidados.</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Esta no es una expresión constante o un valor de atributo personalizado válido.</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Este enlace recursivo usa una mezcla no válida de formatos recursivos.</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' implementa la interfaz 'System.IComparable&lt;_&gt;' de forma explícita. Debe aplicar el atributo 'CustomComparison' al tipo y proporcionar también una implementación coherente de la interfaz no genérica System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Asignación no válida.</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>El final del archivo en la cadena comenzaba aquí o antes.</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>El tipo de una función de primera clase no puede contener byrefs.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'equality' porque es un tipo de función.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'equality' porque es un registro, una unión o un struct con uno o varios tipos de elemento estructural que no admiten la restricción 'equality'. Evite el uso de igualdad con este tipo o agregue el atributo 'StructuralEquality' al tipo para determinar el tipo de campo que no admite igualdad.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>El tipo '{0}' no admite la restricción 'equality' porque tiene el atributo 'NoEquality'.</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Definición de valor incompleta. Si se encuentra en una expresión, se debe aplicar sangría al cuerpo de la expresión hasta la misma columna que la palabra clave 'use!'.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Aquí no se permite el uso de la sintaxis de tipos 'int C' y 'C  &lt;int&gt;'. Considere ajustar este tipo para escribirlo con el formato 'C&lt;int&gt;'.</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Marca de prefijo (' ' o '+') establecida dos veces</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Encontrado por la clave del Registro AssemblyFolders.</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Esta construcción solo se puede usar en expresiones de secuencia y cómputo.</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Error al analizar el tipo IL incrustado.</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>A un valor de literal no se le pueden dar los atributos [&lt;ThreadStatic&gt;] o [&lt;ContextStatic&gt;].</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>El ensamblado '{0}' tiene el atributo TypeProviderAssembly con el valor '{1}' no válido. El valor debe ser un nombre de ensamblado válido.</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Este valor de función se está usando para construir un tipo de delegado cuya signatura incluye un argumento byref. Debe usar una expresión lambda explícita que tome {0} argumentos.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Las abreviaciones para excepciones de Common IL no pueden tomar argumentos.</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>'{0}' no es un tipo de enumerador válido, es decir, no tiene un método 'MoveNext()' que devuelva un valor booleano y una propiedad 'Current'.</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>El final del archivo en la directiva comenzaba aquí o antes.</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>El formato '{0}' no admite precisión.</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Los constructores para el tipo '{0}' deben llamar directa o indirectamente a su constructor de objeto implícito. Use una llamada al constructor de objeto implícito en lugar de una expresión de registro.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' no se usa correctamente. Esta es una operación personalizada de esta expresión de consulta o cómputo.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>'[&lt;' desemparejado. Se esperaba un elemento '&gt;]' de cierre.</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Uso no válido de 'fixed'. 'fixed' debe utilizarse solo en una declaración del formulario 'use x = fixed expr' donde la expresión es una matriz, la dirección de un campo, la dirección de un elemento de matriz o una cadena'</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>No se permite el carácter '{0}' en el nombre de tipo '{1}' proporcionado.</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>El parámetro estático "{0}" del tipo o del método "{1}" proporcionado requiere un valor. Los parámetros estáticos para proveedores de tipo se pueden especificar opcionalmente mediante argumentos con nombre, p. ej. "{2}&lt;{3}=...&gt;".</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>SynMeasure.Anon inesperado.</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>No se puede usar 'assert' como valor de primera clase. Use 'assert &lt;expr&gt;' en su lugar.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>No se puede heredar de un tipo de variable.</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Los casos de unión o campos del tipo '{0}' no son accesibles desde este lugar del código.</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Los valores de función mutable deben escribirse con el formato 'let mutable f = (fun args -&gt; ...)'.</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Solo los tipos de clase pueden tomar argumentos de valor.</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Número de advertencia '{0}' no válido.</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>El tipo '{0}' tiene un tipo de delegado no estándar.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>El miembro '{0}' no acepta el número correcto de argumentos. Se esperan {1} argumentos, pero se dieron {2}. La signatura necesaria es '{3}'.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es final y el otro no.</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>No se permite que los delegados tengan signaturas currificadas.</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Limitar las plataformas en las que se puede ejecutar este código: x86, Itanium, x64, anycpu32bitpreferred o anycpu. El valor predeterminado es anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Se esperaba una unidad de medida, no un tipo.</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Especificar el archivo de recursos Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Los enlaces de clase locales no se pueden marcar como 'inline'. Considere extraer la definición de la clase o no lo marque como 'inline'.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(descripción no disponible...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>El tipo '{0}' no está definido en '{1}'.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Se esperaba un identificador.</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Token inesperado "{0}" en la expresión de preprocesador</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Falta una precisión después de '.'</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Una expresión de código delimitada no puede incluir una asignación a una variable local capturada ni tomar la dirección de esta.</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>La opción de la línea de comandos '{0}' es solo para uso de pruebas</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Considere la posibilidad de usar "yield!" en lugar de "yield".</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>El tipo heredado no es un tipo de modelo de objeto.</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>El módulo principal del programa está vacío: no ocurrirá nada cuando se ejecute.</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Un objeto {0} especificó la versión "{1}", pero este valor es un carácter comodín y ha solicitado una compilación determinista. Estas opciones están en conflicto.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>El paso de un archivo .resx ({0}) como archivo de código fuente al compilador está en desuso. Use resgen.exe para transformar el archivo .resx en un archivo .resources, que se pasará como opción --resource. Si usa MSBuild, esta operación se puede realizar mediante un elemento &lt;recursoIncrustado&gt; en el archivo de proyecto .fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>La ruta de acceso '{0}' es un espacio de nombres. Una abreviación de módulo no puede abreviar un espacio de nombres.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>A una declaración se le puede dar solo un valor en una signatura si la declaración tiene el atributo [&lt;Literal&gt;].</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Se produjo una excepción al obtener acceso al '{0}' de un tipo proporcionado: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Se usa para especificar que un miembro está visible dentro de un ensamblado pero no fuera de él.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>No se encontró #endif para #if o #else.</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Se encontró una signatura de miembro no válida debido a un error anterior.</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>El campo denominado '{0}' está en conflicto con el nombre generado automáticamente para el campo anónimo.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Directiva no válida. Se esperaba '#time', '#time \"on\"' o '#time \"off\"'.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en esta posición para tipos de enumeración.</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>No se permiten atributos aquí.</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- LENGUAJE -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Tipo de depuración '{0}' no reconocido, se esperaba 'pdbonly' o 'full'.</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>El uso de 'into' debe ir seguido del resto del cómputo.</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>No se permiten usos de primera clase de la función 'reraise'.</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;' desemparejado. Se esperaba un elemento '&gt;' de cierre.</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>El módulo o espacio de nombres '{0}' de la unidad de compilación '{1}' no contenía el val '{2}'.</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>A la función genérica '{0}' se le deben proporcionar argumentos de tipo explícitos.</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>La propiedad '{0}' del tipo '{1}' proporcionado tiene el valor CanRead=true, pero no se encontró ningún valor de GetGetMethod().</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Un tipo de valor devuelto de método contenía byrefs y esto no se permite.</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>El evento '{0}' es estático.</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Este token está reservado para uso futuro.</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>En un grupo de declaraciones recursivas, las declaraciones 'abiertas' deben situarse primero en cada módulo</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>El tipo '{0}' proporcionado devolvió un miembro con un nombre de miembro NULL o vacío.</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato incorrecto (después de l o L): se esperaba ld, li, lo, lu, lx o lX. En el código de F#, puede usar %d, %x, %o o %u, que se sobrecargan para funcionar con todos los tipos de entero básicos.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Valor literal '{0}' proporcionado no válido.</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Los tipos de interfaz no se pueden sellar.</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Un patrón nuevo con el mismo nombre oculta el literal en minúsculas "{0}". Solo los literales en mayúsculas y con prefijo de módulo se pueden utilizar como patrones con nombre.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Valor no definido '{0}'.</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Esta construcción solo se puede usar en expresiones de lista, matriz y secuencia; por ejemplo, expresiones con el formato 'seq {{ ... }}', '[ ... ]' o '[| ... |]'. Estas expresiones usan la sintaxis 'for ... in ... do ... yield...' para generar elementos.</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Un atributo personalizado debe ser un tipo de referencia.</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Se usó un campo estático donde se espera un campo de instancia.</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'(' desemparejado.</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>No se pudo determinar una sobrecarga única para el método '{0}' con la información de tipo anterior a este punto del programa. Puede ser necesaria una anotación de tipo.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' no es {1}.</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Emitir información de depuración (forma corta: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>La opción '--keyfile' invalida el atributo 'System.Reflection.AssemblyKeyFileAttribute' proporcionado en un archivo de código fuente o un módulo agregado.</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Leer el archivo de respuesta para ver más opciones</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{' desemparejado.</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin' desemparejado.</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Esta definición 'let' no se puede usar en una consulta. En las consultas solo se pueden usar definiciones de valor simple.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Se llama a un miembro protegido o se usa 'base'. Esto sólo se permite en la implementación directa de miembros, ya que podrían escaparse de su ámbito de objetos.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Los argumentos de tipo se deben colocar directamente adyacentes al nombre de tipo; por ejemplo, \"C&lt;'T&gt;\", no \"C  &lt;'T&gt;\".</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Los parámetros de tipo se deben colocar directamente adyacentes al nombre de tipo; por ejemplo, \"type C&lt;'T&gt;\", no     type \"C   &lt;'T&gt;\".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>No se pudo resolver la ambigüedad inherente en el uso de una cadena de formato de tipo 'printf'.</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Error en la expresión devuelta para este 'let'. Quizá tiene una sangría incorrecta.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>No se pudo resolver la creación de instancia implícita de una construcción genérica en este punto o cerca de él porque se podía resolver en varios tipos no relacionados; por ejemplo, '{0}' y '{1}'. Considere el uso de anotaciones de tipo para resolver la ambigüedad.</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Los argumentos opcionales deben estar al final de la lista de argumentos, después de todos los argumentos no opcionales.</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Se intentó analizar este elemento como nombre de operador, pero se produjo un error.</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Referencia a un ensamblado (forma corta: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Encontrado por la clave del Registro AssemblyFoldersEx.</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>Se requiere 'get', 'set' o 'get,set'.</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' no es un argumento de punto flotante válido.</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>La opción de la línea de comandos '{0}' está en desuso. Use '{1}' en su lugar.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Un tipo con el atributo 'CustomEquality' debe tener una implementación explícita de al menos uno de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'.</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>{0} inesperado en la expresión de tipo.</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Destino de atributo no reconocido. Los destinos de atributo válidos son: 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Falta el cuerpo de la función.</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad aquí, pero se proporcionó "{0}".</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Los tipos no pueden contener definiciones de tipo anidadas.</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Advertencia de salida y mensajes de error en color</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Uso no válido de un nombre de tipo.</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Este valor no tiene un tipo de establecedor de propiedad válido.</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>El directorio de búsqueda '{0}' no es válido.</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Vincular el recurso especificado a este ensamblado donde el formato de resinfo es &lt;archivo&gt;[,&lt;nombre de cadena&gt;[,public|private]].</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>El denominador no debe ser 0 en el exponente de unidad de medida</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>No se puede usar 'inherit' en tipos de interfaz. Considere implementar la interfaz usando 'interface ... with ... end' en su lugar.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Literal entero inesperado en una expresión de unidad de medida.</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' se puede usar sólo con tipos con nombre.</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' toma {1} argumentos, pero aquí se le proporcionan {2}. La signatura necesaria es '{3}'.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>aumento predeterminado del caso de unión</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Este valor no es una función y no se puede aplicar.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Falta un especificador de formato.</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>A una propiedad de indizador se le debe proporcionar al menos un argumento.</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>'{0}' de destino no reconocido, se esperaba 'exe', 'winexe', 'library' o 'module'.</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>Falta 'do' en la expresión 'while'. Se esperaba 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Final de entrada inesperado en el cuerpo de una expresión lambda. Se esperaba 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>El archivo de documentación no tiene el sufijo .xml.</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>El uso de '-&gt;' en expresiones de secuencia y de cómputo está limitado a la forma 'for pat in expr -&gt; expr'. Use la sintaxis 'for ... in ... do ... yield...' para generar elementos en expresiones de secuencia más complejas.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Se espera que una propiedad de captador sea una función; por ejemplo, 'get() = ...' o 'get(index) = ...'.</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Falta el elemento de cierre de una expresión de código delimitada que comienza con '{0}'.</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros no firmados de 64 bits.</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" no se encuentra en el tipo "{2}" del ensamblado "{3}". La razón puede ser una incompatibilidad de versiones. Es posible que tenga que hacer referencia explícitamente a la versión correcta de este ensamblado para permitir que todos los componentes a los que se hace referencia usen la versión correspondiente.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos parámetros genéricos de la signatura y la implementación tienen tipos diferentes. Puede que falte un atributo [&lt;Measure&gt;].</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Este tipo no se puede usar para un campo literal.</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Habilitar o deshabilitar llamadas de cola</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Las expresiones de registro de copiar y actualizar deben incluir al menos un campo.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>El final del archivo en la cadena incrustada en el comentario comenzaba aquí o antes.</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Se requiere una operación de consulta personalizada para '{0}', pero no se especifica.</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Literal no válido en el tipo</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>El miembro "{0}" coincide con varias sobrecargas del mismo método.\nRestrínjalo a una de las siguientes: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Si un tipo de unión tiene más de un caso y un struct, a todos los campos dentro del tipo de unión se les deben dar nombres únicos.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>La propiedad '{0}' del tipo '{1}' proporcionado no se puede leer ni escribir, ya que tiene los valores CanRead=false y CanWrite=false.</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>propiedad generada</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Los campos 'val' estáticos en tipos deben ser mutables, privados y estar marcados con el atributo '[&lt;DefaultValue&gt;]'. Se inicializan con el valor 'null' o 'cero' para su tipo. Considere también el uso de un enlace 'static let mutable' en un tipo de clase.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Este método espera un parámetro CLI 'params' en esta posición. 'params' es una forma de pasar un número variable de argumentos a un método en lenguajes como C#. Considere pasar una matriz para este argumento.</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Los campos 'val' no inicializados deben ser mutables y estar marcados con el atributo '[&lt;DefaultValue&gt;]'. Considere el uso de un enlace 'let' en lugar de un campo 'val'.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>El tipo '{0}' proporcionado tiene 'IsGenericType' establecido como true, pero no se admiten los tipos genéricos.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>(C) Microsoft Corporation. Todos los derechos reservados.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que establezcan campos en valores de excepción.</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Este literal de matriz de bytes contiene caracteres que no se codifican como un solo byte.</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Los atributos deben ponerse delante de 'val'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la implementación define el {2} "{3}"' pero la signatura no (o sí lo define pero en otro orden)</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Una unidad de medida anónima no puede estar anidada en otra expresión de unidad de medida.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>La signatura y la implementación no son compatibles porque la declaración del parámetro de tipo '{0}' requiere una restricción con el formato {1}.</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>tipo o módulo</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Los tipos anidados proporcionados no toman argumentos estáticos o parámetros genéricos.</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Final de entrada inesperado en una expresión.</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Esta declaración abre el módulo '{0}', que está marcado como 'RequireQualifiedAccess'. Ajuste el código para usar referencias completas a los elementos del módulo; por ejemplo, 'List.map' en lugar de 'map'. Este cambio garantizará la solidez del código conforme se agreguen nuevas construcciones a las bibliotecas.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Este elemento de declaración no se permite en un aumento.</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>El constructor de objeto "{0}" toma {1} argumentos, pero aquí se le dan {2}. La signatura necesaria es "{3}".</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Este nuevo miembro oculta el miembro abstracto '{0}'. Cambie el nombre del miembro o use 'override' en su lugar.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>El tipo del tipo especificado por sus atributos no coincide con el tipo que implica su definición.</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Se produjo un problema al escribir el archivo binario '{0}': {1}.</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>No se pueden usar constantes de literal numérico no primitivas en detecciones de patrones porque se pueden asignar a varios tipos diferentes mediante un módulo NumericLiteral. Considere el uso del reemplazo con una variable y use 'when &lt;variable&gt; = &lt;constante&gt;' al final de la cláusula de coincidencia.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>La signatura y la implementación no son compatibles porque el parámetro de tipo de la clase o signatura tiene un requisito en tiempo de compilación diferente al del miembro o implementación.</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Los argumentos redundantes se omiten en la función "{0}". Se esperaban {1} argumentos, pero se recibieron {2}.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Un atributo personalizado debe invocar a un constructor de objeto.</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>La sintaxis 'expr.id' se puede usar solo con propiedades, campos y etiquetas de registro.</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Se esperaba un tipo después de este punto.</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>El atributo 'ReferenceEquality' no puede usarse en structs. Considere el uso del atributo 'StructuralEquality' en su lugar o implemente una invalidación para 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>La invalidación '{0}' implementa más de una ranura abstracta; por ejemplo, '{1}' y '{2}'.</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>El miembro '{0}' no acepta el número correcto de argumentos. Una sobrecarga acepta {1} argumentos, pero se dieron {2}. La signatura necesaria es '{3}'.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Un nombre de módulo debe ser un nombre simple, no una ruta de acceso.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Para indicar que esta propiedad se puede establecer, use 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>No se encuentra FSharp.Core.dll en el directorio del compilador.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque los tipos tienen tipos base diferentes</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>No hay ninguna coincidencia de sobrecarga para el método '{0}'.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Este no es un constructor o un literal, o se está usando un constructor de forma incorrecta.</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>El atributo 'Measure' se puede dar solo a tipos que representen unidades de medida.</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Se esperan argumentos en un miembro de instancia.</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Este código es menos genérico que lo que requieren sus anotaciones, porque la variable de tipo explícito '{0}' no se pudo generalizar. Estaba restringida a ser '{1}'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Normalmente, el operador '{0}' no se debe redefinir. Para definir semántica de igualdad para un tipo, invalide el miembro 'Object.Equals' en la definición de ese tipo.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Un tipo con el atributo 'ReferenceEquality' no puede tener una implementación explícita de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' o 'System.Collections.IStructuralEquatable'.</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>La marca de atributo 'UseNullAsTrueValue' se puede usar solo con tipos de unión que tengan un caso que acepte valores NULL y al menos un caso que no acepte valores NULL.</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' o 'struct' desemparejado.</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Asigna un valor a una variable.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>El final del archivo en la sección #if comenzaba aquí o después.</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Las coincidencias de intervalo de caracteres se han quitado en F#. Considere el uso de una restricción de patrón 'when' en su lugar.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! solo puede aparecer como primera línea al principio de un archivo.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>No se pueden especificar constructores en aumentos de excepciones.</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>El tipo '{0}' proporcionado tiene 'IsArray' establecido como true, pero no se admiten los tipos de matriz.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Propiedad duplicada. La propiedad "{0}" tiene el mismo nombre y la misma signatura que otra propiedad del tipo "{1}" una vez borradas las tuplas, funciones, unidades de medida o tipos proporcionados.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>El módulo o espacio de nombres '{0}' de la unidad de compilación '{1}' no contenía el módulo o espacio de nombres '{2}'.</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>El formato de declaración 'let ... and ...' para enlaces no recursivos no se usa en el código de F#. Considere el uso de una secuencia de enlaces 'let'.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene una implementación explícita de 'Object.GetHashCode' u 'Object.Equals'. Debe aplicar el atributo 'CustomEquality' al tipo.</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Uso no válido de un constructor de delegado. Use la sintaxis 'new Type(args)' o simplemente 'Type(args)'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>La signatura y la implementación no son compatibles porque el parámetro de tipo '{0}' tiene una restricción con el formato {1}, pero la implementación no. Quite esta restricción de la signatura o agréguela en la implementación.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>El ensamblado '{0}' al que se hace referencia tiene el atributo '{1}' de nivel de ensamblado, pero no se encontró ninguna clase de proveedor de tipos públicos.</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Notificar todas las advertencias como errores</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>No se permiten tabulaciones en código de F# a menos que se use la opción #indent \"off\".</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Argumento estático no válido para el tipo proporcionado. Se esperaba un argumento del tipo '{0}'.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Los valores mutables no se pueden marcar como 'inline'.</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Más de una invalidación implementa '{0}'.</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>No se pueden crear instancias de este tipo porque se ha marcado como abstract o no se han proporcionado implementaciones a todos los métodos. Considere el uso de una expresión de objeto '{{ new ... with ... }}' en su lugar.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>En un grupo de declaraciones recursivas, las abreviaturas del módulo deben situarse después de todas las declaraciones 'abiertas' y antes que otras declaraciones</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Se usa como alternativa abreviada a la palabra clave fun y una expresión match en una expresión lambda que tiene coincidencia de patrones en un solo argumento.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos nombres compilados difieren.</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLa accesibilidad especificada en la signatura es superior a la especificada en la implementación.</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Esta no es una expresión de construcción de objeto válida. Los constructores de objeto explícitos deben llamar a un constructor alternativo o inicializar todos los campos del objeto y especificar una llamada a un constructor de superclase.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Plataforma '{0}' no reconocida. Los valores válidos son 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' y 'anycpu'</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>No se puede usar 'new' en tipos de interfaz. Considere el uso de una expresión de objeto '{{ new ... with ... }}' en su lugar.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" de la signatura y la implementación no son compatibles porque una signatura oculta una abreviación. La abreviación debe estar visible para otros lenguajes CLI. Considere hacer que la abreviación esté visible en la signatura.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Formato no válido para un establecedor de propiedad. Se necesita la menos un argumento.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Las expresiones 'let!', 'use!' y 'do!' no se pueden usar en las consultas.</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>El final del archivo en la cadena textual comenzaba aquí o antes.</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Este campo es de solo lectura.</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>No se pudo descodificar el atributo StructLayout.</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>El tipo '{0}' no es un tipo de delegado CLI.</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Esta expresión no es una función y no se puede aplicar. ¿Pretendía tener acceso al indizador a través de expr.[index] en su lugar?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Reemplazar por "{0}"</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>El campo de clase o struct '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Se usa en una expresión de cálculo para anexar el resultado de una expresión de cálculo determinada a una colección de resultados para la expresión de cálculo que contiene.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Expresión '{0}' no válida.</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>No se puede crear una instancia de este parámetro de tipo como 'Nullable'. El motivo de esta restricción es garantizar que el significado de 'null' en algunos lenguajes CLI no sea confuso cuando se use junto con valores 'Nullable'.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Ya se ha proporcionado una implementación del archivo o módulo '{0}'.</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>El proveedor de tipos '{0}' proporcionó un constructor que no se notifica entre los constructores de su tipo declarativo '{1}'</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Las interfaces heredadas por otras interfaces deben declararse con 'inherit ...' en lugar de 'interface ...'.</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Una función etiquetada con el atributo "EntryPointAttribute" debe ser la última declaración en el último archivo de la secuencia de compilación.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>El tipo de registro '{0}' no contiene una etiqueta '{1}'.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Bloque sin cerrar.</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>No se encontró esta propiedad o campo en este tipo de atributo personalizado.</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Hay un espacio de nombres y un módulo con el nombre '{0}' en dos partes de este ensamblado.</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Especifique el perfil de la plataforma de destino de este ensamblado. Los valores válidos son mscorlib, netcore o netstandard. Valor predeterminado: mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>A partir de F# 4.1, la accesibilidad de las abreviaturas de tipo se comprueba en tiempo de compilación. Considere la posibilidad de cambiar la accesibilidad de la abreviatura de tipo. Si pasa por alto esta advertencia, se podrían producir errores de tiempo de ejecución.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>La directiva #endif debe aparecer como el primer carácter que no es un espacio en blanco en una línea.</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Estructura RSAParameters no válida, se esperaba '{{0}}'</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' no admite igualdad estructural porque el parámetro de tipo {1} no satisface la restricción 'equality'. Considere agregar el atributo 'NoEquality' al tipo '{2}' para indicar que el tipo no admite igualdad estructural.</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' no admite igualdad estructural porque el tipo '{1}' no satisface la restricción 'equality'. Considere agregar el atributo 'NoEquality' al tipo '{2}' para indicar que el tipo no admite igualdad estructural.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Este atributo no es válido para usarlo en este elemento de lenguaje. Los atributos de ensamblado deben asociarse a una declaración 'do ()', si es necesario en un módulo de F#.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Las variables ThreadStatic y ContextStatic deben ser estáticas y se les debe proporcionar el atributo [&lt;DefaultValue&gt;] para indicar que el valor se inicializa con el valor predeterminado en cada nuevo subproceso.</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>La dirección de un elemento de matriz no se puede usar en este punto.</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Error de sintaxis: especificación de parámetro de tipo inesperada.</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>No se pudo descodificar el atributo DefaultAugmentation.</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>El tipo de un campo que usa el atributo 'DefaultValue' debe admitir inicialización predeterminada, es decir, tener 'null' como un valor adecuado o ser un tipo struct cuyos campos admitan todos inicialización predeterminada. Puede usar 'DefaultValue(false)' para deshabilitar esta comprobación.</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Se usa para implementar una versión de un método abstracto o virtual que se diferencia de la versión base.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Excepción inesperada del tipo '{0}' proporcionado, miembro '{1}': {2}.</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Una variable de tipo está restringida por varios tipos de clase distintos. Una variable de tipo solamente puede tener una restricción de clase.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>El método proporcionado requiere parámetros estáticos</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>El constructor, módulo o espacio de nombres "{0}" no está definido.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Este tipo no es accesible desde este lugar del código.</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Los atributos de este tipo especifican varios tipos para el tipo.</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Esta operación obtiene acceso a un valor de nivel superior mutable definido en otro ensamblado de forma no admitida. No se puede obtener acceso al valor con su dirección. Considere copiar la expresión en una varibale local mutable (por ejemplo, 'let mutable x = ...') y, si es necesario, asignar el valor de nuevo una vez completada la operación.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Final de entrada inesperado en la expresión 'try'. Se esperaba 'try &lt;expr&gt; with &lt;reglas&gt;' o 'try &lt;expr&gt; finally &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Final de entrada inesperado en una expresión 'for'. Se esperaba 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque las representaciones difieren</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener este tipo de detección de patrones.</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Final de tipo inesperado. Se esperaba un nombre después de este punto.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>El proveedor de tipos '{0}' informó de un error: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Error en la generación de MDB. No se encontró un miembro {0} compatible.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Las abreviaciones de tipo no pueden tener declaraciones de interfaz.</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>El atributo 'StructuralEquality' debe usarse junto con los atributos 'NoComparison' o 'StructuralComparison'.</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Los operadores de inserción de expresión se pueden usar solo en expresiones de código delimitadas.</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif no tiene el correspondiente #if.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Este atributo no es válido para usarlo en este elemento de lenguaje.</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Generar comprobaciones de desbordamiento</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Distribuido de forma gratuita bajo licencia de código abierto de MIT. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' no toma {1} argumentos. Se encontró una sobrecarga que toma {2} argumentos.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>El atributo de ensamblado '{0}' hace referencia a un ensamblado de diseñador '{1}' que no se puede cargar o no existe. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Excepción inesperada de miembro '{0}' del tipo '{1}' proporcionado, miembro '{2}': {3}.</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Un proveedor de tipos implementó GetStaticParametersForMethod, pero ApplyStaticArgumentsForMethod no se implementó o no es válido</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RECURSOS -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>El código de este ensamblado usa literales de expresiones de código delimitadas. La vinculación estática no puede incluir componentes que usen literales de expresiones de código delimitadas, a menos que todos los ensamblados se hayan compilado, como mínimo, con F# 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' debe aparecer después de una cláusula de selección 'for' e ir seguido del resto de la consulta. Sintaxis: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>La opción '--delaysign' invalida el atributo 'System.Reflection.AssemblyDelaySignAttribute' proporcionado en un archivo de código fuente o un módulo agregado.</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>No se permite tomar la dirección de un campo literal.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros firmados de 32 bits.</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|' desemparejado.</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' no es {1}. Los miembros privados solo son accesibles desde el tipo que los declara. Los miembros protegidos solo son accesibles desde un tipo de extensión y no son accesibles desde expresiones lambda internas.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>El constructor de objeto o método "{0}" no es estático.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>El código del ensamblado "{0}" usa literales de expresiones de código delimitadas. La vinculación estática no puede incluir componentes que usen literales de expresiones de código delimitadas, a menos que todos los ensamblados se hayan compilado, como mínimo, con F# 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' no es un nombre de archivo válido.</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Firmar el ensamblado usando solo la parte pública de la clave de nombre seguro y marcarlo como firmado</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros no firmados de 16 bits.</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>El proveedor de tipos '{0}' devolvió un tipo no válido de 'ApplyStaticArguments'. Se esperaba un tipo con el nombre '{1}', pero se devolvió uno denominado '{2}'.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>La variable local mutable "{0}" se asignó implícitamente como celda de referencia porque se capturó mediante una clausura. Esta advertencia solo tiene fines informativos e indica dónde se realizan las asignaciones implícitas.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>En el código de F#, puede usar 'expr.[expr]'. Puede ser necesaria una automatización de tipos para indicar que la primera expresión es una matriz.</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Las interfaces no pueden contener definiciones de constructores de objeto.</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Versión '{0}' no válida de '--subsystemversion'. La versión debe ser 4.00 o posterior.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Los argumentos con nombre deben aparecer después de todos los demás argumentos.</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>La variable '{0}' está enlazada en una expresión de código delimitada, pero se usa como parte de una expresión insertada. Esto no se permite porque puede escaparse del ámbito.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>No se pudo resolver la ambigüedad en el uso de una construcción genérica con una restricción 'enum' en esta posición o cerca de ella.</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>No es un directorio de signaturas</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Operador de infijo inesperado en una expresión de unidad de medida. Los operadores válidos son '*', '/' y '^'.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>propiedad</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>No se puede heredar un tipo sellado.</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Esta construcción es ambigua como parte de una expresión de secuencia. Las expresiones anidadas se pueden escribir usando 'let _ = (...)' y las secuencias anidadas usando 'yield! seq {{... }}'.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' implementa la interfaz 'System.IStructuralEquatable' de forma explícita. Aplique el atributo 'CustomEquality' al tipo.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>No se permite este miembro en una implementación de objeto.</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Un ensamblado importado usa el tipo '{0}', pero el tipo no es público.</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- VARIOS -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>El módulo o espacio de nombres '{0}' de la unidad de compilación '{1}' no contenía el espacio de nombres, módulo o tipo '{2}'.</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>El servicio de compilación residente no se usó porque se produjo un problema en la comunicación con el servidor.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Aquí no se permite una declaración de campo o val.</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Las restricciones 'new' deben tomar un argumento de tipo 'unit' y devolver el tipo construido.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Use un servicio de compilación en segundo plano residente para mejorar los tiempos de inicio del compilador.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Restricción no válida.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la implementación indica que este tipo puede usar valores NULL como una representación pero la signatura no</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Se produjo un error al aplicar los argumentos estáticos a un método proporcionado</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Incrustar el recurso administrado especificado</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>No se pudo encontrar el método System.Runtime.CompilerServices.OffsetToStringData en las referencias al generar expresión 'fixed'.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Un miembro y un enlace de clase local tienen el nombre '{0}'.</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' debe ir seguido de un nombre de variable. Uso: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Esta prueba de tipo con un tipo '{0}' proporcionado no se permite porque el tipo proporcionado se borrará para '{1}' en tiempo de ejecución.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la implementación es una clase abstracta pero la signatura no. Considere agregar el atributo [&lt;AbstractClass&gt;] a la signatura.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Incoherencia de longitud de argumentos.</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Este valor no es una función y no se puede aplicar. ¿Olvidó terminar una declaración?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>El miembro '{0}' no se puede usar para implementar '{1}'. La signatura necesaria es '{2}'.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Este tipo implementa la misma interfaz en diferentes creaciones de instancia genéricas: "{0}" y "{1}". Esta operación no se permite en esta versión de F#.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>La opción '--keycontainer' invalida el atributo 'System.Reflection.AssemblyNameAttribute' proporcionado en un archivo de código fuente o un módulo agregado.</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Se requería el tipo de sistema '{0}', pero ningún archivo DLL del sistema al que se hacía referencia contenía este tipo.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Se usa para indicar una expresión de cálculo que, cuando se evalúa, proporciona el resultado de la expresión de cálculo que contiene.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>El miembro de operador de infijo '{0}' tiene argumentos currificados extra. Se esperaba una tupla de 2 argumentos; por ejemplo, el miembro estático (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>No se permite este miembro en una implementación de interfaz.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>El miembro de operador de infijo '{0}' tiene {1} argumentos iniciales. Se esperaba una tupla de 3 argumentos.</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>El atributo FieldOffset sólo se puede colocar en miembros de tipos marcados con StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Un constructor no puede tener parámetros de tipo explícitos. Considere el uso de un método de construcción estático en su lugar.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>La propiedad '{0}' del tipo '{1}' proporcionado tiene el valor CanRead=false, pero GetGetMethod() devolvió un método.</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>En las consultas, '{0}' debe usar un patrón simple.</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Const_bytearray inesperado.</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Expr.TyChoose inesperado.</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Final de entrada inesperado en miembros de objetos.</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>El método "{0}" tiene argumentos currificados, pero tiene el mismo nombre que otro método del tipo "{1}". Los métodos con argumentos currificados no se pueden sobrecargar. Considere la posibilidad de usar un método que tome argumentos en tuplas.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Un {0} ha especificado la versión "{1}", pero este valor no es válido y se ha omitido</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Un parámetro de tipo no se puede usar como constructor de tipo.</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Las variables mutables no pueden escapar de su método.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Las declaraciones de medida solo pueden tener miembros estáticos.</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Normalmente, el operador '{0}' no se debe redefinir. Considere el uso de un nombre de operador diferente.</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>El valor '{0}' de tipo byref no se puede usar en este punto.</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>No se encontró el directorio de búsqueda '{0}'.</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Esta construcción es ambigua como parte de una expresión de cómputo. Las expresiones anidadas se pueden escribir usando 'let _ = (...)' y los cómputos anidados usando 'let! res = builder {{ ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura define el {2} "{3}" pero la implementación no (o sí lo define pero en otro orden)</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Nombre completo</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Mensajes de salida con rutas de acceso completas</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el campo {2} estaba presente en la implementación pero no en la signatura</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>No copiar FSharp.Core.dll con los archivos binarios producidos</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Una construcción genérica requiere que '{0}' sea un tipo no administrado.</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene una implementación explícita de 'Object.Equals'. Considere implementar una invalidación coincidente para 'Object.GetHashCode()'.</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Las declaraciones de tipos explícitos para constructores deben tener el formato 'ty1 * ... * tyN -&gt; resTy'. Pueden ser necesarios paréntesis en 'resTy'.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Se usa para indicar que una función es recursiva.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Se usa en una signatura para indicar un valor o en un tipo para declarar un miembro, en situaciones muy concretas.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Se usa en lugar de let para los valores que requieren que se llame a Dispose para liberar recursos.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Se usa para incluir un bloque de código que puede generar una excepción. Se usa junto con with o finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Se usa para declarar, definir o invocar un constructor que crea o que puede crear un objeto. También se usa en las restricciones de parámetro genérico para indicar que un tipo debe tener un constructor determinado.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>No es una palabra clave propiamente dicha. Sin embargo, se usa la combinación not struct como restricción de parámetro genérico.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Se usa para asociar o enlazar un nombre a un valor o una función.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Se usa en expresiones lambda, que también se conocen como funciones anónimas.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Se usa en construcciones de bucle.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>En las definiciones de tipo y extensiones de tipo, indica el final de una sección de definiciones de miembro. En la sintaxis detallada, se usa para especificar el final de un bloque de código que comienza con la palabra clave begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>El captador y el establecedor de una propiedad deben tener el mismo tipo. La propiedad '{0}' tiene un captador de tipo '{1}', pero el establecedor es de tipo '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>El número de argumentos de tipo no coincide. Argumentos proporcionados: '{0}'; se esperaban: '{1}'. Esto puede estar relacionado con un error notificado anteriormente.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Este campo requiere un nombre.</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>tipo generado</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Cadena de versión '{0}' no válida.</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Aquí no se pueden especificar argumentos de tipo.</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros nativos firmados.</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Esta prueba de tipo o conversión hacia abajo borrará el tipo '{0}' proporcionado para el tipo '{1}'.</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Las declaraciones 'inherit' no pueden tener enlaces 'as'. Para obtener acceso a los miembros de la clase base al invalidar un método, se puede usar la sintaxis 'base.SomeMember'; 'base' es una palabra clave. Quite este enlace 'as'.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Se usa para declarar un delegado.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>No se encontró el constructor de objeto o método '{0}'.</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Ancho incorrecto en especificador de formato.</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Los tipos con el atributo 'AllowNullLiteral' pueden implementar o se pueden heredar solo de tipos que también permitan el uso del literal null.</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Un inicializador estático require un argumento.</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Error de sintaxis: símbolo '?' inesperado</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Uso no válido de un tipo de interfaz.</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Patrones sucesivos deben separarse con espacios u organizarse en tuplas.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>La signatura necesaria es {0}.</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit no salió.</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Los condicionales de optimización estáticos son solo para usarlos en la biblioteca de F#.</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Todos los elementos de una expresión de constructor de matriz deben tener el mismo tipo. Se esperaba que esta expresión tuviera el tipo "{0}", pero aquí tiene el tipo "{1}".</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>El parámetro de tipo declarado '{0}' no se puede usar aquí porque no se puede resolver en tiempo de compilación.</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' no es un nombre de ensamblado válido.</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Este no es un nombre válido para un patrón activo.</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>La expresión "if" no tiene una rama "else". La rama "then" tiene el tipo '{0}'. Dado que "if" es una expresión y no una instrucción, agregue una rama "else" que devuelva un valor del mismo tipo.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Final de entrada inesperado en la signatura de tipo.</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Método duplicado. El método "{0}" tiene el mismo nombre y la misma signatura que otro método del tipo "{1}".</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Este método está sobrerrestringido en sus parámetros de tipo.</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Falta la variable '{0}'.</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en tipos de código de ensamblado alineado.</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Las definiciones reflejadas no pueden contener usos del operador de inserción de prefijo '%'.</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>No se pueden usar unidades de medida como argumentos de prefijo para un tipo. Escríbalo de nuevo con argumentos de postfijo entre paréntesis angulares.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Las restricciones 'struct' y 'not struct' son incoherentes.</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Este patrón de literal no toma argumentos.</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Sintaxis de declaración no válida.</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Ninguno de los tipos '{0}' admite el operador '{1}'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Los tipos de delegado están siempre sellados.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Se esperaba una expresión después de este punto.</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>El tipo '{0}' es menos accesible que el valor, miembro o tipo '{1}' en el que se usa.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Generar un ensamblado determinista (con el GUID y la marca de tiempo de la versión del módulo)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Valor devuelto 'null' inesperado del tipo '{0}' proporcionado, miembro '{1}'.</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>No se encontró Dispose en IDisposable, o estaba sobrecargado.</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Configuración de privacidad '{0}' no reconocida para un recurso administrado. Las opciones válidas son 'public' y 'private'.</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>No se pudo insertar un valor marcado como 'inline'.</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Una construcción genérica requiere que el tipo '{0}' tenga un constructor predeterminado público.</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} no es un miembro de instancia.</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener este tipo de constante.</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>El proveedor de tipos '{0}' usó un parámetro no válido en ParameterExpression: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>El miembro genérico '{0}' se ha usado en una creación de instancia no uniforme anterior a este punto del programa. Considere reordenar los miembros para que este miembro esté en primer lugar. También puede especificar el tipo completo del miembro de forma explícita, incluidos los tipos de argumento, el tipo de valor devuelto y posibles restricciones y parámetros genéricos adicionales.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Un tipo almacenaría un valor de tipo byref. Esto no se permite en Common IL.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>No se especificaron archivos de implementación.</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLas marcas insertadas difieren.</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Nombre de espacio de nombres, módulo, tipo o caso de unión no válido.</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Las abreviaciones de tipo no pueden tener miembros.</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>La palabra clave 'rec' en este módulo se da por supuesta en una declaración 'rec' externa y se omitirá</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Este tipo no es un tipo de registro. Los valores de clase y los tipos de struct deben crearse usando llamadas a constructores de objeto.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Se espera un tipo que admita el operador '{0}', pero se ha proporcionado un tipo de función. Quizá falta un argumento en una función.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Los espacios de nombres no pueden contener valores. Considere el uso de un módulo para albergar las declaraciones de valor.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>No se encontraron métodos Invoke para el tipo de delegado.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Condicional incompleto. Se esperaba 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Una operación personalizada no se puede usar junto con los operadores 'use', 'try/with', 'try/finally', 'if/then/else' o 'match' dentro de esta expresión de cómputo.</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>El atributo 'StructuralComparison' debe usarse junto con el atributo 'StructuralEquality'.</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Uso no válido de la palabra clave 'rec'</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Las enumeraciones no pueden tener miembros.</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>La etiqueta de registro o el espacio de nombres "{0}" no está definido.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener usos de expresiones genéricas.</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>La opción de la línea de comandos '{0}' está en desuso.</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Se usa en flujos de trabajo asincrónicos para enlazar un nombre al resultado de un cálculo asincrónico o, en otras expresiones de cálculo, se usa para enlazar un nombre a un resultado, que es del tipo de cálculo.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Llamadas</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else no tiene el correspondiente #if.</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Úselo para invalidar cuando el compilador busque mscorlib.dll y componentes del marco de trabajo.</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' toma {1} argumentos de tipo, pero aquí se le proporcionan {2}. La signatura necesaria es '{3}'.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" no se encuentra en el ensamblado "{2}". La razón puede ser una incompatibilidad de versiones. Es posible que tenga que hacer referencia explícitamente a la versión correcta de este ensamblado para permitir que todos los componentes a los que se hace referencia usen la versión correspondiente.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Sintaxis no válida en expresión de tipo.</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para este tipo de entero.</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>El patrón activo '{0}' no es una función</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>La propiedad "{0}" de tipo "{1}" tiene un captador y un establecedor que no coinciden. Si uno es abstracto, el otro debe serlo también.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>En las consultas, use el formato 'for x in n .. m do ...' para abarcar los enteros.</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>El final del archivo en la cadena de comillas triples comenzaba aquí o antes</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Final de entrada inesperado en una definición de miembro, función o valor.</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>El constructor de objeto "{0}" toma {1} argumentos, pero aquí se le dan {2}. La signatura necesaria es "{3}". Si algunos de los argumentos son para asignar valores a propiedades, considere separarlos con una coma (",").</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' se debe aplicar a un argumento de tipo '{1}', pero se ha aplicado a un argumento de tipo '{2}'</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>No se puede crear una extensión de un tipo sellado.</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>No se encontró un 'in' correspondiente a este 'let'.</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>El atributo de visibilidad "{0}" no se permite en la abreviación de módulo. Las abreviaciones de módulo son siempre privadas.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Normalmente, un tipo con el atributo 'NoComparison' no debe tener una implementación explícita de 'System.IComparable', 'System.IComparable&lt;_&gt;' o 'System.Collections.IStructuralComparable'. Deshabilite esta advertencia si esto es intencionado con fines de interoperabilidad.</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Esta construcción se puede usar solo en expresiones de cómputo. Para devolver un valor desde una función ordinaria, simplemente escriba la expresión sin 'return'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Las definiciones de propiedades no se pueden declarar como mutables. Para indicar que esta propiedad se puede establecer, use 'member val PropertyName = expr with get,set'.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- AVANZADAS -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLos modificadores 'static' difieren.</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>forma compilada del caso de unión</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Error de resolución de ensamblado en esta ubicación o cerca de ella.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el orden de los campos es diferente en la signatura y la implementación</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>No se permiten miembros abstractos en un aumento; deben definirse como parte del propio tipo.</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Final de entrada inesperado en la bifurcación 'then' de la expresión condicional. Se esperaba 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Final de entrada inesperado en la expresión 'match' o 'try'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Final de entrada inesperado en la bifurcación 'else' de la expresión condicional. Se esperaba 'if &lt;expr&gt; then &lt;expr&gt;' o 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>No se pueden proporcionar argumentos cuando se construye un valor de registro.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Los identificadores que contienen '@' está reservados para usarlos en la generación de código de F#.</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Aquí no se puede usar esta búsqueda.</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Los miembros que extienden tipos de interfaz, delegado o enumeración deben ponerse en un módulo separado de la definición del tipo. Este módulo debe tener el atributo AutoOpen, o bien código de cliente debe abrirlo de forma explícita para traer los miembros de extensión dentro del ámbito.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>No se pueden proporcionar implementaciones de interfaz en expresiones de construcción.</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Este código no es lo suficientemente genérico. La variable de tipo {0} no se pudo generalizar porque escaparía de su ámbito.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>El final del archivo en la sección IF-OCAML comenzaba aquí o antes.</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>El atributo 'AbstractClass' se puede dar sólo a clases.</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void' se puede usar sólo como 'typeof&lt;System.Void&gt;' en F#.</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>La sintaxis '(typ,...,typ) ident' no se usa en el código de F#. Considere el uso de 'ident&lt;typ,...,typ&gt;' en su lugar.</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Los tipos de struct no pueden contener miembros abstractos.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Este nuevo miembro oculta el miembro abstracto '{0}' una vez borradas las tuplas, funciones, unidades de medida y/o los tipos proporcionados. Cambie el nombre del miembro o use 'override' en su lugar.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Descodificación inesperada de InterfaceDataVersionAttribute.</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Los tokens '|' que separan reglas de esta detección de patrones están desalineados en una columna. Considere realinear el código o usar más sangría.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero la signatura especifica\n    {2}    \nNo se infirió una aridad para este valor.</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Especificación de propiedad de nivel de código fuente inesperada en árbol de sintaxis.</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Se han proporcionado valores a unos campos extraños.</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Se usa para realizar la conversión a un tipo situado en un nivel inferior de la cadena de herencia.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nSe requiere un tipo de tupla para uno o varios argumentos. Considere la posibilidad de incluir los argumentos dados entre paréntesis adicionales o revise la definición de la interfaz.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Constante racional grande inesperada.</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Formato de imagen incorrecto</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Se encontró un espacio de nombres vacío desde el proveedor de tipos '{0}'. Use 'null' para el espacio de nombres global.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>El módulo contiene el constructor\n    {0}    \npero su signatura especifica\n    {1}    \nLos nombres difieren.</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>Variable {0} de la colección {1} (outerKey = innerKey). Tenga en cuenta que, después de "{2}", se requieren paréntesis.</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>Se esperaba 'in' o '='.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Descodificación inesperada de InternalsVisibleToAttribute.</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Expresión de preprocesador incompleta</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: retrasado</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>No se permite una referencia directa al tipo '{0}' generado. En su lugar, use una definición de tipo, por ejemplo, "type TypeAlias = &lt;rutaAcceso&gt;". Esto indica que un proveedor de tipos agrega tipos generados al ensamblado.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Error de sintaxis. #endif anidado incorrecto, se esperaban tokens delante de él.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Habilitar advertencias específicas que pueden estar desactivadas de forma predeterminada</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} es un modelo activo y no se puede tratar como un caso de unión discriminada con campos con nombre.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Los tipos de registro están siempre sellados.</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Signatura no válida para un miembro set.</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>Las expresiones 'while' no se pueden usar en las consultas.</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Este no es un literal de carácter válido.</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Los valores devueltos no pueden tener nombre.</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>No se puede heredar de un tipo proporcionado borrado.</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>El proveedor '{0}' devolvió un tipo '{1}' no generado en el contexto de un conjunto de tipos generados. Considere ajustar el proveedor de tipos para que devuelva solamente tipos generados.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Una restricción 'enum' debe tener el formato 'enum&lt;tipo&gt;'.</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es abstracto y el otro no.</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>El nombre '({0})' no debe usarse como un nombre de miembro. Para definir semántica de igualdad para un tipo, invalide el miembro 'Object.Equals'. Si define un miembro estático para usarlo desde otros lenguajes CLI, use el nombre '{1}' en su lugar.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para literales decimales.</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>Error al leer los metadatos de F# del ensamblado "{0}". Se usó una construcción reservada. Puede que tenga que actualizar el compilador de F# o usar una versión anterior del ensamblado que no utilice una construcción específica.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Hay demasiados parámetros estáticos. Se esperaba un máximo de {0} parámetros, pero se obtuvieron {1} parámetros sin nombre y {2} con nombre.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Después de una declaración 'namespace' no puede haber un símbolo '='.</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Los tipos System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate y System.Array no se pueden usar como tipos superiores en una clase o expresión de objeto.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Este archivo contiene varias declaraciones con el formato 'module SomeNamespace.SomeModule'. Solo se permite una declaración con este formato en un archivo. Cambie el archivo para usar una declaración de espacio de nombres inicial o use 'module ModuleName = ...' para definir los módulos.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>No se puede heredar de un tipo de interfaz. Use 'interface ... with' en su lugar.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Habilitar o deshabilitar optimizaciones entre módulos</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLa accesibilidad especificada en la signatura es superior a la especificada en la implementación.</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Se usa en las expresiones de consulta para especificar los campos o columnas que se van a extraer. Tenga en cuenta que es una palabra clave contextual, es decir, no es una palabra reservada en realidad y actúa solo como palabra clave en el contexto adecuado.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>La dirección del campo '{0}' no se puede usar en este punto.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>No se pudo resolver la ambigüedad en el uso de una construcción genérica con una restricción 'unmanaged' en esta posición o cerca de ella.</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Esta definición de tipo no puede tener el atributo 'CLIMutable'. Solamente los tipos de registro pueden tener este atributo.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros firmados de 64 bits.</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en campos de enumeración.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el número de {2}s difiere.</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Extensión de tipo no válida.</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problema con el nombre de archivo '{0}': {1}.</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif requerido por #else.</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Se usa para declarar un tipo de estructura y también en las restricciones de parámetro genérico. Además, se usa en las definiciones de módulo por motivos de compatibilidad con OCaml.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Se usa para indicar un método o una propiedad que se puede invocar sin ninguna instancia de un tipo, o un miembro de valor que comparten todas las instancias de un tipo.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>El atributo 'EntryPointAttribute' se puede usar sólo en definiciones de función en módulos.</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>El valor predeterminado no tiene el mismo tipo que el argumento. El atributo DefaultParameterValue y los atributos Optional se omitirán. Nota: Debe anotarse el tipo correcto en "null". Por ejemplo, "DefaultParameterValue(null:obj)".</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Creación de instancia genérica incorrecta. Ningún miembro de {0} con el nombre '{1}' toma {2} argumentos genéricos.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Los espacios de nombres no pueden contener miembros de extensión, excepto en el mismo archivo y grupo de declaración del espacio de nombres donde se define el tipo. Considere la posibilidad de usar un módulo para albergar declaraciones de miembros de extensión.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Se usa para indicar un valor que se va a proporcionar como resultado de una expresión de cálculo.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>El valor '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>La sangría de este token 'in' es incorrecta con respecto al 'let' correspondiente.</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Aquí se requiere el tipo '{0}' y no está disponible. Debe agregar una referencia al ensamblado '{1}'.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>El operador '{0}' no acepta el uso de 'into'.</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} no es un miembro estático.</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>No se permiten variables de tipo anónimo en esta declaración.</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Este registro contiene campos de tipos incoherentes.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>Los enlaces 'let' y 'do' deben preceder a las definiciones de miembro e interfaz en las definiciones de tipo.</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Las directivas dentro de módulos se omiten.</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros firmados de 16 bits.</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problema con la página de códigos '{0}': {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Las expresiones de atributo deben ser llamadas a constructores de objeto.</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>A un constructor delegado sólo debe pasársele un único valor de función.</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Este indizador espera {0} argumentos pero aquí se le proporcionan {1}.</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>La expresión "if" debe tener el tipo "{0}" para cumplir con los requisitos del tipo de contexto. Actualmente tiene el tipo "{1}".</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>A los tipos abreviados no se les puede dar el atributo 'Sealed'.</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Habilitar optimizaciones (forma corta: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Esta invalidación toma un número diferente de argumentos para el miembro abstracto correspondiente. Se han encontrado los siguientes miembros abstractos: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'[' desemparejado.</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Un valor literal no se puede marcar como 'inline'.</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>El atributo 'NoEquality' debe usarse junto con el atributo 'NoComparison'.</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que requieran punteros byref.</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Barra / inesperada en el tipo.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Los tipos de código de ensamblado están siempre sellados.</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>No se especificaron entradas</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Las constantes distintas de cero no pueden tener unidades genéricas. Para un cero genérico, escriba 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Captador o establecedor de propiedad no válido.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura declara un {2} mientras la implementación declara un {3}</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>No se permite el carácter '{0}' en el nombre de espacio de nombres '{1}' proporcionado.</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Directiva no válida. Se esperaba '#I \"&lt;ruta de acceso&gt;\"'.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros no firmados de 32 bits.</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>La propiedad "{0}" tiene el mismo nombre que un método del tipo "{1}".</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>evento</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>campo</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Los valores definidos de forma recursiva no pueden aparecer directamente como parte de la construcción de un valor de tupla en un enlace recursivo.</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>La opción de la línea de comandos '{0}' está en desuso. La generación de documentos HTML forma parte ahora de F# Power Pack, a través de la herramienta FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>No se permiten atributos en enlaces 'let' en expresiones.</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nEl recuento de parámetros de tipo respectivos difieren.</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Este miembro no es lo suficientemente genérico.</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Se usa como literal booleano.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener bucles for descendentes.</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Dirección base para la biblioteca que se compilará</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problema al leer el ensamblado '{0}': {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>El tipo '{0}' proporcionado devolvió un miembro NULL.</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Se encontró una referencia al tipo '{0}' en el ensamblado '{1}', pero no se encontró el tipo en ese ensamblado.</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Se ha usado un parámetro de tipo genérico que lo restringe a ser siempre '{0}'.</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno está marcado como invalidación y el otro no.</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Se esperaban {0} expresiones y se obtuvieron {1}.</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Uno o varios parámetros de tipo declarados para esta extensión de tipo tienen una restricción de tipo ausente o errónea que no coincide con las restricciones de tipo original en "{0}"</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Al menos una invalidación no implementó correctamente su correspondiente miembro abstracto.</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Se omitió el atributo 'AssemblyVersionAttribute' porque se proporcionó una versión con una opción de la línea de comandos.</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>El atributo 'DefaultValue' se puede usar sólo en declaraciones 'val'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Los tipos de struct están siempre sellados.</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Los tipos no pueden heredarse de varios tipos concretos.</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Argumentos de tipo inesperados.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura requiere que el tipo admita la interfaz {2}, pero esta interfaz no se ha implementado</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GENERACIÓN DE CÓDIGO -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Const_uint16array inesperado.</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>El miembro '{0}' se usa de forma no válida. Se ha inferido un uso de '{1}' antes que la definición de '{2}', que es una referencia adelantada no válida.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>es</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Este atributo no se puede usar en esta versión de F#.</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>No se permiten atributos en patrones.</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>No se puede invalidar el miembro heredado '{0}' porque es sealed.</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Este tipo no tiene tipos anidados.</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>El nombre de archivo '{0}' contiene el carácter '{1}' no válido.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>El campo, constructor o miembro "{0}" no está definido.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Los términos [&lt;ReflectedDefinition&gt;] no pueden contener usos del operador de inserción de prefijo '%'</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Incoherencia de longitud de creación de instancia de tipo.</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Una propiedad de establecedor puede tener como máximo dos grupos de argumentos.</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Deshabilitar mensajes de advertencia específicos</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Suprimir el mensaje de copyright del compilador</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>El tipo '{0}' se ha marcado como que tiene un diseño explícito, pero el campo '{1}' no se ha marcado con el atributo 'FieldOffset'.</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLos tipos difieren.</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>No se permiten usos de primera clase del operador de inserción de expresión.</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Esta conversión a tipo heredado borrará el tipo '{0}' proporcionado para el tipo '{1}'.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>El tipo {0} contiene el miembro "{1}", pero no es un método virtual o abstracto que esté disponible para invalidarlo o implementarlo.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>El atributo '{0}' aparece tanto en la implementación como en la signatura, pero los argumentos de atributo difieren. Solo se incluirá el atributo de la signatura en el código compilado.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>El operador '{0}' no se puede resolver. Considere abrir el módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Opción no reconocida: '{0}'.</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>extensión</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque el campo '{0}' estaba presente en la implementación pero no en la signatura. El módulo contiene la definición de excepción\n    {1}    \npero su signatura especifica\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>El tipo '{0}' tiene un método '{1}' (nombre completo '{2}'), pero el método no es estático.</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Las llamadas a 'reraise' se pueden realizar solo directamente en un controlador de un bloque try-with.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Los tipos de enumeración están siempre sellados.</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Los tipos de argumento no coinciden.</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>La 'l' o 'L' en este especificador de formato es innecesaria. En el código de F#, puede usar %d, %x, %o o %u, que se sobrecargan para funcionar con todos los tipos de entero básicos.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Permite el acceso a un miembro desde fuera del tipo.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>El tipo '{0}' no tiene 'null' como un valor apropiado. Para crear un valor NULL para un tipo que acepta valores NULL, use 'System.Nullable()'.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>ValValue {0} recursivo</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>El tipo '{0}' no es válido porque T no puede contener tipos byref en byref&lt;T&gt;.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Definir símbolos de compilación condicionales (forma corta: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>No se permiten atributos en declaraciones 'inherit'.</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>La propiedad '{0}' del tipo '{1}' proporcionado tiene el valor CanWrite=true, pero no se encontró ningún valor de GetSetMethod().</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque las declaraciones de excepción difieren. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>No se encontró FSharp.Core.sigdata junto con FSharp.Core. Archivo esperado en {0}. Considere la posibilidad de actualizar a una versión más reciente de FSharp.Core en la que ya no se requiere el archivo.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Se esperaba un comentario de una sola línea o un final de línea</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>El proveedor de tipos devolvió 'null', que no es un valor devuelto válido de '{0}'.</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>La directiva #if debe ir seguida inmediatamente por un identificador.</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>No se proporcionó ninguna implementación para '{0}'. Tenga en cuenta que todos los miembros de interfaz deben implementarse y enumerarse en la correspondiente declaración 'interface'; por ejemplo, 'interface ... with member ...'.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>El bloque que sigue a este objeto '{0}' está sin finalizar. Cada bloque de código es una expresión y debe tener un resultado. '{1}' no puede ser el elemento de código final en un bloque. Considere la posibilidad de asignar a este bloque un resultado explícito.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Final de entrada inesperado en la expresión 'while'. Se esperaba 'while &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Las definiciones de medida no pueden tener parámetros de tipo.</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>El archivo DLL '{0}' compilado por F# debe recompilarse para poder usarlo con esta versión de F#.</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Final de entrada inesperado en una expresión 'match'. Se esperaba 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Los tipos de interfaz y los tipos de delegado no pueden contener campos.</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Las extensiones de archivo '.ml' y '.mli' son para la compatibilidad con ML.</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>espacio de nombres</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' requiere {1} argumentos. La signatura necesaria es '{2}'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Las declaraciones de medida solo pueden tener miembros estáticos: no hay constructores disponibles.</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Las interfaces no pueden contener definiciones de inicializadores estáticos.</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>No se permiten funciones genéricas internas en expresiones entre comillas. Considere agregar restricciones de tipo hasta que esta función deje de ser genérica.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Argumento --test desconocido: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problema de inferencia de tipos demasiado complicado (se alcanzó la profundidad de iteración máxima). Considere agregar más anotaciones de tipo.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>El valor, espacio de nombres, tipo o módulo "{0}" no está definido.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>El módulo contiene el constructor\n    {0}    \npero su signatura especifica\n    {1}    \nEl número respectivo de campos de datos difiere.</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Los structs no pueden contener enlaces 'do' porque el constructor predeterminado para structs no ejecutaría estos enlaces.</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Se usa para realizar la conversión a un tipo situado en un nivel superior de la cadena de herencia.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>Variable {0} de la colección {1} (outerKey = innerKey) en el grupo. Tenga en cuenta que, después de "{2}", se requieren paréntesis.</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>El constructor de inicialización cero predeterminado de un tipo struct solo se puede usar si todos los campos del tipo struct admiten inicialización predeterminada.</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>A los tipos genéricos no se les puede dar el atributo 'StructLayout'.</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Un constructor de objeto explícito debe usar la sintaxis 'new(args) = expr'.</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Delimita una expresión de código sin tipo.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Los structs no pueden contener definiciones de valor porque el constructor predeterminado para structs no ejecutará estos enlaces. Considere agregar argumentos adicionales al constructor principal para el tipo.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros firmados de 8 bits.</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Miembro '{0}' no válido en el tipo '{1}' proporcionado. Solamente se admiten propiedades, métodos y constructores.</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>No se proporcionó ninguna asignación para el campo '{0}' de tipo '{1}'.</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>El tipo '{0}' no admite el operador '{1}'.</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>La dirección del campo estático '{0}' no se puede usar en este punto.</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Esta declaración abre el espacio de nombres o modelo '{0}' a través de una ruta de acceso parcial. Ajuste este código para usar la ruta de acceso completa del espacio de nombres. Este cambio hará que el código sea más sólido conforme se agreguen nuevas construcciones a las bibliotecas de F# y CLI.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!' no se puede usar en expresiones de secuencia.</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Ya se ha proporcionado una implementación del archivo o módulo '{0}'. El orden de compilación es importante en F# debido a la inferencia de tipos. Puede ser necesario ajustar el orden de los archivos para poner el archivo de signatura antes de la implementación. En Visual Studio, el tipo de los archivos se comprueba en el orden en que aparecen en el archivo del proyecto, que se puede editar manualmente o ajustarse con el Explorador de soluciones.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>espacio de nombres no válido para el tipo proporcionado</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Esta definición de tipo implica una referencia cíclica inmediata a través de un campo de struct o una relación de herencia.</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Este valor no es un literal y no se puede usar en un patrón.</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>A cada argumento del constructor principal de un struct debe proporcionársele un tipo; por ejemplo, 'type S(x1:int, x2: int) = ...'. Estos argumentos determinan los campos del struct.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Los valores mutables no pueden tener parámetros genéricos.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>No se pudo resolver la ambigüedad en el uso de una construcción genérica con una restricción 'delegate' en esta posición o cerca de ella.</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Las especificaciones de delegado deben tener el formato 'typ -&gt; typ'.</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute no se puede aplicar a un miembro de instancia en un tipo struct porque dicho miembro toma un parámetro byref 'this' implícito.</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>Se requiere 'get' y/o 'set'.</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' no admite la marca de prefijo '{1}'.</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Este parámetro de tipo se ha usado de forma que lo restringe a ser siempre '{0}'.</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>No se pueden dar argumentos con nombre a llamadas de cola de miembro.</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>La versión de .NET Framework especificada "{0}" no se admite. Especifique un valor de la enumeración Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Una declaración puede ser solo el atributo [&lt;Literal&gt;] si se proporciona también un valor constante; por ejemplo, 'val x : int = 1'.</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>No se reconoce la extensión de archivo de '{0}'. Los archivos de código fuente deben tener la extensión .fs, .fsi, .fsx, .fsscript, .ml o .mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Esta declaración 'inherit' especifica el tipo heredado pero no argumentos. Considere proporcionar argumentos; por ejemplo, 'inherit BaseType(args)'.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Nombre del archivo de depuración de salida</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Especifique un directorio para la ruta de acceso de inclusión que se usa para resolver los ensamblados y archivos de código fuente (forma corta: -I).</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Imprimir la interfaz inferida del ensamblado en un archivo</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Compilar un módulo que se pueda agregar a otro ensamblado</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>El carácter '|' no se permite en identificadores de modelo activo</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en este miembro. Las ranuras abstractas tienen siempre la misma visibilidad que el tipo envolvente.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>El carácter ";" se usa para separar los valores de los campos en los registros. Considere la posibilidad de reemplazar "," por ";".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>No se pudo resolver la ambigüedad inherente en el uso del operador '{0}' en este punto del programa o cerca de él. Considere el uso de anotaciones de tipo para resolver la ambigüedad.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>El tipo "{0}" no está definido.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Se usa para indicar una función que debe integrarse directamente en el código de llamada.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Este no es un nombre válido para un caso de enumeración.</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Este miembro de instancia necesita un parámetro para representar el objeto que se va a invocar. Convierta el miembro en estático o use la notación 'member x.Member(args) = ...'.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>No existe ningún parámetro estático con el nombre '{0}'.</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Normalmente, un tipo con el atributo 'NoEquality' no debe tener una implementación explícita de 'Object.Equals(obj)'. Deshabilite esta advertencia si esto es intencionado con fines de interoperabilidad.</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>El valor se ha copiado para garantizar que esta operación no mute el original.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>No se pudieron generalizar una o varias de las variables de clase explícita o de tipo de función para este enlace, porque estaban restringidas a otros tipos.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Candidatos: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>'with' desemparejado o bloque 'with' mal formado.</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Todas las ramas de una expresión de constructor de lista deben tener el mismo tipo. Se esperaba que esta expresión tuviera el tipo "{0}", pero aquí tiene el tipo "{1}".</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>No se pueden usar especificaciones de tipo explícitas para constructores de excepciones.</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>El tipo de registro del campo de registro "{0}" se definió con el atributo RequireQualifiedAccessAttribute. Incluya el nombre del tipo de registro ("{1}") en el nombre que esté usando.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>El argumento de formato correspondiente no es opcional.</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Valor no válido</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>Los nombres de argumento de la signatura "{0}" y de la implementación "{1}" no coinciden. Se usará el nombre de argumento del archivo de signatura. Esto puede causar problemas durante la depuración o la generación de perfiles.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>El valor '{0}' no se usa.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>La opción requiere el parámetro: {0}.</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Declaración no válida.</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros nativos no firmados.</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>El discriminador de patrones "{0}" no está definido.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Final de entrada inesperado.</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Hay dos módulos con el nombre '{0}' en dos partes de este ensamblado.</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Se encontró más de un método Invoke para el tipo de delegado.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Este valor no es una función y no se puede aplicar. ¿Pretendía tener acceso al indizador a través de {0}.[index] en su lugar?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Se ha inferido que el parámetro '{0}' tiene el tipo byref. A los parámetros de tipo byref se les debe dar una anotación de tipo explícita; por ejemplo, 'x1: byref&lt;int&gt;'. Cuando se usa un parámetro byref, se desreferencia de forma implícita.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Este miembro estático no debería tener un parámetro 'this'. Considere el uso de la notación 'member Member(args) = ...'.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Una construcción genérica requiere que el tipo '{0}' no sea abstracto.</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Incluir solo información de optimización esencial para implementar construcciones inline. Inhibe la inserción entre módulos pero mejora la compatibilidad binaria.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>La signatura oculta la representación de este tipo. Debe proporcionársele un atributo como [&lt;Sealed&gt;], [&lt;Class&gt;] o [&lt;Interface&gt;] para indicar las características del tipo.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>El formato '{0}' no admite la marca '0'.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>La inferencia de tipos provocó que la variable de tipo {0} saliera de su alcance. Considere agregar una declaración de parámetros de tipo explícitos o ajuste el código para que sea menos genérico.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Especifique el tipo de depuración: full, portable, embedded, pdbonly. ('{0}' es el valor predeterminado si no se especifica ningún tipo de depuración y permite conectar un depurador a un programa en ejecución, 'portable' es un formato multiplataforma, 'embedded' es un formato multiplataforma insertado en el archivo de salida).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Solo las directivas de compilador '#' pueden tener lugar antes de la primera declaración 'namespace'.</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>No se encontró el valor local {0} durante la optimización.</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>El proveedor de tipos '{0}' proporcionó un método con un nombre '{1}' y el token de metadatos '{2}' que no se notifica entre los métodos de su tipo declarativo '{3}'</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Sintaxis incorrecta de '{0}'. Uso: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>número de punto flotante no válido.</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>No se permiten constructores como miembros de extensión. Deben definirse como parte de la definición original del tipo.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>El constructor de objeto "{0}" no tiene ningún argumento ni propiedad de valor devuelto "{1}" que se pueda establecer. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>La plataforma 'anycpu32bitpreferred' solo se puede usar con destinos EXE. Debe usar 'anycpu' en su lugar.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLos nombres difieren.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es estático y el otro no.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el tipo de implementación no está sellado y la signatura implica que lo esté. Considere agregar el atributo [&lt;Sealed&gt;] a la implementación.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>No se puede usar 'try'/'with' en expresiones de secuencia.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el miembro abstracto "{2}" estaba presente en la implementación pero no en la signatura</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene una implementación explícita de 'Object.GetHashCode'. Considere implementar una invalidación coincidente para 'Object.Equals(obj)'.</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Se usa para declarar una propiedad o un método en un tipo de objeto.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Se usa para asociar un nombre a un grupo de tipos, valores y funciones relacionados, a fin de separarlo de forma lógica del resto del código.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos tipos difieren.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque los recuentos de parámetros de tipo respectivos difieren</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Las especificaciones de delegado no deben ser tipos currificados. Use 'typ * ... * typ -&gt; typ' para delegados con varios argumentos y, 'typ -&gt; (typ -&gt; typ)', para delegados que devuelven valores de función.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>El valor '{0}' estaba marcado como inline pero su implementación hace uso de una función interna o privada que no es lo suficientemente accesible.</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>La propiedad '{0}' no es estática.</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Expresión de objeto, secuencia o registro no válida.</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Los parámetros de tipo inferidos para este valor no son estables al borrar las abreviaciones de tipo. Esto se debe al uso de abreviaciones de tipo que colocan o reordenan parámetros de tipo; por ejemplo: \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsidere declarar los parámetros de tipo para este valor de forma explícita; por ejemplo: \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' implementa la interfaz 'System.IStructuralComparable' de forma explícita. Aplique el atributo 'CustomComparison' al tipo.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Error de sintaxis</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Relación de combinación no válida en '{0}'. Se esperaba 'expr &lt;op&gt; expr', donde &lt;op&gt; es =, =?, ?= o ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Los enlaces de campo deben tener el formato 'id = expr;'.</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>El evento '{0}' no es estático.</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>Variable {0} de la colección</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Se usa en una expresión de secuencia a fin de generar un valor para una secuencia.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>Las expresiones 'try/finally' no se pueden usar en las consultas.</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Se recomienda que los objetos que admiten la interfaz IDisposable se creen con la sintaxis "new Type(args)", en lugar de con "Type(args)" o "Type" como valor de función que representa al constructor, para indicar que los recursos pueden ser propiedad del valor generado</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Un valor literal no se puede marcar como 'mutable'.</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Incluye una construcción de bucle.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} no es un método estático.</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>No se permiten atributos en implementaciones de interfaz.</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Este formato de expresión se puede usar sólo en expresiones de secuencia y cómputo.</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que busquen índices de caso de unión.</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>En la sintaxis detallada, indica el inicio de una definición de clase.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>En la sintaxis detallada, indica el inicio de un bloque de código.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>No se pueden dar argumentos a llamadas a constructores de objeto en parámetros de tipo.</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Se usa para crear una rama mediante la comparación de un valor con un patrón.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Condición inesperada en ensamblado importado: no se pudo descodificar el atributo AttributeUsage.</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Este caso de unión no toma argumentos.</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Se usa para hacer referencia al espacio de nombres .NET de nivel superior.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Esta construcción de control se puede usar solo si el generador de expresiones de cómputo define un método '{0}'.</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Producto de medidas implícito después de /.</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Campo proporcionado no válido. Los campos proporcionados de los tipos proporcionados borrados deben ser literales.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Este no es un operador de consulta conocido. Los operadores de consulta son identificadores, como 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' y 'averageBy', que se definen usando los métodos correspondientes en el tipo 'QueryBuilder'.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Ningún miembro o constructor de objeto de {0} con el nombre '{1}' toma {2} argumentos.</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Solo se admiten unidades de medida en los tipos float, float32, decimal y de entero firmado.</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>El campo '{0}' no es estático.</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Los archivos deben comenzar con una declaración de espacio de nombres o de módulo; por ejemplo, 'namespace SomeNamespace.SubNamespace' o 'module SomeNamespace.SomeModule', pero no ambas. Para definir un módulo en un espacio de nombres, use 'module SomeModule = ...'.</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>La signatura de esta función externa contiene parámetros de tipo. Restrinja los tipos de argumento y valor devuelto para indicar los tipos de la función de C correspondiente.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Todas las ramas de una expresión de coincidencia de patrones deben tener el mismo tipo. Se esperaba que esta expresión tuviera el tipo "{0}", pero aquí tiene el tipo "{1}".</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>El método '{0}' está sellado y no se puede invalidar.</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}' desemparejado.</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Este elemento no es una variable, una constante, un reconocedor activo ni un literal.</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Se ha proporcionado un valor al campo '{0}', pero no está presente en el tipo '{1}'.</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que busquen campos estáticos.</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Las definiciones de valores estáticos se pueden usar solo en tipos con un constructor principal. Considere agregar argumentos a la definición de tipo, por ejemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>No se encuentra el destino del código de este atributo, probablemente porque el código que aparece después del atributo está incompleto.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Nombre de módulo o espacio de nombres no válido.</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>operación personalizada</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Se usa para comprobar el código durante la depuración.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Las declaraciones de este archivo se pondrán en un módulo implícito '{0}' basado en el nombre de archivo '{1}'. Sin embargo, este no es un identificador de F# válido; por tanto, el contenido no será accesible desde otros archivos. Considere cambiar el nombre del archivo o agregar una declaración 'module' o 'namespace' al principio del archivo.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>No se pudo abrir el archivo de clave '{0}'.</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener detección de patrones de matriz.</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Un tipo de tupla es una tupla de struct, el otro es una tupla de referencia</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' requiere {1} argumentos adicionales. La signatura necesaria es '{2}'. Algunos nombres de argumentos que faltan son {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' requiere {1} argumentos. La signatura necesaria es '{2}'. Algunos nombres de argumentos que faltan son {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>El constructor de objeto o miembro '{0}' requiere {1} argumentos adicionales. La signatura necesaria es '{2}'.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Definición de valor incompleta. Si se encuentra en una expresión, se debe aplicar sangría al cuerpo de la expresión hasta la misma columna que la palabra clave 'let!'.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Se esperaba un argumento de tipo o estático.</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Se especificaron opciones en conflicto: 'win32manifest' y 'win32res'. Solo se puede usar una de ellas.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Propiedad duplicada. La propiedad "{0}" tiene el mismo nombre y la misma signatura que otra propiedad del tipo "{1}".</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Especifique la referencia cultural del idioma de salida que prefiera (por ejemplo, es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>En expresiones de secuencia, los resultados se generan con 'yield'.</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Especificar un archivo de clave de nombre seguro</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Identificador inesperado: '{0}'.</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Número de línea no válido: '{0}'.</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Aquí no se permiten argumentos opcionales.</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Esta construcción es experimental.</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>No se permiten aumentos en moduleDefns de tipo de delegado.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' no es un argumento de entero válido.</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Cuando se hace referencia de forma explícita a mscorlib.dll o FSharp.Core.dll, debe pasarse también la opción {0}.</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Las anotaciones en captadores y establecedores de propiedad se deben proporcionar después de 'get()' o 'set(v)'; por ejemplo, 'with get() : string = ...'.</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Compilar un archivo ejecutable de Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Nombre del archivo de salida (forma corta: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>El modificador --sourcelink solo se admite cuando se emite un archivo PDB portátil (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>El CallerMemberNameAttribute aplicado al parámetro '{0}' no tendrá ningún efecto. Este se reemplaza por CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Los argumentos estáticos con nombre deben aparecer después de todos los argumentos estáticos sin nombre.</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Compilar un archivo ejecutable de consola</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Todas las interfaces implementadas deben declararse en la declaración inicial del tipo.</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Especificación de propiedad de nivel de código fuente inesperada.</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>No se puede llamar a un miembro base abstracto: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>El atributo 'ConditionalAttribute' se puede usar sólo en miembros.</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Un tipo con el atributo 'CustomComparison' debe tener una implementación explícita de al menos uno de 'System.IComparable' o 'System.Collections.IStructuralComparable'.</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos nombres de miembro CLI difieren.</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>El método implementado por este valor predeterminado es ambiguo.</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# admite rangos de matrices entre 1 y 32. El valor {0} no se permite.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener este tipo de tipo.</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Solo se pueden especificar invalidaciones de miembros abstractos y virtuales en expresiones de objeto.</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Escribir el xmldoc del ensamblado en el archivo dado</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque el campo "{2}" estaba presente en la implementación pero no en la signatura. Los tipos struct deben revelar ahora sus campos en la signatura del tipo, aunque los campos pueden continuar etiquetados como "private" o "internal".</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>El caso de unión '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Solo los tipos de registro, unión, excepción y struct se pueden aumentar con los atributos 'ReferenceEquality', 'StructuralEquality' y 'StructuralComparison'.</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Tamaño de signatura no válido</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Especificar un archivo de manifiesto Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Expresión de indizador no válido.</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>El nombre de tipo no puede estar vacío.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>No se encuentra el archivo de código fuente '{0}'.</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Se esperaba un primario de espacio de nombres o módulo {0}.</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Solo se pueden usar enlaces simples con el formato 'id = expr' en expresiones de construcción.</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Indica que un elemento de programa declarado está definido en otro binario o ensamblado.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Archivo de información de vínculos de origen para insertar en el archivo PDB portátil</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' se puede usar sólo con constructores de objeto.</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Este código es menos genérico que lo indicado en sus anotaciones. Se ha determinado que una unidad de medida especificada con '_' sea '1', es decir, sin dimensión. Considere hacer genérico el código o quitar el uso de '_'.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Esta no es una expresión literal válida. El atributo [&lt;Literal&gt;] se omitirá.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la signatura indica que este tipo puede usar valores NULL como un valor extra pero la implementación no</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>Las expresiones 'try/with' no se pueden usar en las consultas.</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Vincular de forma estática la biblioteca de F# y todos los archivos DLL a los que se hace referencia que dependen de ella en el ensamblado que se va a generar</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>El atributo 'AutoOpen(\"{0}\")' del ensamblado '{1}' no hacía referencia a un módulo o espacio de nombres válido en ese ensamblado y se ha omitido.</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Este campo no es mutable.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque los tipos son de tipo diferente</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Las enumeraciones no pueden tener declaraciones de interfaz.</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Compilar una biblioteca (forma corta: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>No se pudo resolver el ensamblado '{0}'</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Un constructor de objeto o miembro '{0}' que toma {1} argumentos no es accesible desde este lugar del código. Todas las versiones accesibles del método '{2}' toman {3} argumentos.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Forma corta de '{0}'</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Ya se ha agregado una implementación predeterminada de esta interfaz porque no se especificó la implementación explícita de la interfaz en la definición del tipo.</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>El campo denominado '{0}' se usa más de una vez.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Las compilaciones deterministas solo admiten PDB portátiles (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Expresión de objeto no válida. Los objetos sin invalidaciones ni interfaces deben usar el formato de expresión 'new Type(args)' sin llaves.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>desde {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>En una expresión for, se usa al contar en orden inverso.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Este tipo no es un tipo de registro.</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que tomen la dirección de un campo.</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' implementa la interfaz 'System.IComparable' de forma explícita. Debe aplicar el atributo 'CustomComparison' al tipo.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>No se puede usar una expresión if/then/else en las consultas. Considere usar una expresión if/then o bien una expresión de secuencia en su lugar.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Ya se ha asignado un valor al parámetro estático '{0}'.</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Inserta archivos de código fuente específicos en el archivo PDB portátil</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>La variable '{0}' de tipo byref se usa de forma no válida. Los tipos byref no pueden ser capturados por clausuras ni pasados a funciones internas.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>La propiedad '{0}' no se puede establecer.</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Esta propiedad no se puede establecer.</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>No se permiten usos de primera clase de operadores address-of.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es un constructor o propiedad y el otro no.</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Las expresiones de construcción de objeto se pueden usar solo para implementar constructores en tipos de clase.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque la signatura requería el campo '{0}' pero la implementación no lo especificó. El módulo contiene la definición de excepción\n    {1}    \npero su signatura especifica\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Este literal numérico requiere que un módulo '{0}' que define las funciones FromZero, FromOne, FromInt32, FromInt64 y FromString esté en el ámbito.</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>No se pueden definir constructores para este tipo</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" de la signatura y la implementación no son compatibles porque la signatura requería el campo {2} pero la implementación no lo especificó</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Los argumentos opcionales se permiten únicamente en miembros de tipo.</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>Una referencia a un tipo proporcionado no contenía un valor para el parámetro estático '{0}'. Puede que sea necesario recompilar uno o varios de los ensamblados a los que se hace referencia.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Todas las ramas de una expresión "if" deben devolver el mismo tipo. Se esperaba que esta expresión tuviera el tipo "{0}", pero aquí tiene el tipo "{1}".</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Borrado para</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Este valor, tipo o método espera {0} parámetros de tipo, pero se le proporcionaron {1}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque el orden de los campos es diferente en la signatura y en la implementación. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Una operación personalizada no se puede usar junto con un enlace 'let' sin valor o recursivo en otra parte de esta expresión de cómputo.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>El miembro '{0}' no tiene el número correcto de parámetros de tipo de método. La signatura necesaria es '{1}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque una signatura oculta una representación de tipo CLI</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene el atributo 'StructuralComparison', pero el parámetro de tipo '{1}' no satisface la restricción 'comparison'. Considere agregar la restricción 'comparison' al parámetro de tipo.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>El tipo de struct, registro o unión '{0}' tiene el atributo 'StructuralComparison', pero el tipo de componente '{1}' no satisface la restricción 'comparison'.</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>La dirección de la variable '{0}' no se puede usar en este punto.</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>caso de unión</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Caché global de ensamblados</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Interfaz duplicada o redundante.</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Archivo de respuesta no válido: '{0}' ('{1}').</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Los enlaces 'use!' deben tener el formato 'use! &lt;var&gt; = &lt;expr&gt;'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque una signatura oculta una representación de tipo</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Expresión de registro, secuencia o cómputo no válida. Las expresiones de secuencia deben tener el formato 'seq {{ ... }}'.</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>El evento '{0}' del tipo '{1}' proporcionado no tiene ningún valor de GetAddMethod().</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Se usa para declarar e implementar interfaces.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es un miembro de extensión y el otro no.</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Los establecedores de propiedad deben definirse con 'set value = ', 'set idx value = ' o 'set (idx1,...,idxN) value = ... '.</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Argumento no válido para parametrizar una etiqueta de patrón.</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Longitud en bits no válida</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>La directiva #if debe aparecer como el primer carácter que no es un espacio en blanco en una línea.</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Existen varios parámetros estáticos con el nombre '{0}'.</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Los campos volátiles deben marcarse como 'mutable' y no pueden ser ThreadStatic.</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Los tipos devueltos de casos de unión deben ser idénticos al tipo que se va a definir, hasta las abreviaciones.</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en invalidaciones o implementaciones de interfaz.</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>En su lugar, considere el uso de un archivo con la extensión '.ml' o '.mli'.</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Esta propiedad invalida o implementa una propiedad abstracta que no tiene un {0} correspondiente.</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Error del compilador: valor no realizado inesperado.</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Una referencia a un tipo proporcionado tenía un valor '{0}' no válido para un parámetro estático. Puede que sea necesario recompilar uno o varios de los ensamblados a los que se hace referencia.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Las definiciones de excepción no son compatibles porque las abreviaciones de excepción de la signatura y la implementación difieren. El módulo contiene la definición de excepción\n    {0}    \npero su signatura especifica\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Valor de atributo personalizado no válido (no es una constante ni un literal).</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Las abreviaciones de excepciones no deben tener listas de argumentos.</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Esta propiedad tiene un tipo no válido. Las propiedades que toman varios argumentos de indizador deben tener tipos con el formato 'ty1 * ty2 -&gt; ty3'. Las propiedades que devuelven funciones deben tener tipos con el formato '(ty1 -&gt; ty2)'.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Aquí se almacenaría un valor de tipo byref. No se permiten valores byref enlazados a let de nivel superior.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Se han especificado varios atributos de visibilidad para este identificador. Los enlaces 'let' en clases son siempre privados, igual que los enlaces 'let' en expresiones.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener definiciones de función que se infieran o declaren como genéricas. Considere agregar restricciones de tipo para que esta sea una expresión entre comillas válida.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Precisión incorrecta en especificador de formato.</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Este tipo no tiene constructores de objeto accesibles.</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>El tipo '{0}' del proveedor de tipos '{1}' tiene un espacio de nombres vacío. Use 'null' para el espacio de nombres global.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque la implementación indica que este tipo puede usar valores NULL como un valor extra pero la signatura no</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Este constructor de objeto requiere argumentos.</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en una declaración 'inherits'.</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Este tipo requiere una definición.</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>No se pueden establecer campos de literal.</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Se usa en los bucles for para indicar un intervalo.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Se usa con las condiciones booleanas como operador booleano or. Equivale a ||. También se usa en las restricciones de miembro.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Se usa en las uniones discriminadas para indicar el tipo de las categorías de valores, así como en declaraciones de delegado y de excepción.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Se usa en construcciones de creación de ramas condicional.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Se usa para las expresiones de secuencia y, en la sintaxis detallada, para separar las expresiones de los enlaces.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Se usa para asignar un nombre de objeto al objeto de clase actual. También se usa para asignar un nombre a un patrón completo en una coincidencia de patrones.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Se usa en construcciones de bucle o para ejecutar código imperativo.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos atributos de mutabilidad difieren.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Las abreviaciones para tipos de excepción de Common IL deben tener un constructor de objeto coincidente.</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Este literal numérico no es válido. Entre los literales numéricos válidos se incluyen 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal) y 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>El atributo 'CustomEquality' debe usarse junto con los atributos 'NoComparison' o 'CustomComparison'.</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Una propiedad de captador puede tener un grupo de argumentos como máximo.</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Esta declaración de miembro, función o valor no se puede declarar como 'inline'.</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Operador de prefijo no válido</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>No se espera un punto y coma en este punto.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' no se usa correctamente. Uso: {1}. Esta es una operación personalizada de esta expresión de consulta o cómputo.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>La invalidación de '{0}' era ambigua.</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Especificar un contenedor de claves de nombre seguro</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Se ha usado el operador 'expr.[idx]' en un objeto de tipo indeterminado basado en información anterior a este punto del programa. Considere agregar más restricciones de tipo.</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ERRORES Y ADVERTENCIAS -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Resolver las referencias de ensamblado con reglas basadas en directorio en lugar de la resolución de MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Método duplicado. El método abstracto '{0}' tiene el mismo nombre y la misma signatura que un método abstracto en un tipo heredado una vez borradas las tuplas, funciones, unidades de medida y/o los tipos proporcionados.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>No se puede usar una unidad de medida en una aplicación de constructor de tipo.</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Las expresiones de construcción de objeto (es decir, expresiones de registro con especificaciones de herencia) se pueden usar solo para implementar constructores en tipos de modelo de objeto. Use 'new ObjectType(args)' para construir instancias de tipos de modelo de objeto fuera de los constructores.</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' no se permite como carácter en nombres de operador y está reservado para uso futuro.</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>Las expresiones 'use' no se pueden usar en las consultas.</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>El tipo '{0}' no es un tipo cuyos valores se puedan enumerar con esta sintaxis, es decir, no es compatible con seq&lt;_&gt;, IEnumerable&lt;_&gt; o IEnumerable y no tiene un método GetEnumerator.</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Identificador largo vacío inesperado.</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Directiva no válida. Se esperaba '#r \"&lt;archivo-o-ensamblado&gt;\"'.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>La inferencia de tipos provocó que una variable de tipo de inferencia saliera de su alcance. Considere agregar las anotaciones de tipo para que el código sea menos genérico.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>El tipo '{0}' no admite una conversión al tipo '{1}'.</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>La opción de la línea de comandos '--cliroot' está en desuso. En su lugar, use una referencia explícita a una copia específica de mscorlib.dll.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Las definiciones de {0} en la signatura y la implementación no son compatibles porque los nombres son diferentes. El tipo se denomina "{1}" en el archivo de la signatura pero "{2}" en la implementación.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Argumento no válido para 'methodhandleof' durante la generación de código.</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Símbolo "= " inesperado en la expresión. ¿Quería usar "for x in y .. z do" en su lugar?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>No hay constructores disponibles para el tipo '{0}'.</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Especificación duplicada en una interfaz.</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>No se encontró el ensamblado '{0}' en el conjunto de dependencias del archivo binario de destino. Las raíces vinculadas de forma estática se deben especificar con un nombre de ensamblado, sin una extensión DLL o EXE. Si se hizo referencia a este ensamblado de forma explícita, es posible que el ensamblado no fuese realmente necesario para el archivo binario generado, en cuyo caso no debería haberse vinculado de forma estática.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>El tipo '{0}' implementa 'System.IComparable'. Considere también agregar una invalidación explícita para 'Object.Equals'.</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Se usa en enlaces mutuamente recursivos, en declaraciones de propiedad y con varias restricciones en parámetros genéricos.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Esta no es una expresión de constante válida.</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>No se encuentra el archivo de respuesta '{0}' en '{1}'.</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>El espacio de nombres "{0}" no está definido.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Ninguno de los tipos '{0}' admite el operador '{1}'. Considere abrir el módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en enlaces "do", pero se proporcionó "{0}".</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Carácter inesperado "{0}" en la expresión de preprocesador</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Solo se permite un aumento 'with' como máximo.</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>A un parámetro con atributos se le debe dar también un nombre; por ejemplo, '[&lt;Atributo&gt;] Nombre : Tipo'.</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Las etiquetas de campo y el tipo esperado de este patrón o expresión de registro no determinan de forma única un tipo de registro correspondiente.</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Solo los patrones activos que devuelven exactamente un resultado pueden aceptar argumentos.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>El miembro de operador de infijo '{0}' tiene {1} argumentos iniciales. Se esperaba una tupla de 2 argumentos; por ejemplo, el miembro estático (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argumento</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Esta construcción es para la compatibilidad con ML. {0}. Puede deshabilitar esta advertencia usando '--mlcompatibility' o '--nowarn:62'.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>El modificador de formato # no es válido en F#.</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Retrasar la signatura del ensamblado usando solo la parte pública de la clave de nombre seguro</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Se usa para declarar un tipo de excepción.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Una o varias sobrecargas de este método tienen argumentos currificados. Considere rediseñar estos miembros para que tomen argumentos con forma de tupla.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' se puede usar sólo como el primer nombre en una ruta de acceso completa.</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Las enumeraciones de literal deben tener el tipo int, uint, int16, uint16, int64, uint64, byte, sbyte o char.</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Error al leer el nodo de metadatos de F# en la posición {0} de la tabla '{1}' del ensamblado '{2}'. El nodo no tiene ninguna declaración coincidente. Informe de esta advertencia. Es posible que necesite volver a compilar el ensamblado de F# que esté usando.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Error al abrir el archivo binario '{0}': {1}.</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Nombre de miembro no válido. Los miembros no pueden tener el nombre '.ctor' o '.cctor'</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Especificador de formato incorrecto: '{0}'.</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Este campo no es un literal y no se puede usar en un patrón.</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Solo los campos de registro y los enlaces 'let' sencillos no recursivos se pueden marcar como mutables</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Directiva no válida. Se esperaba '#load \"&lt;archivo&gt;\" ... \"&lt;archivo&gt;\"'.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>El tipo '{0}' tiene un método '{1}' (nombre completo '{2}'), pero el método es estático.</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>No se encontró ningún miembro abstracto o de interfaz que corresponda a esta invalidación.</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Este no es un patrón válido.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>Falta 'do' en la expresión 'for'. Se esperaba 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Debe declarar de forma explícita todos o ninguno de los parámetros de tipo cuando se invalide un método abstracto genérico.</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Expresión '{0}' no admitida del proveedor de tipo. Si es el autor de este proveedor de tipo, considere ajustarlo para que devuelva una expresión proporcionada distinta.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Especificar la versión del subsistema de este ensamblado</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Uso inesperado de una variable de tipo byref.</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>No se pudo insertar el valor '{0}' marcado como 'inline', quizá porque un valor recursivo estaba marcado como 'inline'.</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>En los tipos de función, delimita los argumentos y los valores devueltos. Genera una expresión (en expresiones de secuencia); es equivalente a la palabra clave yield. Se usa en expresiones de coincidencia.</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Los structs no pueden tener un constructor de objeto sin argumentos. Esta es una restricción impuesta en todos los lenguajes CLI porque los structs admiten automáticamente un constructor predeterminado.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>algId no válido, se esperaba 'Exponent'</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Considere la posibilidad de usar "return!" en lugar de "return".</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>El operador '!' se utiliza para desreferenciar una celda ref. Considere utilizar 'no expr' aquí.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>No agregar un recurso al ensamblado generado que contiene metadatos específicos de F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Operador de infijo inesperado en una expresión de tipo.</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>El modificador --embed solo se admite cuando se emite un archivo PDB portátil (--debug:portable o --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Definición de operador no válida. Las definiciones de operador de prefijo deben usar un nombre de operador de prefijo válido.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Los argumentos sin nombre no forman un prefijo de los argumentos del método llamado.</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>nombre completo no válido para el tipo proporcionado</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>La directiva #else debe aparecer como el primer carácter que no es un espacio en blanco en una línea.</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>El campo de excepción o caso de unión '{0}' no se puede usar más de una vez.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en casos de unión. Use 'type U = internal ...' o 'type U = private ...' para proporcionar una accesibilidad a toda la representación.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>La creación de una instancia de un tipo implica un tipo byref. Las reglas de Common IL no permiten esto.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Caso de unión desconocido.</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>El nombre '({0})' no debe usarse como un nombre de miembro. Para definir semántica de comparación para un tipo, implemente la interfaz 'System.IComparable'. Si define un miembro estático para usarlo desde otros lenguajes CLI, use el nombre '{1}' en su lugar.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Las abreviaciones de tipo no pueden tener aumentos.</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>El módulo contiene el constructor\n    {0}    \npero su signatura especifica\n    {1}    \nLa accesibilidad especificada en la signatura es superior a la especificada en la implementación.</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLas aridades de la signatura y la implementación difieren. La signatura especifica que '{3}' es una definición de función o una expresión lambda que acepta al menos {4} argumentos, pero la implementación es un valor de función calculado. Para declarar que un valor de función calculado es una implementación permitida, simplemente ponga entre paréntesis el tipo en la signatura; por ejemplo\n\tval {5}: int -&gt; (int -&gt; int)\nen lugar de\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>y otras {0} sobrecargas</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>El tipo '{0}' no es un tipo enum CLI.</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Una abreviación de módulo debe ser un nombre simple, no una ruta de acceso.</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Los valores recursivos no pueden aparecer directamente como una construcción del tipo '{0}' en un enlace recursivo. Esta característica se ha quitado del lenguaje F#. Considere el uso de un registro en su lugar.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Compilador F# para F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Se ha asignado más de un valor a un argumento con nombre.</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Se omitirá el ensamblado mixto administrado o no administrado '{0}' durante la vinculación estática.</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>El atributo 'StructLayout' se puede dar solo a structs y clases sin constructores principales.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Se esperaba un parámetro de tipo, no un parámetro de unidad de medida.</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Indica una implementación de un método abstracto. Se usa junto con una declaración de método abstracto para crear un método virtual.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>El final del archivo en la cadena de comillas triples incrustada en el comentario comenzaba aquí o antes.</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Habilitar ASLR de alta entropía</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Se esperaba una clave privada</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>resultado de patrón activo</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Esta declaración no se admite en grupos de declaraciones recursivas</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Falta el token "{0}" en la expresión de preprocesador</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Saliendo, demasiados errores.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>El miembro '{0}' no tiene el número correcto de argumentos. La signatura necesaria es '{1}'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Este tipo usa una combinación no válida de los atributos "NoEquality", "ReferenceEquality", "StructuralEquality", "NoComparison" y "StructuralComparison".</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Esta definición se puede usar solo en un tipo con un constructor principal. Considere agregar argumentos a la definición de tipo, por ejemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>El tipo de atributo '{0}' tiene 'AllowMultiple=false'. No se pueden asociar varias instancias de este atributo a un solo elemento de lenguaje.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>En expresiones de secuencia, se generan varios resultados con 'yield!'.</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>El tipo '{0}' no admite el operador '{1}'. Considere abrir el módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Los structs, interfaces, enumeraciones y delegados no pueden heredarse de otros tipos.</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Número no válido de argumentos genéricos para el tipo '{0}' en el tipo proporcionado. Se esperaban '{1}' argumentos y se proporcionaron '{2}'.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>El método '{0}' no es accesible desde este lugar del código.</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Valor mágico no válido en encabezado CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Asignación opcional a una propiedad o un campo no válida.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Ningún miembro o constructor de objeto de {0} con el nombre '{1}' toma {2} argumentos. El argumento con nombre '{3}' no corresponde a ningún argumento o propiedad de valor devuelto que se pueda establecer para ninguna sobrecarga.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Ningún miembro o constructor de objeto de {0} con el nombre '{1}' toma {2} argumentos. Tenga en cuenta que la llamada a este miembro proporciona también {3} argumentos con nombre.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Etiqueta de campo no válida.</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>No se pudo descodificar el atributo MarshalAs.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" en la signatura y la implementación no son compatibles porque las representaciones de IL difieren</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>El tipo no genérico '{0}' no espera ningún argumento de tipo, pero aquí se le proporcionan {1} argumentos de tipo.</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>El valor, constructor, espacio de nombres o tipo "{0}" no está definido.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>espacio de nombres o módulo</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Jerarquía de clases recursiva en el tipo '{0}'.</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>La referencia de objeto recursiva '{0}' no se usa. La presencia de una referencia de objeto recursiva agrega comprobaciones de inicialización en tiempo de ejecución a los miembros de este tipo y los tipos derivados. Considere quitar esta referencia de objeto recursiva.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Un tipo no puede tener los atributos 'ReferenceEquality' y 'StructuralEquality' o 'StructuralComparison' a la vez.</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Esta construcción se puede usar solo en expresiones de cómputo.</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Un valor debe ser mutable para poder mutar el contenido o tomar la dirección de un tipo de valor; por ejemplo, 'let mutable x = ...'</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Las abreviaciones de excepciones deben hacer referencia a excepciones existentes o tipos de F# que se deriven de System.Exception.</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Insertar todos los archivos de código fuente en el archivo PDB portátil</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Solo se pueden enlazar patrones de variable simple en construcciones 'let rec'.</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Argumentos sucesivos deben separarse con espacios u organizarse en tuplas, y los argumentos que implican aplicaciones de función o método deben encerrarse entre paréntesis.</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>No es una excepción.</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Error interno. Índice no válido en una matriz de patrones activos.</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Se hizo referencia al ensamblado '{0}' de forma transitiva y no se pudo resolver automáticamente. La vinculación estática asumirá que este archivo DLL no tiene dependencias de la biblioteca de F# u otros archivos DLL vinculados de forma estática. Considere agregar una referencia explícita a este archivo DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Error al emitir el atributo 'System.Reflection.AssemblyCultureAttribute': 'Los archivos ejecutables no pueden ser ensamblados satélite y no deben tener referencia cultural'.</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Las interfaces tienen siempre la misma visibilidad que el tipo envolvente.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nUno es una función de tipo y el otro no. La signatura requiere parámetros de tipo explícitos si están presentes en la implementación.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>La sintaxis 'module ... = struct .. end' no se usa en el código de F#. Considere el uso de 'module ... = begin .. end'.</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>El atributo 'VolatileField' se puede usar sólo en enlaces 'let' en clases.</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>El módulo contiene el campo\n    {0}    \npero su signatura especifica\n    {1}    \nLos modificadores 'literal' difieren.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Las definiciones de {0} para el tipo "{1}" de la signatura y la implementación no son compatibles porque las abreviaciones difieren: {2} frente a {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Un inicializador estático explícito debe usar la sintaxis 'static new(args) = expr'.</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Solo las funciones se pueden marcar como 'inline'.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Este tipo no es un tipo de interfaz.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>El tipo '{0}' no es un tipo de interfaz.</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Los constructores de objetos no pueden usar directamente try/with y try/finally antes de la inicialización del objeto. Esto incluye constructores como 'for x in ...' que pueden dar lugar a usos de estos constructores. Esta es una limitación impuesta por Common IL.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' y 'return!' no se pueden usar en las consultas.</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>No se permiten modificadores de accesibilidad en campos de registro. Use 'type R = internal ...' o 'type R = private ...' para proporcionar una accesibilidad a toda la representación.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Se usa en lugar de let! en flujos de trabajo asincrónicos y otras expresiones de cálculo para los valores que requieren que se llame a Dispose para liberar recursos.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Aquí no se permite una declaración de herencia.</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>La información de miembro '{1}' del tipo '{0}' proporcionado tiene un tipo declarativo NULL.</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>El proveedor de tipos "{0}" devolvió un método no válido de "ApplyStaticArgumentsForMethod". Se esperaba un método con el nombre "{1}", pero se devolvió un método con el nombre "{2}".</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} no es una secuencia de escape de caracteres Unicode válida</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Existen varios tipos con el nombre '{0}' que toman números diferentes de parámetros genéricos. Proporcione una creación de instancia de tipo para eliminar la ambigüedad de la resolución de tipos; por ejemplo, '{1}'.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Los atributos del espacio de nombres o módulo difieren entre la signatura y la implementación.</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>La interfaz '{0}' está incluida en varios tipos de interfaz implementados de forma explícita. Agregue una implementación explícita de esta interfaz.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>El evento '{0}' tiene un tipo no estándar. Si este evento está declarado en otro lenguaje CLI, puede ser necesario obtener acceso a este evento usando los métodos explícitos {1} y {2} para el evento. Si este evento está declarado en F#, convierta el tipo del evento en una creación de instancia de 'IDelegateEvent&lt;_&gt;' o 'IEvent&lt;_,_&gt;'.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>La sintaxis 'type X with ...' está reservada para aumentos. Los tipos cuyas representaciones están ocultas pero que tienen miembros se declaran ahora en signaturas con 'type X = ...'. También puede ser necesario agregar el atributo '[&lt;Sealed&gt;] a la definición de tipos en la signatura.</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Puede elegir una de las opciones siguientes:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>La etiqueta de registro '{0}' no está definida.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Esta prueba de tipo o conversión hacia abajo omitirá la unidad de medida '{0}'.</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Blob de clave pública no válido</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>No se puede usar la vinculación estática en un ensamblado que haga referencia a mscorlib (por ejemplo, un ensamblado de .NET Framework) al generar un ensamblado que haga referencia a System.Runtime (por ejemplo, un ensamblado portátil o de .NET Core).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nEl número de parámetros genéricos en la signatura y la implementación difiere (la signatura declara {3} pero la implementación declara {4}).</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>El miembro '{0}' no tiene los tipos correctos de parámetros genéricos. La signatura necesaria es '{1}'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>La signatura y la implementación no son compatibles porque los recuentos de parámetros de tipo respectivos difieren.</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>tipo, excepción o módulo</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Esta expresión de matriz o lista incluye un elemento con el formato 'if ... then ... else'. Ponga paréntesis a esta expresión para indicarla como elemento individual de la lista o matriz, con el fin de eliminar la ambigüedad respecto a una lista generada con una expresión de secuencia.</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>El tipo '{0}' no tiene 'null' como un valor apropiado.</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Los modificadores de accesibilidad deben ir inmediatamente delante del identificador que da nombre a una construcción.</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Definición de valor incompleta. Si se encuentra en una expresión, se debe aplicar sangría al cuerpo de la expresión hasta la misma columna que la palabra clave 'use'.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Definición de valor o función incompleta. Si se encuentra en una expresión, se debe aplicar sangría al cuerpo de la expresión hasta la misma columna que la palabra clave 'let'.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>La excepción o el caso de unión '{0}' no tiene un campo denominado '{1}'.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>El nombre '({0})' no debe usarse como un nombre de miembro. Si define un miembro estático para usarlo desde otros lenguajes CLI, use el nombre '{1}' en su lugar.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>El proveedor de tipos no tiene un constructor válido. Se esperaba un constructor que no tome argumentos o bien que tome un argumento de tipo 'TypeProviderConfig'.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Los tipos de registro, unión, abreviación y struct no pueden tener el atributo 'AllowNullLiteral'.</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>El formato de expresión {{ expr with ... }} se puede usar sólo con tipos de registro. Para compilar tipos de objeto, use {{ new Type(...) with ... }}.</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>No se proporcionó ninguna implementación para '{0}'.</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Este caso de unión espera {0} argumentos en forma de tupla.</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Hay dos definiciones de tipo con el nombre '{0}' en el espacio de nombres '{1}' en dos partes de este ensamblado.</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Nombre de módulo no válido.</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>La conversión de {0} a {1} es una conversión a tipo básico segura en tiempo de compilación, no una conversión a tipo heredado. Considere la posibilidad de usar el operador :&gt; (upcast) en lugar del operador :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>No se permiten especificadores posicionales en cadenas de formato</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>La operación personalizada '{0}' hace referencia a un método sobrecargado. Las implementaciones de operaciones personalizadas no pueden estar sobrecargadas.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>No se permiten enlaces 'use' en módulos y se tratan como enlaces 'let'.</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Especifique la página de códigos usada para leer archivos de código fuente.</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>El tratamiento de este operador se controla ahora directamente con el compilador de F# y su significado no se puede redefinir.</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Convierte un tipo en otro de un nivel inferior de la jerarquía.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>No se pudo leer la versión de mscorlib.dll.</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>El proveedor de tipos '{0}' informó de un error en el contexto del tipo '{1}' proporcionado, miembro '{2}'. El error: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Error al aplicar los argumentos estáticos a un tipo proporcionado.</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- ARCHIVOS DE ENTRADA -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Un bucle for de entero debe usar un identificador simple.</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Este número está fuera del intervalo permitido para enteros firmados de 8 bits hexadecimales.</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Un protector de coincidencia de patrones debe ser del tipo "bool", pero esta expresión "when" es del tipo "{0}".</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Una definición de tipo requiere uno o varios miembros, u otras declaraciones. Si su intención es definir una clase, un struct o una interfaz vacía, use 'type ... = class end', 'interface end' o 'struct end'.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Una construcción genérica requiere que el tipo '{0}' tenga semántica de referencia, pero no la tiene, es decir, es un struct.</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLos nombres difieren.</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>La abreviación de tipo contiene byrefs. Esto no se permite en F#.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>No se puede generar información de depuración de MDB. No se pudo cargar el tipo 'MonoSymbolWriter' del ensamblado 'Mono.CompilerServices.SymbolWriter.dll'.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Error inesperado al crear el archivo de información de depuración '{0}'.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Se esperaba un parámetro de unidad de medida, no un parámetro de tipo. Los parámetros de unidad de medida explícitos deben marcarse con el atributo [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>No se puede analizar la cadena de formato '{0}'.</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Descodificación inesperada de AutoOpenAttribute.</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Las expresiones de código delimitadas no pueden contener expresiones que realicen llamadas de restricción de miembros ni usos de operadores que se resuelvan de forma implícita en una llamada de restricción de miembros.</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Los archivos en bibliotecas o aplicaciones de varios archivos deben comenzar con una declaración de espacio de nombres o de módulo. Cuando se usa una declaración de módulo al principio de un archivo, el signo "=" no se permite. Si se trata de un módulo de nivel superior, considere la posibilidad de quitar el signo = para resolver el error.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>El campo '{0}' aparece dos veces en este patrón o expresión de registro.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Se esperaba un tipo proporcionado con el nombre '{0}', pero el tipo proporcionado tiene el valor '{1}' para 'Name'.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Se esperaba un tipo proporcionado con la ruta de acceso '{0}', pero el tipo proporcionado tiene la ruta de acceso '{1}'</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>El número de argumentos para un atributo personalizado no coincide con el número esperado de argumentos para el constructor de atributo.</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>El miembro '{0}' se usa de forma no válida. Se ha inferido un uso de '{1}' antes de su definición en '{2}' o cerca. Esta es una referencia adelantada no válida.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>El evento '{0}' del tipo '{1}' proporcionado no tiene ningún valor de GetRemoveMethod().</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Se esperaba una clave RSA</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Todos los tipos de registro, unión y struct de FSharp.Core.dll deben estar etiquetados de forma explícita con 'StructuralComparison' o 'NoComparison'.</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>El tipo de unión del caso de unión "{0}" se definió con el atributo RequireQualifiedAccessAttribute. Incluya el nombre del tipo de unión ("{1}") en el nombre que esté usando.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Los patrones activos no pueden devolver más de 7 posibilidades.</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>El valor o constructor "{0}" no está definido.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Esta declaración 'inherit' tiene argumentos, pero no está en un tipo con un constructor principal. Considere agregar argumentos a la definición de tipo, por ejemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Los tipos de unión discriminada están siempre sellados.</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Anotación GetSet inesperada en una propiedad.</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Este no es un valor válido para un literal de enumeración.</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Módulo, expresión o tipo no válidos.</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} sobrecargas</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 sobrecarga</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Se espera un tipo que admita el operador '{0}', pero se ha proporcionado un tipo de tupla.</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>El ensamblado '{0}' aparece en la línea de comandos. Para hacer referencia a ensamblados, debe usarse una marca de la línea de comandos como '-r'.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>El '{0}' de un tipo proporcionado era NULL o estaba vacío.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Método duplicado. El método abstracto '{0}' tiene el mismo nombre y la misma signatura que un método abstracto en un tipo heredado.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>también desde {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>El método de matrices '{0}' se proporciona mediante el runtime y no se puede usar directamente en el código. Para las operaciones con elementos de matriz, considere el uso de la familia de funciones GetArray/SetArray del módulo LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>El atributo de accesibilidad "{0}" no se permite en la abreviación de módulo. Las abreviaciones de módulo son siempre privadas.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Los tipos proporcionados generados por este uso de un proveedor de tipos no se pueden usar desde otros ensamblados de F# y deben marcarse como internos o privados. Considere usar 'type internal TypeName = ...' o 'type private TypeName = ...'.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Agregar . para el acceso de indizador.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Los enlaces DLLImport deben ser miembros estáticos en definiciones de función o clase dentro de un módulo.</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>La función o miembro '{0}' se usa de forma que requiere más anotaciones de tipo en su definición para garantizar la coherencia de los tipos inferidos. La signatura inferida es '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Este método ya tiene una implementación predeterminada.</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>El módulo '{0}' contiene\n    {1}    \npero su signatura especifica\n    {2}    \nLa representación compilada de este método es como un miembro de instancia, pero la signatura indica que su representación compilada es como un miembro estático.</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Este no es un literal de byte válido.</value>
  </data>
</root>