<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w tej pozycji dla skrótów typu</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Łączenie statyczne nie może obejmować pliku EXE</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>Nie można odczytać właściwości „{0}”</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Powiązania „use” muszą mieć postać „use &lt;zmienna&gt; = &lt;wyrażenie&gt;”</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Wersja {0} kompilatora języka Microsoft (R) F#</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Pole rekordu, struktury lub klasy „{0}” jest niedostępne w tej lokalizacji kodu</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Nieprawidłowy element członkowski „{0}” w udostępnionym typie „{1}”. Elementy członkowskie udostępnionego typu muszą być publiczne, a nie ogólne, wirtualne lub abstrakcyjne.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>„{{ }}” nie jest prawidłowym wyrażeniem. Rekordy muszą zawierać co najmniej jedno pole. Puste sekwencje są określane przy użyciu elementu Seq.empty lub pustej listy „[]”.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Dynamiczne wywołanie {0} nie jest obsługiwane</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralEquality”, ale parametr typu „{1}” nie spełnia ograniczenia „equality”. Rozważ dodanie ograniczenia „equality” do parametru typu</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralEquality”, ale typ składnika „{1}” nie spełnia ograniczenia „equality”</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Rozważ użycie osobnego typu rekordu</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>Adres zmiennej „{0}” nie może być użyty w tym punkcie. Metoda lub funkcja może nie zwrócić adresu tej wartości lokalnej.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Nie można odczytać zestawu „{0}”</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Ogólna konstrukcja wymaga, aby typ „{0}” był typem struktury infrastruktury CLI lub języka F#</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Dostawca typów „{0}” zwrócił wartość null z metody GetInvokerExpression.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Używanie wielu odwołań do pliku „{0}.dll” jest niedozwolone</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Niezgodna nazwa operatora cytatu, począwszy od „{0}”</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Wskazuje metodę, która nie ma implementacji w typie, w którym została zadeklarowana, lub jest wirtualna i ma implementację domyślną.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Statyczne łączenie nie może obejmować mieszanej biblioteki zarządzanej/niezarządzanej DLL</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Ogranicza dostęp do elementu członkowskiego kodu w tym samym typie lub module.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Typ „{0}” nie jest zgodny z żadnym z typów {1}, co wynika z użycia ciągu formatu w stylu funkcji printf</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Elementy członkowskie rozszerzeń nie mogą udostępniać przeciążeń operatorów. Zamiast tego rozważ zdefiniowanie operatora jako części definicji typu.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>Zmienna „{0}” jest używana w nieprawidłowy sposób</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>Składnia „{0}” może być używana tylko w celu tworzenia typów obiektów</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Nieoczekiwany token „{0}” lub niepełne wyrażenie</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>Znak „_” nie może być używany jako nazwa pola</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Podano wiele dostępności dla metody ustawiającej lub metody pobierającej właściwość</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Konstruktory muszą być stosowane do argumentów i nie mogą być używane jako wartości pierwszoklasowe. Jeśli to konieczne, użyj funkcji anonimowej „(fun arg1 ... argN -&gt; new Typ(arg1,...,argN))”.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Nieprawidłowy plik wersji „{0}”</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Powiązania cykliczne zawierające specyfikacje elementów członkowskich mogą występować tylko jako bezpośrednie powiększenie typu</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Nieprawidłowe odwołanie cykliczne do miejsca abstrakcyjnego</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać wbudowanego kodu zestawu lub dopasowania wzorca w tablicach</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Obiekty muszą być inicjowane przez wyrażenie konstrukcji obiektu, które wywołuje dziedziczonego konstruktora obiektów i przypisuje wartość do każdego pola</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Argumenty operatorów zapytania mogą wymagać nawiasów, na przykład „where (x &gt; y)” lub „groupBy (x.Length / 10)”</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Ustaw poziom ostrzeżeń (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Wyświetl ten komunikat dotyczący składni (krótka wersja: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>Do korzystania z klas UnknownWrapper\DispatchWrapper jest wymagany zestaw System.Runtime.InteropServices.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>moduł</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie po lewej stronie przypisania</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Nieprawidłowa wbudowana specyfikacja</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Ogranicza typizowany cytat kodu.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>Element MemberKind.PropertyGetSet jest oczekiwany tylko w drzewach analizy</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problem z nazwą pliku „{0}”: niedozwolone znaki w ścieżce.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(trwa ładowanie opisu...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „comparison”, ponieważ jest rekordem, unią lub strukturą z co najmniej jednym typem elementu strukturalnego, który nie obsługuje ograniczenia „comparison”. Unikaj używania porównania z tym typem lub dodaj atrybut „StructuralComparison” do typu w celu ustalenia, jaki typ pola nie obsługuje porównania</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „comparison”. Na przykład typ nie obsługuje interfejsu „System.IComparable”</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „comparison”, ponieważ ma on atrybut „NoComparison”</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>Atrybut „System.Diagnostics.ConditionalAttribute” jest prawidłowy tylko w przypadku metod lub klas atrybutów</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ reprezentacje infrastruktury CLI są różne. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Błąd składni w argumencie typu z etykietą</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Właściwość nie może zawierać jawnych parametrów typu. Zamiast tego rozważ użycie metody.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Wypisz komunikaty w kodowaniu UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Moduł i definicja typu o nazwie „{0}” występują w przestrzeni nazw „{1}” w dwóch częściach tego zestawu</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Nazwa „{0}” nie jest powiązana w kontekście wzorca</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Konstruktor dostawcy typów zgłosił wyjątek: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Nieznany rodzaj argumentu statycznego „{0}” podczas rozpoznawania odwołania do podanego typu lub podanej metody „{1}”</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>Definicja operatora niestandardowego „{0}” nie używa prawidłowej kombinacji flag atrybutów</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: Element {0} był reprezentowany jako metoda statyczna, ale nie był odpowiednim wyrażeniem lambda</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 8-bitowych liczb całkowitych bez znaku</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Atrybuty zostały zignorowane w tej konstrukcji</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>Po operatorze „{0}” musi występować element „in”. Użycie: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IEquatable&lt;_&gt;”. Zastosuj atrybut „CustomEquality” do typu i określ spójną implementację nieogólnego przesłonięcia „System.Object.Equals(obj)”.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Plik źródłowy jest za duży, aby osadzić go w przenośnym pliku PDB</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Konstruktor obiektów wymaga argumentu</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Błąd podczas odczytywania/zapisywania metadanych skompilowanej biblioteki DLL języka F# „{0}”. Czy biblioteka DLL została skompilowana przy użyciu wcześniejszej wersji kompilatora języka F#? (Błąd: „{1}”).</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać definicji przesłonięć elementów członkowskich</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Określono wiele atrybutów widoczności dla tego identyfikatora</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura jest klasą abstrakcyjną, a implementacja nią nie jest. Rozważ dodanie atrybutu [&lt;AbstractClass&gt;] do implementacji.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Udostępniony typ „{0}” ma element członkowski „{1}” z typem deklarującym „{2}”. Oczekiwano, że typ deklarujący będzie taki sam jak udostępniony typ.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Niedopasowany element „class”, „interface” lub „struct”</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Używane do kojarzenia nazwy z grupą powiązanych typów i modułów w celu jej logicznego oddzielenia od innego kodu.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>Nie zdefiniowano przestrzeni nazw lub modułu „{0}”.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Ten przypadek unii akceptuje jeden argument</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Nieoczekiwana pusta lista typu moduleDefn</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Używane na potrzeby warunków wartości logicznych (strażników when) w dopasowaniach wzorca oraz w celu wprowadzenia klauzuli ograniczenia dla parametru typu ogólnego.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Używane razem ze słowem kluczowym match w wyrażeniach dopasowania wzorca. Używane również w wyrażeniach obiektu, wyrażeniach kopiowania rekordu oraz wyrażeniach typu do wprowadzania definicji elementów członkowskich i obsługi wyjątków.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Wskazuje typ void technologii .NET. Używane w przypadku współdziałania z innymi językami .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Używane w wyrażeniach warunkowych oraz do wykonywania efektów ubocznych po skonstruowaniu obiektu.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Używane do deklarowania klasy, rekordu, struktury, unii rozłącznej, typu wyliczeniowego, jednostki miary lub skrótu typu.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Używane do udostępniania zawartości przestrzeni nazw lub modułu bez kwalifikacji.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Wskazuje brak obiektu. Używane również w ograniczeniach parametrów ogólnych.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Konwertuje typ na typ znajdujący się wyżej w hierarchii.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Używane jako nazwa obiektu klasy podstawowej.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Używane do określania obliczenia, które ma być wykonywane tylko, jeśli potrzebny jest wynik.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Używane w rozgałęzianiu warunkowym.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Używane w rozgałęzianiu warunkowym. Krótka postać instrukcji else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>W składni pełnej wskazuje koniec bloku kodu w wyrażeniu zapętlenia.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Odwołanie do biblioteki DLL {0} jest wymagane przez zestaw {1}. Zaimportowany typ {2} znajduje się w pierwszym zestawie i nie można go rozpoznać.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb zmiennoprzecinkowych</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Definicje typów mogą zawierać tylko jedną specyfikację „inherit”, która musi być pierwszą deklaracją</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Wartości literałów nie mogą mieć parametrów ogólnych</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Nieoczekiwany operator cytatu „&lt;@” w definicji typu. Jeśli chcesz przekazać ciąg dosłownego wyrażenia jako argument statyczny do dostawcy typów, wstaw odstęp między znakami „&lt;” i „@”.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Zwykle nie należy ponownie definiować operatora „{0}”. Aby zdefiniować semantykę porównania z przeładowaniem dla określonego typu, zaimplementuj interfejs „System.IComparable” w definicji tego typu.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Metody z argumentami curried nie mogą deklarować argumentu „out”, „ParamArray”, „optional”, „ReflectedDefinition”, „byref”, „CallerLineNumber”, „CallerMemberName” lub „CallerFilePath”</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>Opcja „--pdb” wymaga użycia opcji „--debug”</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>Wartość „{0}” została oznaczona jako śródwierszowa, ale nie powiązano jej w środowisku optymalizacji</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>Właściwość „{0}” jest statyczna</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Nie można porównać struktury typu struktury, rekordu lub unii „{0}”, ponieważ parametr typu {1} nie spełnia ograniczenia „comparison”. Rozważ dodanie atrybutu „NoComparison” do typu „{2}” w celu określenia, że typu nie można porównywać</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Nie można porównać struktury typu struktury, rekordu lub unii „{0}”, ponieważ typ „{1}” nie spełnia ograniczenia „comparison”. Rozważ dodanie atrybutu „NoComparison” do typu „{2}” w celu określenia, że typu nie można porównywać</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja definiuje strukturę, ale sygnatura definiuje typ z ukrytą reprezentacją</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Uwaga: Nie zastosowano optymalizacji przenoszenia elementu lambda, ponieważ ta lokalna funkcja ogólna z ograniczeniami została użyta jako wartość pierwszoklasowa. Dodanie ograniczeń typów może rozwiązać ten problem.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>Używanie ciągu „let! x = coll” w wyrażeniach sekwencji jest niedozwolone. Zamiast tego użyj ciągu „for x in coll”.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „mutable” są różne</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>Nazwa pliku MDB musi mieć postać: &lt;nazwa-pliku-zestawu&gt;.mdb. Opcja --pdb zostanie zignorowana.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nReprezentacja skompilowana tej metody ma postać statycznego elementu członkowskiego, ale sygnatura wskazuje, że jego reprezentacja skompilowana ma postać elementu członkowskiego wystąpienia</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Nie można zdekodować atrybutu DllImport</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Słowo kluczowe „base” jest używane w nieprawidłowy sposób. Wywołania elementów podstawowych nie mogą być używane w zamknięciach. Rozważ użycie prywatnego elementu członkowskiego na potrzeby wywołań elementów podstawowych.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>Element „new” musi być używany z nazwanym typem</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Ten skrót typu zawiera co najmniej jeden zadeklarowany parametr typu, który nie występuje w skracanym typie. Skróty typu muszą używać wszystkich zadeklarowanych parametrów typu w skracanym typie. Rozważ usunięcie co najmniej jednego parametru typu lub użyj konkretnej definicji typu, która opakowuje odpowiedni typ, na przykład „type C&lt;'a&gt; = C of ...”.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Nazwa pliku odpowiedzi „{0}” jest pusta, zawiera nieprawidłowe znaki, ma oznaczenie dysku bez ścieżki bezwzględnej lub jest zbyt długa</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ dostępność określona w sygnaturze jest większa od określonej w implementacji</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Nie odnaleziono żadnej właściwości abstrakcyjnej odpowiadającej temu przesłonięciu</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Błąd podczas analizowania osadzonego obiektu IL</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Klasy zastępcze DLLImport nie mogą być śródwierszowe</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Niedozwolony wzorzec</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>W tym miejscu jest wymagana prosta nazwa metody</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Definicje „member val” są dozwolone tylko w typach z podstawowym konstruktorem. Rozważ dodanie argumentów do definicji typu, na przykład „type X(args) = ...”.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>Dwukrotnie ustawiono flagę „{0}”</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać wyrażeń obiektu</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Wartość oznaczona jako „inline” ma nieoczekiwaną wartość</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>Wyrażenia „match” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>Właściwość „{0}” ma taką samą nazwę co inna właściwość w typie „{1}”, ale pobiera argumenty indeksatora, których druga właściwość nie pobiera. Być może brakuje argumentu indeksatora jednej z właściwości.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Identyfikatory, po których następuje „{0}”, są zarezerwowane do użytku w przyszłości</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Jawne parametry typu mogą być używane tylko w powiązaniach modułów lub elementów członkowskich</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanWrite=false, ale metoda GetSetMethod() zwróciła metodę</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Emituj informacje debugowania w wyrażeniach cytowanych</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Nie dołączaj domyślnego manifestu Win32</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>aktywny aparat rozpoznawania</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Nie można użyć atrybutu „CompiledName” z tym elementem języka</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Używane do deklarowania zmiennej, czyli wartości, która może się zmienić.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Sygnatura dla pliku lub modułu „{0}” została już określona</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które ustawiają pola przypadku unii</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Ta definicja typu zawiera bezpośrednie odwołanie cykliczne za pośrednictwem skrótu</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Nieprawidłowa wartość „{0}” dla opcji „--targetprofile”. Prawidłowe wartości to „mscorlib”, „netcore” i „netstandardx”.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>Powiązania „use” nie są dozwolone w konstruktorach podstawowych</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Struktury mogą tylko tworzyć powiązanie parametru „this” w deklaracjach elementów członkowskich</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Dla wszystkich wyliczanych pól muszą zostać podane wartości</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>W wyrażeniach obiektu nie są dozwolone definicje „member val” ani definicje „override val”.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ skrót wyjątku jest ukrywany przez sygnaturę. Skrót musi być widoczny dla innych języków infrastruktury CLI. Rozważ zapewnienie widoczności skrótu w sygnaturze. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Używane razem ze słowem kluczowym try do wprowadzania bloku kodu, który jest wykonywany bez względu na to, czy wystąpi wyjątek.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Nie można określać niestandardowych organizatorów w kodzie języka F#. Rozważ użycie pomocniczej funkcji języka C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Żadna implementacja elementu „{0}” nie zawiera poprawnej liczby argumentów i parametrów typu. Wymagana sygnatura: „{1}”.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Przesłonięcia metod i implementacje interfejsów nie są tutaj dozwolone</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Nie można zdekodować atrybutu FieldOffset</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Plik sygnatury „{0}” nie ma odpowiedniego pliku implementacji. Jeśli plik implementacji istnieje, sprawdź, czy istnieją zgodne deklaracje „module” i „namespace” w plikach sygnatury i implementacji.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Nie można ponownie zdefiniować operatora „{0}”. Rozważ użycie innej nazwy operatora</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura ma skrót, a implementacja go nie ma</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Nie zdefiniowano parametru typu „{0}”.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Używane do określania klasy podstawowej lub interfejsu podstawowego.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Możliwe niepoprawne wcięcie: ten token jest poza kontekstem rozpoczynającym się w pozycji {0}. Spróbuj użyć dodatkowego wcięcia dla tego tokenu lub standardowych konwencji formatowania.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy wyświetlane są różne</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Wynikiem tego wyrażenia literału lub argumentu atrybutu jest przepełnienie arytmetyczne.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Argumenty opcjonalne nie mogą być używane w atrybutach niestandardowych</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Statycznie połącz podany zestaw i wszystkie przywoływane biblioteki DLL, które zależą od tego zestawu. Użyj nazwy zestawu (np. mojabiblioteka), a nie nazwy biblioteki DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Koniec pliku w ciągu dosłownego wyrażenia osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nWartości i/lub atrybuty stałych literału są różne</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>To kodowanie Unicode jest prawidłowe tylko w literałach ciągu</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>Element „{0}” można stosować tylko do argumentów opcjonalnych</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Ta operacja obejmuje pobieranie adresu wartości „{0}” reprezentowanej przy użyciu zmiennej lokalnej lub innej specjalnej reprezentacji. Jest to nieprawidłowe.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Domyślnie nie odwołuj się do domyślnych zestawów infrastruktury CLI</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>Nie znaleziono pliku „{0}” z plikiem FSharp.Core. Plik oczekiwany w {1}. Rozważ uaktualnienie do nowszej wersji pliku FSharp.Core, w której ten plik nie jest już wymagany.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wskazuje, że ten typ może używać wartości null jako reprezentacji, ale implementacja tego nie wskazuje</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Koniec pliku w komentarzu rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” nie ma argumentu lub ustawialnej właściwości zwracanej „{1}”. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Nieobsługiwany typ stałej „{0}”. Cytowania udostępniane przez dostawców typu mogą zawierać tylko proste stałe. Implementacja dostawcy typu może wymagać dostosowania przez przeniesienie wartości zadeklarowanej poza udostępnionym literałem cytowania w celu utworzenia powiązania typu „let” wewnątrz literału cytowania.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Częściowe aktywne wzorce mogą generować tylko jeden wynik</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do typu „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>To wyrażenie listy przekracza maksymalny rozmiar literałów list. W przypadku większych literałów użyj tablicy i wywołaj element Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typ implementacji jest zapieczętowany, ale sygnatura sugeruje, że nie jest zapieczętowany. Rozważ dodanie atrybutu [&lt;Sealed&gt;] do sygnatury.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>Nazwany argument „{0}” nie jest zgodny z żadnym argumentem ani z żadną właściwością modyfikowalną</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Nieprawidłowe ograniczenie: typ użyty dla ograniczenia jest zapieczętowany, co oznacza, że ograniczenie może spełnić maksymalnie jedno rozwiązanie</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Nieoczekiwany znak „{0}”</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ mapowanie wyjątków infrastruktury CLI jest ukrywane przez sygnaturę. Mapowanie wyjątków musi być widoczne dla innych modułów. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Ignorowanie atrybutów w skrócie modułu</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Oczekiwano typu, a nie jednostki miary</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Typ „{0}” zawiera jawną implementację elementu „System.IComparable”, ale nie dostarcza odpowiedniego przesłonięcia elementu „Object.Equals”. Implementacja elementu „Object.Equals” została automatycznie dostarczona (implementacja za pośrednictwem elementu „System.IComparable”). Rozważ jawne zaimplementowanie przesłonięcia elementu „Object.Equals”</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Nie można rozpoznać zestawu „{0}” wymaganego przez „{1}”</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Nieprawidłowa mutacja wyrażenia stałej. Rozważ skopiowanie wyrażenia do modyfikowalnej wartości lokalnej, na przykład „let mutable x = ...”.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Raportuj określone ostrzeżenia jako błędy</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>Konwersja z {0} do {1} jest przypisaniem elementu nadrzędnego bezpiecznym w czasie kompilacji, a nie przypisaniem elementu podrzędnego. Rozważ użycie słowa kluczowego „upcast” zamiast „downcast”.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>Identyfikator „{0}” jest zarezerwowany do użytku w przyszłości przez język F#</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Pliki w bibliotekach lub aplikacjach z wieloma plikami muszą rozpoczynać się od deklaracji przestrzeni nazw lub modułu (np. „namespace PrzestrzenNazw.PodrzednaPrzestrzenNazw” lub „module PrzestrzenNazw.Modul”). Taka deklaracja może zostać pominięta tylko w ostatnim pliku źródłowym aplikacji.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Powiązanie nie może być oznaczone zarówno jako „use”, jak i „rec”</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w argumentach typu</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem wirtualnym, a drugi nie</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Ta notacja indeksatora została usunięta z języka F#</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Typ „{0}” jest używany w nieprawidłowy sposób. Wartość przed elementem „{1}” ma wywnioskowany typ dotyczący elementu „{2}”, który jest nieprawidłowym odwołaniem w przód.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Zduplikowana metoda. Metoda „{0}” ma taką samą nazwę i sygnaturę co inna metoda w typie „{1}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Błąd wewnętrzny lub źle sformułowane metadane: podczas importowania w zakresie była niewystarczająca liczba parametrów typu</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Niepoprawna liczba argumentów typu dla wywołania lokalnego</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>Składnia „module ... : sig .. end” nie jest używana w kodzie języka F#. Rozważ użycie składni „module ... = begin .. end”</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Oczekiwano typu interfejsu</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego, ponieważ ma standardową definicję w bibliotece języka F# dla typów stałych</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w definicji typu</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Nieprawidłowa wartość parametru „{0}” jednostki miary</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Nieprawidłowa wartość „{0}” parametru „{1}” jednostki miary</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Nieprawidłowa postać metody pobierającej właściwość. W przypadku używania jawnej składni jest wymagany co najmniej jeden argument „()”.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Podczas konfigurowania udostępnionych typów napotkano co najmniej jeden błąd</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Wyrażenia konstruktora interfejsów nie akceptują argumentów</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Nieprawidłowy poziom ostrzeżenia „{0}”</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Przypadek unii o nazwie „{0}” powoduje konflikt z wygenerowanym typem „{1}”</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Element członkowski „{0}” nie odpowiada żadnej metodzie abstrakcyjnej ani wirtualnej dostępnej do przesłonięcia lub zaimplementowania.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Nieprawidłowa konstrukcja rekordu</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nTypy pól są różne</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Nie znaleziono etykiety {0}</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Aktywny wzorzec „{0}” ma typ wyniku zawierający zmienne typu, które nie są określone przez dane wejściowe. Częstą przyczyną jest brak podanego przypadku wyniku (np. „let (|A|B|) (x:int) = A x”). Można to naprawić za pomocą ograniczenia typu (np. „let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x”)</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” wymaga argumentów w liczbie {1}, ale podano tutaj nienazwane i nazwane argumenty w liczbie wynoszącej odpowiednio {2} i {3}. Wymagana sygnatura to „{4}”.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Typ/moduł „{0}” nie jest konkretnym modułem lub typem</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- PLIKI WYJŚCIOWE -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Dostępne przeciążenia pokazano poniżej (lub w oknie Lista błędów).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>Element „{0}” jest używany z niepoprawną liczbą argumentów. Jest to niestandardowa operacja w tym zapytaniu lub wyrażeniu obliczenia. Oczekiwana liczba argumentów: {1}. Rzeczywista liczba argumentów: {2}.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>Metoda {0} nie jest metodą wystąpienia</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Ta postać wyrażenia obiektu nie jest używana w języku F#. Aby zdefiniować implementacje elementów członkowskich w wyrażeniach obiektów, użyj konstrukcji „member this.MemberName ... = ...”.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Nieoczekiwane wyrażenie w punkcie wnioskowania cyklicznego</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ abstrakcyjny element członkowski „{2}” był wymagany przez sygnaturę, ale nie został określony przez implementację</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>Dla metody lub funkcji „{0}” nie powinny być podawane jawne argumenty typu, ponieważ nie deklaruje ona jawnie swoich parametrów typu</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Typ „{0}” ma reprezentację śródwierszowego kodu zestawu</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Wartości cykliczne nie mogą być przypisywane bezpośrednio do niezmienialnego pola „{0}” typu „{1}” w powiązaniu cyklicznym. Zamiast tego rozważ użycie pola modyfikowalnego.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignoruj ostrzeżenia dotyczące zgodności z językiem ML</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Element członkowski operatora infiksu „{0}” nie ma argumentów. Oczekiwano krotka liczącej 2 argumenty, np. static member (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać definicji konkretnych elementów członkowskich. Może być konieczne zdefiniowanie konstruktora w typie, aby określić, że typ to klasa.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Brak kwalifikacji po znaku „.”</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Brak wystąpienia typu ogólnego „{0}” i nie można wywnioskować wystąpienia przy użyciu argumentów lub zwracanego typu tego elementu członkowskiego. Rozważ udostępnienie wystąpienia typu podczas uzyskiwania dostępu do tego typu (np. „{1}”).</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Aktywne identyfikatory przypadku wzorca muszą się rozpoczynać od wielkiej litery</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>Litera „h” lub „H” w tym specyfikatorze formatu jest niepotrzebna. Można zamiast tego używać specyfikatora %d, %x, %o lub %u, które są przeciążone w celu współdziałania ze wszystkimi podstawowymi typami liczb całkowitych.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>Wyrażenie w postaci „wyrażenie then wyrażenie” może być używane tylko jako część jawnego konstruktora obiektów</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Wartości „base” mogą być używane tylko w celu bezpośrednich wywołań, które dotyczą podstawowych implementacji przesłoniętych elementów członkowskich</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>To nie jest prawidłowe wyrażenie stałej lub prawidłowa niestandardowa wartość atrybutu</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Powiązanie cykliczne używa nieprawidłowej kombinacji form cyklicznych</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IComparable&lt;_&gt;”. Musisz zastosować atrybut „CustomComparison” do typu i określić spójną implementację nieogólnego interfejsu System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Nieprawidłowe przypisanie</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Koniec pliku w ciągu rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Typ funkcji pierwszoklasowej nie może zawierać typów byref</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ ma on typ funkcji</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ jest rekordem, unią lub strukturą z co najmniej jednym typem elementu strukturalnego, który nie obsługuje ograniczenia „equality”. Unikaj używania równości z tym typem lub dodaj atrybut „StructuralEquality” do typu w celu ustalenia, jaki typ pola nie obsługuje równości</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje ograniczenia „equality”, ponieważ ma on atrybut „NoEquality”</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „use!”.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Użycie składni typu „int C” i „C  &lt;int&gt;” jest tutaj niedozwolone. Rozważ dopasowanie tego typu w celu zapisania go w postaci „C&lt;int&gt;”</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Dwukrotnie ustawiono flagę prefiksu („ ” lub „+”)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Znalezione przez klucz rejestru AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Ta konstrukcja może być używana tylko w wyrażeniach sekwencji lub obliczeń</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Błąd podczas analizowania typu osadzonego obiektu IL</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Wartość literału nie może mieć atrybutu [&lt;ThreadStatic&gt;] lub [&lt;ContextStatic&gt;]</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>Zestaw „{0}” ma atrybut TypeProviderAssembly z nieprawidłową wartością „{1}”. Wartość powinna być prawidłową nazwą zestawu</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Ta wartość funkcji jest używana do utworzenia typu delegata, którego sygnatura zawiera argument byref. Musisz użyć jawnego wyrażenia lambda pobierającego następującą liczbę argumentów: {0}..</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Skróty wyjątków Common IL nie mogą pobierać argumentów</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Typ „{0}” nie jest prawidłowym typem modułu wyliczającego, czyli nie zawiera metody „MoveNext()” zwracającej wartość logiczną i właściwości „Current”</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Koniec pliku w dyrektywie rozpoczętej w tym miejscu lub przed nim</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>Format „{0}” nie obsługuje dokładności</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Konstruktory typu „{0}” muszą bezpośrednio lub pośrednio wywoływać swojego niejawnego konstruktora obiektów. Użyj wywołania niejawnego konstruktora obiektów zamiast wyrażenia rekordu.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>Operacja „{0}” nie jest używana poprawnie. Jest to operacja niestandardowa w tym zapytaniu lub wyrażeniu obliczenia.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Niedopasowany element „[&lt;”. Oczekiwano elementu zamykającego „&gt;]”</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Nieprawidłowe użycie wyrażenia „fixed”. Wyrażenia „fixed” można użyć tylko w deklaracji w postaci „use x = fixed expr”, gdzie wyrażenie jest tablicą, adresem pola, adresem elementu tablicy lub ciągiem</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Znak „{0}” jest niedozwolony w nazwie udostępnionego typu „{1}”</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Parametr statyczny „{0}” podanego typu lub podanej metody „{1}” wymaga wartości. Parametry statyczne dostawców typów mogą być opcjonalnie określane przy użyciu argumentów nazwanych (np. „{2}&lt;{3}=...&gt;”).</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Nieoczekiwany element SynMeasure.Anon</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>Element „assert” nie może być używany jako wartość pierwszoklasowa. Użyj elementu „assert &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Nie można dziedziczyć po typie zmiennej</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do przypadków unii lub pól typu „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Modyfikowalne wartości funkcji powinny mieć postać „let mutable f = (fun args -&gt; ...)”</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Tylko typy klasy mogą pobierać argumenty wartości</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Nieprawidłowy numer ostrzeżenia „{0}”</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Typ „{0}” ma niestandardowy typ delegata.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Element członkowski „{0}” nie akceptuje poprawnej liczby argumentów. Oczekiwana liczba argumentów: {1}, podano argumentów: {2}. Wymagany podpis to „{3}”.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>zmienna wzorca</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem finalnym, a drugi nie</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Delegaty nie mogą mieć sygnatur typu curried.</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Ogranicz platformy, na jakich można uruchomić ten kod: x86, Itanium, x64, anycpu32bitpreferred lub anycpu. Domyślna platforma to anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Oczekiwano jednostki miary, a nie typu</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Określ plik zasobów Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Lokalne powiązania klas nie mogą być oznaczone jako śródwierszowe. Rozważ przeniesienie definicji poza klasę lub nie oznaczaj jej jako śródwierszowej.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(niedostępny opis...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Typ „{0}” nie jest zdefiniowany w elemencie „{1}”.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Oczekiwano identyfikatora</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Nieoczekiwany token „{0}” w wyrażeniu preprocesora</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Brak dokładności po znaku „.”</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Wyrażenie cytowane nie może obejmować przypisania lub pobrania adresu przechwyconej zmiennej lokalnej</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>Opcja wiersza polecenia „{0}” jest tylko do celów testowych</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Rozważ użycie polecenia „yield!” zamiast „yield”.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Dziedziczony typ nie jest typem modelu obiektów</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Główny moduł programu jest pusty: nic się nie wydarzy po jego uruchomieniu</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Element {0} określił wersję „{1}”, ale wartość jest symbolem wieloznacznym. Żądano kompilacji deterministycznej. Te wartości powodują konflikt.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Przekazywanie pliku .resx ({0}) jako pliku źródłowego do kompilatora jest przestarzałe. Użyj programu resgen.exe, aby przekształcić plik .resx w plik .resources w celu przekazania go w opcji --resource. Jeśli używasz narzędzia MSBuild, może to zostać zrealizowane za pośrednictwem elementu &lt;EmbeddedResource&gt; w pliku projektu .fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Ścieżka „{0}” jest przestrzenią nazw. Skrót modułu nie może zawierać skrótu przestrzeni nazw.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Deklaracja może mieć określoną wartość w sygnaturze tylko wtedy, gdy deklaracja zawiera atrybut [&lt;Literal&gt;]</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Wystąpił wyjątek podczas uzyskiwania dostępu do elementu „{0}” udostępnionego typu: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Używane do wskazywania, że element członkowski jest widoczny wewnątrz zestawu, ale nie poza nim.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Nie znaleziono dyrektywy #endif dla dyrektywy #if lub #else</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Napotkano nieprawidłową sygnaturę elementu członkowskiego z powodu wcześniejszego błędu</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Nazwane pole „{0}” powoduje konflikt z automatycznie generowaną nazwą pola anonimowego.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Nieprawidłowa dyrektywa. Oczekiwano „#time”, „#time \"on\"” lub „#time \"off\"”.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w tej pozycji dla typów wyliczanych</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Atrybuty są tutaj niedozwolone</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- JĘZYK -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Nierozpoznany typ debugowania „{0}”. Oczekiwano typu „pdbonly” lub „full”</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>Po elemencie „into” należy użyć pozostałej części obliczenia</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Pierwszoklasowe użycia funkcji „reraise” są niedozwolone</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Niedopasowany znak „&lt;”. Oczekiwano znaku zamykającego „&gt;”</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera wartości „{2}”</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Ogólna funkcja „{0}” musi mieć jawne argumenty typów</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanRead=true, ale brakuje wartości z metody GetGetMethod()</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Zwracany typ metody może zawierać wartości typu byref, co jest niedozwolone</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>Zdarzenie „{0}” jest statyczne</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Ten token jest zarezerwowany do użytku w przyszłości</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>W cyklicznej grupie deklaracji deklaracje „open” muszą występować jako pierwsze w każdym module</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Udostępniony typ „{0}” zwrócił element członkowski z wartością null lub pustą nazwą elementu członkowskiego</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Zły specyfikator formatu (po l lub L): oczekiwano ld,li,lo,lu,lx lub lX. W kodzie języka F# można zamiast tego używać specyfikatorów %d, %x, %o lub %u, które są przeciążone w celu współpracy z wszystkimi podstawowymi typami liczb całkowitych.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Nieprawidłowa udostępniona wartość literału „{0}”</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Typy interfejsów nie mogą być zapieczętowane</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Literał pisany małymi literami „{0}” jest zasłaniany przez nowy wzorzec o tej samej nazwie. Tylko literały pisane wielkimi literami i literały z prefiksem modułu mogą być używane jako wzorce nazwane.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Niezdefiniowana wartość „{0}”</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Ta konstrukcja może być używana tylko w wyrażeniach list, tablic i sekwencji, na przykład w wyrażeniach „seq {{ ... }}”, „[ ... ]” lub „[| ... |]”. Generują one elementy za pomocą składni „for ... in ... do ... yield...”</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Atrybut niestandardowy musi mieć typ odwołania</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Użyto pola statycznego w miejscu, w którym jest oczekiwane pole wystąpienia</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Niedopasowany element „(”</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Nie można określić unikatowego przeciążenia dla metody „{0}” na podstawie informacji o typach przed tym punktem programu. Może być wymagana adnotacja typu.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” nie jest {1}</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Emituj informacje debugowania (krótka wersja: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>Opcja „--keyfile” przesłania atrybut „System.Reflection.AssemblyKeyFileAttribute” podany w pliku źródłowym lub dodanym module</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Przeczytaj plik odpowiedzi, aby uzyskać informacje na temat kolejnych opcji</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Niedopasowany element „{{”</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Niedopasowany element „begin”</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Nie można użyć tej definicji „let” w zapytaniu. W zapytaniach mogą być używane tylko proste definicje wartości.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Wywołano chroniony element członkowski lub używane jest słowo kluczowe „base”. Jest to dozwolone tylko w bezpośredniej implementacji elementów członkowskich, ponieważ mogą one wykraczać poza swój zakres obiektu</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Argumenty typu muszą być umieszczone w bezpośrednim sąsiedztwie nazwy typu (np. \"C&lt;'T&gt;\", a nie \"C  &lt;'T&gt;\")</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Parametry typu muszą być umieszczone w bezpośrednim sąsiedztwie nazwy typu (np. \"type C&lt;'T&gt;\", a nie     type \"C   &lt;'T&gt;\")</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Nie można usunąć niejednoznaczności spowodowanej użyciem ciągu formatu „printf”</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Błąd w wyrażeniu zwracanym dla tego słowa kluczowego „let”. Możliwe niepoprawne wcięcie.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Nie można rozpoznać niejawnego wystąpienia konstrukcji ogólnej w tym miejscu lub w jego pobliżu, ponieważ może to spowodować powstanie wielu niepowiązanych typów, na przykład „{0}” i „{1}”. Rozważ użycie adnotacji typu w celu rozwiązania niejednoznaczności</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Argumenty opcjonalne muszą występować na końcu listy argumentów po argumentach nieopcjonalnych</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Podjęto próbę analizy tego elementu jako nazwy operatora, ale analiza nie powiodła się</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Utwórz odwołanie do zestawu (krótka wersja: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Znalezione przez klucz rejestru AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>Wymagana instrukcja „get”, „set” lub „get,set”</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>Argument „{0}” nie jest prawidłowym argumentem liczby zmiennoprzecinkowej</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Opcja wiersza polecenia „{0}” jest przestarzała. Użyj opcji „{1}”.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Typ z atrybutem „CustomEquality” musi mieć jawną implementację co najmniej jednego z następujących elementów: metody „Object.Equals(obiekt)”, interfejsu „System.IEquatable&lt;_&gt;” lub interfejsu „System.Collections.IStructuralEquatable”</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Nieoczekiwany symbol {0} w wyrażeniu typu</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Nierozpoznany element docelowy atrybutu. Prawidłowe elementy docelowe atrybutu: „assembly”, „module”, „type”, „method”, „property”, „return”, „param”, „field”, „event”, „constructor”.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Brak treści funkcji</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Modyfikatory dostępności nie są tutaj dozwolone, ale podano element „{0}”.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Typy nie mogą zawierać definicji typów zagnieżdżonych</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Ostrzeżenia i komunikaty o błędzie wyróżnione kolorem</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Nieprawidłowe użycie nazwy typu</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Ta wartość nie ma prawidłowego typu metody ustawiającej właściwość</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Katalog wyszukiwania „{0}” jest nieprawidłowy</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Połącz określony zasób z tym zestawem, gdzie format informacji o zasobie to &lt;plik&gt;[,&lt;nazwa_ciągu&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Mianownik w wykładniku jednostki miary nie może być równy 0</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Deklaracja „inherit” nie może być używana w typach interfejsu. Zamiast tego rozważ zaimplementowanie interfejsu za pomocą konstrukcji „interface ... with ... end”.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Nieoczekiwany literał całkowity w wyrażeniu jednostki miary</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>Element „{0}” może być używany tylko z nazwanymi typami</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” pobiera argumenty w liczbie {1}, ale podano tutaj {2}. Wymagana sygnatura to „{3}”.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>domyślnym rozszerzeniu przypadku unii</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Ta wartość nie jest funkcją i nie można jej zastosować.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Brak specyfikatora formatu</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Wymagane jest podanie co najmniej jednego argumentu dla właściwości indeksatora</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Nierozpoznany cel „{0}”. Oczekiwano celu „exe”, „winexe”, „library” lub „module”</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>Brak instrukcji „do” w wyrażeniu „while”. Oczekiwano konstrukcji „while &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w treści wyrażenia lambda. Oczekiwano konstrukcji „fun &lt;wzorzec&gt; ... &lt;wzorzec&gt; -&gt; &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Plik dokumentacji nie ma sufiksu xml</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>Użycie konstrukcji „-&gt;” w wyrażeniach obliczenia i sekwencji jest ograniczone do postaci „for wzorzec in wyrażenie -&gt; wyrażenie”. Użyj składni „for ... in ... do ... yield...”, aby wygenerować elementy w bardziej złożonych wyrażeniach sekwencji.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Oczekiwano, że właściwość pobierająca będzie funkcją, np. „get() = ...” lub „get(indeks) = ...”</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Niezgodny cytat, począwszy od „{0}”</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 64-bitowych liczb całkowitych bez znaku</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>Nie znaleziono elementu {0} „{1}” w typie „{2}” z zestawu „{3}”. Możliwa przyczyna to niezgodność wersji. Być może trzeba jawnie odwołać się do prawidłowej wersji tego zestawu, aby zezwolić wszystkim przywoływanym składnikom na użycie prawidłowej wersji.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nParametry ogólne w sygnaturze i implementacji są różnego rodzaju. Być może brakuje atrybutu [&lt;Measure&gt;].</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Ten typ nie może być używany dla pola literału</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Włącz lub wyłącz wywołania tail</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Wyrażenia rekordów kopiowania i aktualizowania muszą zawierać co najmniej jedno pole.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Koniec pliku w ciągu osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Wymagana jest niestandardowa operacja zapytania „{0}”, ale jej nie określono</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Nieprawidłowy literał w typie</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Element członkowski „{0}” pasuje do wielu przeciążeń tej samej metody.\nOgranicz go do jednej z następujących opcji: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Jeśli typ unii ma więcej niż jeden przypadek i jest strukturą, wszystkim polom w typie unii należy nadać unikatowe nazwy.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>Właściwość „{0}” w udostępnionym typie „{1}” nie jest ani odczytywalna ani zapisywalna, ponieważ ma właściwości CanRead=false i CanWrite=false</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>wygenerowana właściwość</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Statyczne pola „val” w typach muszą być modyfikowalne, prywatne i oznaczone przy użyciu atrybutu „[&lt;DefaultValue&gt;]”. Są one inicjowane dla swoich typów przy wartości „null” lub „zero”. Rozważ też użycie powiązania „static let mutable” w typie klasy.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Ta metoda oczekuje parametru „params” infrastruktury CLI na tej pozycji. Parametr „params” umożliwia przekazywanie zmiennej liczby argumentów metodzie w językach takich jak C#. Rozważ przekazanie tablicy dla tego argumentu</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Niezainicjowane pola „val” muszą być modyfikowalne i oznaczone przy użyciu atrybutu „[&lt;DefaultValue&gt;]”. Rozważ użycie powiązania „let” zamiast pola „val”.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Udostępniony typ „{0}” ma właściwość „IsGenericType” o wartości true, ale typy ogólne nie są obsługiwane.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Wszelkie prawa zastrzeżone.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które ustawiają pola w wartościach wyjątku</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Ten literał tablicy bajtowej zawiera znaki, które nie są kodowane jako pojedynczy bajt</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Atrybuty powinny być umieszczone przed elementem „val”</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja definiuje element {2} „{3}”, ale sygnatura nie (albo definiuje w innej kolejności)</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Anonimowa jednostka miary nie może być zagnieżdżona w innym wyrażeniu jednostki miary</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>Sygnatura i implementacja nie są zgodne, ponieważ deklaracja parametru typu „{0}” wymaga ograniczenia w postaci {1}</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>typ lub moduł</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Udostępnione typy zagnieżdżone nie pobierają argumentów statycznych lub parametrów ogólnych</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Nieoczekiwany koniec danych wejściowych w wyrażeniu</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Ta deklaracja powoduje otwarcie modułu „{0}”, który jest oznaczony jako „RequireQualifiedAccess”. Dostosuj kod, aby używał odwołań kwalifikowanych do elementów modułu, na przykład „List.map” zamiast „map”. Ta zmiana pozwoli zagwarantować niezawodność kodu, gdy do bibliotek zostaną dodane nowe konstrukcje.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Ten element deklaracji nie jest dozwolony w rozszerzeniu</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Konstruktor obiektu „{0}” przyjmuje argumenty {1}, ale tutaj podano {2}. Wymagany podpis to „{3}”.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Ten nowy element członkowski ukrywa abstrakcyjny element członkowski „{0}”. Zmień nazwę elementu członkowskiego lub użyj elementu „override”.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Rodzaj typu określony przez jego atrybuty nie jest zgodny z rodzajem implikowanym przez jego definicję</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Wystąpił problem podczas zapisywania danych binarnych „{0}”: {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Niepierwotne stałe literałów liczbowych nie mogą być używane w dopasowaniach wzorców, ponieważ mogą być mapowane na wiele różnych typów przez użycie modułu NumericLiteral. Zamiast tego rozważ użycie zmiennej i użyj konstrukcji „when &lt;zmienna&gt; = &lt;stała&gt;” na końcu klauzuli dopasowania.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>Sygnatura i implementacja nie są zgodne, ponieważ parametr typu w klasie/sygnaturze ma inne wymaganie dotyczące czasu kompilacji niż parametr w elemencie członkowskim/implementacji</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Nadmiarowe argumenty są ignorowane w funkcji „{0}”. Oczekiwana liczba argumentów: {1}, rzeczywista liczba argumentów: {2}.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Atrybut niestandardowy musi wywoływać konstruktora obiektów</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>Składnia „wyrażenie.identyfikator” może być używana tylko z etykietami rekordów, właściwościami i polami</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Oczekiwano typu po tym punkcie</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Atrybut „ReferenceEquality” nie może być używany w strukturach. Rozważ użycie atrybutu „StructuralEquality” lub implementację przesłonięcia metody „System.Object.Equals(obiekt)”.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>Przesłonięcie „{0}” zawiera implementację więcej niż jednego miejsca abstrakcyjnego, na przykład „{1}” i „{2}”</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Element członkowski „{0}” nie akceptuje poprawnej liczby argumentów. Jedno przeciążenie akceptuje następującą liczbę argumentów: {1}, podano argumentów: {2}. Wymagany podpis to „{3}”.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Nazwa modułu musi być prostą nazwą, a nie ścieżką</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Aby wskazać, że można ustawić tę właściwość, użyj konstrukcji „member val NazwaWłaściwości = wyrażenie with get,set”.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Nie można znaleźć pliku FSharp.Core.dll w katalogu kompilatora</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typy mają różne typy podstawowe</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Brak przeciążeń zgodnych z metodą „{0}”.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Nie jest to konstruktor ani literał albo konstruktor jest niepoprawnie używany</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Tylko typy reprezentujące jednostkę miary mogą mieć atrybut „Measure”</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Oczekiwano argumentów elementu członkowskiego wystąpienia</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Ten kod jest mniej ogólny niż jest to wymagane przez jego adnotacje, ponieważ nie można uogólnić jawnej zmiennej typu „{0}”. Została ona ograniczona do postaci „{1}”.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Zwykle nie należy ponownie definiować operatora „{0}”. Aby zdefiniować semantykę równości dla typu, przesłoń element członkowski „Object.Equals” w definicji tego typu.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Typ z atrybutem „ReferenceEquality” nie może mieć jawnej implementacji metody „Object.Equals(obiekt)”, interfejsu „System.IEquatable&lt;_&gt;” lub interfejsu „System.Collections.IStructuralEquatable”</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>Flaga atrybutu „UseNullAsTrueValue” może być używana tylko z typami unii, które mają jeden przypadek o wartości null i co najmniej jeden przypadek o wartości innej niż null</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Niedopasowany element „begin” lub „struct”</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Przydziela wartość do zmiennej.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Koniec pliku w sekcji #if rozpoczętej w tym miejscu lub za nim</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Dopasowania zakresu znaków zostały usunięte w języku F#. Zamiast tego rozważ użycie ograniczenia wzorca „when”.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>Element #! może występować tylko jako pierwszy wiersz na początku pliku.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Nie można określać konstruktorów w rozszerzeniach wyjątków</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Udostępniony typ „{0}” ma właściwość „IsArray” o wartości true, ale typy tablicy nie są obsługiwane.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Zduplikowana właściwość. Właściwość „{0}” ma taką samą nazwę i sygnaturę co inna właściwość w typie „{1}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera modułu/przestrzeni nazw „{2}”</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Postać deklaracji „let ... and ...” dla powiązań innych niż cykliczne nie jest używana w kodzie języka F#. Rozważ użycie sekwencji powiązań „let”</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.GetHashCode” lub „Object.Equals”. Musisz zastosować atrybut „CustomEquality” do typu</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Nieprawidłowe użycie konstruktora delegatów. Użyj składni „new Typ(argumenty)” lub „Typ(argumenty)”..</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>Sygnatura i implementacja nie są zgodne, ponieważ parametr typu „{0}” ma ograniczenie w postaci {1}, ale nie ma go implementacja. Usuń to ograniczenie z sygnatury lub dodaj je do implementacji.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Zestaw „{0}”, którego dotyczy odwołanie, ma atrybut poziomu zestawu „{1}”, ale nie znaleziono publicznych klas dostawcy typów</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Raportuj wszystkie ostrzeżenia jako błędy</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>Znaki TAB są niedozwolone w kodzie języka F#, chyba że użyto opcji #indent \"off\"</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Nieprawidłowy argument statyczny udostępnionego typu. Oczekiwano argumentu rodzaju: „{0}”.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Wartości modyfikowalne nie mogą być oznaczone jako „inline”</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Więcej niż jedno przesłonięcie zawiera implementację elementu „{0}”</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Nie można utworzyć wystąpień tego typu, ponieważ został on oznaczony jako abstrakcyjny lub nie wszystkie metody mają implementacje. Zamiast tego rozważ użycie wyrażenia obiektu „{{ new ... with ... }}”.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>W cyklicznej grupie deklaracji skróty modułu muszą następować po wszystkich deklaracjach „open” i przed innymi deklaracjami</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Używane jako krótsza alternatywa słowa kluczowego fun i wyrażenie dopasowania w wyrażeniu lambda, które ma wzorzec pasujący do pojedynczego argumentu.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy skompilowane są różne</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>To nie jest prawidłowe wyrażenie konstrukcji obiektu. Jawne konstruktory obiektów muszą wywoływać konstruktora alternatywnego lub inicjować wszystkie pola obiektu i określić wywołanie konstruktora superklasy.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Nierozpoznana platforma „{0}”. Prawidłowe wartości to „x86”, „x64”, „Itanium”, „anycpu32bitpreferred” i „anycpu”</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Element „new” nie może być używany w typach interfejsów. Zamiast tego rozważ użycie wyrażenia obiektu „{{ new ... with ... }}”.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ skrót jest ukrywany przez sygnaturę. Skrót musi być widoczny dla innych języków infrastruktury CLI. Rozważ zapewnienie widoczności skrótu w sygnaturze.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Nieprawidłowa forma metody ustawiającej właściwości. Wymagany jest co najmniej jeden argument.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Nie można używać wyrażeń „let!”, „use!” i „do!” w zapytaniach</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Koniec pliku w ciągu dosłownego wyrażenia rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>To pole jest tylko do odczytu</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Nie można zdekodować atrybutu StructLayout</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Typ „{0}” nie jest typem delegata infrastruktury CLI.</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>To wyrażenie nie jest funkcją i nie można go zastosować. Czy zamiast tego zamierzano uzyskać dostęp do indeksatora przy użyciu formatu wyrażenie.[indeks]?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Zamień na element „{0}”</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do pola struktury lub klasy „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Używane w wyrażeniach obliczenia do dołączania wyniku danego wyrażenia obliczenia do kolekcji wyników dla zawartego wyrażenia obliczenia.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie „{0}”</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Dla tego parametru typu nie można utworzyć wystąpienia jako „Nullable”. Jest to ograniczenie nałożone w celu zapewnienia, że znaczenie wartości „null” w niektórych językach infrastruktury CLI nie zostanie niewłaściwie określone podczas używania w połączeniu z wartościami „Nullable”.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Implementacja pliku lub modułu „{0}” została już podana</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Dostawca typów „{0}” udostępnił konstruktor, który nie został zgłoszony wśród konstruktorów jego typu deklarującego „{1}”</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Interfejsy dziedziczone przez inne interfejsy powinny być deklarowane przy użyciu ciągu „inherit ...” zamiast ciągu „interface ...”</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Funkcja z etykietą i atrybutem „EntryPointAttribute” musi być ostatnią deklaracją w ostatnim pliku sekwencji kompilacji.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Typ rekordu „{0}” nie zawiera etykiety „{1}”.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Niezamknięty blok</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Nie odnaleziono tej właściwości pola w tym niestandardowym typie atrybutu</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Przestrzeń nazw i moduł o nazwie „{0}” występują w dwóch częściach tego zestawu</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Określ profil platformy docelowej tego zestawu. Prawidłowe wartości to mscorlib, netcore i netstandard. Wartość domyślna to mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>Począwszy od wersji F# 4.1, dostępność skrótów typów jest sprawdzana w czasie kompilacji. Rozważ sprawdzenie dostępności skrótu typu. Zignorowanie tego ostrzeżenia może prowadzić do błędów w czasie wykonywania.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>Dyrektywa #endif musi występować jako pierwszy znak wiersza, który nie jest odstępem</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Nieprawidłowa struktura elementu RSAParameters — oczekiwano „{{0}}”</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” nie obsługuje równości strukturalnej, ponieważ parametr typu {1} nie spełnia ograniczenia „equality”. Rozważ dodanie atrybutu „NoEquality” do typu „{2}” w celu określenia, że typ nie obsługuje równości strukturalnej</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” nie obsługuje równości strukturalnej, ponieważ typ „{1}” nie spełnia ograniczenia „equality”. Rozważ dodanie atrybutu „NoEquality” do typu „{2}” w celu określenia, że typ nie obsługuje równości strukturalnej</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Ten atrybut jest nieprawidłowy do użycia w tym elemencie języka. Atrybuty zestawu powinny być dołączone do deklaracji „do ()” (w module języka F#, jeśli to konieczne).</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Zmienne ze statycznymi wątkami i kontekstami muszą być statyczne i mieć określony atrybut [&lt;DefaultValue&gt;] w celu określenia, że wartość została zainicjowana w każdym nowym wątku przy użyciu wartości domyślnej</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Nie można użyć adresu elementu tablicy w tym momencie</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Błąd składni: nieoczekiwana specyfikacja parametru typu</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Nie można zdekodować atrybutu DefaultAugmentation</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Typ pola używający atrybutu „DefaultValue” musi przyjąć domyślne inicjowanie (np. mieć wartość „null” jako poprawną wartość lub być typem struktury, którego wszystkie pola przyjmują domyślne inicjowanie). Aby wyłączyć to sprawdzenie, można użyć atrybutu „DefaultValue(false)”</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Używane do implementowania wersji metody abstrakcyjnej lub wirtualnej, która różni się od wersji podstawowej.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Nieoczekiwany wyjątek udostępnionego typu „{0}”. Element członkowski: „{1}”: {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Zmienna typu została ograniczona przez wiele różnych typów klasy. Zmienna typu może mieć tylko jedno ograniczenie klasy.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Ta udostępniona metoda wymaga parametrów statycznych</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Nie zdefiniowano konstruktora, modułu lub przestrzeni nazw „{0}”.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Ten typ nie jest dostępny z tej lokalizacji kodu</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Atrybuty tego typu określają wiele rodzajów typu</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Ta operacja uzyskuje dostęp do modyfikowalnej wartości najwyższego poziomu zdefiniowanej w innym zestawie w nieobsługiwany sposób. Nie można uzyskiwać dostępu do wartości za pośrednictwem jej adresu. Rozważ skopiowanie wyrażenia do modyfikowalnej wartości lokalnej, na przykład „let mutable x = ...”, i w razie potrzeby ponowne przypisanie wartości po ukończeniu operacji</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „try”. Oczekiwano konstrukcji „try &lt;wyrażenie&gt; with &lt;reguły&gt;” lub „try &lt;wyrażenie&gt; finally &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „for”. Oczekiwana wartość: „for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;”.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacje są różne</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać tego rodzaju dopasowania wzorca</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Nieoczekiwany koniec typu. Oczekiwano nazwy po tym punkcie.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Dostawca typów „{0}” zgłosił błąd: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Generowanie pliku MDB nie powiodło się. Nie można znaleźć zgodnego elementu członkowskiego {0}</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Skróty typów nie mogą mieć deklaracji interfejsów</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>Atrybut „StructuralEquality” musi być używany w połączeniu z atrybutami „NoComparison” lub „StructuralComparison”</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Operatory łączenia wyrażenia mogą być używane tylko w cudzysłowach</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>Dyrektywa #endif nie ma zgodnej dyrektywy #if</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Ten atrybut jest nieprawidłowy do użycia w tym elemencie języka</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Generuj operacje sprawdzenia przepełnienia</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Swobodnie dystrybuowane na licencji MIT Open Source.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” nie pobiera argumentów w liczbie {1}. Znaleziono przesłonięcie pobierające argumenty o następującej liczbie: {2}.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Atrybut zestawu „{0}” odwołuje się do zestawu projektanta „{1}”, którego nie można załadować lub który nie istnieje. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Nieoczekiwany wyjątek elementu członkowskiego „{0}” udostępnionego typu „{1}”. Element członkowski: „{2}”: {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Dostawca typów zaimplementował funkcję GetStaticParametersForMethod, lecz funkcja ApplyStaticArgumentsForMethod nie jest zaimplementowana lub jest nieprawidłowa</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- ZASOBY -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Kod w tym zestawie używa literałów cytatu. Statyczne połączenie nie może obejmować składników, które używają literałów cytatu, chyba że wszystkie zestawy są kompilowane przy użyciu języka F# w wersji co najmniej 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>Element „{0}” musi występować po klauzuli wyboru „for” i przed pozostałą częścią zapytania. Składnia: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>Opcja „--delaysign” przesłania atrybut „System.Reflection.AssemblyDelaySignAttribute” podany w pliku źródłowym lub dodanym module</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Pobieranie adresu pola literału jest nieprawidłowe</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb całkowitych ze znakiem</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Niedopasowany element „[|”</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” nie jest {1}. Prywatne elementy członkowskie mogą być dostępne tylko w obrębie typu deklarującego. Chronione elementy członkowskie mogą być dostępne tylko z poziomu typu rozszerzającego. Nie można uzyskać do nich dostępu z poziomu wewnętrznych wyrażeń lambda.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Metoda nie jest statyczna lub konstruktor obiektu „{0}” nie jest statyczny</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>Kod w zestawie „{0}” używa literałów cytatu. Statyczne połączenie nie może obejmować składników, które używają literałów cytatu, chyba że wszystkie zestawy są kompilowane przy użyciu języka F# w wersji co najmniej 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>Nazwa „{0}” nie jest prawidłową nazwą pliku</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Podpisz zestaw na użytek publiczny za pomocą tylko publicznej części klucza o silnej nazwie i oznacz zestaw jako podpisany</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 16-bitowych liczb całkowitych bez znaku</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Dostawca typów „{0}” zwrócił nieprawidłowy typ z metody „ApplyStaticArguments”. Oczekiwano typu o nazwie „{1}”, ale został zwrócony typ o nazwie „{2}”.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Modyfikowalna wartość lokalna „{0}” jest niejawnie przydzielona jako komórka odwołania, ponieważ została przechwycona przez zamknięcie. To ostrzeżenie informuje tylko o miejscach, w których są wykonane niejawne operacje przydzielania.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>W kodzie języka F# możesz użyć konstrukcji „expr.[expr]”. Adnotacja typu może być wymagana do wskazania, że pierwsze wyrażenie to tablica</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać definicji konstruktorów obiektów</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Nieprawidłowa wersja „{0}” dla opcji „--subsystemversion”. Wymagana jest wersja 4.00 lub nowsza.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Nazwane argumenty muszą występować po wszystkich pozostałych argumentach</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>Zmienna „{0}” jest powiązana w wyrażeniu cytowanym, ale jest używana jako część połączonego wyrażenia. Jest to niedozwolone, ponieważ może spowodować wykroczenie zmiennej poza jej zakres.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „enum” w tym miejscu lub w jego pobliżu</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Nie ma katalogu sygnatury</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Nieoczekiwany operator infiksu w wyrażeniu jednostki miary. Dozwolone operatory: „*”, „/” i „^”.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>właściwość</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Nie można odziedziczyć zapieczętowanego typu</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Ta konstrukcja jest niejednoznaczna jako część wyrażenia sekwencji. Zagnieżdżone wyrażenia mogą zawierać ciąg „let _ = (...)”, a zagnieżdżone sekwencje mogą zawierać ciąg „yield! seq {{... }}”.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IStructuralEquatable”. Zastosuj atrybut „CustomEquality” do typu.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Ten element członkowski jest niedozwolony w implementacji obiektu</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Zaimportowany zestaw używa typu „{0}”, który nie jest publiczny</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- RÓŻNE -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Moduł/przestrzeń nazw „{0}” z jednostki kompilacji „{1}” nie zawiera modułu, przestrzeni nazw lub typu „{2}”</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Rezydentna usługa kompilacji nie została użyta, ponieważ wystąpił problem z komunikowaniem się z serwerem.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Deklaracja pola/wartości nie jest tutaj dozwolona</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Ograniczenia „new” muszą pobierać jeden argument typu „unit” i zwracać utworzony typ</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Użyj rezydentnej usługi kompilacji działającej w tle w celu poprawienia czasów uruchamiania kompilatora.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Nieprawidłowe ograniczenie</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja wskazuje, że ten typ może używać wartości null jako reprezentacji, ale sygnatura tego nie wskazuje</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Wystąpił błąd podczas stosowania argumentów statycznych dla podanej metody</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Osadź określony zasób zarządzany</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Nie można odnaleźć metody System.Runtime.CompilerServices.OffsetToStringData w odwołaniach podczas kompilowania wyrażenia „fixed”.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Element członkowski i lokalne powiązanie klasy mają tę samą nazwę („{0}”)</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>Element „{0}” musi występować przed nazwą zmiennej. Użycie: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Ten test typu z udostępnionym typem „{0}” nie jest dozwolony, ponieważ ten udostępniony typ zostanie wymazany do typu „{1}” w środowisku uruchomieniowym.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja jest klasą abstrakcyjną, ale sygnatura nią nie jest. Rozważ dodanie atrybutu [&lt;AbstractClass&gt;] do sygnatury.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Niezgodność długości argumentów</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Ta wartość nie jest funkcją i nie można jej zastosować. Czy deklaracja została zakończona?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Nie można zaimplementować elementu „{1}” przy użyciu elementu członkowskiego „{0}”. Wymagana sygnatura: „{2}”.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Ten typ implementuje ten sam interfejs w różnych ogólnych utworzonych wystąpieniach „{0}” i „{1}”. Nie jest to dozwolone w tej wersji języka F#.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>Opcja „--keycontainer” przesłania atrybut „System.Reflection.AssemblyNameAttribute” podany w pliku źródłowym lub dodanym module</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Typ systemowy „{0}” był wymagany, ale żadna z przywoływanych systemowych bibliotek DLL nie zawierała tego typu</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Używane do wskazywania wyrażenia obliczenia, które po obliczeniu udostępnia wynik zawartego wyrażenia obliczenia.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Element członkowski operatora infiksu „{0}” ma dodatkowe argumenty curried. Oczekiwano krotki liczącej 2 argumenty, np. static member (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Ten element członkowski nie jest dozwolony w implementacji interfejsu</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Element członkowski operatora infiksu „{0}” ma następującą liczbę argumentów początkowych: {1}. Oczekiwano krotki liczącej 3 argumenty</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>Atrybut FieldOffset można umieścić tylko w elementach członkowskich o typie oznaczonym przy użyciu atrybutu StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Konstruktor nie może zawierać jawnych parametrów typu. Zamiast tego rozważ użycie statycznej metody konstrukcji.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanRead=false, ale metoda GetGetMethod() zwróciła metodę</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>W zapytaniach element „{0}” musi używać prostego wzorca</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Nieoczekiwana wartość Const_bytearray</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Nieoczekiwany element Expr.TyChoose</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w elementach członkowskich obiektu</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>Metoda „{0}” ma argumenty curried i taką samą nazwę co inna metoda w typie „{1}”. Nie można przeciążać metod z argumentami curried. Rozważ użycie metody pobierającej argumenty w postaci krotki.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Element {0} określił wersję „{1}”, ale ta wartość jest nieprawidłowa i została zignorowana</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Nie można użyć parametru typu jako konstruktora typów</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Zmienne modyfikowalne nie mogą opuścić swojej metody</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Deklaracje miary mogą mieć tylko statyczne elementy członkowskie</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Zwykle nie należy ponownie definiować operatora „{0}”. Rozważ użycie innej nazwy operatora</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Wartość z podanym typem byref „{0}” nie może być używana w tym momencie</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Nie można znaleźć katalogu wyszukiwania „{0}”</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Ta konstrukcja jest niejednoznaczna jako część wyrażenia obliczenia. Zagnieżdżone wyrażenia mogą zawierać ciąg „let _ = (...)”, a zagnieżdżone obliczenia mogą zawierać ciąg „let! wynik = konstruktor {{ ... }}”.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura definiuje element {2} „{3}”, ale implementacja nie (albo definiuje w innej kolejności)</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Pełna nazwa</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Komunikaty z w pełni kwalifikowanymi ścieżkami</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole {2} było obecne w implementacji, ale nie w sygnaturze</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Nie kopiuj pliku FSharp.Core.dll wraz z utworzonymi plikami binarnymi</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Ogólna konstrukcja wymaga, aby typ „{0}” był typem niezarządzanym</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.Equals”. Rozważ zaimplementowanie zgodnego przesłonięcia dla elementu „Object.GetHashCode()”</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Jawne deklaracje typów w przypadku konstruktorów muszą mieć postać „typ1 * ... * typN -&gt; typWynikowy”. Może być konieczne ujęcie elementu „typWynikowy” w nawiasy</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Używane do wskazywania, że funkcja jest cykliczna.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Używane w podpisie do wskazywania wartości lub w typie do deklarowania elementu członkowskiego w pewnych określonych sytuacjach.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Używane zamiast instrukcji let na potrzeby wartości, które wymagają wywołania operacji Dispose w celu zwolnienia zasobów.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Używane do wprowadzania bloku kodu, który może generować wyjątek. Używane razem ze słowem kluczowym with lub finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Używane do deklarowania, definiowania lub wywoływania konstruktora, który tworzy lub może utworzyć obiekt. Używane również w ograniczeniach parametrów ogólnych do wskazywania, że typ musi mieć określonego konstruktora.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>To nie jest naprawdę słowo kluczowe. Struktura not w kombinacji jest jednak używana w ograniczeniach parametrów ogólnych.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Używane do kojarzenia lub powiązywania nazwy z wartością lub funkcją.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Używane w wyrażeniach lambda, znane również jako funkcje anonimowe.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Używane w konstrukcjach zapętlenia.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>W definicjach typu i rozszerzeniach typu wskazuje koniec sekcji definicji elementów członkowskich. W składni pełnej używane do określania końca bloku kodu rozpoczynającego się słowem kluczowym begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Metoda pobierająca i metoda ustawiająca właściwość muszą mieć taki sam typ. Właściwość „{0}” ma metodę pobierającą typu „{1}”, a metodę ustawiającą typu „{2}”.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Liczba argumentów typu nie jest zgodna. Podana liczba: „{0}”; oczekiwana liczba: „{1}”. Może to być związane z wcześniej zgłoszonym błędem.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>To pole wymaga nazwy</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>wygenerowany typ</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Nieprawidłowy ciąg wersji „{0}”</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Nie można tutaj określać argumentów typu</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem natywnych liczb całkowitych ze znakiem</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Ten test typu lub to przypisanie elementu podrzędnego spowoduje wymazanie podanego typu „{0}” w typie „{1}”</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Deklaracje „inherit” nie mogą mieć powiązań „as”. Aby uzyskać dostęp do elementów członkowskich klasy podstawowej podczas przesłaniania metody, można użyć składni „base.ElementCzłonkowski”. „base” to słowo kluczowe. Usuń to powiązanie „as”.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Używane do deklarowania delegata.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Nie znaleziono metody lub konstruktora obiektów „{0}”</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Zła szerokość w specyfikatorze formatu</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Typy z atrybutem „AllowNullLiteral” mogą dziedziczyć tylko po typach, które również zezwalają na używanie literału o wartości null, lub zawierać ich implementację</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Inicjator statyczny wymaga argumentu</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Błąd składni — nieoczekiwany symbol „?”</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Nieprawidłowe użycie typu interfejsu</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Kolejne wzorce powinny być oddzielone spacjami lub mieć postać krotek</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>Wymagana sygnatura to {0}</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>Metoda System.Environment.Exit nie została zakończona</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Statyczne wyrażenia warunkowe optymalizacji mogą być używane tylko w bibliotece języka F#</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Wszystkie elementy wyrażenia konstruktora tablicy muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Zadeklarowany parametr typu „{0}” nie może być tutaj używany, ponieważ nie można rozpoznać parametru typu w czasie kompilacji</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>Nazwa „{0}” nie jest prawidłową nazwą zestawu</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>To nie jest prawidłowa nazwa aktywnego wzorca</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>W wyrażeniu „if” brakuje gałęzi „else”. Gałąź „then” ma typ „{0}”. Jako że „if” jest wyrażeniem, a nie instrukcją, dodaj gałąź „else”, która będzie zwracać wartość tego samego typu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w sygnaturze typu</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Zduplikowana metoda. Metoda „{0}” ma taką samą nazwę i sygnaturę co inna metoda w typie „{1}”.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Ta metoda ma zbyt wiele ograniczeń w parametrach typu</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Brak zmiennej „{0}”</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności nie są dozwolone w typach śródwierszowego kodu zestawu</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Odbite definicje nie mogą używać operatora łączenia prefiksu „%”</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Jednostki miary nie mogą być używane jako argumenty prefiksu typu. Zapisz je ponownie jako argumenty postfiksowe w nawiasach ostrych.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Ograniczenia „struct” i „not struct” nie są spójne</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Ten wzorzec literału nie przyjmuje argumentów</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Nieprawidłowa składnia deklaracji</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Żaden z typów „{0}” nie obsługuje operatora „{1}”</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Typy delegatów są zawsze zapieczętowane.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Oczekiwano wyrażenia po tym punkcie</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Typ „{0}” jest mniej dostępny niż wartość, element członkowski lub typ „{1}”, w którym jest używany.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Utwórz zestaw deterministyczny (łącznie z sygnaturą czasową i identyfikatorem GUID wersji modułu)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Nieoczekiwana wartość zwracana „null” udostępnionego typu „{0}”. Element członkowski: „{1}”</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Nie można odnaleźć elementu Dispose w interfejsie IDisposable lub jest on przeciążony</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Nierozpoznane ustawienie prywatności „{0}” dla zasobu zarządzanego. Prawidłowe opcje to „public” i „private”</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Nie można użyć konstrukcji śródwierszowej dla wartości oznaczonej jako „inline”</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Ogólna konstrukcja wymaga, aby typ „{0}” miał publiczny konstruktor domyślny</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>Element {0} nie jest elementem członkowskim wystąpienia</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać tego rodzaju stałej</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Dostawca typów „{0}” użył nieprawidłowego parametru w elemencie ParameterExpression: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Ogólny element członkowski „{0}” został użyty w niejednolitym utworzeniu wystąpienia przed tym punktem programu. Rozważ zmianę kolejności elementów członkowskich, aby ten element członkowski występował jako pierwszy. Możesz też jawnie określić pełny typ elementu członkowskiego, łącznie z typami argumentów, zwracanym typem i wszelkimi dodatkowymi ogólnymi parametrami i ograniczeniami.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Typ będzie przechowywać wartość typu byref. Nie jest to dozwolone przez język Common IL.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Nie określono żadnych plików implementacji</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nFlagi śródwierszowe są różne</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Nieprawidłowa nazwa przestrzeni nazw, modułu, typu lub przypadku unii</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Skróty typów nie mogą mieć elementów członkowskich</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>Deklaracja „rec” tego modułu jest określona niejawnie przez zewnętrzną deklarację „rec” i zostanie zignorowana</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Ten typ nie jest typem rekordu. Wartości typów klas i struktur muszą zostać utworzone przy użyciu wywołań konstruktorów obiektów.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Oczekiwany jest typ obsługujący operator „{0}”, ale podano typ funkcji. Być może brakuje argumentu funkcji.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Przestrzenie nazw nie mogą zawierać wartości. Rozważ użycie modułu zawierającego deklaracje wartości.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Dla typu delegata nie znaleziono metod Invoke.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Niekompletna instrukcja warunkowa. Oczekiwano konstrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Operacja niestandardowa nie może być używana razem z operatorem „use”, „try/with”, „try/finally”, „if/then/else” lub „match” w tym wyrażeniu obliczenia</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>Atrybut „StructuralComparison” musi być używany w połączeniu z atrybutem „StructuralEquality”</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Nieprawidłowe użycie słowa kluczowego „rec”</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Wyliczenia nie mogą zawierać elementów członkowskich</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>Nie zdefiniowano etykiety rekordu lub przestrzeni nazw „{0}”.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą używać wyrażeń ogólnych</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Opcja wiersza polecenia „{0}” jest przestarzała</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Używane w asynchronicznych przepływach pracy do powiązywania nazwy z wynikiem obliczenia asynchronicznego lub w innych wyrażeniach obliczenia do powiązywania nazwy z wynikiem, którego typ to obliczenie.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Wywołania</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>Dyrektywa #else nie jest zgodna z dyrektywą #if</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Użyj do przesłonięcia miejsca, w którym kompilator szuka pliku mscorlib.dll i składników struktury</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” pobiera argumenty typu w liczbie {1}, ale podano tutaj {2}. Wymagana sygnatura to „{3}”.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>Nie znaleziono elementu {0} „{1}” w zestawie „{2}”. Możliwa przyczyna to niezgodność wersji. Być może trzeba jawnie odwołać się do prawidłowej wersji tego zestawu, aby zezwolić wszystkim przywoływanym składnikom na użycie prawidłowej wersji.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Niedozwolona składnia w wyrażeniu typu</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem tego typu liczb całkowitych</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Aktywny wzorzec „{0}” nie jest funkcją</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>Właściwość „{0}” typu „{1}” ma metodę pobierającą i metodę ustawiającą, które są niezgodne. Jeśli jedna z nich jest abstrakcyjna, druga również musi taka być.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>W zapytaniach użyj formy „for x in n .. m do ...” w celu określenia zakresu liczb całkowitych</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Koniec pliku w ciągu z potrójnym cudzysłowem rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Nieoczekiwany koniec danych wejściowych w definicji wartości, funkcji lub elementu członkowskiego</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Konstruktor obiektu „{0}” przyjmuje argumenty {1}, ale tutaj podano {2}. Wymagany podpis to „{3}”. Jeśli niektóre z argumentów mają przypisywać wartości do właściwości, rozważ rozdzielenie tych argumentów za pomocą przecinka („,”).</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>Element „{0}” należy zastosować do argumentu typu „{1}”, jednak został on zastosowany do argumentu typu „{2}”</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Nie można utworzyć rozszerzenia zapieczętowanego typu</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Nie znaleziono zgodnego tokenu „in” dla tego tokenu „let”</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Atrybut widoczności „{0}” nie jest dozwolony w skrócie modułu. Skróty modułu zawsze są prywatne.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Typ z atrybutem „NoComparison” nie powinien zwykle mieć jawnej implementacji interfejsu „System.IComparable”, interfejsu „System.IComparable&lt;_&gt;” lub interfejsu „System.Collections.IStructuralComparable”. Wyłącz to ostrzeżenie, jeśli jest to zamierzone do celów związanych z międzyoperacyjnością</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Ta konstrukcja może być używana tylko w wyrażeniach obliczeń. Aby zwrócić wartość ze zwykłej funkcji, wpisz wyrażenie bez wyrazu „return”.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Definicje właściwości nie mogą być deklarowane jako modyfikowalne. Aby wskazać, że można ustawić tę właściwość, użyj konstrukcji „member val NazwaWłaściwości = wyrażenie with get,set”.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- ZAAWANSOWANE -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „static” są różne</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>skompilowanej postaci przypadku unii</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Niepowodzenie rozpoznania zestawu w tej lokalizacji lub w jej pobliżu</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne z powodu różnej kolejności pól w sygnaturze i implementacji</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Abstrakcyjne elementy członkowskie nie są dozwolone w rozszerzeniu — muszą być zdefiniowane w ramach samego typu</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w rozgałęzieniu „then” wyrażenia warunkowego. Oczekiwano konstrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „match” lub „try”</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Nieoczekiwany koniec danych wejściowych w rozgałęzieniu „else” wyrażenia warunkowego. Oczekiwano instrukcji „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt;” lub „if &lt;wyrażenie&gt; then &lt;wyrażenie&gt; else &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Podczas tworzenia wartości rekordu nie można określić żadnych argumentów</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Identyfikatory zawierające znak „@” są zarezerwowane do użytku podczas generowania kodu języka F#</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Nie można tutaj użyć tego odnośnika</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Elementy członkowskie stanowiące rozszerzenie typu interfejsu, delegata lub wyliczenia muszą znajdować się w innym module niż ten, w którym znajduje się definicja typu. Ten moduł musi mieć atrybut AutoOpen lub musi zostać jawnie otwarty przez kod klienta w celu uwzględnienia elementów członkowskich rozszerzeń w zakresie.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Implementacje interfejsów nie mogą być określane w wyrażeniach konstrukcji</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Ten kod nie jest wystarczająco ogólny. Nie można uogólnić zmiennej typu {0}, ponieważ wykroczy ona poza swój zakres.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Koniec pliku w sekcji IF-OCAML rozpoczętej w tym miejscu lub przed nim</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Tylko klasy mogą mieć atrybut „AbstractClass”</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>Typ „System.Void” może być używany w języku F# tylko w postaci „typeof&lt;System.Void&gt;”</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>Składnia „(typ,...,typ) ident” nie jest używana w kodzie języka F#. Rozważ użycie składni „ident&lt;typ,...,typ&gt;”</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Typy struktur nie mogą zawierać abstrakcyjnych elementów członkowskich</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Ten nowy element członkowski ukrywa abstrakcyjny element członkowski „{0}” po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów. Zmień nazwę elementu członkowskiego lub użyj elementu „override”.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Nieoczekiwane dekodowanie elementu InterfaceDataVersionAttribute</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Reguły oddzielające tokeny „|” tego dopasowania wzorca są niewłaściwie wyrównane o jedną kolumnę. Rozważ ponowne wyrównanie kodu lub użycie dodatkowego wcięcia.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nLiczba argumentów nie została wywnioskowana dla tej wartości</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Nieoczekiwana specyfikacja właściwości poziomu źródła w drzewie składni</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Określono wartości dodatkowych pól</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Używane do konwertowania na typ znajdujący się niżej w łańcuchu dziedziczenia.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nDla co najmniej jednego argumentu jest wymagany typ krotki. Rozważ ujęcie danych argumentów w dodatkowy nawias lub przejrzenie definicji interfejsu.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Nieoczekiwana duża stała wymierna</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Nieprawidłowy format obrazu</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Znaleziono pustą przestrzeń nazw od dostawcy typów „{0}”. Użyj wartości „null” dla globalnej przestrzeni nazw.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nNazwy są różne</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} zmienna in kolekcja {1} (klucz_zewnętrzny = klucz_wewnętrzny). Pamiętaj, że po elemencie „{2}” wymagane są nawiasy</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>Oczekiwano konstrukcji „in” lub „=”</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Nieoczekiwane dekodowanie elementu InternalsVisibleToAttribute</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Niepełne wyrażenie preprocesora</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: opóźnione</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Bezpośrednie odwołanie do wygenerowanego typu „{0}” jest niedozwolone. Użyj definicji typu (np. „type AliasTypu = &lt;ścieżka&gt;”). Wskazuje to, że dostawca typów dodaje wygenerowane typy do używanego zestawu.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Błąd składni. Niewłaściwie zagnieżdżona dyrektywa #endif, przed którą występują nieoczekiwane tokeny.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Włącz określone ostrzeżenia, które domyślnie mogą być wyłączone</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} jest wzorcem aktywnym i nie można go traktować jako przypadku unii rozłącznej z nazwanymi polami.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Typy rekordów są zawsze zapieczętowane</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Nieprawidłowa sygnatura elementu członkowskiego ustawiania</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>Wyrażenia „while” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Nie jest to prawidłowy literał znakowy</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Zwracane wartości nie mogą mieć nazw</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Nie można dziedziczyć po dostarczonym wymazanym typie</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Dostawca „{0}” zwrócił niegenerowany typ „{1}” w kontekście zestawu wygenerowanych typów. Rozważ dostosowanie dostawcy typów tak, aby zwracał tylko wygenerowane typy.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Ograniczenie „enum” musi mieć postać „enum&lt;typ&gt;”</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest abstrakcyjny, a drugi nie</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. Aby zdefiniować semantykę równości dla typu, przesłoń element członkowski „Object.Equals”. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków infrastruktury CLI użyj nazwy „{1}”.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem literałów dziesiętnych</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>Wystąpił błąd podczas odczytu metadanych języka F# zestawu „{0}”. Wykorzystano zarezerwowaną konstrukcję. Konieczne może być uaktualnienie kompilatora języka F# lub użycie starszej wersji zestawu, która nie korzysta z tej konkretnej konstrukcji.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Zbyt wiele parametrów statycznych. Oczekiwano co najwyżej następującej liczby parametrów: {0}, ale uzyskano następującą liczbę parametrów nienazwanych i nazwanych: {1} i {2} .</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Symbol „=” nie może następować po deklaracji „namespace”</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Typy System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate i System.Array nie mogą być używane jako supertypy w wyrażeniu obiektu lub klasie.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Ten plik zawiera wiele deklaracji w postaci „module PrzestrzeńNazw.Moduł”. W pliku dozwolona jest tylko jedna deklaracja o takiej postaci. Zmień plik w celu użycia początkowej deklaracji przestrzeni nazw i/lub zastosuj konstrukcję „module NazwaModułu = ...” do zdefiniowania własnych modułów.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Nie można dziedziczyć po typie interfejsu. Zamiast tego użyj konstrukcji interface ... with.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Włącz lub wyłącz optymalizacje między modułami</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Używane w wyrażeniach zapytania do określania, które pola lub kolumny będą wyodrębniane. Należy pamiętać, że jest to kontekstowe słowo kluczowe, co oznacza, że nie jest to naprawdę słowo zastrzeżone i działa jako słowo kluczowe tylko w odpowiednim kontekście.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>Adres pola „{0}” nie może być używany w tym momencie</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „unmanaged” w tym miejscu lub w jego pobliżu</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Ta definicja typu może nie zawierać atrybutu „CLIMutable”. Tylko typy rekordów mogą zawierać ten atrybut.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 64-bitowych liczb całkowitych ze znakiem</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w polach wyliczanych</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ liczba elementów {2} jest różna</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Nieprawidłowe rozszerzenie typu</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problem z nazwą pliku „{0}”: {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>Dyrektywa #endif jest wymagana dla dyrektywy #else</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Używane do deklarowania typu struktury, w ograniczeniach parametrów ogólnych oraz na potrzeby zgodności OCami w definicjach modułu.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Używane do wskazywania metody lub właściwości, którą można wywołać bez wystąpienia typu, lub elementu członkowskiego wartości, który jest udostępniany wszystkich wystąpieniom typu.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>Atrybut „EntryPointAttribute” może być używany tylko w definicjach funkcji w modułach</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Wartość domyślna nie ma takiego samego typu jak argument. Atrybut DefaultParameterValue i wszelkie atrybuty Optional zostaną zignorowane. Uwaga: dla wartości „null” należy użyć adnotacji z poprawnym typem, np. „DefaultParameterValue(null:obj)”.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Niepoprawne ogólne tworzenie wystąpienia. Żaden element członkowski {0} o nazwie „{1}” nie pobiera {2} argumentów ogólnych.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Przestrzenie nazw nie mogą zawierać elementów członkowskich rozszerzeń, z wyjątkiem grupy deklaracji pliku i przestrzeni nazw, w których zdefiniowano dany typ. Rozważ użycie modułu zawierającego deklaracje elementów członkowskich rozszerzeń.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Używane do wskazywania wartości do podania jako wyniku wyrażenia obliczenia.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do wartości „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Wcięcie tego tokenu „in” jest niepoprawne w odniesieniu do odpowiadającego tokenu „let”</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Typ „{0}” jest tutaj wymagany i niedostępny. Musisz dodać odwołanie do zestawu „{1}”.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>Operator „{0}” nie akceptuje elementu „into”</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>Element {0} nie jest statycznym elementem członkowskim</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Zmienne typów anonimowych nie są dozwolone w tej deklaracji</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Ten rekord zawiera pola niespójnych typów</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>Powiązania „let” i „do” muszą występować przed definicjami elementów członkowskich i interfejsów w definicjach typów</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Dyrektywy wewnątrz modułów są ignorowane</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 16-bitowych liczb całkowitych ze znakiem</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problem ze stroną kodową „{0}”: {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Wyrażenia atrybutów muszą być wywołaniami konstruktorów obiektów</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Do konstruktora delegatów musi zostać przekazana jedna wartość funkcji.</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Ten indeksator oczekuje argumentów w liczbie {0}, ale podano tutaj argumenty w liczbie {1}</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>Wyrażenie „if” musi mieć typ „{0}”, aby spełnić wymagania typu kontekstu. Obecny typ: „{1}”.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Skrócone typy nie mogą mieć atrybutu „Sealed”</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Włącz optymalizacje (krótka wersja: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>To przesłonięcie pobiera inną liczbę argumentów niż odpowiedni abstrakcyjny element członkowski. Znaleziono następujące abstrakcyjne elementy członkowskie: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Niedopasowany element „[”</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Wartość literału nie może być oznaczona jako „inline”</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>Atrybut „NoEquality” musi być używany w połączeniu z atrybutem „NoComparison”</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które wymagają wskaźników byref</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Nieoczekiwany znak / w typie</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Typy kodu zestawu są zawsze zapieczętowane</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Nie określono danych wejściowych</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Stałe inne niż zero nie mogą mieć jednostek ogólnych. W przypadku ogólnej wartości zero użyj formy 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Nieprawidłowa metoda ustawiająca lub metoda pobierająca właściwość</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura deklaruje element {2}, natomiast implementacja deklaruje element {3}</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Znak „{0}” jest niedozwolony w podanej nazwie przestrzeni nazw „{1}”</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Nieprawidłowa dyrektywa. Oczekiwano „#I \"&lt;ścieżka&gt;\"„.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 32-bitowych liczb całkowitych bez znaku</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>Właściwość „{0}” ma taką samą nazwę co metoda w typie „{1}”.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>zdarzenie</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>pole</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Wartości zdefiniowane cyklicznie nie mogą występować bezpośrednio jako część konstrukcji wartości krotki w powiązaniu cyklicznym</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Opcja wiersza polecenia „{0}” jest przestarzała. Generowanie dokumentów HTML jest teraz częścią pakietu Power Pack języka F# i jest wykonywane za pośrednictwem narzędzia FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Atrybuty nie są dozwolone w powiązaniach „let” w wyrażeniach</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nOdpowiednie liczby parametrów typu są różne</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Ten element członkowski nie jest wystarczająco ogólny</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Używane jako literał wartości logicznej.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać malejących pętli for</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Adres podstawowy biblioteki, która ma zostać skompilowana</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problem z odczytem zestawu „{0}”: {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Udostępniony typ „{0}” zwrócił element członkowski o wartości null</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Znaleziono odwołanie do typu „{0}” w zestawie „{1}”, ale nie można znaleźć typu w tym zestawie</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Parametr typu ogólnego został użyty w sposób ograniczający go tak, aby zawsze miał postać „{0}”</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest oznaczony jako przesłonięcie, a drugi nie</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Oczekiwano wyrażeń w liczbie {0}; otrzymano: {1}</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Co najmniej jeden zadeklarowany parametr typu dla tego rozszerzenia typu nie ma ograniczenia typu lub ograniczenie typu jest nieprawidłowe i niezgodne z oryginalnymi ograniczeniami typu w elemencie „{0}”</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Co najmniej jedno przesłonięcie nie zawiera poprawnej implementacji odpowiadającego mu abstrakcyjnego elementu członkowskiego</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Element „AssemblyVersionAttribute” został zignorowany, ponieważ wersję podano przy użyciu opcji wiersza polecenia</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>Atrybut „DefaultValue” może być używany tylko z deklaracjami „val”</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Typy struktur są zawsze zapieczętowane</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Typy nie mogą dziedziczyć po wielu konkretnych typach</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Nieoczekiwane argumenty typu</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wymaga, aby typ obsługiwał interfejs {2}, ale interfejs nie został zaimplementowany</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GENEROWANIE KODU -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Nieoczekiwana wartość Const_uint16array</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Element członkowski „{0}” jest używany w nieprawidłowy sposób. Użycie elementu „{1}” zostało wywnioskowane przed definicją elementu „{2}”, co jest nieprawidłowym odwołaniem w przód.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>jest</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Ten atrybut nie może być używany w tej wersji języka F#</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Atrybuty nie są dozwolone we wzorcach</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Nie można przesłonić dziedziczonego elementu członkowskiego „{0}”, ponieważ jest on zapieczętowany</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Ten typ nie ma typów zagnieżdżonych</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Nazwa pliku „{0}” zawiera nieprawidłowy znak „{1}”</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Nie zdefiniowano pola, konstruktora lub elementu członkowskiego „{0}”.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Warunki [&lt;ReflectedDefinition&gt;] nie mogą zawierać zastosowań operatora łączenia prefiksów „%”</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Niezgodność długości tworzenia wystąpienia typu</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Właściwość metody ustawiającej może mieć co najwyżej dwie grupy argumentów</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Wyłącz określone komunikaty ostrzegawcze</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Pomiń komunikat kompilatora o prawach autorskich</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Typ „{0}” został oznaczony jako mający układ Explicit, ale pole „{1}” nie zostało oznaczone za pomocą atrybutu „FieldOffset”</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nTypy są różne</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Pierwszoklasowe użycia operatora łączenia wyrażenia są niedozwolone</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>To przypisanie elementu podrzędnego spowoduje wymazanie podanego typu „{0}” w typie „{1}”.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Typ {0} zawiera element członkowski „{1}”, ale nie jest metodą wirtualną lub abstrakcyjną, która jest dostępna do przesłonięcia lub zaimplementowania.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>Atrybut „{0}” występuje w implementacji i sygnaturze, ale argumenty atrybutu różnią się między sobą. W kompilowanym kodzie zostanie uwzględniony tylko atrybut z sygnatury.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Nie można rozpoznać operatora „{0}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Nierozpoznana opcja: „{0}”</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>rozszerzenie</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ pole „{0}” było obecne w implementacji, ale nie w sygnaturze. Moduł zawiera definicję wyjątku\n    {1},    \nale jego sygnatura określa\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Typ „{0}” ma metodę „{1}” (pełna nazwa „{2}”), ale metoda nie jest statyczna</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Wywołania „reraise” mogą występować tylko bezpośrednio w procedurze obsługi instrukcji try-with</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Typy wyliczeń są zawsze zapieczętowane</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Typy argumentu są niezgodne</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Litera „l” lub „L” w tym specyfikatorze formatu jest niepotrzebna. W kodzie języka F# można zamiast tego używać specyfikatorów %d, %x, %o lub %u, które są przeciążone w celu współpracy z wszystkimi podstawowymi typami liczb całkowitych.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Umożliwia dostęp do elementu członkowskiego spoza typu.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>Typ „{0}” nie ma wartości „null” jako właściwej wartości. Aby utworzyć wartość null dla typu Nullable, użyj wartości „System.Nullable()”.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Cykliczny element ValValue {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Typ „{0}” jest niedozwolony, ponieważ w konstrukcji byref&lt;T&gt; typ T nie może zawierać typów byref.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Definiuj symbole kompilacji warunkowej (krótka wersja: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Atrybuty są niedozwolone w deklaracjach „inherit”</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>Właściwość „{0}” w udostępnionym typie „{1}” ma właściwość CanWrite=true, ale brakuje wartości z metody GetSetMethod()</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ deklaracje wyjątku są różne. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>Nie znaleziono zasobu FSharp.Core.sigdata z plikiem FSharp.Core. Plik oczekiwany w {0}. Rozważ uaktualnienie do nowszej wersji pliku FSharp.Core, w której ten plik nie jest już wymagany.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Oczekiwano jednowierszowego komentarza lub końca wiersza</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Dostawca typów zwrócił wartość „null”, która nie jest prawidłową wartością zwracaną z „{0}”</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>Po dyrektywie #if powinien od razu następować identyfikator</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Nie określono implementacji elementu „{0}”. Wszystkie elementy członkowskie interfejsu muszą zostać zaimplementowane i występować w odpowiedniej deklaracji „interface”, na przykład „interface ... with member ...”.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Blok następujący po elemencie „{0}” jest niezakończony. Każdy blok kodu jest wyrażeniem i musi mieć wynik. Element „{1}” nie może być ostatnim elementem kodu w bloku. Rozważ zastosowanie jawnego wyniku w tym bloku.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „while”. Oczekiwano konstrukcji „while &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Definicje miary nie mogą mieć parametrów typu</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>Biblioteka DLL „{0}” skompilowana przy użyciu języka F# wymaga ponownego skompilowania, aby została użyta z tą wersją języka F#</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Nieoczekiwane zakończenie danych wejściowych w wyrażeniu „match”. Oczekiwana wartość: „match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...”.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Typy interfejsów i delegatów nie mogą zawierać pól</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Rozszerzenia pliku „ml” i „mli” są używane na potrzeby zgodności z językiem ML</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>przestrzeń nazw</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” wymaga argumentów w liczbie {1}. Wymagana sygnatura to „{2}”.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Deklaracje miary mogą mieć tylko statyczne elementy członkowskie: konstruktory są niedostępne</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać definicji inicjatorów statycznych</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Wewnętrzne funkcje ogólne są niedozwolone w wyrażeniach cytowanych. Rozważ dodanie ograniczeń typów, tak aby ta funkcja nie była już ogólna.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Nieznany argument --test: „{0}”</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problem wnioskowania o typie jest zbyt złożony (osiągnięto maksymalną głębokość iteracji). Rozważ dodanie dodatkowych adnotacji typów.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>Nie zdefiniowano wartości, przestrzeni nazw, typu lub modułu „{0}”.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nOdpowiednia liczba pól danych jest różna</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Struktury nie mogą zawierać powiązań „do”, ponieważ domyślny konstruktor struktur nie wykona tych powiązań</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Używane do konwertowania na typ znajdujący się wyżej w łańcuchu dziedziczenia.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} zmienna in kolekcja {1} (klucz_zewnętrzny = klucz_wewnętrzny) into grupa. Pamiętaj, że po elemencie „{2}” wymagane są nawiasy</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Domyślny konstruktor typu struktury inicjujący wartość zero może być używany tylko wtedy, gdy wszystkie pola typu struktury akceptują domyślną inicjalizację</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Typy ogólne nie mogą mieć atrybutu „StructLayout”</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Jawny konstruktor obiektów powinien używać składni „new(args) = expr”</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Ogranicza nietypizowany cytat kodu.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Struktury nie mogą zawierać definicji wartości, ponieważ domyślny konstruktor konstrukcji nie wykona tych powiązań. Rozważ dodanie kolejnych argumentów do podstawowego konstruktora typu.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem 8-bitowych liczb całkowitych ze znakiem</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Nieprawidłowy element członkowski „{0}” w udostępnionym typie „{1}”. Dozwolone są tylko właściwości, metody i konstruktory</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Brak przypisania dla pola „{0}” typu „{1}”</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje operatora „{1}”</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>Nie można użyć adresu pola statycznego „{0}” w tym momencie</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Ta deklaracja powoduje otwarcie przestrzeni nazw lub modułu „{0}” za pośrednictwem częściowo kwalifikowanej ścieżki. Dostosuj ten kod, aby używał pełnej ścieżki przestrzeni nazw. Dzięki tej zmianie kod będzie bardziej niezawodny, gdy do bibliotek języka F# i infrastruktury CLI zostaną dodane nowe konstrukcje.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>Wyrażenie „do!” nie może być używane w wyrażeniach sekwencji</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Implementacja pliku lub modułu „{0}” została już podana. Kolejność kompilacji jest istotna w języku F# z powodu wnioskowania o typie. Może być wymagane dostosowanie kolejności plików w celu umieszczenia pliku sygnatury przed implementacją. W programie Visual Studio kontrola typów jest wykonywana dla plików w kolejności ich występowania w pliku projektu; kolejność ta może być edytowana ręcznie lub dostosowywana przy użyciu Eksploratora rozwiązań.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>nieprawidłowa przestrzeń nazw udostępnionego typu</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Ta definicja typu zawiera bezpośrednie odwołanie cykliczne za pośrednictwem pola struktury lub relacji dziedziczenia</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Ta wartość nie jest literałem i nie można jej użyć we wzorcu</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Każdy argument podstawowego konstruktora struktury musi mieć określony typ, na przykład „type S(x1:int, x2:int) = ...”. Te argumenty określają pola struktury.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Wartości modyfikowalne nie mogą mieć parametrów ogólnych</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Nie można usunąć niejednoznaczności w przypadku użycia konstrukcji ogólnej z ograniczeniem „delegate” w tym miejscu lub w jego pobliżu.</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Specyfikacje delegatów muszą mieć postać „typ -&gt; typ”.</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>Atrybut ReflectedDefinitionAttribute nie może być stosowany do elementu członkowskiego wystąpienia w typie struktury, ponieważ element członkowski wystąpienia pobiera niejawny parametr „this” typu byref</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>wymagane słowa „get” i/lub „set”</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>Element „{0}” nie obsługuje flagi „{1}” prefiksu</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Ten parametr typu został użyty w sposób ograniczający go tak, aby zawsze miał postać „{0}”</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Nazwane argumenty nie mogą być określane dla wywołań cech elementów członkowskich</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Określona wersja platformy .NET Framework „{0}” nie jest obsługiwana. Określ wartość z wyliczenia Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Deklaracja może mieć postać atrybutu [&lt;Literal&gt;] tylko wtedy, gdy jest też podana wartość stałej, na przykład „val x : int = 1”</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Rozszerzenie pliku „{0}” nie zostało rozpoznane. Pliki źródłowe muszą mieć rozszerzenie fs, fsi, fsx, fsscript, ml lub mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Ta deklaracja „inherit” określa dziedziczony typ, ale nie określa argumentów. Rozważ określenie argumentów, na przykład „inherit TypPodstawowy(argumenty)”.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Nazwa wyjściowego pliku debugowania</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Określ katalog dla ścieżki dołączenia, która służy do rozpoznawania plików źródłowych i zestawów (krótka wersja: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Zapisz w pliku wnioskowany interfejs zestawu</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Kompiluj moduł, który można będzie dodać do innego zestawu</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Znak „|” nie jest dozwolony w identyfikatorach przypadku aktywnego wzorca</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w tym elemencie członkowskim. Miejsca abstrakcyjne zawsze mają taką samą widoczność co typ otaczający.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Znak „;” jest używany do rozdzielania wartości pól w rekordach. Rozważ zastąpienie znaku „,” znakiem „;”.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Nie można rozwiązać odziedziczonej niejednoznaczności w przypadku użycia operatora „{0}” w tym punkcie programu lub w jego pobliżu. Rozważ użycie adnotacji typu w celu rozwiązania niejednoznaczności.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Nie zdefiniowano typu „{0}”.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Używane do wskazywania funkcji, która powinna zostać zintegrowana bezpośrednio z kodem funkcji wywołującej.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>To nie jest prawidłowa nazwa przypadku wyliczenia</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Ten element członkowski wystąpienia wymaga parametru, aby mógł reprezentować wywoływany obiekt. Ustaw element członkowski jako element statyczny lub użyj notacji „member x.Member(args) = ...”.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Nie istnieje parametr statyczny o nazwie „{0}”</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Typ z atrybutem „NoEquality” nie powinien zwykle mieć jawnej implementacji metody„Object.Equals(obiekt)”. Wyłącz to ostrzeżenie, jeśli jest to zamierzone do celów związanych z międzyoperacyjnością</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Wartość została skopiowana w celu zagwarantowania, że oryginalna wartość nie zostanie zmodyfikowana przez tę operację, lub ponieważ kopia jest niejawna, gdy podczas zwracania struktury z elementu członkowskiego nastąpi otwarcie innego elementu członkowskiego.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Nie można uogólnić co najmniej jednej zmiennej jawnej klasy lub typu funkcji dla tego powiązania, ponieważ są one ograniczone do innych typów</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Kandydujący: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Niedopasowany blok „with” lub niepoprawnie sformatowany blok „with”</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Wszystkie elementy wyrażenia konstruktora listy muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Jawne specyfikacje typów nie mogą być używane w przypadku konstruktorów wyjątków</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Typ rekordu dla pola rekordu „{0}” został zdefiniowany z użyciem wartości RequireQualifiedAccessAttribute. Uwzględnij nazwę typu rekordu („{1}”) w używanej nazwie.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>Odpowiedni argument formalny nie jest opcjonalny</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Nieprawidłowa wartość</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>Nazwy argumentów w sygnaturze „{0}” i implementacji „{1}” nie są zgodne. Zostanie użyta nazwa argumentu z pliku sygnatury. Może to spowodować problemy podczas debugowania lub profilowania.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>Wartość „{0}” nie jest używana</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Opcja wymaga parametru: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Nieprawidłowa deklaracja</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem natywnych liczb całkowitych bez znaku</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Nie zdefiniowano rozróżniacza wzorców „{0}”.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Nieoczekiwany koniec danych wejściowych</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Moduły o nazwie „{0}” występują w dwóch częściach tego zestawu</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Dla typu delegata znaleziono więcej niż jedną metodę Invoke.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Ta wartość nie jest funkcją i nie można jej zastosować. Czy zamiast tego zamierzano uzyskać dostęp do indeksatora przy użyciu formatu {0}.[indeks]?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Wywnioskowano, że parametr „{0}” ma typ byref. Parametry typu byref muszą mieć jawną adnotację typu, na przykład „x1: byref&lt;int&gt;”. Parametr typu byref zostanie niejawnie wyłuskany, jeśli zostanie użyty.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Ten statyczny element członkowski nie powinien mieć parametru „this”. Rozważ użycie notacji „member ElementCzłonkowski(argumenty) = ...”.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Ogólna konstrukcja wymaga, aby typ „{0}” nie był typem abstrakcyjnym</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Dołącz tylko informacje o optymalizacji, które są istotne dla implementacji konstrukcji śródwierszowych. Uniemożliwia używanie konstrukcji śródwierszowych między modułami, ale zwiększa zgodność binarną.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>Reprezentacja tego typu została ukryta przez sygnaturę. W celu wskazania charakterystyki typu musi ona zawierać atrybut, taki jak [&lt;Sealed&gt;], [&lt;Class&gt;] lub [&lt;Interface&gt;].</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>Format „{0}” nie obsługuje flagi „0”</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Wnioskowanie typu spowodowało wyjście zmiennej {0} poza jej zakres. Rozważ dodanie jawnej deklaracji parametru typu lub skorygowanie kodu tak, aby był mniej ogólny.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Określ typ debugowania: full, portable, pdbonly. Wartość „{0}” jest wartością domyślną, jeśli nie określono typu debugowania, i umożliwia dołączenie debugera do działającego programu. Wartość „portable” określa format międzyplatformowy. Wartość „embedded” określa format międzyplatformowy osadzony w pliku wyjściowym.</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Tylko dyrektywy kompilatora „#” mogą występować przed pierwszą deklaracją „namespace”</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Nie znaleziono wartości lokalnej {0} podczas optymalizacji</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Dostawca typów „{0}” udostępnił metodę o nazwie „{1}” i token metadanych „{2}”, które nie zostały zgłoszone wśród metod dostawcy jego typu deklarującego „{3}”</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Niepoprawna składnia operatora „{0}”. Użycie: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Nieprawidłowa liczba zmiennoprzecinkowa</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Używanie konstruktorów jako elementów członkowskich rozszerzenia jest niedozwolone — należy je zdefiniować w ramach oryginalnej definicji typu</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Konstruktor obiektu „{0}” nie ma argumentu lub konfigurowalnej właściwości zwracania „{1}”. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>Flaga platformy „anycpu32bitpreferred” może być używana tylko z obiektami docelowymi EXE. Należy zamiast tego użyć flagi „anycpu”.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nNazwy są różne</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem statycznym, a drugi nie</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typ implementacji nie jest zapieczętowany, ale sygnatura sugeruje, że jest zapieczętowany. Rozważ dodanie atrybutu [&lt;Sealed&gt;] do implementacji.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>Wyrażenia „try”/„with” nie mogą być używane w wyrażeniach sekwencji</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ abstrakcyjny element członkowski „{2}” był obecny w implementacji, ale nie w sygnaturze</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” ma jawną implementację elementu „Object.GetHashCode”. Rozważ zaimplementowanie zgodnego przesłonięcia dla elementu „Object.Equals(obiekt)”</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Używane do deklarowania właściwości lub metody w typie obiektu.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Używane do kojarzenia nazwy z grupą powiązanych typów, wartości i funkcji w celu jej logicznego oddzielenia od innego kodu.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nTypy są różne</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ odpowiednie liczby parametrów typu są różne</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Specyfikacje delegatów nie mogą być typu curried. Użyj konstrukcji „typ * ... * typ -&gt; typ” w przypadku delegatów z wieloma argumentami i konstrukcji „typ -&gt; (typ -&gt; typ)” w przypadku delegatów zwracających wartości funkcji..</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>Wartość „{0}” została oznaczona jako śródwierszowa, ale jej implementacja używa funkcji wewnętrznej lub prywatnej, która jest niewystarczająco dostępna</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>Właściwość „{0}” nie jest statyczna</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie obiektu, sekwencji lub rekordu</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Parametry typu wywnioskowane dla tej wartości nie są stabilne po wymazaniu skrótów typu. Jest to spowodowane przez użycie skrótów typu, które porzucają parametry typu lub zmieniają ich kolejność, na przykład \n\ttype taggedInt&lt;'a&gt; = int lub\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nRozważ jawne zadeklarowanie parametrów typu dla tej wartości, na przykład\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IStructuralComparable”. Zastosuj atrybut „CustomComparison” do typu.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Błąd składni</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Nieprawidłowa relacja połączenia w elemencie „{0}”.Oczekiwany ciąg: „expr &lt;op&gt; expr”, gdzie &lt;op&gt; to =, =?, ?= lub ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Powiązania pól muszą mieć postać „identyfikator = wyrażenie;”</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>Zdarzenie „{0}” nie jest statyczne</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} zmienna in kolekcja</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Używane w wyrażeniu sekwencji do tworzenia wartości sekwencji.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>Wyrażenia „try/finally” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Zaleca się, aby obiekty obsługujące interfejs IDisposable były tworzone przy użyciu składni „new Type(args)”, a nie „Type(args)” lub „Type” jako wartości funkcji reprezentującej konstruktor, w celu określenia, że zasoby mogą należeć do wygenerowanej wartości</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Wartość literału nie może być oznaczona jako „mutable”</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Wprowadza konstrukcję zapętlenia.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>Metoda {0} nie jest metodą statyczną</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Atrybuty są niedozwolone w implementacjach interfejsu</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Ta postać wyrażenia może być używana tylko w wyrażeniach sekwencji i obliczeń</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać wyrażeń, które pobierają indeksy przypadku unii</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>W składni pełnej wskazuje początek definicji klasy.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>W składni pełnej wskazuje początek bloku kodu.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Wywołania konstruktorów obiektów w parametrach typu nie mogą mieć argumentów</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Używane do rozgałęziania przez porównanie wartości z wzorcem.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Nieoczekiwany warunek w zaimportowanym zestawie: nie można zdekodować atrybutu AttributeUsage</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Ten przypadek unii nie akceptuje argumentów</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Używane do tworzenia odwołania do przestrzeni nazw najwyższego poziomu w technologii .NET.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Ta konstrukcja kontrolna może być używana tylko wtedy, gdy konstruktor wyrażeń obliczeń definiuje metodę „{0}”</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Niejawny iloczyn miar poprzedzony znakiem /</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Nieprawidłowe podane pole. Podane pola wymazanych podanych typów muszą być literałami.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>To nie jest znany operator zapytania. Do operatorów zapytań należą takie identyfikatory jak „select”, „where”, „sortBy”, „thenBy”, „groupBy”, „groupValBy”, „join”, „groupJoin”, „sumBy” i „averageBy” zdefiniowane przy użyciu odpowiednich metod typu „QueryBuilder”.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Żaden element członkowski {0} lub konstruktor obiektu o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Jednostki miary są obsługiwane tylko w przypadku typów float, float32, decimal i signed integer</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Pole „{0}” nie jest statyczne</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Pliki powinny rozpoczynać się od deklaracji przestrzeni nazw lub modułu (np. „namespace PrzestrzeńNazw.PodrzędnaPrzestrzeńNazw” lub „module PrzestrzeńNazw.Moduł”), ale nie od obu. Aby zdefiniować moduł w przestrzeni nazw, użyj konstrukcji „module Moduł = ...”</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>Sygnatura dla tej funkcji zewnętrznej zawiera parametry typu. Ogranicz typy argumentów i zwracane typy, tak aby wskazywały typy odpowiedniej funkcji języka C.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Wszystkie gałęzie wyrażenia dopasowania do wzorca muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>Metoda „{0}” jest zapieczętowana i nie można jej przesłonić</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Niedopasowany element „{0}”</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>To nie jest zmienna, stała, aktywny aparat rozpoznawania ani literał</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Pole „{0}” ma określoną wartość, ale nie występuje w typie „{1}”</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać wyrażeń, które pobierają pola statyczne</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Definicje wartości statycznych mogą być używane tylko w przypadku typów z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(argumenty) = ...”.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Nie można znaleźć celu kodu dla tego atrybutu, ponieważ kod po atrybucie jest niekompletny.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Nieprawidłowa nazwa modułu lub przestrzeni nazw</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>operacja niestandardowa</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Używane do weryfikowania kodu podczas debugowania.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Deklaracje w tym pliku będą umieszczane w niejawnym module „{0}” na podstawie nazwy pliku „{1}”. Nie jest to jednak prawidłowy identyfikator języka F#, dlatego zawartość nie będzie dostępna z innych plików. Rozważ zmianę nazwy pliku lub dodanie deklaracji „module” lub „namespace” na początku pliku.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Nie można otworzyć pliku klucza „{0}”</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać dopasowania wzorca tablicy</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Jednym typem krotki jest krotka struktury, innym — krotka odwołania</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” wymaga dodatkowych argumentów w liczbie {1}. Wymagana sygnatura to „{2}”. Niektóre nazwy brakujących argumentów to: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” wymaga argumentów w liczbie {1}. Wymagana sygnatura to „{2}”. Niektóre nazwy brakujących argumentów to: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Element członkowski lub konstruktor obiektów „{0}” wymaga dodatkowych argumentów w liczbie {1}. Wymagana sygnatura to „{2}”.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „let!”.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Oczekiwano argumentu typu lub argumentu statycznego</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Podano opcje powodujące konflikt: „win32manifest” i „win32res”. Może zostać użyta tylko jedna z nich.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Zduplikowana właściwość. Właściwość „{0}” ma taką samą nazwę i sygnaturę co inna właściwość w typie „{1}”.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Określ nazwę kultury preferowanego języka wyjściowego (np. es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>W wyrażeniach sekwencji wyniki są generowane przy użyciu elementu „yield”</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Określ plik klucza o silnej nazwie</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Nieoczekiwany identyfikator: „{0}”</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Nieprawidłowy numer wiersza: „{0}”</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Argumenty opcjonalne nie są tutaj dozwolone</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Ta konstrukcja jest eksperymentalna</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Rozszerzenia są niedozwolone w typie delegata moduleDefns.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>Argument „{0}” nie jest prawidłowym argumentem liczby całkowitej</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>W przypadku jawnego odwołania do pliku mscorlib.dll lub pliku FSharp.Core.dll musi również zostać przekazana opcja {0}</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Adnotacje typu w metodach ustawiających i pobierających właściwości muszą być podane po metodzie „get()” lub „set(v)” (np. „with get() : string = ...”)</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Kompiluj plik wykonywalny systemu Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Nazwa pliku wyjściowego (krótka wersja: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Przełącznik --sourcelink jest obsługiwany tylko dla emitowania przenośnego pliku PDB (--debug:portable lub --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłonięty przez element CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Nazwane argumenty statyczne muszą następować po wszystkich nienazwanych argumentach statycznych</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Kompiluj plik wykonywalny konsoli</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Wszystkie zaimplementowane interfejsy powinny zostać zadeklarowane w początkowej deklaracji typu</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Nieoczekiwana specyfikacja właściwości poziomu źródła</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Nie można wywołać abstrakcyjnego podstawowego elementu członkowskiego: „{0}”</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>Atrybut „ConditionalAttribute” może być używany tylko z elementami członkowskimi</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Typ z atrybutem „CustomComparison” musi mieć jawną implementację co najmniej jednego z następujących interfejsów: „System.IComparable” lub „System.Collections.IStructuralComparable”</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy elementów członkowskich infrastruktury CLI są różne</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Metoda zaimplementowana w tym elemencie jest niejednoznaczna</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>Język F# obsługuje rangi tablicy między 1 i 32. Wartość {0} jest niedozwolona.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać tego rodzaju typu</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>W wyrażeniach obiektów można określić tylko przesłonięcia abstrakcyjnych i wirtualnych elementów członkowskich</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Zapisz dokument XML zestawu w podanym pliku</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole „{2}” było obecne w implementacji, ale nie w sygnaturze. Typy struktury muszą teraz udostępniać swoje pola w sygnaturze dla typu, chociaż pola nadal mogą mieć etykietę „private” lub „internal”.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do przypadku unii „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Za pomocą atrybutów „ReferenceEquality”, „StructuralEquality” i „StructuralComparison” mogą być rozszerzane tylko typy rekordu, unii, wyjątku i struktury</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Nieprawidłowy rozmiar sygnatury</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Określ plik manifestu biblioteki Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie indeksatora</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Nazwa typu nie może być pusta.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Nie można znaleźć pliku źródłowego „{0}”</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Oczekiwano elementu nadrzędnego modułu lub przestrzeni nazw {0}</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>W wyrażeniach konstrukcji mogą być używane tylko proste powiązania w postaci „identyfikator = wyrażenie”</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Wskazuje, że zadeklarowany element programu został zdefiniowany w innym pliku binarnym lub zestawie.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Plik informacji o linku kodu źródłowego do osadzenia w przenośnym pliku PDB</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>Element „new” może być używany tylko z konstruktorami obiektów</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Ten kod jest mniej ogólny, niż wskazują na to jego adnotacje. Jednostka miary podana przy użyciu konstrukcji „_” została określona jako „1” (czyli bez wymiaru). Rozważ zapewnienie ogólności kodu lub zrezygnowanie z użycia konstrukcji „_”.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>To nie jest prawidłowe wyrażenie literału. Atrybut [&lt;Literal&gt;] zostanie zignorowany.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ sygnatura wskazuje, że ten typ może używać wartości null jako dodatkowej wartości, ale implementacja tego nie wskazuje</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>Wyrażenia „try/with” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Połącz statycznie bibliotekę języka F# i wszystkie przywoływane biblioteki DLL w generowanym zestawie</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>Atrybut „AutoOpen(\"{0}\")” w zestawie „{1}” nie odwołuje się do prawidłowego modułu lub prawidłowej przestrzeni nazw w tym zestawie i został zignorowany</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Nie można modyfikować tego pola</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ typy są różnego rodzaju</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Wyliczenia nie mogą zawierać deklaracji interfejsu</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Kompiluj bibliotekę (krótka wersja: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Nie można rozpoznać zestawu „{0}”</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Konstruktor elementu członkowskiego lub obiektu „{0}” pobiera argumenty, których liczba to {1} i które są niedostępne w tej lokalizacji kodu. Wszystkie dostępne wersje metody „{2}” pobierają argumenty o następującej liczbie: {3}.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Krótka wersja dla „{0}”</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Dodano już domyślną implementację tego interfejsu, ponieważ nie określono jawnej implementacji interfejsu w definicji typu</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Nazwane pole „{0}” jest używane więcej niż raz.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Kompilacje deterministyczne obsługują tylko przenośne pliki PDB (--debug:portable lub --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie obiektu. Obiekty bez przesłonięć lub interfejsy powinny używać wyrażenia w postaci „new Typ(argumenty)” bez nawiasów.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>z {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>W wyrażeniu for używane podczas liczenia w kolejności odwrotnej.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Ten typ nie jest typem rekordu</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Konstrukcje w cudzysłowie nie mogą zawierać wyrażeń, które pobierają adres pola</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera jawną implementację interfejsu „System.IComparable”. Musisz zastosować atrybut „CustomComparison” do typu.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Wyrażenie if/then/else nie może być używane w zapytaniach. Zamiast tego rozważ użycie wyrażenia if/then lub wyrażenia sekwencji.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Została już podana wartość parametru statycznego „{0}”</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Osadź określone pliki źródłowe w przenośnym pliku PDB</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>Zmienna z podanym typem byref „{0}” jest używana w nieprawidłowy sposób. Tego typu zmienne nie mogą być przechwytywane przez zamknięcia lub przekazywane do funkcji wewnętrznych.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Nie można ustawić właściwości „{0}”</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Nie można ustawić tej właściwości</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Pierwszoklasowe użycia operatorów adresu są niedozwolone</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest konstruktorem/właściwością, a drugi nie</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Wyrażenia konstrukcji obiektów mogą być używane tylko do implementowania konstruktorów w typach klas</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne, ponieważ pole „{0}” było wymagane przez sygnaturę, ale nie zostało określone przez implementację. Moduł zawiera definicję wyjątku\n    {1},    \nale jego sygnatura określa\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Ten literał liczbowy wymaga, aby moduł „{0}” definiujący funkcje FromZero, FromOne, FromInt32, FromInt64 i FromString mieścił się w zakresie</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Nie można definiować konstruktorów dla tego typu</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ pole {2} było wymagane przez sygnaturę, ale nie zostało określone przez implementację</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Argumenty opcjonalne są dozwolone tylko w przypadku elementów członkowskich typów</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>W odwołaniu do udostępnionego typu brakuje wartości parametru statycznego „{0}”. Może być konieczne ponowne skompilowanie co najmniej jednego zestawu, do którego występuje odwołanie.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Wszystkie gałęzie wyrażenia „if” muszą mieć ten sam typ. Oczekiwano, że to wyrażenie będzie miało typ „{0}”, ale tutaj ma typ „{1}”.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Wymazano do postaci</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Ta wartość, ten typ lub ta metoda oczekuje następującej liczby parametrów typów: {0}. Podana liczba parametrów: {1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Definicje wyjątku są niezgodne z powodu różnej kolejności pól w sygnaturze i implementacji. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Operacja niestandardowa nie może być używana razem z powiązaniem „let” bez wartości lub cyklicznym powiązaniem „let” w innej części tego wyrażenia obliczenia</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Element członkowski „{0}” nie zawiera poprawnej liczby parametrów typu metody. Wymagana sygnatura: „{1}”.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacja typu infrastruktury CLI jest ukrywana przez sygnaturę</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralComparison”, ale parametr typu „{1}” nie spełnia ograniczenia „comparison”. Rozważ dodanie ograniczenia „comparison” do parametru typu</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Typ struktury, rekordu lub unii „{0}” zawiera atrybut „StructuralComparison”, ale typ składnika „{1}” nie spełnia ograniczenia „comparison”</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>Nie można użyć adresu zmiennej „{0}” w tym momencie</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>przypadek unii</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Globalna pamięć podręczna zestawów</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Zduplikowany lub nadmiarowy interfejs</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Nieprawidłowy plik odpowiedzi „{0}” („{1}”)</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Powiązania „use!” muszą mieć postać „use! &lt;var&gt; = &lt;expr&gt;”</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ reprezentacja typu jest ukrywana przez sygnaturę</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie rekordu, sekwencji lub obliczenia. Wyrażenia sekwencji powinny mieć postać „seq {{ ... }}”</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>Zdarzenie „{0}” w udostępnionym typie „{1}” nie ma wartości z metody GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Używane do deklarowania i implementowania interfejsów.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest elementem członkowskim rozszerzenia, a drugi nie</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Metody ustawiające właściwości muszą być definiowane przy użyciu konstrukcji „set wartość = ”, „set indeks wartość = ” lub „set (indeks1,...,indeksN) wartość = ... ”</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Nieprawidłowy argument etykiety wzorca z parametrami</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Nieprawidłowa długość bitowa</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>Dyrektywa #if musi występować jako pierwszy znak wiersza, który nie jest odstępem</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Istnieje wiele parametrów statycznych o nazwie „{0}”</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Pola nietrwałe muszą być oznaczone jako „mutable” i nie mogą być statyczne dla wątku</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Zwracane typy przypadków unii muszą być identyczne z definiowanym typem, łącznie ze skrótami</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności nie są dozwolone w przypadku przesłonięć lub implementacji interfejsów</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Rozważ użycie pliku z rozszerzeniem „ml” lub „mli”</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Ta właściwość przesłania właściwość abstrakcyjną lub zawiera jej implementację, ale właściwość abstrakcyjna nie ma odpowiedniego elementu {0}</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Błąd kompilatora: nieoczekiwana niezrealizowana wartość</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Odwołanie do udostępnionego typu miało nieprawidłową wartość „{0}” parametru statycznego. Może być konieczne ponowne skompilowanie co najmniej jednego zestawu, do którego występuje odwołanie.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Definicje wyjątków są niezgodne, ponieważ różnią się skróty wyjątków w sygnaturze i implementacji. Moduł zawiera definicję wyjątku\n    {0},    \nale jego sygnatura określa\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Nieprawidłowa wartość atrybutu niestandardowego (nie jest to stała ani literał)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Skróty wyjątków nie powinny zawierać list argumentów</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Ta właściwość ma nieprawidłowy typ. Właściwości z wieloma argumentami indeksatora powinny mieć typy w postaci „ty1 * ty2 -&gt; ty3”. Właściwości zwracające funkcje powinny mieć typy w postaci „(ty1 -&gt; ty2)”.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Może tutaj być przechowywana wartość typu byref. Wartości typu byref najwyższego poziomu wiązane słowem kluczowym let są niedozwolone.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Określono wiele atrybutów widoczności dla tego identyfikatora. Powiązania „let” w klasach są zawsze prywatne, tak jak powiązania „let” w wyrażeniach.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Wyrażenia cytowane nie mogą zawierać definicji funkcji, które są wnioskowane lub deklarowane jako ogólne. Rozważ dodanie ograniczeń typów w celu zapewnienia poprawności tego wyrażenia cytowanego.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Zła dokładność w specyfikatorze formatu</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Ten typ nie ma dostępnych konstruktorów obiektów</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Typ „{0}” od dostawcy typów „{1}” ma pustą przestrzeń nazw. Użyj wartości „null” dla globalnej przestrzeni nazw.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ implementacja wskazuje, że ten typ może używać wartości null jako dodatkowej wartości, ale sygnatura tego nie wskazuje</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Ten konstruktor obiektów wymaga argumentów</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Modyfikatory dostępności nie są dozwolone w deklaracji „inherits”</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Ten typ wymaga definicji</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Nie można ustawić pól literału</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Używane w pętlach do wskazywania zakresu.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Używane z warunkami wartości logicznej jako wartość logiczna lub operator. Odpowiednik symbolu ||. Używane również w ograniczeniach elementu członkowskiego.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Używane w uniach rozłącznych do wskazywania typów kategorii wartości oraz w deklaracjach delegowania i wyjątków.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Używane w konstrukcjach rozgałęziania warunkowego.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Używane na potrzeby wyrażeń sekwencji oraz — w składni pełnej — do oddzielania wyrażeń od powiązań.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Używane do nadawania nazwy bieżącemu obiektowi klasy oraz do nadawania nazwy całemu wzorcowi w obrębie dopasowania wzorca.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Używane w konstrukcjach zapętlenia lub do wykonywania kodu imperatywnego.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nAtrybuty modyfikowalności są różne</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Skróty typów wyjątków Common IL muszą mieć zgodnego konstruktora obiektów</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Jest to nieprawidłowy literał liczbowy. Do prawidłowych literałów liczbowych należą: 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1ui (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal) oraz 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>Atrybut „CustomEquality” musi być używany w połączeniu z atrybutami „NoComparison” lub „CustomComparison”</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Właściwość pobierająca może mieć najwyżej jedną grupę argumentów</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Ta deklaracja elementu członkowskiego, funkcji lub wartości nie może być zadeklarowana jako „inline”</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Nieprawidłowy operator prefiksu</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Średnik nie jest oczekiwany w tym miejscu</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>Operacja „{0}” nie jest używana poprawnie. Użycie: {1}. Jest to operacja niestandardowa w tym zapytaniu lub wyrażeniu obliczenia.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>Przesłonięcie elementu „{0}” jest niejednoznaczne</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Określ kontener kluczy o silnej nazwie</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Operator „wyrażenie.[indeks]” został użyty w obiekcie nieokreślonego typu na podstawie informacji przed tym punktem programu. Rozważ dodanie kolejnych ograniczeń typów</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- BŁĘDY I OSTRZEŻENIA -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Rozpoznaj odwołania do zestawu przy użyciu reguł opartych na katalogu, a nie rozpoznawania narzędzia MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Zduplikowana metoda. Metoda abstrakcyjna „{0}” ma taką samą nazwę i sygnaturę co metoda abstrakcyjna w typie dziedziczonym po wymazaniu krotek, funkcji, jednostek miary i/lub udostępnionych typów.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Jednostka miary nie może być używana w aplikacji konstruktora typów</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Wyrażenia konstrukcji obiektów (czyli wyrażenia rekordów ze specyfikacjami dziedziczenia) mogą być używane w celu implementowania konstruktorów w typach modeli obiektów. Aby utworzyć wystąpienia typów modeli obiektów poza konstruktorami, użyj wyrażenia „new ObjectType(args)”</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>Znak „{0}” jest niedozwolony w nazwach operatora i zarezerwowany do użytku w przyszłości</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>Wyrażenia „use” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Typ „{0}” nie jest typem, którego wartości mogą być wyliczane przy użyciu tej składni. Oznacza to, że nie jest zgodny z elementem seq&lt;_&gt;, IEnumerable&lt;_&gt; lub IEnumerable i nie ma metody GetEnumerator</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Nieoczekiwany pusty, długi identyfikator </value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Nieprawidłowa dyrektywa. Oczekiwano „#r \"&lt;plik-lub-zestaw&gt;\"”.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Wnioskowanie typu spowodowało wyjście zmiennej typu wnioskowania poza jej zakres. Rozważ dodanie adnotacji typu w celu uczynienia kodu mniej ogólnym.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje konwersji do typu „{1}”</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Opcja wiersza polecenia „--cliroot” jest przestarzała. Użyj odwołania jawnego do konkretnej kopii pliku mscorlib.dll.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Definicje {0} w sygnaturze i implementacji są niezgodne, ponieważ nazwy są różne. Typ w pliku sygnatury ma nazwę „{1}”, a w implementacji „{2}”.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Nieprawidłowy argument dla „methodhandleof” podczas generowania kodu</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Nieoczekiwany symbol „=” w wyrażeniu. Czy w zamian planowano użycie instrukcji „for x in y .. z do”?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Brak konstruktorów dostępnych dla typu „{0}”</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Zduplikowana specyfikacja interfejsu</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Nie znaleziono zestawu „{0}” w zestawie zależności docelowych danych binarnych. Statycznie połączone elementy główne powinny być określone przy użyciu nazwy zestawu bez rozszerzenia DLL lub EXE. Jeśli do tego zestawu wystąpiło jawne odwołanie, możliwe jest, że zestaw nie był w rzeczywistości wymagany przez wygenerowane dane binarne. W takim przypadku nie powinny być statycznie połączone.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Typ „{0}” zawiera implementację elementu „System.IComparable”. Rozważ również dodanie jawnego przesłonięcia elementu „Object.Equals”</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Używane w powiązaniach wzajemnie cyklicznych, deklaracjach właściwości oraz z wieloma ograniczeniami parametrów ogólnych.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>To nie jest prawidłowe wyrażenie stałej</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Nie można znaleźć pliku odpowiedzi „{0}” w lokalizacji „{1}”</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>Nie zdefiniowano przestrzeni nazw „{0}”.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Żaden z typów „{0}” nie obsługuje operatora „{1}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w powiązaniach „do”, ale podano element „{0}”.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Nieoczekiwany znak „{0}” w wyrażeniu preprocesora</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Dozwolone jest najwyżej jedno rozszerzenie „with”</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Parametr z atrybutami musi mieć też nazwę, na przykład „[&lt;Atrybut&gt;] nazwa : typ”</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Etykiety pól i oczekiwany typ tego wyrażenia rekordu lub wzorca nie określają jednoznacznie odpowiedniego typu rekordu</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Tylko aktywne wzorce zwracające dokładnie jeden wynik mogą akceptować argumenty</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Element członkowski operatora infiksu „{0}” ma następującą liczbę argumentów początkowych: {1}. Oczekiwano krotki liczącej 2 argumenty, np. static member (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argument</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Ta konstrukcja zapewnia zgodność z językiem ML. {0}. Możesz wyłączyć to ostrzeżenie, używając opcji „--mlcompatibility” lub opcji „--nowarn:62”.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Modyfikator formatu # jest nieprawidłowy w języku F#</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Podpisz zestaw z opóźnieniem, używając tylko publicznej części klucza o silnej nazwie</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Używane do deklarowania typu wyjątku.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Co najmniej jedno przeciążenie tej metody ma argumenty curried. Rozważ zmodyfikowanie tych elementów członkowskich tak, aby akceptowały argumenty w postaci spójnej kolekcji.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>Elementu „global” można używać tylko jako pierwszej nazwy w kwalifikowanej ścieżce</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Wyliczenia literałów muszą być typu int, uint, int16, uint16, int64, uint64, byte, sbyte lub char</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Wystąpił błąd podczas odczytu węzła metadanych F# w pozycji {0} tabeli „{1}” zestawu „{2}”. Węzeł nie ma pasującej deklaracji. Zgłoś wystąpienie tego ostrzeżenia. Może być konieczne ponowne skompilowanie używanego zestawu F#.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Błąd podczas otwierania pliku binarnego „{0}”: {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Nieprawidłowa nazwa elementu członkowskiego. Elementy członkowskie nie mogą mieć nazw „.ctor” i „.cctor”</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Zły specyfikator formatu: „{0}”</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>To pole nie jest literałem i nie można go użyć we wzorcu</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Tylko pola rekordów i proste, niecykliczne powiązania „let” mogą być oznaczone jako modyfikowalne</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Nieprawidłowa dyrektywa. Oczekiwano „#load \"&lt;plik&gt;\" ... \"&lt;plik&gt;\"”.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Typ „{0}” ma metodę „{1}” (pełna nazwa „{2}”), ale metoda jest statyczna</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Nie odnaleziono abstrakcyjnych elementów członkowskich lub elementów członkowskich interfejsu odpowiadających temu przesłonięciu</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>To nie jest prawidłowy wzorzec</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>Brak instrukcji „do” w wyrażeniu „for”. Oczekiwano konstrukcji „for &lt;wzorzec&gt; in &lt;wyrażenie&gt; do &lt;wyrażenie&gt;”.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>W przypadku przesłaniania ogólnej metody abstrakcyjnej musisz jawnie zadeklarować wszystkie parametry typu lub brak parametrów typu</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Nieobsługiwane wyrażenie „{0}” z dostawcy typów. Jeśli ten dostawca typów jest Twojego autorstwa, rozważ dostosowanie go w celu zapewnienia innego udostępnionego wyrażenia.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Określi wersję podsystemu tego zestawu</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Nieoczekiwane użycie zmiennej typu byref</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Nie powiodło się użycie śródwierszowej wartości „{0}” oznaczonej jako „inline” prawdopodobnie z powodu oznaczenia wartości cyklicznej jako „inline”</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>W typach funkcji ogranicza argumenty i wartości zwracane. Implikuje wyrażenie (w wyrażeniach sekwencji); odpowiednik słowa kluczowego yield. Używane w wyrażeniach dopasowania</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Struktury nie mogą mieć konstruktora obiektów bez argumentów. To ograniczenie dotyczy wszystkich języków CLI, ponieważ struktury automatycznie obsługują konstruktor domyślny.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Nieprawidłowy element algId — oczekiwano wartości „Exponent”</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Rozważ użycie polecenia „return!” zamiast „return”.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>Operator „!” umożliwia wyłuskanie komórki odwołania. Rozważ użycie tutaj elementu „not expr”.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Nie dodawaj zasobu do wygenerowanego zestawu zawierającego metadane specyficzne dla języka F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Nieoczekiwany operator infiksu w wyrażeniu typu</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Przełącznik --embed jest obsługiwany tylko dla emitowania przenośnego pliku PDB (--debug:portable lub --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Nieprawidłowa definicja operatora. Definicje operatora prefiksu muszą używać prawidłowej nazwy operatora prefiksu.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Nienazwane argumenty nie tworzą prefiksu argumentów wywołanej metody</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>nieprawidłowa pełna nazwa udostępnionego typu</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>Dyrektywa #else musi występować jako pierwszy znak wiersza, który nie jest odstępem</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Pole przypadku unii/wyjątku „{0}” nie może zostać użyte więcej niż raz.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności nie są dozwolone w przypadkach unii. Użyj ciągu type U = internal ...” lub „type U = private ...”, aby dodać dostępność do całej reprezentacji.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Tworzenie wystąpienia typu obejmuje typ byref. Nie jest to dozwolone przez reguły języka Common IL.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Nieznany przypadek unii</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. Aby zdefiniować semantykę porównania dla typu, zaimplementuj interfejs „System.IComparable”. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków infrastruktury CLI użyj nazwy „{1}”.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Skróty typów nie mogą mieć rozszerzeń</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Moduł zawiera konstruktora\n    {0},    \nale jego sygnatura określa\n    {1}    \nDostępność określona w sygnaturze jest większa od określonej w implementacji</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nLiczby argumentów w sygnaturze i implementacji są różne. Sygnatura określa, że „{3}” to definicja funkcji lub wyrażenie lambda akceptujące liczbę argumentów wynoszącą co najmniej {4}, ale implementacja jest obliczaną wartością funkcji. Aby zadeklarować, że obliczana wartość funkcji to dozwolona implementacja, po prostu umieść w nawiasach okrągłych jej typ w sygnaturze, np.\n\tval {5}: int -&gt; (int -&gt; int)\nzamiast\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>i inne przeciążenia ({0})</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Typ „{0}” nie jest typem wyliczeniowym infrastruktury CLI</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Skrót modułu musi być prostą nazwą, a nie ścieżką</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Wartości cykliczne nie mogą występować bezpośrednio jako konstrukcja typu „{0}” w powiązaniu cyklicznym. Ta funkcja została usunięta z języka F#. Zamiast tego rozważ użycie rekordu.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Kompilator języka F# dla języka F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Do nazwanego argumentu przypisano więcej niż jedną wartość</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Ignorowanie mieszanego zestawu zarządzanego/niezarządzanego „{0}” podczas statycznego łączenia</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Tylko struktury i klasy bez konstruktorów podstawowych mogą mieć atrybut „StructLayout”</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Oczekiwano parametru typu, a nie parametru jednostki miary</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Wskazuje implementację metody abstrakcyjnej; używane razem z deklaracją metody abstrakcyjnej do tworzenia metody wirtualnej.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Koniec pliku w ciągu z potrójnym cudzysłowem osadzonym w komentarzu rozpoczętym w tym miejscu lub przed nim</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Włącz losowe generowanie układu przestrzeni adresowej o wysokiej entropii</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Oczekiwano klucza prywatnego</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>wynik aktywnego wzorca</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Ta deklaracja nie jest obsługiwana w cyklicznych grupach deklaracji</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Brak tokenu „{0}” w wyrażeniu preprocesora</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Zakończenie — zbyt wiele błędów</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Element członkowski „{0}” nie zawiera poprawnej liczby argumentów. Wymagana sygnatura: „{1}”.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Ten typ używa nieprawidłowej kombinacji atrybutów „NoEquality”, „ReferenceEquality”, „StructuralEquality”, „NoComparison” i „StructuralComparison”</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Ta definicja może być używana tylko w typie z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(args) = ...”.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Typ atrybutu „{0}” zawiera wartość „AllowMultiple=false”. Do pojedynczego elementu języka nie można dołączyć wielu wystąpień tego atrybutu.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>W wyrażeniach sekwencji wiele wyników jest generowanych przy użyciu elementu „yield!”</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Typ „{0}” nie obsługuje operatora „{1}”. Rozważ otwarcie modułu „Microsoft.FSharp.Linq.NullableOperators”.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Struktury, interfejsy, wyliczenia i delegaty nie mogą dziedziczyć po innych typach.</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Nieprawidłowa liczba ogólnych argumentów typu „{0}” w udostępnionym typie. Oczekiwano następującej liczby argumentów: „{1}”. Podano: „{2}”.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Nie można uzyskać dostępu do tej metody „{0}” z tej lokalizacji kodu</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Nieprawidłowa wartość magiczna w nagłówku CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Nieprawidłowe opcjonalne przypisanie do właściwości lub pola</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Żaden element członkowski {0} lub konstruktor obiektów o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}. Argument nazwany „{3}” nie odpowiada żadnemu argumentowi lub ustawialnej właściwości zwracanej w żadnym przeciążeniu.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Żaden element członkowski {0} lub konstruktor obiektu o nazwie „{1}” nie pobiera następującej liczby argumentów: {2}. Zauważ, że wywołanie tego elementu członkowskiego udostępnia również argumenty nazwane o następującej liczbie: {3}.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Nieprawidłowa etykieta pola</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Nie można zdekodować atrybutu MarshalAs</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne z powodu różnych reprezentacji obiektu IL</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Typ inny niż ogólny „{0}” nie oczekuje żadnych argumentów typu, ale tutaj podano następującą liczbę argumentów typu: {1}</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>Nie zdefiniowano wartości, konstruktora, przestrzeni nazw lub typu „{0}”.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>przestrzeń nazw/moduł</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Cykliczna hierarchia klas w typie „{0}”</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Cykliczne odwołanie do obiektu „{0}” nie jest używane. Obecność cyklicznego odwołania do obiektu powoduje dodanie kontroli inicjowania środowiska uruchomieniowego do elementów członkowskich w tym typie i typach pochodnych. Rozważ usunięcie tego cyklicznego odwołania do obiektu.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Typ nie może mieć jednocześnie atrybutu „ReferenceEquality” i atrybutów „StructuralEquality” lub „StructuralComparison”</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Ta konstrukcja może być używana tylko w wyrażeniach obliczeń</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Aby można było zmodyfikować zawartość lub pobrać adres typu wartości, wartość musi być modyfikowalna, na przykład „let mutable x = ...”</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Skróty wyjątków muszą odwoływać się do istniejących wyjątków lub typów języka F# pochodzących od elementu System.Exception</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Osadź wszystkie pliki źródłowe w przenośnym pliku PDB</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Tylko proste wzorce zmiennych mogą być powiązane w konstrukcjach „let rec”</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Kolejne argumenty powinny być oddzielone spacjami lub mieć postać krotek, a argumenty obejmujące aplikacje metody lub funkcji powinny być umieszczone w nawiasach okrągłych</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>To nie jest wyjątek</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Błąd wewnętrzny. Nieprawidłowy indeks w tablicy aktywnego wzorca</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Do zestawu „{0}” wystąpiło odwołanie przechodnie i nie można automatycznie rozpoznać zestawu. W przypadku statycznego łączenia zostanie przyjęte, że ta biblioteka DLL nie ma żadnych zależności od biblioteki języka F# lub innych statycznie połączonych bibliotek DLL. Rozważ dodanie jawnego odwołania do tej biblioteki DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Błąd podczas emitowania atrybutu „System.Reflection.AssemblyCultureAttribute” -- „Pliki wykonywalne nie mogą być zestawami satelickimi. Kultura zawsze powinna być pusta”</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Interfejsy zawsze mają taką samą widoczność jak typ otaczający</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nJeden element jest funkcją typu, a drugi nie. Sygnatura wymaga jawnych parametrów typu, jeśli są obecne w implementacji.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>Składnia „module ... = struct .. end” nie jest używana w kodzie języka F#. Rozważ użycie składni „module ... = begin .. end”</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>Atrybut „VolatileField” może być używany tylko w powiązaniach „let” w klasach</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Moduł zawiera pole\n    {0},    \nale jego sygnatura określa\n    {1}    \nModyfikatory „literal” są różne</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Definicje {0} dla typu „{1}” w sygnaturze i implementacji są niezgodne, ponieważ skróty są różne: {2} i {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Jawny inicjator statyczny powinien używać składni „static new(args) = expr”</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Tylko funkcje mogą być oznaczone jako „inline”</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Ten typ nie jest typem interfejsu</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Typ „{0}” nie jest typem interfejsu</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Konstruktory obiektów nie mogą bezpośrednio używać instrukcji try/with i try/finally przed zainicjowaniem obiektu. Obejmuje to takie konstrukcje, jak „for x in ...”, które mogą skutkować użyciem takich konstrukcji. Jest to ograniczenie nałożone przez język Common IL.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>Elementy „return” i „return!” nie mogą być używane w zapytaniach</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modyfikatory dostępności są niedozwolone w polach rekordu. Użyj konstrukcji „type R = internal ...” lub „type R = private ...”, aby zapewnić dostępność całej reprezentacji.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Używane zamiast instrukcji let! w asynchronicznych przepływach pracy i innych wyrażeniach obliczenia na potrzeby wartości, które wymagają wywołania operacji Dispose w celu zwolnienia zasobów.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Deklaracja dziedziczenia nie jest tutaj dozwolona</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>Informacje elementu członkowskiego „{1}” udostępnionego typu „{0}” mają typ deklarujący o wartości null</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Dostawca typów „{0}” zwrócił nieprawidłową metodę z funkcji „ApplyStaticArgumentsForMethod”. Oczekiwano metody o nazwie „{1}”, lecz zwrócono metodę o nazwie „{2}”.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} nie jest prawidłową sekwencją znaku ucieczki Unicode</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Istnieje wiele typów o nazwie „{0}”, które pobierają różne liczby parametrów ogólnych. Udostępnij wystąpienie typu w celu odróżnienia rozpoznawania typu (np. „{1}”).</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Atrybuty przestrzeni nazw lub modułu w sygnaturze i implementacji nie są zgodne</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>Interfejs „{0}” występuje w wielu jawnie zaimplementowanych typach interfejsów. Dodaj jawną implementację tego interfejsu.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>Zdarzenie „{0}” ma niestandardowy typ. Jeśli to zdarzenie zadeklarowano w innym języku infrastruktury CLI, może być konieczne uzyskanie dostępu do tego zdarzenia przy użyciu jawnych metod {1} i {2} zdarzenia. Jeśli to zdarzenie zadeklarowano w języku F#, utwórz dla typu zdarzenia wystąpienie interfejsu „IDelegateEvent&lt;_&gt;” lub interfejsu „IEvent&lt;_,_&gt;”..</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>Składnia „type X with ...” jest zarezerwowana dla powiększeń. Typy, których reprezentacje są ukryte, zawierające elementy członkowskie są obecnie deklarowane w sygnaturach przy użyciu składni „type X = ...”. Może być też konieczne dodanie atrybutu [&lt;Sealed&gt;] do definicji typu w sygnaturze</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Możliwe, że chcesz wykonać jedną z następujących czynności:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>Nie zdefiniowano etykiety rekordu „{0}”.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Ten test typu lub to przypisanie elementu podrzędnego zignoruje jednostkę miary „{0}”</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Nieprawidłowy obiekt blob klucza publicznego</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Nie można użyć łączenia statycznego w przypadku zestawu przywołującego bibliotekę mscorlib (np. zestaw programu .NET Framework) podczas generowania zestawu przywołującego element System.Runtime (np. zestaw programu .NET Core lub przenośny).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nLiczba parametrów ogólnych w sygnaturze i implementacji jest różna (sygnatura deklaruje {3}, ale implementacja deklaruje {4})</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Element członkowski „{0}” nie zawiera poprawnych rodzajów parametrów ogólnych. Wymagana sygnatura: „{1}”.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>Sygnatura i implementacja nie są zgodne z powodu różnej liczby odpowiednich parametrów typu</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>typ, wyjątek lub moduł</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>To wyrażenie listy lub tablicy zawiera element „if ... then ... else”. Ujmij to wyrażenie w nawiasy, aby określić, że jest to pojedynczy element listy lub tablicy, w celu odróżnienia go od listy wygenerowanej przy użyciu wyrażenia sekwencji</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Typ „{0}” nie ma wartości „null” jako właściwej wartości</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Modyfikatory dostępności powinny występować bezpośrednio przed identyfikatorem konstrukcji</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Niepełna definicja wartości. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „use”.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Niepełna definicja wartości lub funkcji. Jeśli jest to wyrażenie, treść wyrażenia musi być wcięta w tej samej kolumnie co słowo kluczowe „let”.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Przypadek unii/wyjątek „{0}” nie ma pola o nazwie „{1}”.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>Nazwa „({0})” nie powinna być używana jako nazwa elementu członkowskiego. W przypadku definiowania statycznego elementu członkowskiego do użycia z innych języków CLI użyj nazwy „{1}”.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Dostawca typów nie ma prawidłowego konstruktora. Oczekiwano konstruktora, który nie pobiera argumentów lub pobiera jeden argument typu „TypeProviderConfig”.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Typy rekordów, unii, skrótów i struktur nie mogą zawierać atrybutu „AllowNullLiteral”</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>Wyrażenie w postaci {{ wyrażenie with ... }} może być używane tylko z typami rekordów. Aby utworzyć typy obiektów, użyj wyrażenia {{ new Typ(...) with ... }}</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Nie określono implementacji elementu „{0}”</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Ten przypadek unii oczekuje {0} argumentów w postaci spójnej kolekcji</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Dwie definicje typów o nazwie „{0}” występują w przestrzeni nazw „{1}” w dwóch częściach tego zestawu</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Nieprawidłowa nazwa modułu</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>Konwersja z {0} do {1} jest przypisaniem elementu nadrzędnego bezpiecznym w czasie kompilacji, a nie przypisaniem elementu podrzędnego. Rozważ użycie operatora :&gt; (przypisanie elementu nadrzędnego) zamiast :?&gt; (przypisanie elementu podrzędnego).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Specyfikatory pozycyjne są niedozwolone w ciągach formatu</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>Operacja niestandardowa „{0}” odwołuje się do przeciążonej metody. Implementacje operacji niestandardowych nie mogą być przeciążone.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>Powiązania „use” nie są dozwolone w modułach i są traktowane jak powiązania „let”</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Określ stronę kodową używaną do odczytu plików źródłowych</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Ten operator jest teraz obsługiwany bezpośrednio przez kompilator języka F# i nie można ponownie zdefiniować jego znaczenia</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Konwertuje typ na typ znajdujący się niżej w hierarchii.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Nie można odczytać wersji z pliku mscorlib.dll</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Dostawca typów „{0}” zgłosił błąd w kontekście udostępnionego typu „{1}”. Element członkowski: „{2}”. Błąd: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Wystąpił błąd podczas stosowania argumentów statycznych do udostępnionego typu</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- PLIKI WEJŚCIOWE -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Pętla for z liczbami całkowitymi musi używać prostego identyfikatora</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Ta liczba jest poza dozwolonym zakresem szesnastkowych, 8-bitowych liczb całkowitych ze znakiem</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Zabezpieczenie dopasowania do wzorca musi mieć typ „bool”, ale to wyrażenie „when” ma typ „{0}”.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Definicja typu wymaga co najmniej jednego elementu członkowskiego lub innych deklaracji. Jeśli zamierzasz zdefiniować pustą klasę, strukturę lub interfejs, użyj konstrukcji „type ... = class end”, „interface end” lub „struct end”.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Konstrukcja ogólna wymaga, aby typ „{0}” miał semantykę odwołania, ale tak nie jest, ponieważ jest on strukturą</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nNazwy są różne</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>Skrót typu zawiera typy byref. Jest to niedozwolone w języku F#.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Nie można wygenerować informacji o debugowaniu pliku MDB. Nie można załadować typu „MonoSymbolWriter” z zestawu „Mono.CompilerServices.SymbolWriter.dll”.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Nieoczekiwany błąd podczas tworzenia pliku informacji o debugowaniu „{0}”</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Oczekiwano parametru jednostki miary, a nie parametru typu. Jawne parametry jednostki miary muszą być oznaczone za pomocą atrybutu [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Nie można przeanalizować ciągu formatu „{0}”</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Nieoczekiwane dekodowanie elementu AutoOpenAttribute</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Konstrukcja w cudzysłowie nie mogą zawierać wyrażeń, które tworzą wywołania ograniczenia elementu członkowskiego, lub używać operatorów niejawnie rozpoznawanych jako wywołanie ograniczenia elementu członkowskiego</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Pliki w bibliotekach lub aplikacje złożone z wielu plików muszą rozpoczynać się od deklaracji przestrzeni nazw lub modułu. W przypadku użycia deklaracji modułu na początku pliku nie dopuszcza się zastosowania znaku „=”. Jeśli jest to moduł najwyższego poziomu, rozważ usunięcie znaku = w celu usunięcia tego błędu.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Pole „{0}” występuje dwa razy w tym wyrażeniu rekordu lub wzorcu</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Oczekiwano udostępnionego typu o nazwie „{0}”, ale udostępniony typ ma właściwość Name o wartości „{1}”.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Oczekiwano udostępnionego typu ze ścieżką „{0}”, ale udostępniony typ ma ścieżkę „{1}”</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Liczba argumentów atrybutu niestandardowego nie jest zgodna z oczekiwaną liczbą argumentów konstruktora atrybutów</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Element członkowski „{0}” jest używany w nieprawidłowy sposób. Użycie „{1}” zostało wywnioskowane przed jego definicją w „{2}” lub w pobliżu tego miejsca. Jest to nieprawidłowe odwołanie w przód.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>Zdarzenie „{0}” w udostępnionym typie „{1}” nie ma wartości z metody GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Oczekiwano klucza RSA</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Wszystkie typy rekordów, unii i struktur w pliku FSharp.Core.dll muszą mieć jawną etykietę „StructuralComparison” lub „NoComparison”</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Typ unii dla przypadku unii „{0}” został zdefiniowany z użyciem wartości RequireQualifiedAccessAttribute. Uwzględnij nazwę typu unii („{1}”) w używanej nazwie.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Aktywne wzorce nie mogą zwracać więcej niż 7 możliwości</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>Nie zdefiniowano wartości lub konstruktora „{0}”.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Ta deklaracja „inherit” zawiera argumenty, ale nie należy do typu z konstruktorem podstawowym. Rozważ dodanie argumentów do definicji typu, na przykład „type X(argumenty) = ...”.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Typy unii rozłącznych są zawsze zapieczętowane</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Nieoczekiwana adnotacja GetSet dla właściwości</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>To nie jest prawidłowa wartość literału wyliczenia</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Nieprawidłowy moduł/wyrażenie/typ</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ przeciążenia ({0})</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 przeciążenie</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Oczekiwany jest typ obsługujący operator „{0}”, ale podano typ krotki</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>Zestaw „{0}” wyszczególniono w wierszu polecenia. Odwołania do zestawów powinny być tworzone przy użyciu flagi wiersza polecenia, takiej jak „-r”.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>Nazwa „{0}” udostępnionego typu miała wartość null lub była pusta.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Zduplikowana metoda. Metoda abstrakcyjna „{0}” ma taką samą nazwę i sygnaturę co metoda abstrakcyjna w typie dziedziczonym.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>również z {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Metoda tablicy „{0}” jest dostarczana przez środowisko uruchomieniowe i nie może być używane bezpośrednio w kodzie. W przypadku operacji z elementami tablic rozważ użycie rodziny funkcji GetArray/SetArray z modułu LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Atrybut dostępności „{0}” nie jest dozwolony w skrócie modułu. Skróty modułu zawsze są prywatne.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Podane typy wygenerowane w ramach tego użycia dostawcy typów nie mogą być używane z innych zestawów języka F# i powinny być oznaczone jako wewnętrzne lub prywatne. Rozważ użycie ciągu „type internal TypeName = ...” lub „type private TypeName = ...”.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Dodaj znak . na potrzeby dostępu indeksatora.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Powiązania DLLImport muszą być statycznymi elementami członkowskimi w definicjach klas lub funkcji w module</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>Element członkowski funkcji „{0}” jest używany w sposób wymagający dodatkowych adnotacji typów w definicji w celu zapewnienia spójności wywnioskowanych typów. Wywnioskowana sygnatura: „{1}”.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Ta metoda ma już domyślną implementację</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Moduł „{0}” zawiera element\n    {1},    \nale jego sygnatura określa element\n    {2}    \nReprezentacja skompilowana tej metody ma postać elementu członkowskiego wystąpienia, ale sygnatura wskazuje, że jego reprezentacja skompilowana ma postać statycznego elementu członkowskiego</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Nie jest to prawidłowy literał bajtowy</value>
  </data>
</root>