<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fsiUnexpectedThreadAbortException" xml:space="preserve">
    <value>- Inesperada ThreadAbortException (Ctrl-C) durante o manuseio do evento: Tentando reiniciar...</value>
  </data>
  <data name="fsiProductNameCommunity" xml:space="preserve">
    <value>F# Interativo para F# {0}</value>
  </data>
  <data name="fsiDidAHashrWithLockWarning" xml:space="preserve">
    <value>--&gt; Referenciado '{0}' (o arquivo pode ter sido bloqueado pelo processo F# Interativo)</value>
  </data>
  <data name="fsiTimeInfoMainString" xml:space="preserve">
    <value>Real: {0}, CPU: {1}, GC {2}</value>
  </data>
  <data name="fsiReadline" xml:space="preserve">
    <value>Suportar a conclusão TAB no console (por padrão)</value>
  </data>
  <data name="fsiIntroTextHashloadInfo" xml:space="preserve">
    <value>Carregar os arquivo(s) como se compilados e referenciados</value>
  </data>
  <data name="fsiFailedToResolveAssembly" xml:space="preserve">
    <value>Falha ao resolver assembly '{0}'</value>
  </data>
  <data name="fsiIntroTextHeader2commandLine" xml:space="preserve">
    <value>  Opções de linha de comando F# interativo:</value>
  </data>
  <data name="fsiIntroTextHashquitInfo" xml:space="preserve">
    <value>Sair</value>
  </data>
  <data name="fsiRemaining" xml:space="preserve">
    <value>Tratar argumentos restantes como argumentos de linha de comando acessados através de fsi.CommandLineArgs</value>
  </data>
  <data name="fsiEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Emitir informações de depuração entre aspas</value>
  </data>
  <data name="fsiAbortingMainThread" xml:space="preserve">
    <value>- Anulando thread principal...</value>
  </data>
  <data name="fsiAdvanced" xml:space="preserve">
    <value>- AVANÇADO -</value>
  </data>
  <data name="fsiIntroTextHashrInfo" xml:space="preserve">
    <value>Referenciar (carregar dinamicamente) o DLL dado</value>
  </data>
  <data name="fsiDidAHashI" xml:space="preserve">
    <value>--&gt; '{0}' foi adicionado à biblioteca de caminho de inclusão</value>
  </data>
  <data name="fsiDidAHashr" xml:space="preserve">
    <value>--&gt; Referenciado '{0}'</value>
  </data>
  <data name="fsiIntroTextHashtimeInfo" xml:space="preserve">
    <value>Liga/desliga medição de tempo</value>
  </data>
  <data name="fsiIntroTextHashIInfo" xml:space="preserve">
    <value>Adicionar o caminho pesquisado dado aos DLLs referenciados</value>
  </data>
  <data name="fsiIntroTextHeader1directives" xml:space="preserve">
    <value>  Diretrizes interativas F#:</value>
  </data>
  <data name="fsiLoadingFilesPrefixText" xml:space="preserve">
    <value>Carregando</value>
  </data>
  <data name="stoppedDueToError" xml:space="preserve">
    <value>Interrompido devido a erro\n</value>
  </data>
  <data name="fsiInterrupt" xml:space="preserve">
    <value>\n- Interrupção\n</value>
  </data>
  <data name="fsiInvalidAssembly" xml:space="preserve">
    <value>'{0}' não é um nome de assembly válido</value>
  </data>
  <data name="fsiExceptionDuringPrettyPrinting" xml:space="preserve">
    <value>\n\nExceção levantadas durante formatação.\nReporte esta exceção para ela que possa ser corrigida.\nRastrear: {0}\n</value>
  </data>
  <data name="fsiTurnedTimingOff" xml:space="preserve">
    <value>--&gt; Timing desligado agora</value>
  </data>
  <data name="fsiDidAHashrWithStaleWarning" xml:space="preserve">
    <value>--&gt; '{0}' referenciado (um assembly com um carimbo de data/hora diferente já foi referenciado deste local, redefina o fsi para carregar o assembly atualizado)</value>
  </data>
  <data name="fsiLanguage" xml:space="preserve">
    <value>- LINGUAGEM -</value>
  </data>
  <data name="fsiMiscellaneous" xml:space="preserve">
    <value>- DIVERSOS -</value>
  </data>
  <data name="fsiConsoleProblem" xml:space="preserve">
    <value>Um problema ocorreu na inicialização do processo interativo #F. Isto pode ter ocorrido devido a um problema conhecido com processo de fundo do console de apoio pelo aplicativos habilitados Unicode em alguns sistemas do Windows. Tente Ferramentas-&gt;Opções-&gt;Interativo F# para Visual Studio e insira '--fsi-server-no-unicode'.</value>
  </data>
  <data name="fsiIntroTextHashhelpInfo" xml:space="preserve">
    <value>Exibir ajuda</value>
  </data>
  <data name="fsiTurnedTimingOn" xml:space="preserve">
    <value>--&gt; Timing ligado agora</value>
  </data>
  <data name="fsiIntroTextHeader3" xml:space="preserve">
    <value>      Consulte '{0}' para obter opções</value>
  </data>
  <data name="fsiExceptionRaisedStartingServer" xml:space="preserve">
    <value>Exceção levantadas ao iniciar o servidor remoto.\n{0}</value>
  </data>
  <data name="fsiInvalidDirective" xml:space="preserve">
    <value>Diretriz inválida '#{0} {1}'</value>
  </data>
  <data name="fsiProductName" xml:space="preserve">
    <value>Microsoft (R) F# Interactive versão {0}</value>
  </data>
  <data name="fsiBindingSessionTo" xml:space="preserve">
    <value>Associando sessão a '{0}'...</value>
  </data>
  <data name="fsiCodeGeneration" xml:space="preserve">
    <value>- GERAÇÃO DE CÓDIGO -</value>
  </data>
  <data name="fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration" xml:space="preserve">
    <value>gen</value>
  </data>
  <data name="fsiDirectoryDoesNotExist" xml:space="preserve">
    <value>O diretório '{0}' não existe</value>
  </data>
  <data name="fsiCouldNotInstallCtrlCHandler" xml:space="preserve">
    <value>Falha ao instalar o manipulador ctrl-c - As manipulações Ctrl-C não estarão disponíveis. O erro foi:\n\t{0}</value>
  </data>
  <data name="fsiLineTooLong" xml:space="preserve">
    <value>Aviso: linha muito longa, ignore alguns caracteres\n</value>
  </data>
  <data name="fsiUse" xml:space="preserve">
    <value>Use o arquivo fornecido na inicialização como entrada inicial</value>
  </data>
  <data name="fsiGui" xml:space="preserve">
    <value>Execute interações em um loop de eventos do Windows Forms (por padrão)</value>
  </data>
  <data name="shadowCopyReferences" xml:space="preserve">
    <value>Impede que as referências sejam bloqueadas pelo processo de F# interativo</value>
  </data>
  <data name="fsiBanner3" xml:space="preserve">
    <value>Para ajuda digite #help;;</value>
  </data>
  <data name="fsiInputFiles" xml:space="preserve">
    <value>- ARQUIVOS DE ENTRADA -</value>
  </data>
  <data name="fsiHelp" xml:space="preserve">
    <value>Exibir esta mensagem de uso (Forma abreviada: -?)</value>
  </data>
  <data name="fsiLoad" xml:space="preserve">
    <value>#load o arquivo dado na inicialização</value>
  </data>
  <data name="fsiExec" xml:space="preserve">
    <value>Feche fsi após o carregamento dos arquivos ou execução do script .fsx fornecido na linha de comando</value>
  </data>
  <data name="fsiExit" xml:space="preserve">
    <value>\n- Sair...\n</value>
  </data>
  <data name="fsiErrorsAndWarnings" xml:space="preserve">
    <value>- ERROS E AVISOS -</value>
  </data>
  <data name="fsiQuiet" xml:space="preserve">
    <value>Suprimir fsi gravando ao stdout</value>
  </data>
  <data name="fsiUsage" xml:space="preserve">
    <value>Uso: {0} &lt;opções&gt; [script.fsx [&lt;argumentos&gt;]]</value>
  </data>
</root>