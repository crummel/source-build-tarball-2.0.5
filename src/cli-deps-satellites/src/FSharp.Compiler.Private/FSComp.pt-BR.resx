<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos nesta posição para abreviações do tipo</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>A vinculação estática pode não incluir um .EXE</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>A propriedade '{0}' não é legível</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Associações 'use' devem estar no formato 'use &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Compilador Microsoft (R) F# versão {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>O campo de registro, struct ou classe '{0}' não está acessível neste local de código</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Membro inválido '{0}' no tipo fornecido '{1}'. Os membros do tipo fornecido devem ser públicos, e não genéricos, virtuais ou abstratos.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' não é uma expressão válida. Registros devem incluir pelo menos um campo. Sequências vazias são especificadas pelo uso de Seq.empty ou uma lista vazia '[]'.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>A chamada dinâmica de {0} não é suportada</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem o atributo 'StructuralEquality', mas o parâmetro de tipo '{1}' não satisfaz a restrição 'equality'. Considere adicionar a restrição 'equality' ao parâmetro de tipo</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem o atributo 'StructuralEquality', mas o tipo de componente '{1}' não satisfaz a restrição 'equality'</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Considere usar um tipo de registro separado em vez disso</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>O endereço da variável '{0}' não pode ser usado neste momento. Um método ou uma função pode não retornar o endereço deste valor local.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Não é possível ler o assembly '{0}'</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Uma construção genérica requer que o tipo '{0}' seja um CLI ou tipo struct F#</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>O provedor de tipos '{0}' retornou nulo de GetInvokerExpression.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>As referências múltiplas '{0}.dll' não são permitidas</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Nome de operador de cotação incompatível, começando com '{0}'</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Indica um método que não tem implementação no tipo no qual ele é declarado ou que é virtual e tem uma implementação padrão.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>A vinculação estática pode não incluir uma DLL gerenciada/não gerenciada mista</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Restringe o acesso a um membro para codificar no mesmo tipo ou módulo.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>O tipo '{0}' não é compatível com qualquer um dos tipos {1}, decorrentes da utilização de uma cadeia de caracteres do formato estilo printf</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Membros de extensão não podem fornecer sobrecargas de operadores. Considere definir o operador como parte da definição de tipo.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>A variável '{0}' é usada de forma incorreta</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' só podem ser usados para tipos de objetos de constructo</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Token '{0}' inesperado ou expressão incompleta</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' não pode ser usado como nome de campo</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Acessibilidades múltiplas fornecidas para getter ou setter de propriedade</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Construtores devem ser aplicados aos argumentos e não podem ser usados como valores de primeira classe. Se for necessário, use uma função anônima '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Arquivo de versão inválida '{0}'</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Associações recursivas que incluem especificações de membros só podem ocorrer como um aumento direto de um tipo</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Referência recursiva inválida para um slot abstrato</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Cotações não podem conter código de assembly embutido ou padrões coincidentes em matrizes</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Objetos devem ser inicializados por uma expressão de construção de objeto que chame um construtor de objeto herdado e atribua um valor para cada campo</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Argumentos de operadores de consultas podem exigir parênteses, por exemplo, 'where (x &gt; y)' ou 'groupBy (x.Length / 10)'</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Definir um nível de aviso (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Exibir esta mensagem de uso (Forma abreviada: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>O assembly System.Runtime.InteropServices é necessário para usar classes as UnknownWrapper\DispatchWrapper.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>módulo</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Expressão inválida à esquerda da atribuição</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Especificação embutida inválida</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Delimita uma citação tipada do código.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet só é esperado em árvores de análise</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Problema com nome de arquivo '{0}': caracteres inválidos no caminho.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(carregando descrição...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'comparison' porque é um registro, união ou struct com um ou mais tipos de elementos estruturais que não suportam a restrição 'comparison'. Evite usar comparação com este tipo, a não ser que você adicione o atributo 'StructuralComparison' ao tipo para determinar qual tipo de campo não suporta comparação</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'comparison'. Por exemplo, ele não suporta a interface 'System.IComparable'</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'comparison' porque ela não possui o atributo 'NoComparison'</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>O atributo 'System.Diagnostics.ConditionalAttribute' somente é válido em classes de métodos ou atributos</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois as representações CLI são diferentes. O módulo contém a definição da exceção\n    {0}    \n, mas a sua assinatura especifica\n\t{1}</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Erro de sintaxe no argumento de tipo rotulado</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Uma propriedade não pode ter parâmetros de tipo explícito. Considere usar um método.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Mensagens de saída em codificação UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Uma definição de módulo e tipo chamada '{0}' ocorreu no namespace '{1}' em duas partes deste assembly</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Nome '{0}' não associado no contexto de padrão</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>O construtor do provedor de tipos gerou uma exceção: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Tipo de argumento estático desconhecido '{0}' ao resolver uma referência a um método ou tipo fornecido '{1}'</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>A definição do operador personalizado '{0}' não usa uma combinação válida de sinalizadores de atributos</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} foi representado como método estático mas não foi uma expressão lambda apropriada</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 8-bit sem sinal</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Os atributos foram ignorados neste constructo</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' deve ser seguido por 'in'. Uso: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IEquatable&lt;_&gt;' . Aplique o atributo 'CustomEquality' ao tipo e forneça uma implementação consistente da substituição não genérica 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>O arquivo de origem é muito grande para ser inserido em um PDB portátil</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Um construtor de objeto requer um argumento</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Erro na leitura/gravação do metadado no DLL '{0}', que foi compilado por F#. O DLL foi compilado com uma versão inferior ao compilador F#? (erro: '{1}').</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Interfaces não podem conter definições de substituições de membros</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Atributos de visibilidade múltipla foram especificados por este identificador</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura é uma classe abstrata, mas a implementação não. Considere adicionar o atributo [&lt;AbstractClass&gt;] à implementação.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>O tipo fornecido '{0}' possui um membro '{1}' com tipo declarativo '{2}'. O tipo declarativo esperado deve ser o mesmo que o tipo fornecido.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class', 'interface' ou 'struct' incompatível</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Usado para associar um nome com um grupo de tipos e módulos relacionados, para separá-lo logicamente de outro código.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>O namespace ou o módulo '{0}' não está definido.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Este caso união obtém um argumento</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Lista de moduleDefn do tipo vazio inesperada</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Usado para condições boolianas (when guards) em correspondências de padrão e para introduzir uma cláusula de restrição para um parâmetro de tipo genérico.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Usado em conjunto com a palavra-chave correspondente em expressões de correspondência de padrão. Também usado em expressões de objeto, expressões de cópia de registros e extensões de tipo para apresentar as definições de membro e introduzir os manipuladores de exceção.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Indica o tipo void .NET. Usado ao interoperar com outras linguagens .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Usado em expressões condicionais. Também usado para desempenhar efeitos colaterais depois de construção de objeto.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Usado para declarar uma classe, registro, estrutura, união discriminada, tipo de enumeração, unidade de medida ou abreviação de tipo.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Usado para disponibilizar o conteúdo de um namespace ou módulo sem qualificação.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Indica a ausência de um objeto. Também usado em restrições de parâmetros genéricos.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Converte um tipo em um tipo em posição superior na hierarquia.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Usado como o nome do objeto de classe base.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Usado para especificar uma computação que deve ser executada somente quando um resultado é necessário.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Usado em ramificação condicional.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Usado em ramificação condicional. Uma forma abreviada de else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>Na sintaxe detalhada, indica o fim de um bloco de código em uma expressão de looping.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Uma referência ao DLL {0} é requerida pelo assembly {1}. O tipo importado {2} está localizado no primeiro assembly e não pôde ser resolvido.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para floats de 32-bit</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>As definições de tipo só podem ter uma especificação 'inherit' e devem ser a primeira declaração</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Valores literais não têm parâmetros genéricos</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Operador de cotação inesperado '&lt;@' na definição do tipo. Se você pretende passar uma cadeia de caracteres textual como argumento estático para um provedor de tipos, coloque um espaço entre os caracteres '&lt;' e '@'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>O operador '{0}' não deve ser referenciado normalmente. Para definir semânticas de comparação sobrecarregadas para um tipo particular, implemente a interface 'System.IComparable' na definição deste tipo.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Os métodos com argumentos via currying não podem declarar os argumentos 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' ou 'CallerFilePath'</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>A opção '--pdb' requer que seja usada a opção '--debug'</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>O valor '{0}' foi marcado como embutido, mas não está associado no ambiente de otimização</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>A propriedade '{0}' é estática</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' não é estruturalmente comparável porque o parâmetro de tipo {1} não satisfaz a restrição 'comparison'. Considere adicionar o atributo 'NoComparison' ao tipo '{2}' para esclarecer que o tipo não é comparável</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' não é estruturalmente comparável porque o tipo {1} não satisfaz a restrição 'comparison'. Considere adicionar o atributo 'NoComparison' ao tipo '{2}' para esclarecer que o tipo não é comparável</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação define um struct, mas a assinatura define um tipo com representação oculta</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Observação: as otimizações de levantamento de lambda não foram aplicadas devido ao uso desta função genérica restrita local como um valor de primeira classe. Adicionar restrições pode resolver esta condição.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>O uso de 'let! x = coll' em expressões de sequência não é permitido. Em vez disso, use 'for x in coll'.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificares 'mutable' são diferentes</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>O nome do arquivo MDB deve ser &lt;nome-do-arquivo-do-assembly&gt;.mdb. A opção --pdb será ignorada.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nA representação compilada deste método é como um membro estático, mas a assinatura indica que sua representação compilada seria como um membro de instância</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Não foi possível decodificar o atributo DllImport</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>A palavra-chave 'base' é usada de forma incorreta. Chamadas de base não podem ser usadas em fechamentos. Considere utilizar um membro particular para fazer chamadas de base.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' deve ser usado com um tipo nomeado</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Esta abreviação de tipo possui um ou mais parâmetros que não aparecem no tipo sendo abreviado. Abreviações de tipo usam todos os parâmetros de tipo declarados no tipo que está sendo abreviado. Considere remover um ou mais parâmetro de tipo ou usar uma definição de tipo concreto que encapsula um tipo adjacente, como 'type C&lt;'a&gt; = C of ...'.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>O nome do arquivo de resposta '{0}' está vazio, contém caracteres inválidos, tem uma especificação de unidade sem um caminho absoluto ou é muito longo</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a acessibilidade especificada na assinatura é maior que a especificada na implementação</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Nenhuma propriedade abstrata que corresponde a esta substituição foi encontrada</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Erro ao analisar IL incorporado</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Stubs DLLImport não podem ser embutidos</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Padrão inválido</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Um nome de método simples é requerido aqui</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>As definições de 'member val' são permitidas apenas em tipos com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>O sinalizador '{0}' foi definido duas vezes</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Cotações não podem conter expressões de objeto </value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Um valor marcado como 'embutido' possui um valor inesperado</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>As expressões 'match' não podem ser usadas em consultas</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>A propriedade '{0}' tem o mesmo nome que outra propriedade no tipo '{1}', mas uma tem argumentos de indexador e a outra não. Talvez você precise de um argumento de indexador para uma das suas propriedades.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Os identificadores seguidos por '{0}' são reservados para uso futuro</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Parâmetros de tipo explícitos só podem ser usados em associações de módulo ou membro</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>A propriedade '{0}' no tipo fornecido '{1}' possui CanWrite=false, mas GetSetMethod() retornou um método</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Emitir informações de depuração entre aspas</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Não inclua o manifesto Win32 padrão</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>reorganizador ativo</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>O atributo 'CompiledName' não pode ser usado com este elemento de linguagem</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Usado para declarar uma variável, ou seja, um valor que pode ser alterado.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>A assinatura para o arquivo ou módulo '{0}' já tinha sido especificada</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Cotações não podem conter expressões que definem campos de casos união</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Esta definição de tipo envolve uma referência cíclica imediata através de uma abreviação</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Valor inválido '{0}' para '--targetprofile', os valores válidos são 'mscorlib', 'netcore' ou 'netstandard'.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>As associações 'use' não são permitidas em construtores primários</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Os structs só podem vincular um parâmetro 'this' em declarações de membros</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Todos campos enum devem ser valores especificados</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>As definições de 'member val' e 'override val' não são permitidas em expressões de objetos.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois a abreviação de exceção está ocultada pela assinatura. A abreviação deve ser visível a outras linguagens CLI. Considere deixar a abreviação visível na assinatura. O módulo contém a definição de assinatura\n    {0}    \nmas sua assinatura especifica\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Usado junto com try para introduzir um bloco de código que é executado independentemente da ocorrência de uma exceção.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Marshallers personalizados não podem ser especificados em código F#. Considere usar uma função de ajuda de C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Nenhuma implementação de '{0}' tinha o número correto de argumentos e parâmetros de tipo. A assinatura necessária é '{1}'.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Substituições de método e implementações de interface não são permitidas aqui</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Não foi possível decodificar o atributo FieldOffset</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>O arquivo de assinatura '{0}' não possui um arquivo de implementação correspondente. Se houver um arquivo de implementação, você deverá verificar as declarações de 'módulo' e 'namespace' na assinatura e a correspondência de arquivos de implementação.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>O operador '{0}' não pode ser redefinido. Considere usar um nome de operador diferente</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura foi uma abreviação enquanto a implementação não</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>O parâmetro de tipo '{0}' não está definido.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Usado para especificar uma classe base ou interface base.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Recuo possivelmente incorreto: este token está fora do contexto iniciado na posição {0}. Tente recuar mais este token ou use conversões de formatação padrão.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes para exibição são diferentes</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Esta expressão literal ou este argumento de atributo resulta em um estouro aritmético.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Argumentos opcionais não podem ser usados em atributos personalizados</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Vincule estaticamente o assembly fornecido e todas as DLLs referenciadas que dependem deste assembly. Use um nome de assembly como mylib, por exemplo, não um nome de DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres textual inserida no comentário iniciado aqui ou anteriormente</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs valores de constantes literais e/ou atributos são diferentes</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Esta codificação Unicode só é válida em literais de cadeia de caracteres</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' só pode ser aplicado a argumentos opcionais</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Esta operação envolve pegar o endereço de um valor representado '{0}' através do uso de variável local ou outra representação especial, o que é inválido.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Não referencie os assemblies CLI padrões por padrão</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>O arquivo '{0}' não foi encontrado junto com FSharp.Core. Arquivo esperado em {1}. Considere atualizar para uma versão mais recente do FSharp.Corem, na qual esse arquivo não é mais necessário.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura diz que este tipo pode usar nulos como uma representação, mas a implementação não</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Fim de arquivo no comentário iniciado aqui ou anteriormente</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' não possui argumento ou propriedade de retorno configurável '{1}'. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Tipo da constante sem suporte '{0}'. Citações fornecidas pelos provedores de tipo só podem conter constantes simples. A implementação do provedor do tipo talvez precise ser ajustada movendo um valor declarado para fora de um literal de citação fornecido para que seja uma associação 'let' dentro do literal de citação.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Padrões ativos parciais só podem gerar um resultado</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>O tipo '{0}' não é acessível deste local do código</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Esta expressão de lista excede o tamanho máximo para literais de lista. Use uma matriz para literais maiores e chame Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o tipo de implementação é lacrado mas a assinatura implica que ele não é. Considere adicionar o atributo [&lt;Sealed&gt;] à assinatura.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>O argumento nomeado '{0}' não correspondeu ao argumento ou propriedade mutável</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Restrição inválida: o tipo usado para restrição está lacrado, o que significa que a restrição só pode ser satisfeita por no máximo uma solução</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Caractere inesperado '{0}'</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois um mapeamento de exceção CLI está sendo ocultado pela assinatura. O mapeamento de exceção deve ser visível a outros módulos. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Ignorando atributos em abreviação de módulo</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Tipo esperado, não unidade de medida</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>O tipo '{0}' implementa explicitamente o 'System.IComparable', mas não fornece nenhuma substituição correspondente para 'Object.Equals'. Uma implementação de 'Object.Equals' foi automaticamente fornecida e implementada via 'System.IComparable'. Considere implementar a substituição explícita 'Object.Equals'</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Não foi possível resolver o assembly '{0}' requerido por '{1}'</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Mutação inválida de uma expressão constante. Considere copiar a expressão para um local mutável, por exemplo: 'let mutable x = ...'.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Relatar avisos específicos como erros</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>A conversão de {0} para {1} é um upcast de segurança de tempo de compilação, não um downcast. Considere usar 'upcast' em vez de 'downcast'.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>O identificador '{0}' é reservado para uso futuro por F#</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Arquivos em bibliotecas ou aplicativos com arquivos múltiplos devem começar com uma declaração de namespace ou módulo, por exemplo, 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule'. Somente o último arquivo de origem de um aplicativo pode omitir tal declaração.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Uma associação não pode ser marcada com 'use' e 'rec' ao mesmo tempo</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Fim inesperado de entrada em argumentos de tipo</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é virtual e o outro não</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Esta notação de indexador foi removida do idioma F#</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>O tipo '{0}' é usado de forma inválida. Um valor anterior a '{1}' possui um tipo inferido envolvendo '{2}', que é uma referencia de encaminhamento inválida.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Método duplicado. O método '{0}' tem o mesmo nome e assinatura que outro método no tipo '{1}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Erro interno ou metadado malformado: os parâmetros de tipo que estavam no escopo durante a importação não são suficientes</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Número incorreto de argumentos de tipo para chamadas locais</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>A sintaxe 'module ... : sig .. end' não é usada no código F#. Considere usar 'module ... = begin .. end'</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Um tipo de interface é esperado</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>O nome '({0})' não deve ser usado como um nome de membro porque ele é dado a uma definição padrão na biblioteca F# sobre tipos fixos</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Fim inesperado de entrada em definição de tipo</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Valor inválido do parâmetro de unidade de medida '{0}'</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Valor inválido '{0}' para parâmetro de unidade de medida '{1}'</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Forma inválida para um getter de propriedade. Pelo menos um argumento '()' é necessário quando a sintaxe explícita é usada.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Um ou mais erros observados durante a configuração de tipo fornecida</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Expressões de construtor para interfaces não possuem argumentos</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Nível de aviso '{0}' inválido</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>O caso união chamado '{0}' conflita com o tipo gerado '{1}'</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>O membro '{0}' não corresponde a nenhum método virtual ou abstrato disponível para substituição ou implementação.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Construção de registros inválida</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs tipos dos campos são diferentes</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Rótulo {0} não encontrado</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>O padrão ativo '{0}' possui um tipo de resultado contendo variáveis de tipo que não são determinadas pela entrada. A causa comum é a falta da menção ao caso de resultado, por exemplo 'let (|A|B|) (x:int) = A x'. Isto pode ser corrigido com uma restrição de tipo, por exemplo 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' requer {1} argumentos, mas aqui são fornecidos os argumentos sem nome {2} e nomeado {3}. A assinatura requerida é '{4}'.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>O tipo/módulo '{0}' não é um módulo ou tipo concreto</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- ARQUIVOS DE SAÍDA -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>As sobrecargas disponíveis são mostradas abaixo (ou na janela Lista de Erros).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' é usado com um número incorreto de argumentos. Esta é uma operação personalizada nesta consulta ou expressão de computação. {1} argumentos são esperados, mas {2} foram fornecidos.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} não é um método de instância</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Esta forma de expressão de objeto não é usada em F#. Use 'member this.MemberName ... = ...' para definir implementações de membros em expressões de objetos.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Expressão inesperada no ponto de inferência recursiva</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o membro abstrato '{2}' foi requerido pela assinatura, mas não foi especificado pela implementação</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>O método ou função '{0}' não deverá receber argumentos de tipo explícito porque eles não declaram explicitamente seus parâmetros de tipo</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>O tipo '{0}' possui uma representação de código de assembly embutida</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Valores recursivos não podem ser atribuídos diretamente ao campo não mutável '{0}' do tipo '{1}' em uma associação recursiva. Considere usar um registro em vez disso.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignore avisos de compatibilidade ML</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>O membro do operador infixo '{0}' não possui argumentos. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Interfaces não podem conter definições de membros concretos. Talvez seja necessário definir um construtor no seu tipo para indicar que o tipo é uma classe.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Qualificação após '.' ausente</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Está faltando a instanciação do tipo genérico '{0}', a qual não pode ser inferida a partir de argumentos ou tipo de retorno deste membro. Considere providenciar uma instanciação de tipo quando acessar este tipo, por exemplo '{1}'.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Identificadores de caso de padrão ativo precisam ser iniciados com uma letra maiúscula</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>O 'h' ou 'H' é desnecessário neste especificador de formato. Você pode usar %d, %x, %o ou %u em seu lugar, que estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>A forma de expressão 'expr then expr' só pode ser usada como parte de um construtor de objeto explícito</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Valores 'base' só podem ser usados para fazer chamadas diretas às implementações de base de membros substituídos</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Esta não é uma expressão constante ou um valor de atributo personalizado válido</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Esta associação recursiva usa uma mistura inválida de formas recursivas</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IComparable&lt;_&gt;'. Você deve aplicar o atributo 'CustomComparison' ao tipo, além de fornecer uma implementação consistente da interface não genérica System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Atribuição inválida</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres iniciada aqui ou anteriormente</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>O tipo de uma função de primeira classe não pode conter byrefs</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'equality' porque ele é um tipo de função</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'equality' porque é um registro, união ou struct com um ou mais tipos de elementos estruturais que não suportam a restrição 'equality'. Evite usar igualdade com este tipo, a não ser que você adicione o atributo 'StructuralEquality' ao tipo para determinar qual tipo de campo não suportará a igualdade</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>O tipo '{0}' não suporta a restrição 'equality' porque possui o atributo 'NoEquality'</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'use!'.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>O uso da sintaxe de tipo 'int C' e 'C &lt;int&gt;' não é permitido aqui. Considere adaptar este tipo para ser gravado na forma 'C&lt;int&gt;'</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Sinalizador de prefixo (' ' ou '+') definido duas vezes</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Localizada pela chave de registro AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Esse constructo só pode ser utilizado em expressões de sequência ou computação</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Erro ao analisar tipo de IL embutido</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Atributos [&lt;ThreadStatic&gt;] ou [&lt;ContextStatic&gt;] não podem ser dados a um valor literal</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>O assembly '{0}' possui um atributo TypeProviderAssembly com valor inválido '{1}'. O valor deve ser um nome de assembly válido</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Este valor de função está sendo usado para construir um tipo delegado cuja assinatura inclui argumento byref. Você deve usar uma expressão lambda que obtenha argumentos {0}.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Abreviações para exceções do IL Comum não podem pegar argumentos</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de enumerador válido, ou seja, não possui um método MoveNext()' retornando um bool e uma propriedade 'Current'</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Fim de arquivo na diretiva iniciada aqui ou anteriormente</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>O sinalizador '{0}' não suporta precisão</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Construtores para o tipo '{0}' devem chamar seu construtor de objeto implícito direta ou indiretamente. Use uma chamada para o construtor de objeto implícito em vez de uma expressão de registro.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' não está sendo usado corretamente. Esta é uma operação personalizada nesta consulta ou expressão de computação.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>[&lt;' Fechamento esperado '&gt;]' incompatível</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Uso inválido da 'fixed'. 'fixed' somente pode ser usada em uma declaração no formato 'use x = fixed expr', em que a expressão é uma matriz, o endereço de um campo, o endereço de um elemento de matriz ou uma cadeia de caracteres</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>O caractere '{0}' não é permitido no nome de tipo fornecido '{1}'.</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>O parâmetro estático '{0}' do tipo fornecido ou método '{1}' requer um valor. Parâmetros estáticos para provedores de tipos podem, opcionalmente, ser especificados usando argumentos nomeados, por exemplo, e.g. '{2}&lt;{3}=...&gt;'.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>SynMeasure.Anon Inesperado</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert' não pode ser usado como um valor de primeira classe. Em vez disso, use 'assert &lt;expr&gt;'.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Não é possível herdar de um tipo de variável</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Os casos união ou campos do tipo '{0}' não são acessíveis deste local de código</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Valores de função mutáveis devem ser escritos como 'let mutable f = (fun args -&gt; ...)'</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Apenas tipos de classe podem ter argumentos de valor</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Número de aviso inválido '{0}'</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>O tipo '{0}' tem um tipo delegado não padrão</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>O membro '{0}' não aceita o número correto de argumentos. São esperados {1} argumentos, mas foram fornecidos {2}. A assinatura exigida é '{3}'.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é final e o outro não</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Delegados não estão autorizados a ter assinaturas na forma curried</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Limite em quais plataformas este código pode ser executado: x86, Itanium, x64, anycpu32bitpreferred ou anycpu. O padrão é anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Unidade de medida esperada, não tipo</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Especificar um arquivo de recursos do Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Associações de classes locais não podem ser marcadas como embutidas. Considere elevar a definição de classe ou não marcá-la como embutida.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(descrição não disponível...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>O tipo '{0}' não está definido em '{1}'.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Identificador esperado</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Token inesperado '{0}' na expressão do pré-processador</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Precisão após o '.' ausente</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Uma cotação não pode incluir uma atribuição para ou assumir o endereço de uma variável local capturada</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>A opção de linha de comando '{0}' é somente para propósitos de teste</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Considere usar 'yield!' em vez de 'yield'.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>O tipo herdado não é um tipo de objeto modelo</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>O módulo principal do programa está vazio: nada ocorrerá enquanto ele estiver em execução</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Uma versão especificada {0} '{1}', mas esse valor é um curinga, e você solicitou uma compilação determinística. Eles estão em conflito.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>A passagem de um arquivo .resx ({0}) como arquivo de origem para o compilador foi preterida. Use o resgen.exe para transformar o arquivo .resx em um arquivo .resources para passar como uma opção --resource. Se você estiver usando o MSBuild, isso poderá ser feito via um item &lt;EmbeddedResource&gt; no arquivo de projeto .fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>O caminho '{0}' é um namespace. Uma abreviação de módulo não pode abreviar um namespace.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Uma declaração só pode ser dada a uma assinatura se a declaração possuir o atributo [&lt;Literal&gt;]</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Exceção ao acessar o '{0}' de um tipo fornecido: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Usado para especificar que membro está visível dentro de um assembly, mas não fora dele.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Nenhum #endif encontrado para #if ou #else</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Assinatura de membro inválida encontrada devido a um erro anterior</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>O campo nomeado '{0}' está em conflito com o nome gerado automaticamente para o campo anônimo.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Diretiva inválida. '#time', '#time \"on\"' ou '#time \"off\"' era esperado.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos nesta posição para tipos enum</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Não são permitidos atributos aqui</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- LINGUAGEM -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Tipo de depuração desconhecida '{0}', 'pdbonly' ou 'full' era esperado</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>O uso de 'into' deve ser seguido pelo restante da computação</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Não são permitidos usos de primeira classe da função 'reraise'</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;' sem correspondência. '&gt;' de fechamento esperado</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o val '{2}'</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Argumentos de tipo explícito devem ser dados à função genérica '{0}'</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>A propriedade '{0}' no tipo fornecido '{1}' possui CanRead=true, mas não houve valor de GetGetMethod()</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Um tipo de retorno de método conteria byrefs que não são permitidos</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>O evento '{0}' é estático</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Este token está reservado para uso futuro</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>Em um grupo de declaração recursivo, as declarações 'open' devem vir antes em cada módulo</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>O tipo fornecido '{0}' retornou um membro com nome de membro nulo ou vazio</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato inválido (após l ou L): esperado: ld,li,lo,lu,lx ou lX. No código F#, você pode usar %d, %x, %o ou %u no lugar, os quais estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Valor literal fornecido '{0}' inválido</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Tipos de interface não podem ser lacrados</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>O literal em minúsculas '{0}' está sendo ocultado por um novo padrão com o mesmo nome. Somente literais com prefixo de módulo e em maiúsculas podem ser usados como padrões de nomes.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Valor indefinido '{0}'</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Esse constructo só pode ser utilizado em expressões de lista, a matriz e sequência, como expressões da forma 'seq {{ ... }}', '[ ... ]' ou '[| ... |]', por exemplo. Elas usam a sintaxe 'for ... in ... do ... yield...' para gerar elementos</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Um atributo personalizado deve ser um tipo de referência</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Um campo estático foi usado onde era esperado um campo de instância</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'(' incompatível</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Não foi possível determinar uma sobrecarga única para o método '{0}' com base nas informações de tipo anteriores a este ponto do programa. Uma anotação de tipo pode ser necessária.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' não é {1}</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Emita as informação de depuração (Forma abreviada: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>A opção '--keyfile' substitui o atributo 'System.Reflection.AssemblyKeyFileAttribute' fornecido em um módulo adicionado ou arquivo de origem</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Leia o arquivo de resposta para obter mais opções</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{' incompatível</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin' incompatível</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Esta definição 'let' não pode ser usada em uma consulta. Somente definições de valores simples podem ser usadas em consultas.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Um membro protegido é chamado ou a 'base' está sendo usada. Isso só é permitido na implementação direta dos membros, uma vez que eles poderiam escapar do escopo de seus objetos.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Argumentos de tipo devem ser colocados diretamente ao lado do nome do tipo, por exemplo: \"C&lt;'T&gt;\", não \"C  &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Parâmetros de tipo devem ser colocados diretamente ao lado do nome do tipo, por exemplo: \"type C&lt;'T&gt;\", não     type \"C   &lt;'T&gt;\"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Não foi possível resolver a ambiguidade inerente ao uso de uma cadeia de caracteres com formato de estilo 'printf'</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Erro na expressão de retorno para este 'let'. Possível recuo incorreto.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>A instanciação implícita do constructo genérico neste ponto ou próximo a ele não pode ser resolvida porque ele conseguiu resolver tipos não relacionados múltiplos, por exemplo '{0}' e '{1}'. Considere usar anotações de tipo para resolver a ambiguidade</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Argumentos opcionais devem vir no final da lista de argumentos, depois dos argumentos não opcionais</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>A tentativa de analisar isto como um nome de operador falhou</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Referenciar um assembly (Forma abreviada: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Localizada pela chave de registro AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get', 'set' ou 'get,set' necessários</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' não é um argumento de ponto flutuante válido</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>A opção de linha de comando '{0}' foi preterida. Use '{1}' em seu lugar.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Um tipo com atributo 'CustomEquality' deve ter uma implementação explícita de pelo menos 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>{0} inesperado na expressão de tipo</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Destino de atributo não reconhecido. Os destinos de atributos válidos são 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event' e 'constructor'.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Corpo de função ausente</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Os modificadores de acessibilidade não são permitidos aqui, mas '{0}' foi fornecido.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Tipos não podem conter definições de tipo aninhadas</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Mensagens de aviso e erro de saída em cores</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Uso inválido de um nome de tipo</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Este valor não possui um tipo de setter de propriedade válido</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>O diretório de pesquisa '{0}' é inválido</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Vincule o recurso especificado a este assembly, em que o formato resinfo é &lt;arquivo&gt;[,&lt;nome da cadeia de caracteres&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>O denominador não deve ser 0 no expoente de unidade de medida</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'inherit' não pode ser usado em tipos de interface. Considere implementar a interface usando 'interface ... with ... end'.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Literal de inteiro inesperado na expressão de unidade de medida</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' só podem ser usados com tipos nomeados</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>aumento padrão do caso união</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Este valor não é uma função e não pode ser aplicado.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato ausente</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Uma propriedade do indexador deve receber pelo menos um argumento</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Destino desconhecido '{0}', 'exe', 'winexe', 'library' ou 'module' era esperado</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'do' ausente em expressão 'while'. 'while &lt;expr&gt; do &lt;expr&gt;' esperado.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Fim inesperado de entrada no corpo da expressão lambda. 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' esperado.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>O arquivo de documentação não possui sufixo .xml</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>O uso de '-&gt;' em sequência e expressões computacionais é limitado à forma 'for pat in expr -&gt; expr'. Use a sintaxe 'for ... in ... do ... yield...' para gerar elementos em expressões de sequência mais complexas.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Espera-se que uma propriedade getter seja uma função, por exemplo, 'get() = ...' ou 'get(índice) = ...'</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Cotação incompatível, começando com '{0}'</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 64-bit sem sinal</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' não encontrado no tipo '{2}' do assembly '{3}'. Uma possível causa seria uma incompatibilidade de versão. Talvez seja necessário fazer uma referência explicitamente à versão correta deste assembly para permitir que todos os componentes referenciados utilizem a versão correta.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs parâmetros genéricos na assinatura e na implementação possuem tipos diferentes. Talvez exista um atributo [&lt;Measure&gt;] ausente.</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Este tipo não pode ser usado para um campo literal</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Habilitar ou desabilitar tailcalls</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>As expressões de registros copiar e atualizar devem incluir pelo menos um campo.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres inserida no comentário iniciado aqui ou anteriormente</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Uma consulta de operação personalizada para '{0}' é necessária, mas não foi especificada</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Literal inválido no tipo</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>O membro '{0}' corresponde a várias sobrecargas do mesmo método.\nLimite-o a uma das seguintes:{1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Se um tipo de união tiver mais de um caso e for struct, então todos os campos dentro do tipo de união deverão ter nomes exclusivos.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>A propriedade '{0}' no tipo fornecido '{1}' não é legível nem gravável, pois possui CanRead=false e CanWrite=false</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>propriedade gerada</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Campos 'val' estáticos em tipos devem ser mutáveis, particulares e marcados com o atributo '[&lt;DefaultValue&gt;]'. Eles são iniciados com o valor 'null' ou 'zero' para seus tipos. Também considere usar uma associação 'static let mutable' em um tipo de classe.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Este método espera um parâmetro CLI 'params' nesta posição. 'params' é uma forma de transmitir um número de variável de argumentos para um método em linguagens como C#. Considere transmitir uma matriz para este argumento</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Campos 'val' não inicializados devem ser mutáveis, particulares e marcados com o atributo '[&lt;DefaultValue&gt;]'. Considere usar uma vinculação 'let' em vez de um campo 'val'.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>O tipo fornecido '{0}' possui 'IsGenericType' como verdadeiro, mas não há suporte a tipos genéricos.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Todos direitos reservados.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Cotações não podem conter expressões que definem campos nos valores de exceção</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Este literal matriz de byte contém caracteres não codificados como um byte simples</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Atributos devem ser localizados antes de 'val'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação define {2} '{3}', mas a assinatura não (ou define em ordem diferente)</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Uma medida de unidade anônima não poder ser aninhada dentro de outra expressão de unidade de medida</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>A assinatura e implementação não são compatíveis porque a declaração do parâmetro de tipo '{0}' requer uma restrição da forma {1}</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>tipo ou módulo</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Os tipos fornecidos aninhados não recebem argumentos estáticos ou parâmetros genéricos</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Esta declaração abre o módulo '{0}', que é marcado como 'RequireQualifiedAccess'. Ajuste seus códigos para usar referências qualificadas aos elementos do módulo, por exemplo 'List.map' ao invés de 'map'. Esta mudança garantirá que seu código seja robusto porque novos construtores são adicionados às bibliotecas.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Este elemento de declaração não é permitido em um aumento</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>O construtor de objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Este novo membro oculta o membro abstrato '{0}'. Renomeie o membro ou use 'override'.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>A espécie do tipo especificado por seus atributos não corresponde à espécie sugerida por sua definição</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Ocorreu um problema ao gravar o binário '{0}': {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Restrições de literais numéricos não primitivos não podem ser usadas em correspondências padrões porque podem ser mapeadas para multiplicar tipos diferentes através do uso de um módulo NumericLiteral. Considere substituir por uma variável e use 'when &lt;variável&gt; = &lt;constante&gt;' no final da cláusula de correspondência.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>A assinatura e implementação não são compatíveis porque o parâmetro de tipo na classe/assinatura tem um requisito em tempo de compilação diferente de um membro/implementação</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Argumentos redundantes estão sendo ignorados na função '{0}'. Era esperado {1} mas foi obtido {2} argumentos.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Um atributo personalizado deve chamar um construtor de objeto</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>A sintaxe 'expr.id' só pode ser usada em rótulos de registros, propriedades e campos</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Um tipo é esperado após este ponto</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>O atributo 'ReferenceEquality' não pode ser usado em structs. Considere usar o atributo 'StructuralEquality' em seu lugar, ou implemente uma substituição para 'System.Object.Equals(obj)'.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>A substituição '{0}' implementa mais de um slot abstrato, por exemplo '{1}' e '{2}'</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>O membro '{0}' não aceita o número correto de argumentos. Uma sobrecarga aceita {1} argumentos, mas {2} foram fornecidos. A assinatura exigida é '{3}'.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Um nome de módulo precisa ser um nome simples, não um caminho</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Para indicar que esta propriedade pode ser definida, use 'member val PropertyName = expr com get,set'.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Não é possível localizar FSharp.Core.dll no diretório do compilador</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois os tipos têm bases diferentes</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Nenhuma sobrecarga corresponde ao método '{0}'.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Este não é um construtor ou literal, ou então um construtor está sendo usado de forma incorreta</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Apenas unidades de medida de representações de tipos podem receber o atributo 'Measure'</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Argumentos esperados para um membro de instância</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Este código é menos genérico que o requerido por suas anotações porque não foi possível gerar a variável de tipo explícito '{0}'. Ela foi restrita para ser '{1}'.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>O operador '{0}' não deve ser referenciado normalmente. Para definir semânticas de igualdade para um tipo, substitua o membro 'Object.Equals' na definição deste tipo.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Um tipo com atributo 'ReferenceEquality' não pode ter uma implementação explícita de 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' ou 'System.Collections.IStructuralEquatable'</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>O sinalizador de atributo 'UseNullAsTrueValue' só podem ser usados com tipos de união que possuem um caso nulário e pelo menos um caso não nulário</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' ou 'struct' incompatível</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Atribui um valor a uma variável.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Fim de arquivo na seção #if iniciada aqui ou anteriormente</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Correspondências de intervalo de caractere foram removidas em F#. Considere usar um 'when' na proteção padrão.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! somente pode aparecer na primeira linha do início de um arquivo.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Não é possível especificar construtores em aumentos de exceções</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>O tipo fornecido '{0}' possui 'IsArray' como verdadeiro, mas não há suporte a tipos matriz.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Propriedade duplicada. A propriedade '{0}' tem o mesmo nome e assinatura que outra propriedade no tipo '{1}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o módulo/namespace '{2}'</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>A forma de declaração 'let ... and ...' para associações não recursivas não são usadas em código F#. Considere usar uma sequência de associações 'let'</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.GetHashCode' ou 'Object.Equals'. Você deve aplicar o atributo 'CustomEquality' ao tipo</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Uso inválido de um construtor delegado. Use a sintaxe 'new Type(args)' ou somente 'Type(args)'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>A assinatura e implementação não são compatíveis porque o parâmetro de tipo '{0}' possui uma restrição da forma {1}, mas a implementação não. Remova esta restrição da assinatura ou a adicione à implementação.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>O assembly referenciado '{0}' possui atributo de nível de assembly '{1}', mas nenhuma classe de provedor de tipos público foi encontrada</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Relatar todos os avisos como erros</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>TABs não são permitidos em código F#, a menos que a opção #indent \"off\" seja usada</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Argumento estático inválido para tipo fornecido. Argumento do tipo '{0}' esperado.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Valores mutáveis não podem ser marcados como 'inline'</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Mais de uma substituição implementa '{0}'</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Instâncias desse tipo não podem ser criadas uma vez que elas foram marcadas como abstratas ou nem todos os métodos receberam implementações. Considere usar uma expressão de objeto '{{ new ... with ... }}' em vez disso.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>Em um grupo de declaração recursivo, as abreviações de módulo devem vir após todas as declarações 'open' e antes de outras declarações</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Usado como uma alternativa menor para a palavra-chave "fun" e uma expressão de correspondência em uma expressão lambda que tem correspondência de padrão em um único argumento.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes compilados são diferentes</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \ n, mas sua assinatura especifica\n    {2}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Esta não é uma expressão de construção de objeto válida. Construtores de objeto explícitos devem chamar um construtor alternativo ou então iniciar todos os campos do objeto e especificar uma chamada para um construtor de superclasse.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Plataforma não reconhecida '{0}', os valores válidos são 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' e 'anycpu'</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>new' não pode ser usado em tipos de interface. Considere usar uma expressão de objeto '{{ new ... with ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma abreviação está sendo ocultada por uma assinatura. A abreviação deve estar visível a outras linguagens CLIs. Considere deixar a abreviação visível na assinatura.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Forma inválida para um setter de propriedade. Pelo menos um argumento é necessário.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>As expressões 'let!', 'use!' e 'do!' não podem ser usadas em consultas</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres textual iniciada aqui ou anteriormente</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Este campo é somente leitura</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Não foi possível decodificar o atributo StructLayout</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo delegado CLI</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Esta expressão não é uma função e não pode ser aplicada. Você pretendia acessar o indexador por meio do expr.[index] como alternativa?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Substituir por '{0}'</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>O campo da struct ou classe '{0}' não é acessível neste local do código</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Usado em uma expressão de computação para acrescentar ao resultado de uma expressão de computação fornecida a uma coleção de resultados para a expressão de computação que a contém.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Expressão '{0}' inválida</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Esse parâmetro de tipo não pode ser instanciado como 'Nullable'. Esta é uma restrição imposta para assegurar que o significado de 'null' em algumas linguagens CLI não seja confuso quando usado em conjunto com valores 'Nullable'.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Uma implementação de arquivo ou módulo '{0}' já foi fornecida</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>O provedor de tipos '{0}' forneceu um construtor que não é relatado entre os construtores de seu tipo declarante '{1}'</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Interfaces herdadas de outras interfaces devem ser declaradas com o uso de 'inherit ...' ao invés de 'interface ...'</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Uma função rotulada com o atributo 'EntryPointAttribute' deve ser a última declaração no último arquivo na sequência de compilação.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>O tipo de registro '{0}' não contém um rótulo '{1}'.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Bloco não foi fechado</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Esta propriedade ou campo não foram encontrados neste tipo de atributo personalizado</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Um namespace e um módulo chamado '{0}' ocorrem em duas partes deste assembly</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Especifique o perfil da estrutura de destino deste assembly. Os valores válidos são mscorlib, netcore ou netstandard. O padrão é mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>Começando no F# 4.1, a acessibilidade das abreviações de tipo é verificada no momento da compilação. Considere alterar a acessibilidade do tipo de abreviação. Ignorar este aviso pode levar a erros de tempo de execução.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>A diretiva #endif deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Estrutura RSAParameters inválida - '{{0}}' esperado</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' não suporta igualdade estrutural porque o parâmetro de tipo {1} não satisfaz a restrição 'equality'. Considere adicionar o atributo 'NoEquality' ao tipo '{2}' para esclarecer que o tipo não suporta igualdade estrutural</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' não suporta igualdade estrutural porque o tipo {1} não satisfaz a restrição 'equality'. Considere adicionar o atributo 'NoEquality' ao tipo '{2}' para esclarecer que o tipo não suporta igualdade estrutural</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Este atributo não é válido para ser usado neste elemento de linguagem. Os atributos de assembly devem ser anexados a uma declaração 'do ()' e, se necessário, em um módulo F#.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Variáveis de thread estático e de contexto estático devem ser estáticas e receber o atributo [&lt;DefaultValue&gt;] para indicar que o valor é inicializado como valor padrão a cada novo thread</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>O endereço de um elemento de matriz não pode ser usado neste ponto</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Erro de sintaxe: especificação de parâmetro de tipo inesperada</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Não foi possível decodificar o atributo DefaultAugmentation</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>O tipo de um campo que usa o atributo 'DefaultValue' deve admitir inicialização padrão, ou seja, possuir 'null' como valor adequado, ou ser um tipo struct cujos todos campos admitem inicialização padrão. Você pode usar 'DefaultValue(false)' para desabilitar esta verificação</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Usado para implantar uma versão de um resumo ou método virtual que difere da versão de base.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Exceção inesperada do membro '{1}' do tipo fornecido '{0}': {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Uma variável de tipo foi restringida por vários tipos de classes diferentes. Uma variável de tipo só pode conter uma restrição de classe.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Esse método fornecido requer parâmetros estáticos</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>O construtor, o módulo ou o namespace '{0}' não está definido.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Este tipo não é acessível deste local de código</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Os atributos deste tipo especificam múltiplas variedades para este tipo</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Esta operação acessa um valor de alto nível mutável definido em outro assembly de uma forma não suportada. O valor não pode ser acessado através de seu endereço. Considere copiar a expressão ao local mutável, por exemplo: 'let mutable x = ...', e se for necessário atribuir o valor de volta após a conclusão da operação</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão 'try'. 'try &lt;expr&gt; with &lt;regras&gt;' ou 'try &lt;expr&gt; finally &lt;expr&gt;' esperado.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão 'for'. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' esperado.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as representações são diferentes</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Cotações não podem conter este tipo de correspondência de padrão</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Fim de tipo inesperado. Esperado um nome após este ponto.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>O provedor de tipos '{0}' relatou um erro: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Falha ao gerar MDB. Não foi possível encontrar o membro compatível {0}</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Abreviações de tipo não podem ter declarações de interface</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>O atributo 'StructuralEquality' deve ser usado junto com os atributos 'NoComparison' ou 'StructuralComparison'</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Operadores da união de expressão só podem ser usados entre aspas</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif não tem nenhuma correspondência #if</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Este atributo não é válido para ser usado neste elemento de linguagem</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Gerar verificações de estouro</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Livremente distribuído sob a Licença de Software Livre do MIT. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' não obtém argumentos {1}. Uma sobrecarga foi encontrada ao obter argumentos {2}.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>O atributo '{0}' do assembly refere-se a um assembly de designer '{1}' que não pode ser carregado ou não existe. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Exceção inesperada do membro '{0}' do membro '{2}' do tipo fornecido '{1}': {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Um provedor de tipos implementado ObterParâmetrosEstáticosParaMétodo, mas AplicarArgumentosEstatísticasParaMétodo não foi implementado ou inválido</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- RECURSOS -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>O código neste assembly usa literais de cotação. A vinculação estática pode não incluir componentes que usam literais de cotação, a menos que todos os assemblies estejam compilados com, pelo menos, F# 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' deve vir após uma cláusula de seleção 'for' e ser seguido pelo restante da consulta. Sintaxe: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>A opção '--delaysign' substitui o atributo 'System.Reflection.AssemblyDelaySignAttribute' fornecido em um arquivo de origem ou módulo adicionado</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Não é válido pegar o endereço de um campo literal</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 32-bit com sinal</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|' incompatível</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' não é {1}. Membros particulares só podem ser acessados no tipo de declaração. Membros protegidos só podem ser acessados em um tipo de extensão e não podem ser acessados em expressões lambda internas.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>O método ou o construtor de objeto '{0}' não é estático</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>O código no assembly '{0}' usa literais de cotação. A vinculação estática pode não incluir componentes que usam literais de cotação, a menos que todos os assemblies estejam compilados com, pelo menos, F# 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' não é um nome de arquivo válido</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Assine de forma pública o assembly usando a única parte pública da chave de nome forte e marque o assembly como assinado</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 16-bit sem sinal</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>O provedor de tipos '{0}' retornou um tipo inválido de 'ApplyStaticArguments'. Um tipo com nome '{1}' era esperado, mas um tipo com nome '{2}' foi retornado.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>O local mutável '{0}' está alocado implicitamente como uma célula de referência porque foi capturado por um fechamento. Este aviso é somente para fins informativos para indicar onde alocações implícitas são executadas.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>No código F#, é possível usar o 'expr.[expr]'. Uma anotação de tipo pode ser necessária para indicar que a primeira expressão é uma matriz</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Interfaces não podem conter definições de construtores de objeto</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Versão inválida '{0}' para '--subsystemversion'. A versão deve ser 4.00 ou posterior.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Argumentos nomeados devem aparecer depois de todos os argumentos</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>A variável '{0}' está associada a uma cotação, mas é usada como parte de uma expressão de união. Isso não é permitido, pois pode sair do escopo.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Não foi possível resolver a ambiguidade no uso de um construtor genérico com uma restrição 'enum' nesta posição ou próximo a ela</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Nenhum diretório de assinatura</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Operador infixo inesperado na expressão de unidade de medida. Os operadores válidos são '*','/' e '^'.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>propriedade</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Não é possível herdar um tipo lacrado</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Esse constructo é ambíguo como parte de uma expressão de sequência. Expressões aninhadas podem ser gravadas usando 'let _ = (...)' e sequências aninhadas através de 'yield! seq {{... }}'.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IStructuralEquatable'. Aplique o atributo 'CustomEquality' ao tipo.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Este membro não é permitido em uma implementação do objeto</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Um assembly importado usa o tipo '{0}', mas este tipo não é público</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- DIVERSOS -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>O módulo/namespace '{0}' da unidade de compilação '{1}' não contém o namespace, módulo ou tipo '{2}'</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>O serviço de compilação residente não foi usado porque houve um problema de comunicação com o servidor.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Uma declaração de campo/val não é permitida aqui</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Restrições 'new' devem pegar um argumento do tipo 'unit' e retornar o tipo construído</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Use um serviço de compilação em segundo plano residente para aprimorar os tempos de inicialização do compilador.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Restrição inválida</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação diz que este tipo pode usar nulos como uma representação, mas a assinatura não</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Ocorreu um erro ao aplicar os argumentos estáticos para um método fornecido</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Inserir o recurso gerenciado especificado</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Não foi possível encontrar o método System.Runtime.CompilerServices.OffsetToStringData nas referências ao compilar a expressão 'fixed'.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Um membro e uma associação de classe local têm o mesmo nome '{0}'</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' deve ser seguido por um nome de variável. Uso: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Este teste de tipo com um tipo fornecido '{0}' não é permitido porque este tipo fornecido será apagado para '{1}' no tempo de execução.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação é uma classe abstrata e a assinatura não. Considere adicionar o atributo [&lt;AbstractClass&gt;] à assinatura.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Incompatibilidade de comprimento do argumento</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Este valor não é uma função e não pode ser aplicado. Você esqueceu de finalizar a declaração?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>O membro '{0}' não pode ser usado para implementar '{1}'. A assinatura necessária é '{2}'.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Este tipo implementa a mesma interface em instanciações genéricas diferentes '{0}' e '{1}'. Isto não é permitido nesta versão de F#.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>A opção '--keycontainer' substitui o atributo 'System.Reflection.AssemblyNameAttribute' fornecido em um módulo adicionado ou arquivo de origem</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>O tipo de sistema '{0}' era necessário, mas nenhum DLL de sistema referenciado o continha</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Usado para indicar uma expressão de computação que, quando avaliada, fornece o resultado da expressão de computação que a contém.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>O membro do operador infixo '{0}' possui argumentos na forma curried adicionais. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Este membro não é permitido em implementação de interfaces</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>O membro do operador infixo '{0}' possui {1} argumentos iniciais. Uma tupla de 3 argumentos é esperada</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>O atributo FieldOffset só pode ser colocado em membros de tipos marcados com StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Um construtor não pode ter parâmetros de tipo explícitos. Considere usar um método de construção estática.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>A propriedade '{0}' no tipo fornecido '{1}' possui CanRead=false, mas GetGetMethod() retornou um método</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>Em consultas, '{0}' deve usar um padrão simples</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Const_bytearray inesperado</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Expr.TyChoose inesperado</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Fim inesperado de entrada em membros de objeto.</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>O método '{0}' tem argumentos na forma curried, mas tem o mesmo nome que outro método no tipo '{1}'. Os métodos com argumentos na forma curried não podem estar sobrecarregados. Considere usar um método que tenha argumentos na forma de tupla.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Um {0} especificou a versão '{1}', mas esse valor é inválido e foi ignorado</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>O parâmetro de tipo não pode ser usado como construtor de tipo</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Variáveis mutáveis não podem escapar de seus métodos</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Declarações de medida só podem ter membros estáticos</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>O operador '{0}' não deve ser referenciado normalmente. Considere usar um nome de operador diferente</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>O valor do tipo byref '{0}' não pode ser usado neste ponto</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Não foi possível encontrar o diretório de pesquisa '{0}'</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Esse constructo é ambíguo como parte de uma expressão de computação. Expressões aninhadas podem ser gravadas com o uso de 'let _ = (...)' e computações aninhadas através de 'let! res = builder {{ ... }}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura define {2} '{3}', mas a implementação não (ou define em uma ordem diferente)</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Nome completo</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Mensagens de saída com caminhos totalmente qualificados</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo {2} estava presente na implementação, mas não na assinatura</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Não copiar FSharp.Core.dll nos binários produzidos</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Uma construção genérica requer que o tipo '{0}' seja um tipo não gerenciado</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.Equals'. Considere implementar uma substituição correspondente para 'Object.GetHashCode()'</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Declarações de tipo explícito para construtores devem estar na forma 'ty1 * ... * tyN -&gt; resTy'. Pode ser necessário usar parênteses em torno de 'resTy'</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Usado para indicar que uma função é recursiva.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Usado em uma assinatura para indicar um valor ou em um tipo para declarar um membro em situações limitadas.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Usado ao invés de let para valores que necessitam que Dispose seja chamado para liberar recursos.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Usado para introduzir um bloco de código que pode gerar uma exceção. Usado junto com with ou finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Usado para declarar, definir ou invocar um construtor que cria ou que pode criar um objeto. Também usado em restrições de parâmetro genérico para indicar que um tipo deve ter um certo construtor.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Não é uma palavra-chave real. No entanto, o "not struct" em combinação é usado como uma restrição de parâmetro genérico.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Usado para associar um nome para uma função ou valor.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Usado em expressões lambda, também conhecidas como funções anônimas.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Usado em constructos de looping.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Em definições e extensões de tipo, indica o final de uma seção de definições de membro. Na sintaxe detalhada, é usado para especificar o final de um bloco de código que começa com a palavra-chave "begin".</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>O getter e o setter de uma propriedade devem ter o mesmo tipo. A propriedade '{0}' possui getter do tipo '{1}', mas setter do tipo '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>O número de argumentos de tipo não corresponde: '{0}' fornecido, '{1}' esperado. Isso pode estar relacionado a um erro relatado anteriormente.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Este campo requer um nome</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>tipo gerado</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Cadeia de caracteres de versão inválida '{0}'</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Argumentos de tipos não podem ser especificados aqui</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros nativos com sinal</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Esse teste de tipo ou downcast irá apagar o tipo fornecido '{0}' para o tipo '{1}'</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Declarações 'inherit' não podem ter associações 'as'. Para acessar membros de classe base quando um método estiver sendo substituído pode se usar a sintaxe 'base.SomeMember'; 'base' é uma palavra-chave. Remova essa associação 'as'.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Usada para declarar um delegado.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>O método ou construtor de objeto '{0}' não foi encontrado</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Especificador de formato com largura ruim</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Tipos com o atributo 'AllowNullLiteral' só podem implementar ou herdar tipos que também permitem o uso do literal nulo.</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Um inicializador estático requer um argumento</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Erro de sintaxe - símbolo '?' inesperado</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Uso inválido de um tipo de interface</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Padrões sucessivos devem ser separados por espaços ou serem tuplas.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>A assinatura requerida é {0}</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit não foi finalizado</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Condicionais de otimização estáticas destinam-se apenas ao uso na biblioteca F#</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Todos os elementos de uma expressão do construtor de matriz devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>O parâmetro do tipo declarado '{0}' não pode ser usado aqui, uma vez que o parâmetro de tipo não pode ser resolvido no tempo de compilação</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' não é um nome de assembly válido</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Este não é um nome válido para um padrão ativo</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>A expressão 'if' está sem uma ramificação 'else'. A ramificação 'then' tem tipo '{0}'. Como 'if' é uma expressão e não uma instrução, adicione uma ramificação 'else' que retorna um valor do mesmo tipo.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Fim inesperado de entrada em assinatura de tipo</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Método duplicado. O método '{0}' tem o mesmo nome e assinatura que outro método no tipo '{1}'.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Este método possui muitas restrições em seus parâmetros de tipo</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Variável '{0}' ausente</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos em tipo de código de assembly embutido</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Definições refletidas não podem conter usos do operador união pré-fixo '%'</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>As unidades de medida não podem ser usadas como argumentos de prefixo para um tipo. Reescreva como argumentos de sufixo entre colchetes.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>As restrições 'struct' e 'not struct' são inconsistentes</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Esse padrão literal não tem argumentos</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Declaração de sintaxe inválida</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Nenhum dos tipos '{0}' oferece suporte ao operador '{1}'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Tipos delegados são sempre lacrados</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Expressão esperada após este ponto</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>O tipo '{0}' é menos acessível que o valor, membro ou tipo '{1}' no qual ele é usado.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Produzir um assembly determinístico (incluindo GUID de versão de módulo e carimbo de data/hora)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Valor 'null' inesperado retornado do membro '{1}' do tipo fornecido '{0}'</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Não foi possível localizar Dispose em IDisposable, ou ele estava sobrecarregado</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>A configuração de privacidade '{0}' não foi reconhecida pelo recurso gerenciado, as opções válidas são 'public' e 'private'</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Um valor marcado como 'embutido' não pôde ser embutido</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Uma construção genérica requer que o tipo '{0}' tenha um construtor padrão público</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} não é um membro de instância</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Cotações não podem conter este tipo de constante</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>O provedor de tipos '{0}' usou um parâmetro inválido na ParameterExpression: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>O membro genérico '{0}' foi usado em uma instanciação não uniforme anterior a este ponto de programa. Considere reordenar os membros para que ele venha antes. Como alternativa, especifique o tipo completo do membro explicitamente, incluindo tipos de argumentos, tipo de retorno e todos parâmetros e restrições genéricas adicionais.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Um tipo armazenaria um valor do tipo byref. Isso não é permitido pelo IL Comum.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Nenhum arquivo de implementação especificado</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs sinalizadores embutidos são diferentes</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Nome de namespace, módulo, tipo ou caso união inválido</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Abreviações de tipo não podem ter membros</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>O 'rec' neste módulo é implícito por uma declaração 'rec' externa e está sendo ignorado</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Este tipo não é um tipo de registro. Valores de tipos de classe e struct devem ser criados com o uso de construtores de objeto.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Um tipo que suporte o operador '{0}' era esperado, mas um tipo de função foi recebido. Pode estar faltando um argumento para alguma função.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Namespaces não podem conter valores. Considere usar um módulo para isentar suas declarações de valores.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Nenhum método de invocação encontrado para o tipo delegate</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Condicional incompleta. Esperado 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Uma operação personalizada não pode ser usada em conjunto com os operadores 'use', 'try/with', 'try/finally', 'if/then/else' ou 'match' nesta expressão computacional</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>O atributo 'StructuralComparison' deve ser usado em conjunto com o atributo 'StructuralEquality'</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Uso inválido da palavra-chave 'rec'</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Enumerações não podem ter membros</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>O rótulo de registro ou o namespace '{0}' não está definido.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Cotações não podem conter utilizações de expressões genéricas</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>A opção de linha de comando '{0}' foi preterida</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Usado em fluxos de trabalho assíncronos para associar um nome ao resultado de uma computação assíncrona ou, em outras expressões de cálculo, usado para associar um nome a um resultado, que é do tipo de computação.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Chamadas</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else não tem nenhuma correspondência #if</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Use para substituir onde o compilador deve procurar por mscorlib.dll e componentes de framework</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' obtém argumentos de tipo {1}, mas aqui é dado {2}. A assinatura requerida é '{3}'.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' não encontrado no assembly '{2}'. Uma possível causa seria uma incompatibilidade de versão. Talvez seja necessário fazer uma referência explicitamente à versão correta deste assembly para permitir que todos os componentes referenciados possam utilizar a versão correta.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Sintaxe inválida na expressão de tipo</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para este tipo de inteiro</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>O padrão ativo '{0}' não é uma função</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>A propriedade '{0}' do tipo '{1}' tem um getter e um setter que não são correspondentes. Se um deles for abstrato, o outro também deverá ser.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>Em consultas, use o formato 'for x in n .. m do ...' para inteiros abrangentes</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres com aspas triplas iniciada aqui ou antes</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Fim inesperado de entrada em definição de valor, função ou membro</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>O construtor de objeto '{0}' obtém {1} argumentos, mas aqui são fornecidos {2}. A assinatura requerida é '{3}'. Se alguns dos argumentos tiver que atribuir valores a propriedades, considere separar esses argumentos com uma vírgula (',').</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' deve ser aplicado a um argumento do tipo '{1}', mas foi aplicado a um argumento do tipo '{2}'</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Não é possível criar uma extensão de um tipo lacrado</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Nenhum 'in' correspondente encontrado para 'let'</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>O atributo de visibilidade '{0}' não é permitido na abreviação de módulo. As abreviações de módulo são sempre particulares.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Geralmente um tipo com o atributo 'NoComparison' não deve ter uma implementação explícita de 'System.IComparable', 'System.IComparable&lt;_&gt;' ou 'System.Collections.IStructuralComparable'. Desabilite este aviso caso a intenção seja obter interoperabilidade</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Esse constructo só pode ser utilizado em expressões de computação. Para retornar um valor de uma função comum apenas escreva a expressão sem o 'return'.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>As definições de propriedades podem não ser declaradas mutáveis. Para indicar que esta propriedade pode ser definida, use 'member val PropertyName = expr com get,set'.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- AVANÇADO -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificadores 'static' são diferentes</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>forma compilada do caso união</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Falha na resolução do assembly neste local ou próximo a ele</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a ordem dos campos está diferente na assinatura e na implementação</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Membros abstratos não são permitidos em um aumento, eles devem ser definidos como parte do tipo por eles mesmos</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Fim inesperado de entrada em ramificação 'then' de expressão condicional. 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' esperado.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão 'match' ou 'try'.</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Fim inesperado de entrada em ramificação 'else' de expressão condicional. 'if &lt;expr&gt; then &lt;expr&gt;' ou 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' esperado.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Nenhum argumento pode ser dado na construção de um valor de registro</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Identificadores que contém '@' são reservados para uso em geração de código F#</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Esta pesquisa não pode ser usada aqui</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Membros que estendem tipos de interface, delegado ou enum devem ser colocados em um módulo separado da definição do tipo. Este módulo deve ter o atributo AutoOpen ou ser aberto explicitamente por um código de cliente para trazer os membros de extensão para o escopo.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Implementações de interface não podem ser fornecidas em expressões de construção</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Este código não é suficientemente genérico. A variável de tipo {0} não pode ser gerada porque ela escaparia de seu escopo.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Fim de arquivo na seção de IF-OCAML iniciada aqui ou anteriormente</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>O atributo 'AbstractClass' só pode ser dado a classes</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void' só pode ser usado como 'typeof &lt;system.void&gt;' em F#</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>A sintaxe '(typ,...,typ) ident' não é usada em código F#. Considere o uso de 'ident&lt;typ,...,typ&gt;' ao invés dela</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Tipos de struct não podem conter membros abstratos</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Este novo membro oculta o membro abstrato '{0}' assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados. Renomeie o membro ou use 'override'.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Decodificação de InterfaceDataVersionAttribute inesperada</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Os tokens '|' que separam regras desta correspondência de padrão estão desalinhados em uma coluna. Considere realinhar seu código ou usar mais recuo.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUma aridade não foi inferida para este valor</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Especificação de propriedade em nível de código inesperada na árvore de sintaxe</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Campos incorretos receberam valores</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Usada para converter para um tipo que é inferior na cadeia de herança.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nUm tipo de tupla é exigido para um ou mais argumentos. Considere agrupar os argumentos fornecidos em parênteses adicionais ou revisar a definição da interface.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Constante racional grande inesperada</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Formato de imagem inválido</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Namespace vazio encontrado do provedor de tipos '{0}'. Use 'null' para o namespace global.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs nomes diferem</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>Var {0} na coleção {1} (outerKey = innerKey). Observe que os parênteses são necessários após '{2}'</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' ou '=' esperado</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Decodificação de InternalsVisibleToAttribute inesperada</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Expressão incompleta do pré-processador</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: atrasado</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Uma referência direta ao tipo gerado '{0}' não é permitida. Em vez disso, use uma definição de tipo, por exemplo, 'type TypeAlias = &lt;caminho&gt;'. Isso indica que um provedor de tipos adiciona tipos gerados ao seu assembly.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Erro de sintaxe. #endif aninhado de forma errada, tokens não são esperados antes dele.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Habilitar avisos específicos que podem estar desativados por padrão</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} é um padrão ativo e não pode ser tratado como um caso de união discriminada com campos nomeados.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Tipos de registros são sempre lacrados</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Assinatura para configuração de membro inválida</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>As expressões 'while' não podem ser usadas em consultas</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Este não é um literal de caractere válido</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Valores retornados não podem ter nomes</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Não é possível herdar de um tipo fornecido apagado</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>O provedor '{0}' retornou um tipo não gerado '{1}' no contexto de um conjunto de tipos gerados. Considere ajustar o provedor de tipos para retornar somente tipos gerados.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Uma restrição 'enum' deve ser da forma 'enum&lt;type&gt;'</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é abstrato e outro não</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>O nome '({0})' não deve ser usado como um nome de membro. Para definir a semântica de igualdade substitua o membro 'Object.Equals'. Se for definir um membro estático para uso em outras linguagens CLI, use o nome '{1}'.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para literais decimais</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>Ocorreu um erro ao ler os metadados F# do assembly '{0}'. Um constructo reservado foi utilizado. Talvez seja necessário atualizar o compilador F# ou usar uma versão anterior do assembly que não faça uso de um constructo específico.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Excesso de parâmetros estáticos. Eram esperados no máximo {0} parâmetros, mas {1} parâmetros não nomeados e {2} parâmetros nomeados foram recebidos.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Nenhum símbolo '=' deve seguir uma declaração 'namespace'</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Os tipos System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate e System.Array não podem ser usados como supertipos em uma expressão ou classe de objeto</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Este arquivo possui declarações múltiplas da forma 'module SomeNamespace.SomeModule'. Apenas uma declaração deste forma é permitida no arquivo. Modifique seu arquivo para usar declaração de namespace inicial e/ou use 'module ModuleName = ...' para definir seus módulos.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Não é possível herdar de um tipo de interface. Use interface ... with em seu lugar.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Habilite ou desabilite otimizações de módulo cruzado</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Usado em expressões de consulta para especificar quais campos ou colunas extrair. Observe que isso é uma palavra-chave contextual, o que significa que não é realmente uma palavra reservada e age apenas como uma palavra-chave no contexto apropriado.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>O endereço do campo '{0}' não pode ser usado neste ponto</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Não foi possível resolver a ambiguidade no uso do constructo genérico com uma restrição 'unmanaged' nesta posição ou próxima a ela</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Esta definição de tipo pode não ter o atributo CLIMutable'. Somente tipos de registro podem ter este atributo.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 64-bit com sinal</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos em campos de enumeração</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o número de {2}s são diferentes</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Extensão de tipo inválida</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problema com nome de arquivo '{0}': {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif requerido por #else</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Usado para declarar um tipo de estrutura. Também usado nas restrições de parâmetro genérico. Usado para compatibilidade OCaml nas definições do módulo.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Usado para indicar um método ou propriedade que podem ser chamados sem uma instância de um tipo ou um membro de valor que é compartilhado entre todas as instâncias de um tipo.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>O atributo 'EntryPointAttribute' só pode ser usado em definições de função em módulos</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>O valor padrão não tem o mesmo tipo que o argumento. O atributo DefaultParameterValue e qualquer atributo Optional serão ignorados. Observação: 'null' precisa ser anotado com o tipo correto, por exemplo, 'DefaultParameterValue(null:obj)'.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Instanciação genérica incorreta. Nenhum membro {0} chamado '{1}' obtém argumentos genéricos {2}.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Namespaces não podem conter membros de extensão, exceto no mesmo arquivo e grupo de declaração de namespace, em que o tipo é definido. Considere o uso de um módulo para reter declarações de membros de extensão.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Usado para indicar o valor a ser fornecido como o resultado de uma expressão de computação.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>O valor '{0}' não é acessível deste local de código</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>O recuo deste token 'in' é incorreto em relação ao 'let' correspondente</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>O tipo '{0}' é requerido aqui e não está disponível. Você deve adicionar uma referência ao assembly '{1}'.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>O operador '{0}' não aceita o uso de 'into'</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} não é um membro estático</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Variáveis de tipos anônimos não são permitidas nesta declaração </value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Este registro contém campos de tipos inconsistentes</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>As associações 'let' e 'do' devem vir antes das definições de membro e interface nas definições de tipos</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Diretivas dentro de módulos são ignoradas</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 16-bit com sinal</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problema com o código de página '{0}': {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Expressões de atributo devem ser chamadas para construtores de objeto</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Um construtor delegado deve ser transmitido como um valor de função único</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Este indexador espera argumentos {0}, mas aqui é dado {1}</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>A expressão 'if' precisa ter o tipo '{0}' para atender aos requisitos do tipo de contexto. No momento, ela tem o tipo '{1}'.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>O atributo 'Sealed' não pode ser dado aos tipos abreviados.</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Habilite otimizações (Forma abreviada: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Esta substituição obteve um número de argumentos diferente do membro abstrato correspondente. Os seguintes membros abstratos foram encontrados:{0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'[' incompatível</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Um valor literal não pode ser marcado como 'inline'</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>O atributo 'NoEquality' deve ser usado em conjunto com o atributo 'NoComparison'</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Cotações não podem conter expressões que requerem ponteiros byref</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Inesperado / em tipo</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Tipos de código de assembly são sempre lacrados</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Nenhuma entrada especificada</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Constantes não nulas não podem ter unidades genéricas. Para um zero genérico, grave 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Propriedade getter ou setter inválida</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura declara um {2} enquanto a implementação declara um {3}</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>O caractere '{0}' não é permitido no nome de namespace fornecido '{1}'.</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Diretiva inválida. '#I \"&lt;caminho&gt;\"' era esperado.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 32-bit sem sinal</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>A propriedade '{0}' tem o mesmo nome que um método no tipo '{1}'.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>evento</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>campo</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Valores definidos recursivamente não podem aparecer diretamente como parte da construção de um valor tupla em uma associação recursiva</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>A opção de linha de comando '{0}' foi preterida. A geração de documento HTML é agora parte do pacote de energia F#, através da ferramenta FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Atributos não são permitidos em associações 'let' das expressões</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nAs respectivas contagens de parâmetro de tipo são diferentes</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Este membro não é suficientemente genérico</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Usado como um literal Booliano.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Cotações não podem conter decrescentes para loops</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Endereço base para a biblioteca a ser criada</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problema ao ler assembly '{0}': {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>O tipo fornecido '{0}' retornou um membro nulo</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>A referência para o tipo '{0}' no assembly '{1}' foi encontrada, mas o tipo não pôde ser encontrado neste assembly</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Um parâmetro de tipo genérico foi usado de modo que ficou restrito a ser sempre '{0}'</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é marcado como uma substituição e o outro não</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Expressões {0} esperadas, {1} obtidas</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Um ou mais dos parâmetros de tipo declarados para esta extensão de tipo têm uma restrição ausente ou incorreta que não corresponde às restrições de tipo originais em '{0}'</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Pelo menos uma substituição não foi implementada corretamente no membro abstrato correspondente</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>O 'AssemblyVersionAttribute' foi ignorado porque uma versão foi atribuída usando uma opção de linha de comando</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>O atributo 'DefaultValue' só pode ser utilizado em declarações 'val'</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Tipos struct são sempre lacrados</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Tipos não podem ser herdados de tipos concretos múltiplos</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Argumentos de tipo inesperados</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura requer que o tipo dê suporte a interface {2}, mas esta não foi implementada</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GERAÇÃO DE CÓDIGO -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Const_uint16array inesperado</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>O membro '{0}' é usado de forma inválida. Um uso de '{1}' possui inferência anterior à definição de '{2}', que é uma referência de encaminhamento inválida.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>is</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Este atributo não pode ser usado nesta versão de F#</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Atributos não são permitidos em padrões</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Não é possível substituir o membro herdado '{0}' porque ele é sealed</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Este tipo não possui tipos aninhados</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>O nome de arquivo '{0}' contém o caractere inválido '{1}'.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>O campo, o construtor ou o membro '{0}' não está definido.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Termos [&lt;reflecteddefinition&gt;] não podem conter usos de operador da união pré-fixo '%'</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Incompatibilidade de comprimento de instanciação de tipo</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Uma propriedade setter pode ter no máximo dois grupos de argumento</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Desabilitar mensagens de aviso específicas</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Suprimir a mensagem de direitos autorais do compilador</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>O tipo '{0}' foi marcado como tendo um layout explícito, mas o campo '{1}' não tinha sido marcado com o atributo 'FieldOffset'</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs tipos são diferentes</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Não são permitidos usos de primeira classe do operador da união de expressão</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Este downcast apagará o tipo fornecido '{0}' para o tipo '{1}'.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>O tipo {0} contém o membro '{1}', mas ele não é um método virtual ou abstrato disponível para substituição ou implementação.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>O atributo '{0}' parece tanto na implementação quanto na assinatura, mas os argumentos de atributos são diferentes. Apenas o atributo da assinatura será incluído no código compilado.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>O operador '{0}' não pode ser resolvido. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Opção não reconhecida: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>extensão</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois o campo '{0}' estava presente na implementação, mas não na assinatura. O módulo contém a definição da exceção\n    {1}    \n, mas sua assinatura especifica\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>O tipo '{0}' possui um método '{1}' (nome completo '{2}'), mas o método não é estático</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Chamadas para 'reraise' só podem ocorrer diretamente em um manipulador de um try-with</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Tipos enum são sempre lacrados</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Os tipos de argumento não coincidem</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>O 'l' nem 'L' são necessários neste especificador de formato. No código F#, você pode usar %d, %x, %o ou %u no lugar, os quais estão sobrecarregados para trabalhar com todos os tipos básicos de inteiro.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Permite acesso a um membro de fora do tipo.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>O tipo '{0}' não possui 'null' como valor adequado. Para criar um valor nulo para um tipo Nullable, use 'System.Nullable()'.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>ValValue {0} recursivo </value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>O tipo '{0}' é inválido porque o byref&lt;T&gt;, T não pode conter tipos byref.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Defina símbolos de compilação condicional (Forma abreviada: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Não são permitidos atributos em declarações 'inherit'</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>A propriedade '{0}' no tipo fornecido '{1}' possui CanWrite=true, mas não houve valor de GetSetMethod()</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois as declarações de exceções diferem. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core.sigdata não encontrado junto com FSharp.Core. Arquivo esperado em {0}. Considere atualizar para uma versão mais recente do FSharp.Corem, na qual esse arquivo não é mais necessário.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Linha de comando simples ou fim de linha esperado</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>O provedor de tipos retornou 'null', o que não é um valor retornado válido de '{0}'.</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>A diretiva #if deve ser seguida imediatamente por um identificador</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Nenhuma implementação foi dada por '{0}'. Note que todos membros de interface devem ser implementados e listados sob uma declaração apropriada 'interface', por exemplo 'interface ... with member ...'.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>O bloco após '{0}' está inacabado. Cada bloco de código é uma expressão e deve ter um resultado. '{1}' não pode ser o elemento de código final em um bloco. Considere dar a este bloco um resultado explícito.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão 'while'. 'while &lt;expr&gt; do &lt;expr&gt;' esperado.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Definições de medida não podem ter parâmetros de tipo</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>O DDL '{0}', que foi compilado por F#, precisa ser recompilado para ser usado com esta versão do F#</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Fim inesperado de entrada na expressão 'match'. 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' esperado.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Tipos de interface e tipos delegado não podem conter campos</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>As extensões de arquivo '.ml' e '.mli' são para compatibilidade com ML</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>namespace</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' requer {1} argumentos. A assinatura requerida é '{2}'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Declarações de medida só podem ter membros estáticos: construtores não estão disponíveis</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Interfaces não podem conter definições de inicializadores estáticos</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Funções genéricas interiores não são permitidas em expressões entre aspas. Considere adicionar algumas restrições de tipo até que esta função não seja mais genérica.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Argumento --test desconhecido: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problema de inferência de tipo excessivamente complicado (profundidade de iteração máxima atingida). Considere adicionar mais anotações de tipo.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>O valor, o namespace, o tipo ou o módulo '{0}' não está definido.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs respectivos números de campos de dados diferem</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Structs não podem conter associações 'do' porque o construtor padrão para structs não as executaria</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Usada para converter para um tipo que é superior na cadeia de herança.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>Var {0} na coleção {1} (outerKey = innerKey) no grupo. Observe que os parênteses são necessários após '{2}'</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>O construtor padrão de um tipo struct iniciado com zero só pode ser usado se todos os campos do tipo struct admitirem inicialização padrão</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>O atributo 'StructLayout' não pode ser dado a tipos genéricos</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Um construtor de objeto explícito deve usar a sintaxe 'new(args) = expr'</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Delimita uma citação não tipada do código.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Structs não podem conter definições de valores porque o construtor padrão para structs não executará essas vinculações. Considere adicionar argumentos complementares ao construtor primário para o tipo.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros de 8-bit com sinal</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Membro inválido '{0}' no tipo fornecido '{1}'. Somente propriedades, métodos e construtores são permitidos</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Nenhuma atribuição foi dada ao campo '{0}' do tipo '{1}'</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>O tipo '{0}' não oferece suporte ao operador '{1}'</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>O endereço do campo estático '{0}' não pode ser usado neste ponto</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Esta declaração abre o namespace ou módulo '{0}' através de um caminho parcialmente qualificado. Ajuste este código par usar o caminho completo do namespace. Esta mudança deixará seu código mais robusto uma vez que novos construtores são adicionados a F# e bibliotecas CLI.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!' não pode ser resolvido em expressões de sequência</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Uma implementação de arquivo ou módulo '{0}' já foi fornecida. A ordem de compilação é significativa em F# devido à inferência de tipo. Talvez você precise ajustar a ordem dos arquivos para colocar o arquivo de assinatura antes da implementação. No Visual Studio, os arquivos são tipo verificado na ordem em que aparecem no arquivo de projeto, que pode ser editada manualmente ou ajustada por meio do gerenciador de soluções.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>namespace inválido para tipo fornecido</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Esta definição de tipo envolve uma referência cíclica imediata através de um campo struct ou relação de herança</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Este valor não é um literal e não pode ser usado em um padrão</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Cada argumento do construtor primário para um struct deve receber um tipo, por exemplo 'type S(x1:int, x2: int) = ...'. Esses argumentos determinam o campo do struct.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Valores mutáveis não podem ter parâmetros genéricos</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Não foi possível resolver a ambiguidade no uso de um construtor genérico com uma restrição 'delegate' nesta posição ou próximo a ela</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>A especificação de delegado deve ser da forma 'typ -&gt; typ'</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>O ReflectedDefinitionAttribute não pode ser aplicado a um membro de instância em um tipo struct porque o membro da instância assume um parâmetro byref 'this' implícito</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get' e/ou 'set' necessários</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' não suporta sinalizador '{1}' de prefixo</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Este parâmetro de tipo foi usado de forma que fique restrito a ser sempre '{0}'</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Argumentos nomeados não podem ser dados às chamadas características de membros</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Não há suporte para a versão especificada do .NET Framework '{0}'. Especifique um valor da enumeração Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Uma declaração só pode ser o atributo [&lt;Literal&gt;] se um valor constante também for dado, por exemplo 'val x : int = 1'</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>A extensão de arquivo de '{0}' não é reconhecida. Arquivos de origem devem ter extensão .fs, .fsi, .fsx, .fsscript, .ml ou .mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Esta declaração 'inherit' especifica o tipo herdado, mas não especifica nenhum argumento. Considere fornecer argumentos, por exemplo 'inherit BaseType(args)'.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Nomear o arquivo de depuração de saída</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Especifique um diretório para incluir o caminho que é usado para resolver arquivos de origem e assemblies (Forma abreviada: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Imprimir interface deduzida do assembly para um arquivo</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Criar um módulo que possa ser adicionado a outro assembly</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>O caractere '|' não é permitido em identificadores de caso de padrão ativo</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos neste membro. Slots abstratos sempre têm a mesma visibilidade que o tipo de delimitador.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Um ';' é usado para separar os valores de campo nos registros. Considere substituir ',' por ';'.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Não foi possível resolver a ambiguidade no uso de um operador '{0}' neste ponto do programa ou próximo a ele. Considere usar anotações de tipo para resolver a ambiguidade.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>O tipo '{0}' não está definido.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Usado para indicar a função que deve ser integrada diretamente no código do chamador.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Este não é um nome válido para um caso de enumeração</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Este membro de instância precisa de um parâmetro para representar um objeto a ser chamado. Deixe o membro estático ou use a notação 'membro x.Membro(argumentos) = ...'.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Não existe um parâmetro estático com o nome '{0}'</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Geralmente um tipo com atributo 'NoEquality' não deve ter uma implementação explícita de 'Object.Equals(obj)'. Desabilite este aviso caso a intenção seja obter interoperabilidade</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>O valor que foi copiado para assegurar que o original não seja mudado por esta operação ou porque a cópia está implícita ao retornar o struct de um membro e outro membro é acessado</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Uma ou mais classes explícitas ou variáveis de tipo função explícita para essa associação não puderam ser geradas, porque foram restritas a outros tipos</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Candidatos: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>'with' incompatível ou bloco 'with' mal formatado</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Todos os elementos de uma expressão do construtor de lista devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Especificações de tipo explícitas não podem ser usadas para construtores de exceção</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>O tipo de registro para o campo de registro '{0}' foi definido com o RequireQualifiedAccessAttribute. Inclua o nome do tipo de registro ('{1}') no nome que você está usando.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>O argumento formal correspondente não é opcional</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Valor inválido</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>Os nomes de argumento na assinatura '{0}' e na implementação'{1}' não coincidem. O nome do argumento do arquivo de assinatura será usado. Isso pode causar problemas durante a depuração ou a criação de perfil.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>O valor '{0}' é não usado.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>A opção requer o parâmetro: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Declaração inválida</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros nativos sem sinal</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>O discriminador de padrão '{0}' não está definido.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Final da entrada inesperado</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Dois módulos chamados '{0}' ocorrem em duas partes deste assembly</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Mais de um método de chamada encontrado para o tipo delegado</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Este valor não é uma função e não pode ser aplicado. Você pretendia acessar o indexador por meio do {0}.[index] como alternativa?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>O parâmetro '{0}' foi inferido para ter o tipo byref. Parâmetros de tipo byref devem receber uma anotação de tipo explícito, por exemplo 'x1: byref&lt;int&gt;'. Ao ser usado, um parâmetro byref é desreferenciado implicitamente.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Este membro estático não deve ter um parâmetro 'this'. Considere usar a notação 'member Member(args) = ...'.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Uma construção genérica requer que o tipo '{0}' não seja abstrato</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Inclua somente informações de otimização essenciais para a implementação de constructos embutidos. Isso inibe a integração dos módulos cruzados, mas aumenta a compatibilidade binária.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>A representação deste tipo está oculta pela assinatura. Ela deve receber um atributo como [&lt;Sealed&gt;], [&lt;Class&gt;] ou [&lt;Interface&gt;] para indicar as características deste tipo.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>O formato '{0}' não suporta sinalizador '0'</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>A inferência de tipos causou um escape no escopo da variável de tipo {0}. Considere adicionar uma declaração de parâmetro de tipo explícito ou ajustar seu código para ser menos genérico.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Especificar tipo de depuração: completo, portátil, incorporado, somente PDB. ('{0}' será o padrão se nenhum tipo de depuração for especificado e permite anexar um depurador a um programa em execução; 'portátil' é um formato multiplataforma; 'incorporado' é um formato multiplataforma incorporado no arquivo de saída).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Apenas diretivas de compilador '#' podem ficar antes da primeira declaração de 'namespace'</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>O valor local {0} não foi encontrado durante a otimização</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>O provedor de tipos '{0}' forneceu um método com um nome '{1}' e um token de metadados '{2}' que não é relatado entre seus métodos de seu tipo declarante '{3}'</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Sintaxe incorreta para '{0}'. Uso: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Número do ponto flutuante inválido</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Os construtores não são permitidos como membros de extensão - eles devem ser definidos como parte da definição original do tipo</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>O construtor de objeto '{0}' não tem argumento ou propriedade de retorno configurável '{1}'. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>A plataforma 'anycpu32bitpreferred' só pode ser usada com destinos EXE. Em vez disso, use 'anycpu'.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs nomes são diferentes</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é estático e o outro não</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o tipo de implementação não é lacrado, mas a assinatura implica que ele é. Considere adicionar o atributo [&lt;Sealed&gt;] à implementação.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>'try'/'with' não podem ser usados em expressões de sequência</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o membro abstrato '{2}' estava presente na implementação, mas não na assinatura</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem uma implementação explícita de 'Object.GetHashCode'. Considere implementar uma substituição correspondente para 'Object.Equals(obj)'</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Usado para declarar uma propriedade ou método em um tipo de objeto.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Usado para associar um nome com um grupo de tipos, valores e funções relacionados para separá-lo de outro código.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs tipos são diferentes</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as respectivas contagens de parâmetro de tipo são diferentes</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Especificações de delegado não devem ser do tipo curried. Use 'typ * ... * typ -&gt; typ' para delegados de múltiplos argumentos e 'typ -&gt; (typ -&gt; typ)' para delegados que retornam valores de função.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>O valor '{0}' foi marcado como embutido, mas sua implementação faz uso de uma função interna ou privada que não é suficientemente acessível</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>A propriedade '{0}' não é estática</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Expressão de objeto, sequência ou registro inválida</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Os parâmetros de tipo inferidos para este valor não são estáveis sob a eliminação de abreviações de tipo. Isso ocorre devido ao uso de abreviações de tipo que cancelam ou reorganizam os parâmetros de tipo, isto é \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nConsidere declarar os parâmetros de tipo para este valor explicitamente, isto é\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>O tipo de struct, registro ou união '{0}' implementa explicitamente a interface 'System.IStructuralComparable'. Aplique o atributo 'CustomComparison' ao tipo.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Erro de sintaxe</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Relação de junção inválida em '{0}'. 'expr &lt;op&gt; expr' é esperado, onde &lt;op&gt; é =, =?, ?= ou ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Associações de campo devem ter a forma ' id = expr; '</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>O evento '{0}' não é estático</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>Var {0} na coleção</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Usado em uma expressão de sequência para produzir um valor de uma sequência.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>As expressões 'try/finally' não podem ser usadas em consultas</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Recomenda-se que objetos que deem suporte à interface IDisposable sejam criados usando a sintaxe 'new Type(args)', em vez de 'Type(args)' ou 'Type' como um valor de função representando o construtor, para indicar que os recursos podem ser de propriedade do valor gerado</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Um valor literal não pode ser marcado como 'mutável'</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Apresenta um constructo de looping.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} não é um método estático</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Os atributos não são permitidos em implementações de interface</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Este forma de expressão só pode ser utilizada em expressões de computação e sequência</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Cotações não podem conter expressões que busquem índices de casos união</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>Na sintaxe detalhada, indica o começo de uma definição de classe.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>Na sintaxe detalhada, indica o começo de um bloco de código.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Chamadas para construtores de objeto sobre parâmetros de tipo não podem receber argumentos</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Usado para ramificar ao comparar um valor a um padrão.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Condição inesperada no assembly importado: falha ao decodificar o atributo AttributeUsage</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Este caso união não obtém argumentos</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Usado para referenciar o namespace .NET de nível superior.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Esta construção de controle só é usada se o compilador de expressões de computação definir um método '{0}'</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Produto de medida implícito seguindo /</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Campo fornecido inválido. Os campos fornecidos de tipos fornecidos apagados devem ser literais.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Este não é um operador de consulta válido. Operadores de consulta são identificadores como 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' e 'averageBy' definidos usando métodos correspondentes no tipo 'QueryBuilder'.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Unidades de medida só são suportadas em tipos float, float32, decimal e inteiro com sinal</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>O campo '{0}' não é estático</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Os arquivos devem começar com a declaração de um namespace ou de um módulo, como 'namespace SomeNamespace.SubNamespace' ou 'module SomeNamespace.SomeModule', mas não ambos. Para definir um módulo dentro de um namespace, use 'module SomeModule =...'</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>A assinatura para esta função externa contém parâmetros de tipo. Restrinja o argumento e tipos de retorno para indicar os tipos de função C correspondente.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Todas as ramificações de uma expressão de correspondência de padrões devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>O método '{0}' está lacrado e não pode ser substituído</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}' incompatível</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Isto não é uma variável, constante, reorganizador ativo ou literal</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>O campo '{0}' recebeu um valor, mas ele não está presente no tipo '{1}'</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Cotações não podem conter expressões que buscam campos estáticos </value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Definições de valores estáticos só podem ser usadas em tipos com um construtor primário. Considere adicionar argumentos à definição de tipo, por exemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Não é possível encontrar o destino de código para este atributo, possivelmente porque o código após o atributo está incompleto.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Nome de módulo ou namespace inválido</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>operação personalizada</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Usado para verificar o código durante a depuração.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>As declarações neste arquivo serão localizadas em um módulo implícito '{0}' com base no nome do arquivo '{1}'. Entretanto este não é um identificador F# válido, de maneira que os conteúdos não estarão acessíveis de outros arquivos. Considere renomear o arquivo ou adicionar uma declaração 'module' ou 'namespace' na parte superior do arquivo.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Não foi possível abrir o arquivo de chave '{0}'</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Cotações não podem conter correspondências de padrão de matriz</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Um tipo de tupla é uma tupla de struct, o outro é uma tupla de referência</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' requer {1} argumentos adicionais. A assinatura requerida é '{2}'. Alguns nomes dos argumentos em falta são {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' requer {1} argumentos. A assinatura requerida é '{2}'. Alguns nomes dos argumentos em falta são {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>O construtor de membro ou objeto '{0}' requer {1} argumentos adicionais. A assinatura requerida é '{2}'.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'let'.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Argumento de tipo ou argumento estático esperado</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Opções de conflito especificadas: 'win32manifest' e 'win32res'. Somente uma delas pode ser usada.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Propriedade duplicada. A propriedade '{0}' tem o mesmo nome e assinatura que outra propriedade no tipo '{1}'.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Especifique o nome de cultura de idioma de saída preferencial (por exemplo, es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>Em expressões de sequência, os resultados são gerados com o uso de 'yield'</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Especificar um arquivo de chave de nome forte</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Identificador inesperado: '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Número de linha inválido: '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Argumentos opcionais não são permitidos aqui</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Este constructo é experimental</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Aumentos não são permitidos no tipo delegado moduleDefns</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' não é um argumento inteiro válido</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Enquanto mscorlib.dll ou FSharp.Core.dll é explicitamente referenciado, a opção {0} também deve ser passada</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Anotações de tipo em getters e setters de propriedade devem ser fornecidas após o 'get()' ou 'set(v)', por exemplo: 'with get() : string = ...'</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Criar um executável do Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Nome do arquivo de saída (Forma abreviada: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>o comutador --sourcelink tem suporte somente ao emitir um PDB Portátil (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>O CallerMemberNameAttribute aplicado ao parâmetro '{0}' não terá nenhum efeito. Ele será substituído pelo CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Argumentos estáticos nomeados devem ser colocados após todos os argumentos estáticos não nomeados</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Criar um executável de console</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Todas as interfaces implementadas devem ser declaradas na declaração inicial do tipo</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Especificação de propriedade no nível da origem inesperada</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Não é possível chamar o membro de base abstrata: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>O atributo 'ConditionalAttribute' só pode ser usado em membros</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Um tipo com atributo 'CustomComparison' deve ter uma implementação explícita de pelo menos 'System.IComparable' ou 'System.Collections.IStructuralComparable'</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes de membros CLI são diferentes</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>O método implementado por este padrão é ambíguo</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# dá suporte a classificações de matriz entre 1 e 32. O valor {0} não é permitido.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Cotações não podem conter esta espécie de tipo</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Apenas substituições de membros abstratos e virtuais podem ser especificadas nas expressões de objeto</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Gravar o xmldoc do assembly para o arquivo especificado</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo '{2}' estava presente na implementação, mas não na assinatura. Os tipos struct agora devem revelar seus campos na assinatura para o tipo, embora os campos ainda possam ser rotulados como 'private' ou 'internal'.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>O caso união '{0}' não está acessível deste local de código</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Somente tipos registro, união, exceção e struct podem ser aumentados com os atributos 'ReferenceEquality', 'StructuralEquality' e 'StructuralComparison'</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Tamanho de assinatura inválido</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Especificar um arquivo de manifesto Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Expressão de indexador inválida</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>O nome do tipo não pode ficar vazio.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>O arquivo de origem '{0}' não pôde ser localizado</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Pai de módulo ou namespace {0} esperado</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Apenas associações simples da forma 'id = expr' podem ser usadas em expressões de construções</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Indica que um elemento de programa declarado é definido em outro binário ou assembly.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>O arquivo de informações do link de origem para inserir em um arquivo PDB portátil</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' deve ser usado com construtores de objeto</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Este código é menos genérico que o indicado pelas suas anotações. Uma unidade de medida especificada com uso de '_' foi determinada como '1', ou seja, sem dimensão. Considere tornar o código genérico ou remover a utilização de '_'.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Expressão literal inválida. O atributo [&lt;Literal&gt;] será ignorado.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a assinatura diz que este tipo pode usar nulos como um valor adicional, mas a implementação não</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>As expressões 'try/with' não podem ser usadas em consultas</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Vincular estaticamente a biblioteca F# e todos os DLLs referenciados que dependem do assembly que está sendo gerado</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>O atributo 'AutoOpen(\"{0}\")' no assembly '{1}' não referenciou um módulo ou namespace válido neste assembly e foi ignorado</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Este campo não é mutável</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois os tipos são de diferentes tipos</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Enumeradores não podem ter declarações de interface</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Criar uma biblioteca (Forma abreviada: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Não foi possível resolver o assembly '{0}'</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>O construtor de objeto ou de membro '{0}' que obtém {1} argumentos não é acessível por meio desta localização do código. Todas as versões acessíveis do método '{2}' obtêm {3} argumentos.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Forma abreviada de '{0}'</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Uma implementação padrão desta interface já foi adicionada porque a implementação explícita da interface não foi especificada na definição do tipo</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>O campo nomeado '{0}' é usado mais de uma vez.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Compilações determinísticas dão suporte somente a PDBs portáteis (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Expressão de objeto inválida. Objetos sem substituições ou interfaces devem usar o formato de expressão 'new Type(args)' sem as chaves.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>de {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Em uma expressão, usado ao contar regressivamente.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Este não é um tipo de registro</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Cotações não podem conter expressões que obtêm o endereço de um campo</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' implementa explicitamente a interface 'System.IComparable'. Você deve aplicar o atributo 'CustomComparison' ao tipo.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Uma expressão if/then/else não pode ser usada em consultas. Considere usar uma expressão if/then ou uma expressão de sequência.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>O parâmetro estático '{0}' já recebeu um valor</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Inserir os arquivos de origem específicos no arquivo PDB portátil</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>A variável do tipo byref '{0}' é usada de forma inválida. Byrefs não podem ser capturados por fechamentos ou transmitidos para funções de interiores.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>A propriedade '{0}' não pode ser definida</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Esta propriedade não pode ser definida</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Utilizações de primeira classe dos operadores de endereço não são permitidas</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é construtor/propriedade e o outro não</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Expressões de construção de objeto só podem ser usadas para implementar construtores nos tipos de classe</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois o campo '{0}' foi requerido pela assinatura, mas não foi especificado na implementação. O módulo contém a definição da exceção\n    {1}    \n, mas sua assinatura especifica\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Este literal numérico requer que um módulo '{0}' que define funções FromZero, FromOne, FromInt32, FromInt64 e FromString esteja no escopo</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Não é possível definir construtores para este tipo</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois o campo {2} foi solicitado pela assinatura, mas não foi especificado pela implementação</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Argumentos opcionais somente são permitidos em membros do tipo</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>Uma referência para um tipo fornecido não continha um valor para o parâmetro estático '{0}'. Talvez seja necessário recompilar um ou mais assemblies referenciados.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Todas as ramificações de uma expressão 'if' devem ter o mesmo tipo. Essa expressão deveria ter o tipo '{0}', mas aqui tem o tipo '{1}'.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Apagado para</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Este valor, tipo ou método espera parâmetros de tipo {0}, mas foi dado {1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois a ordem dos campos é diferente na assinatura e na implementação. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Uma operação personalizada não pode ser usada em conjunto com uma vinculação 'let' recursiva ou sem valor em outra parte desta expressão computacional</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>O membro '{0}' não possui o número correto de parâmetros de tipo de método. A assinatura necessária é '{1}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma representação do tipo CLI foi ocultada pela assinatura</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem o atributo 'StructuralComparison', mas o parâmetro de tipo '{1}' não satisfaz a restrição 'comparison'. Considere incluir a restrição 'comparison' ao parâmetro de tipo</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>O tipo struct, registro ou união '{0}' tem o atributo 'StructuralComparison', mas o tipo de componente '{1}' não satisfaz a restrição 'comparison'</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>O endereço da variável '{0}' não pode ser usado neste ponto</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>caso união</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Cache de Assembly Global</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Interface duplicada ou redundante</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Arquivo de resposta '{0}' inválido ( '{1}' )</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Associações 'use!' devem estar no formato 'use! &lt;var&gt; = &lt;expr&gt;'</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois uma representação de tipo está sendo ocultada por uma assinatura</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Expressão de registro, sequência ou computação inválida. Expressões de sequência devem estar na forma 'seq {{ ... }}'</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>O evento '{0}' no tipo fornecido '{1}' não tem valores de GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Usado para declarar e implementar interfaces.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é membro de extensão e o outro não</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Setters de propriedade devem ser definidos com o uso de 'set value = ', 'set idx value = ' ou 'set (idx1,...,idxN) value = ... '</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Argumento inválido para rótulo padrão parametrizado</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Tamanho de bit inválido</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>A diretiva #if deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Há vários parâmetros estáticos com o nome '{0}'</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Campos voláteis devem ser marcados como 'mutable' e não podem ser thread estático</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Tipos de retorno de casos união devem ser idênticos aos tipos que estão sendo definidos, até as abreviações</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos em implementações de substituições ou de interfaces</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Considere usar um arquivo com extensão '.ml' ou '.mli' em vez disso</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Esta propriedade substitui ou implementa uma propriedade abstrata, mas esta não possui uma correspondência {0}</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Erro de compilador: valor não realizado inesperado</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Uma referência a um tipo fornecido possuía um valor inválido '{0}' para um parâmetro estático. Talvez seja necessário recompilar um ou mais assemblies referenciados.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>As definições de exceções não são compatíveis, pois as abreviações de exceções na assinatura e implementação são diferentes. O módulo contém a definição da exceção\n    {0}    \n, mas sua assinatura especifica\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Valor do atributo personalizado inválido (não é uma constante ou um literal)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Abreviações de exceção não devem ter listas de argumentos</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Esta propriedade possui um tipo inválido. Propriedades que pegam argumentos de indexador múltiplo devem ter tipos da forma 'ty1 * ty2 -&gt; ty3'. Propriedades que retornam funções devem ter tipos da seguinte forma '(ty1 -&gt; ty2)'.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Um valor do tipo byref seria armazenado aqui. Não são permitidos valores de alto nível associados a let byref.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Atributos de visibilidade múltipla foram especificados por este identificador. Associações 'let' em classes são sempre privadas, como quaisquer associações 'let' nestas expressões.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Cotações não podem conter definições de funções que foram deduzidas ou declaradas como genéricas. Considere adicionar algumas restrições para fazer desta uma expressão cotada válida.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Especificador de formato com pouca precisão</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Este tipo não possui construtores de objeto acessíveis</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>O tipo '{0}' do provedor de tipos '{1}' possui um namespace vazio. Use 'null' para o namespace global.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois a implementação diz que este tipo pode usar nulos como um valor adicional, mas a assinatura não</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Este construtor do objeto requer argumentos</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos em uma declaração 'inherits'</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Este tipo requer uma definição</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Não foi possível definir os campos literais</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Usado em loops para indicar um intervalo.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Usado com condições Boolianas como um Booliano ou operador. Equivalente a ||. Também usado em restrições de membro.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Usado em uniões discriminadas para indicar o tipo de categorias de valores e nas declarações de delegado e exceção.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Usado em constructos de ramificação condicional.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Usada para expressões de sequência e, na sintaxe detalhada, para separar expressões de ligações.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Usado para dar ao objeto de classe atual um nome de objeto. Também usado para dar um nome para um padrão completo em uma correspondência de padrão.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Usado em construções de looping ou para executar código imperativo.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs atributos de mutabilidade são diferentes</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Abreviações para tipos de exceção do IL Comum devem ter um construtor de objeto correspondente</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Este não é um literal numérico válido. Literais numéricos válidos incluem 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>O atributo 'CustomEquality' deve ser usado na conjunção com atributos 'NoComparison' ou 'CustomComparison'</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Uma propriedade getter pode ter no máximo um grupo de argumento</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Esta declaração de membro, função ou valor não pode ser declarada 'inline'</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Operador pré-fixo inválido</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Não é esperado ponto-e-vírgula neste ponto</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' não está sendo usado corretamente. Uso: {1}. Esta é uma operação personalizada nesta consulta ou expressão de computação.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>A substituição para '{0}' foi ambígua</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Especificar um contêiner de chave de nome forte</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>O operador 'expr.[idx]' foi usado em um objeto de tipo indeterminado baseado em informações anteriores a este ponto do programa. Considere adicionar novas restrições de tipo</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ERROS E AVISOS -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Resolver referências de assembly usando regras baseadas em diretório em vez da resolução do MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Método duplicado. O método abstrato '{0}' possui mesmo nome e assinatura que um método abstrato em um tipo herdado assim que tuplas, funções, unidades de medida e/ou tipos fornecidos são apagados.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>A unidade de medida não pode ser usada em aplicativos de construtor de tipo</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Expressões de construção de objeto (isto é, expressões de registros com especificações de herança) só podem ser usadas para implementar construtores em tipos de modelo de objeto. Use 'new ObjectType(args)' para instâncias de tipos de modelo de objeto fora dos construtores</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' não é permitido como um caractere em nomes de operadores e está reservado para uso futuro</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>As expressões 'use' não podem ser usadas em consultas</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo cujos valores possam ser enumerados com esta sintaxe, ou seja, não é compatível com seq&lt;_&gt;, IEnumerable&lt;_&gt; ou IEnumerable e não tem um método GetEnumerator</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Identificador de long vazio inesperado</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Diretiva inválida. '#r \"&lt;arquivo-ou-assembly&gt;\"' era esperado.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>A inferência de tipos causou um escape no escopo de uma variável de tipo de inferência. Considere adicionar anotações de tipo para tornar seu código menos genérico.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>O tipo '{0}' não suporta conversão para o tipo '{1}'</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>A opção de linha de comando '--cliroot' foi preterida. Use uma referência explicita para uma cópia específica de mscorlib.dll em seu lugar.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>As definições {0} na assinatura e implementação não são compatíveis, pois os nomes são diferentes. O tipo é chamado de '{1}' no arquivo de assinatura, mas de '{2}' na implementação.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Argumento inválido para 'methodhandleof' durante geração de código</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Símbolo inesperado '=' na expressão. Você pretendia usar 'for x in y .. z do' em vez disso?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Nenhum construtor está disponível para o tipo '{0}'</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Especificação duplicada de uma interface</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>O assembly '{0}' não foi encontrado no conjunto de dependências do binário de destino. Raízes vinculadas estaticamente devem ser especificadas por um nome de assembly, sem extensão DLL ou EXE. Se esse assembly foi referenciado explicitamente, é possível que ele não tenha sido exigido de fato pelo binário gerado e, nesse caso, ele não deve ser vinculado estaticamente.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>O tipo '{0}' implementa o 'System.IComparable'. Considere também adicionar uma substituição explícita para 'Object.Equals'</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Usado em associações mutualmente recursivas, em declarações de propriedade e em múltiplas restrições em parâmetros genéricos.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Esta não é uma expressão constante válida</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Arquivo de resposta '{0}' não encontrado em '{1}'</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>O namespace '{0}' não está definido.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Nenhum dos tipos '{0}' oferece suporte ao operador '{1}'. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Os modificadores de acessibilidade não são permitidos em associações 'do', mas '{0}' foi fornecido.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Caractere inesperado '{0}' na expressão do pré-processador</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>No máximo um aumento 'with' é permitido</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Um parâmetro com atributos também deve receber um nome, por exemplo, '[&lt;Atributo&gt;] Nome : Tipo'</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Os rótulos de campo e tipo esperado desta expressão ou padrão de registro não determinam exclusivamente um tipo de registro correspondente</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Somente padrões ativos que retornam exatamente um resultado podem aceitar argumentos</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>O membro do operador infixo '{0}' possui {1} argumentos iniciais. Uma tupla de 2 argumentos é esperada, como por exemplo o membro estático (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argumento</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Este constructo serve para a compatibilidade ML. {0}. Você pode desabilitar esse aviso usando '--mlcompatibility' ou '--nowarn:62'.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>O modificador de formatação # é inválido em F#</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Assinatura atrasada do assembly usando somente a parte pública da chave de nome forte</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Usado para declarar um tipo de exceção.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Uma ou mais das sobrecargas deste método possui argumentos na forma curried. Considere reformular esses membros para terem argumentos na forma de tupla.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' só pode ser usado com primeiro nome em um caminho qualificado</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Enumerações literais devem ter tipo int, uint, int16, uint16, int64, uint64, byte, sbyte ou char</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Ocorreu um erro ao ler o nó de metadados F# na posição {0} na tabela '{1}' do assembly '{2}'. O nó não tinha declaração correspondente. Reporte este aviso. Pode ser necessário recompilar o assembly F# que você está usando.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Erro ao abrir o arquivo binário '{0}': {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Nome de membro inválido. Os membros não podem ter os nomes '.ctor' ou '.cctor'</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Especificador de formato incorreto: '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Este campo não é um literal e não pode ser usado como um padrão</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Apenas campos de registro e associações 'let' simples e não recursivas podem ser marcados como mutáveis</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Diretiva inválida. Esperado '#load \"&lt;arquivo&gt;\" ... \"&lt;arquivo&gt;\"'.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>O tipo '{0}' possui um método '{1}' (nome completo '{2}'), mas o método é estático</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Nenhum membro abstrato ou de interface que corresponde a esta substituição foi localizado</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Este não é um padrão válido</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'do' ausente em expressão 'for'. Esperado 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Você deve declarar explicitamente todos ou nenhum parâmetro de tipo quando for substituir um método abstrato genérico</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Expressão '{0}' sem suporte do provedor de tipos. Se você é o autor desse provedor de tipo, considere ajustá-lo para oferecer uma expressão diferente.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Especificar a versão do subsistema deste assembly</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Uso inesperado de uma variável do tipo byref</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Falha ao embutir o valor '{0}' marcado como 'inline', talvez porque um valor recursivo tenha sido marcado como 'inline'</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>Em tipos de função, delimita argumentos e valores retornados. Produz uma expressão (em expressões de sequência); equivalente à palavra-chave de rendimento. Usado em expressões de correspondência</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Os structs não podem ter um construtor de objetos sem argumentos. Esta é uma restrição imposta a todas as linguagens CLI, porque os structs suportam automaticamente um construtor padrão.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>algId inválido - 'Exponente' esperado</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Considere usar 'return!' em vez de 'return'.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>O operador '!' é usado para desreferenciar uma célula de referência. Considere usar 'not expr' aqui.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Não adicione um recurso ao assembly gerado que contenha metadados específicos a F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Operador infixo inesperado na expressão de tipo</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>o comutador --embed tem suporte somente ao emitir um PDB Portátil (--debug:portable ou --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Definição de operador inválida. Definições de operadores pré-fixos precisam usar um nome de operador válido.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Os argumentos sem nome não formam um prefixo dos argumentos de métodos chamados</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>nome completo inválido para tipo fornecido</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>A diretiva #else deve aparecer como o primeiro caractere diferente de um espaço em branco em uma linha</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>O campo '{0}' do caso união/exceção não pode ser usado mais de uma vez.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos em casos união. Use ' type U = internal... ' ou ' type U = private... ' para dar uma acessibilidade à representação inteira.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Uma instanciação de tipo inclui um tipo de byref. Isto não é permitido pelas regras do IL Comum.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Caso união desconhecido</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>O nome '({0})' não deve ser usado como um nome de membro. Para definir semânticas de comparação para um tipo, implemente a interface 'System.IComparable'. Se for definir um membro estático para uso em outras linguagens CLI use o nome '{1}'.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Abreviações de tipo não podem ter aumentos</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>O módulo contém o construtor\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nA acessibilidade especificada na assinatura é maior que a especificada na implementação</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \ n, mas sua assinatura especifica\n    {2}    \nAs aridades diferem na assinatura e na implementação. A assinatura especifica que '{3}' é definição de função ou expressão lambda aceitando pelo menos {4} argumentos, mas a implementação é um valor de função computado. Para declarar que um valor de função computado é uma implementação permitida, basta colocar seu tipo entre parênteses na assinatura, por exemplo:\n\tval {5}: int -&gt; (int -&gt; int)\nao invés de\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>e {0} outras sobrecargas</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo enum CLI</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Uma abreviação de módulo precisa ser um nome simples, não um caminho</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Valores recursivos não podem aparecer diretamente como uma construção do tipo '{0}' em uma associação recursiva. Este recurso foi removido da linguagem F#. Considere usar um registro em seu lugar.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Compilador F# para F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Foi atribuído mais de um valor a um argumento nomeado</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Ignorando assembly gerenciado/não gerenciado misto '{0}' durante vinculação estática</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Somente structs e classes sem construtores primários podem receber o atributo 'StructLayout'.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Um parâmetro de tipo é esperado, não um parâmetro de unidade de medida</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Indica uma implementação de um método abstrato; usado em conjunto com uma declaração de método abstrato para criar um método virtual.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Fim de arquivo na cadeia de caracteres com aspas triplas inserida no comentário iniciado aqui ou antes</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Habilitar ASLR de alta entropia</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Chave privada esperada</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>resultado padrão ativo</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Não há suporte para esta declaração em grupos de declaração recursivos</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Token ausente '{0}' na expressão do pré-processador</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Saindo: excesso de erros</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>O membro '{0}' não possui o número correto de argumentos. A assinatura necessária é '{1}'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Este tipo usa uma combinação inválida dos atributos 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' e 'StructuralComparison'</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Esta definição só pode ser usada em um tipo com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>O tipo de atributo '{0}' possui 'AllowMultiple=false'. Instâncias múltiplas deste atributo não podem ser conectadas a um elemento de linguagem simples.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>Em expressões de sequência, os resultados múltiplos são gerados com o uso de 'yield!'</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>O tipo '{0}' não oferece suporte ao operador '{1}'. Considere abrir o módulo 'Microsoft.FSharp.Linq.NullableOperators'.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Structs, interfaces, enums e delegados não podem ser herdados de outros tipos</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Número inválido de argumentos genéricos para o tipo '{0}' no tipo fornecido. '{1}' argumentos esperados, '{2}' recebidos.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>O método '{0}' não é acessível no local deste código</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Valor Mágico Inválido no Cabeçalho CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Atribuição opcional inválida para uma propriedade ou um campo</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}. O argumento nomeado '{3}' não corresponde a nenhum argumento ou propriedade de retorno configurável para qualquer sobrecarga.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Nenhum membro {0} ou construtor de objeto com nome '{1}' obtém argumentos {2}. Observe que a chamada para este membro também fornece argumentos com nome {3}.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Rótulo de campo inválido</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Não foi possível decodificar o atributo MarshalAs</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as representações de nível de integridade são diferentes</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>O tipo não genérico '{0}' não espera nenhum argumento de tipo, mas aqui são dados argumentos do tipo {1}</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>O valor, o construtor, o namespace ou o tipo '{0}' não está definido.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>namespace/módulo</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Hierarquia de classe recursiva no tipo '{0}'</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>A referência de objeto recursiva '{0}' não é usada. A presença de uma referência de objeto recursiva adiciona verificações de inicialização em tempo de execução aos membros destes tipos e seus derivados. Considere remover essa referência de objeto recursiva.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Um tipo não pode ter, ao mesmo tempo, os atributos 'ReferenceEquality' e 'StructuralEquality' ou 'StructuralComparison'</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Esse constructo só pode ser utilizado em expressões de computação</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Um valor deve ser mutável para que seja possível mudar o conteúdo ou pegar o endereço de um tipo de valor, por exemplo: 'let mutable x = ...'</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Abreviações de exceção devem referir-se às exceções existentes ou tipos F# derivados de System.Exception</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Inserir todos os arquivos de origem no arquivo PDB portátil</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Apenas padrões de variáveis simples podem ser associados em construtores 'let rec'</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Argumentos sucessivos devem ser separados por espaços ou serem tuplas; argumentos envolvendo aplicações de função ou de método devem estar entre parênteses</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Não é uma exceção</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Erro interno. Indexação inválida em matriz de padrão ativa</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>O assembly '{0}' foi referenciado transitivamente e o assembly não pôde ser resolvido automaticamente. A vinculação estática assumirá que esta DLL não possui dependências na biblioteca F# ou outras DLLs vinculadas estaticamente. Considere adicionar uma referência explícita a esta DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Erro ao emitir o atributo 'System.Reflection.AssemblyCultureAttribute' -- 'Executáveis não podem ser assemblies satélites, a Cultura deve estar sempre vazia'</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Interfaces sempre possuem a mesma visibilidade que o tipo de delimitador</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nUm é função de tipo e o outro não. A assinatura requer parâmetros de tipo explícito caso estejam presentes na implementação.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>A sintaxe 'module ... = struct .. end' não é usada no código F#. Considere usar 'module ... = begin .. end'</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>O atributo 'VolatileField' só pode ser usado em associações 'let' nas classes</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>O módulo contém o campo\n    {0}    \n, mas sua assinatura especifica\n    {1}    \nOs modificadores 'literal' são diferentes</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>As definições {0} para o tipo '{1}' na assinatura e implementação não são compatíveis, pois as abreviações são diferentes: {2} versus {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Um inicializador estático explícito deve usar a sintaxe 'static new(args) = expr'</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Apenas funções podem ser marcadas como 'inline'</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Este não é um tipo de interface</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de interface</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Construtores de objeto não podem usar try/with nem try/finally antes da inicialização do objeto. O que inclui construções como ' x in... ' que podem elaborar usos dessas construções. Esta é uma limitação imposta pelo IL Comum.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' e 'return!' não podem ser usados em consultas</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modificadores de acessibilidade não são permitidos nos campos de registros. Use 'type R = internal ...' ou 'type R = private ...' para dar uma acessibilidade à representação inteira.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Usado ao invés de let! em fluxos de trabalho assíncronos e outras expressões de computação para valores que necessitam que Dispose seja chamado para liberar recursos.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Não é permitido usar uma declaração herdada aqui</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>As informações do membro {1} do tipo fornecido '{0}' possui um tipo de declaração nulo</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>O provedor de tipos '{0}' retornou um método inválido de 'AplicarArgumentosEstáticosParaMétodo'. Um método com o nome '{1}' era esperado, mas um método com o nome '{2}' foi retornado.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} não é uma sequência de escape de caracteres Unicode válida</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Existem tipos múltiplos chamados '{0}', que pegam diferentes números de parâmetros genéricos. Forneça uma instanciação de tipo para desfazer a ambiguidade da resolução de tipo, por exemplo '{1}'.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Os atributos de namespace ou módulo diferem entre assinatura e implementação</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>A interface '{0}' está incluída em múltiplos tipos de interface explicitamente implementada. Adicione uma implementação explícita desta interface.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>O evento '{0}' possui um tipo não padrão. Se este evento for declarado em outra linguagem CLI, você pode precisar acessar este evento com o uso de {1} explícito e métodos {2} para ele. Se este evento estiver declarado em F#, faça o tipo de evento também ser uma instanciação de 'IDelegateEvent&lt;_&gt;' ou 'IEvent&lt;_,_&gt;'.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>A sintaxe 'type X with ...' é reservada para aumentos. Tipos cujas representações são ocultas, mas possuem membros, agora são declarados em assinaturas usando 'type X = ...'. Talvez também seja necessário adicionar o atributo '[&lt;Sealed&gt;] à definição de tipo na assinatura</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Talvez você queira um dos seguintes:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>O rótulo do registro '{0}' não está definido.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Esse teste de tipo ou downcast ignorará a unidade de medida '{0}'</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Blob de Chave Pública Inválido</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>A vinculação estática não pode ser usada em um assembly com referência a mscorlib (por exemplo, um assembly do .NET Framework) ao gerar um assembly com referência a System.Runtime (por exemplo, um assembly .NET Core ou Portátil).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs números de parâmetros genéricos na assinatura e na implementação são diferentes (a assinatura declara {3} mas sua implementação declara {4}</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>O membro '{0}' não possui os tipos corretos de parâmetros genéricos. A assinatura necessária é '{1}'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>A assinatura e implementação não são compatíveis porque as contagens de parâmetros de tipo respectivas são diferentes</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>tipo, exceção ou módulo</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Esta expressão de lista ou matriz inclui um elemento da forma 'if ... then ... else'. Use parênteses nesta expressão para indicar os elementos individuais da lista ou matriz. Use uma expressão de sequência para tirar esta ambiguidade desta lista gerada</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>O tipo '{0}' não possui 'null' como valor adequado</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Modificadores de acessibilidade devem vir imediatamente antes do identificador na nomeação de um constructo</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Definição incompleta de valor. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'use'.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Definição incompleta de valor ou função. Se isso for uma expressão, o corpo da expressão deverá ser recuado para a mesma coluna que a palavra-chave 'let'.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>O caso união/exceção '{0}' não possui um campo chamado '{1}'.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>O nome '({0})' não deve ser usado como um nome de membro. Se for definir um membro estático para uso em outras linguagens CLI, use o nome '{1}'.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>O provedor de tipos não tem um construtor válido. Um construtor que não recebe argumentos ou recebe um argumento do tipo 'TypeProviderConfig' era esperado.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Tipos de registros, união, abreviações e struct não podem ter o atributo 'AllowNullLiteral'</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>A forma de expressão {{ expr with ... }} só pode ser usada com tipos de registro. Para compilar tipos de objeto, use {{ new Type(...) with ... }}</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Nenhuma implementação foi dada por '{0}'</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Este caso união espera argumentos {0} na forma de tupla</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Dois tipos de definição chamados '{0}' ocorreram no namespace '{1}' em duas partes deste assembly</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Nome de módulo inválido</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>A conversão de {0} para {1} é o upcast de segurança de tempo de compilação, não um downcast. Considere usar o operador :&gt; (upcast) em vez do operador :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Não são permitidos especificadores posicionais em cadeias de caracteres de formato</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>A operação personalizada '{0}' refere-se a um método que está sobrecarregado. As implementações das operações personalizadas não podem ser sobrecarregadas.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>Não são permitidas associações 'use' em módulos e são tratadas como ligações 'let'</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Especifique a página de código usada para ler arquivos de origem</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>O tratamento deste operador agora é manipulado diretamente pelo compilador F# e seu significado não pode ser redefinido</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Converte um tipo em um tipo em posição inferior na hierarquia.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Não foi possível ler a versão em mscorlib.dll</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>O provedor de tipos '{0}' relatou um erro no contexto do tipo fornecido '{1}', membro '{2}'. Erro: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Erro ao aplicar os argumentos estáticos a um tipo fornecido</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- ARQUIVOS DE ENTRADA -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Um inteiro para um loop precisa usar um identificador simples</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Este número está fora do intervalo permitido para inteiros hexadecimais de 8-bit com sinal</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>A proteção da correspondência de padrão deve ser do tipo 'bool', mas esta expressão 'when' é do tipo '{0}'.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Uma definição de tipo requer um ou mais membros ou outras declarações. Se você pretende definir uma classe vazia, struct ou interface, então use 'type ... = class end', 'interface end' ou 'struct end'.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Uma construção genérica requer que o tipo '{0}' tenha semânticas de referência, mas ele não tem, ou seja, é um struct</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nOs nomes são diferentes</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>A abreviação de tipo contém byrefs. Isto não é permitido por F#.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Não é possível gerar informações de depuração de MDB. Falha ao carregar o tipo 'MonoSymbolWriter' do assembly 'Mono.CompilerServices.SymbolWriter.dll'.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Erro inesperado ao criar o arquivo de informação de depuração '{0}'</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Um parâmetro de unidade de medida é esperado, não um parâmetro de tipo. Parâmetros de unidade de medida explícitos devem ser marcados com o atributo [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Não é possível analisar a cadeia de caracteres de formato '{0}'</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Decodificação de AutoOpenAttribute inesperada</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>As cotações não podem conter expressões que façam chamadas de restrição de membros ou usem operadores que resolvem implicitamente uma chamada de restrição de membro</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Arquivos em bibliotecas ou aplicativos de múltiplos arquivos devem começar com um namespace ou declaração de módulo. Ao usar uma declaração de módulo no início de um arquivo, o sinal '=' não é permitido. Se esse for um módulo de nível superior, considere remover o = para resolver esse erro.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>O campo '{0}' aparece duas vezes nesta expressão de registro ou padrão</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Um tipo fornecido com nome '{0}' era esperado, mas o tipo fornecido possui 'Name' com o valor '{1}'</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Um tipo fornecido com caminho '{0}' era esperado, mas o tipo fornecido possui o caminho '{1}'</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>O número de argumentos de um atributo personalizado não corresponde ao número de argumentos esperado para o construtor de atributos</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>O membro '{0}' é usado de uma forma inválida. Um uso de '{1}' foi inferido anteriormente para sua definição em '{2}' ou próximo a ele. Esta é uma referência de encaminhamento inválida.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>O evento '{0}' no tipo fornecido '{1}' não tem valores de GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Chave RSA esperada</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Todos tipos de registro, união e struct em FSharp.Core.dll devem ser rotulados explicitamente com 'StructuralComparison' ou 'NoComparison'</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>O tipo de união para o caso de união '{0}' foi definido com o RequireQualifiedAccessAttribute. Inclua o nome do tipo de união ('{1}') no nome que você está usando.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Padrões ativos não podem retornar mais que 7 possibilidades</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>O valor ou o construtor '{0}' não está definido.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Esta declaração 'inherit' possui argumentos, mas não está em um tipo com um construtor primário. Considere adicionar argumentos à sua definição de tipo, por exemplo, 'type X(args) = ...'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Tipos de união discriminados são sempre lacrados</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Anotação GetSet inesperada em um propriedade</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Este não é um valor válido para um literal de enumeração</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Módulo/expressão/tipo inválido</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} sobrecargas</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 sobrecarga</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Um tipo que suporte o operador '{0}' era esperado, mas um tipo de tupla foi recebido.</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>O assembly '{0}' está listado na linha de comando. Assemblies devem ser referenciados usando um sinalizador de linha de comando como '-r'.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>O '{0}' de um tipo fornecido era nulo ou vazio.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Método duplicado. O método abstrato '{0}' possui o mesmo nome e assinatura que um método abstrato em um tipo herdado.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>também de {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>O método de matriz '{0}' é fornecido pelo tempo de execução e não pode ser usado diretamente no código. Para operações com elementos de matriz, considere usar a família de funções GetArray/SetArray do módulo LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>O atributo de acessibilidade '{0}' não é permitido na abreviação de módulo. As abreviações de módulo são sempre particulares.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Os tipos fornecidos gerados por este uso de um provedor de tipos não podem ser usados de outros assemblies F# e devem ser marcados como internos ou privados. Considere usar 'type internal TypeName = ...' ou 'type private TypeName = ...'.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Adicione um . para obter acesso ao indexador.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>As associações DLLImport devem ser membros estáticos em uma classe ou definições de função em um módulo</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>A função ou o membro '{0}' é usado de uma forma que requer anotações de tipo adicionais em sua definição para garantir a consistência de tipos deduzidos. A assinatura deduzida é '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Este método já tem uma implementação padrão</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>O módulo '{0}' contém\n    {1}    \n, mas sua assinatura especifica\n    {2}    \nA representação compilada deste método é como um membro de instância, mas a assinatura indica que sua representação compilada seria como um membro estático</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Este não é um literal de byte válido</value>
  </data>
</root>