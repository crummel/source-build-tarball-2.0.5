<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fsiUnexpectedThreadAbortException" xml:space="preserve">
    <value>- ThreadAbortException inattendu (Ctrl-C) durant la gestion des événements : tentative de redémarrage...</value>
  </data>
  <data name="fsiProductNameCommunity" xml:space="preserve">
    <value>F# Interactive pour F# {0}</value>
  </data>
  <data name="fsiDidAHashrWithLockWarning" xml:space="preserve">
    <value>--&gt; Référencement de '{0}' (le fichier est peut-être verrouillé par le processus F# Interactive)</value>
  </data>
  <data name="fsiTimeInfoMainString" xml:space="preserve">
    <value>Réel : {0}, Processeur : {1}, GC {2}</value>
  </data>
  <data name="fsiReadline" xml:space="preserve">
    <value>Prend en charge la saisie semi-automatique via la touche Tab dans la console (activée par défaut)</value>
  </data>
  <data name="fsiIntroTextHashloadInfo" xml:space="preserve">
    <value>Charge le ou les fichiers spécifiés comme s'ils étaient compilés et référencés</value>
  </data>
  <data name="fsiFailedToResolveAssembly" xml:space="preserve">
    <value>Échec de la résolution de l'assembly '{0}'</value>
  </data>
  <data name="fsiIntroTextHeader2commandLine" xml:space="preserve">
    <value>  Options de ligne de commande F# Interactive :</value>
  </data>
  <data name="fsiIntroTextHashquitInfo" xml:space="preserve">
    <value>Quitter</value>
  </data>
  <data name="fsiRemaining" xml:space="preserve">
    <value>Traite les arguments restants en tant qu'arguments de ligne de commande, accessibles via fsi.CommandLineArgs</value>
  </data>
  <data name="fsiEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Émettre les informations de débogage entre quotations</value>
  </data>
  <data name="fsiAbortingMainThread" xml:space="preserve">
    <value>- Abandon du thread principal...</value>
  </data>
  <data name="fsiAdvanced" xml:space="preserve">
    <value>- AVANCÉ -</value>
  </data>
  <data name="fsiIntroTextHashrInfo" xml:space="preserve">
    <value>Référence (charger dynamiquement) la DLL spécifiée</value>
  </data>
  <data name="fsiDidAHashI" xml:space="preserve">
    <value>--&gt; Ajout de '{0}' au chemin d'accès Include de la bibliothèque</value>
  </data>
  <data name="fsiDidAHashr" xml:space="preserve">
    <value>--&gt; Référencement de '{0}'</value>
  </data>
  <data name="fsiIntroTextHashtimeInfo" xml:space="preserve">
    <value>Minutage activé/désactivé</value>
  </data>
  <data name="fsiIntroTextHashIInfo" xml:space="preserve">
    <value>Ajoute le chemin de recherche spécifié pour les DLL référencées</value>
  </data>
  <data name="fsiIntroTextHeader1directives" xml:space="preserve">
    <value>  Directives F# Interactive :</value>
  </data>
  <data name="fsiLoadingFilesPrefixText" xml:space="preserve">
    <value>Chargement en cours</value>
  </data>
  <data name="stoppedDueToError" xml:space="preserve">
    <value>Arrêt en raison d'une erreur\n</value>
  </data>
  <data name="fsiInterrupt" xml:space="preserve">
    <value>\n- Interrompre\n</value>
  </data>
  <data name="fsiInvalidAssembly" xml:space="preserve">
    <value>'{0}' n'est pas un nom d'assembly valide</value>
  </data>
  <data name="fsiExceptionDuringPrettyPrinting" xml:space="preserve">
    <value>\n\nException déclenchée durant l'impression automatique.\nSignalez ce problème afin qu'il soit corrigé.\nTrace : {0}\n</value>
  </data>
  <data name="fsiTurnedTimingOff" xml:space="preserve">
    <value>--&gt; Minutage désactivé</value>
  </data>
  <data name="fsiDidAHashrWithStaleWarning" xml:space="preserve">
    <value>--&gt; Référencement de '{0}' (un assembly avec un horodatage différent a déjà été référencé à partir de cet emplacement, réinitialisez fsi pour charger l'assembly mis à jour)</value>
  </data>
  <data name="fsiLanguage" xml:space="preserve">
    <value>- LANGAGE -</value>
  </data>
  <data name="fsiMiscellaneous" xml:space="preserve">
    <value>- DIVERS -</value>
  </data>
  <data name="fsiConsoleProblem" xml:space="preserve">
    <value>Un problème s'est produit lors du démarrage du processus F# Interactive. Cela peut être dû à un problème connu lié à la prise en charge par la console des processus en arrière-plan pour les applications Unicode sur certains systèmes Windows. Essayez de sélectionner Outils-&gt;Options-&gt;F# Interactive pour Visual Studio, puis entrez '--fsi-server-no-unicode'.</value>
  </data>
  <data name="fsiIntroTextHashhelpInfo" xml:space="preserve">
    <value>Afficher l'aide</value>
  </data>
  <data name="fsiTurnedTimingOn" xml:space="preserve">
    <value>--&gt; Minutage activé</value>
  </data>
  <data name="fsiIntroTextHeader3" xml:space="preserve">
    <value>      Consulter '{0}' pour les options</value>
  </data>
  <data name="fsiExceptionRaisedStartingServer" xml:space="preserve">
    <value>Exception déclenchée lors du démarrage du serveur de communication à distance.\n{0}</value>
  </data>
  <data name="fsiInvalidDirective" xml:space="preserve">
    <value>Directive non valide '#{0} {1}'</value>
  </data>
  <data name="fsiProductName" xml:space="preserve">
    <value>Microsoft (R) F# Interactive version {0}</value>
  </data>
  <data name="fsiBindingSessionTo" xml:space="preserve">
    <value>Liaison de la session à '{0}'...</value>
  </data>
  <data name="fsiCodeGeneration" xml:space="preserve">
    <value>- GÉNÉRATION DE CODE -</value>
  </data>
  <data name="fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration" xml:space="preserve">
    <value>gén</value>
  </data>
  <data name="fsiDirectoryDoesNotExist" xml:space="preserve">
    <value>Le répertoire '{0}' n'existe pas</value>
  </data>
  <data name="fsiCouldNotInstallCtrlCHandler" xml:space="preserve">
    <value>Impossible d'installer le gestionnaire ctrl-c - La gestion Ctrl-C n'est pas disponible. L'erreur était :\n\t{0}</value>
  </data>
  <data name="fsiLineTooLong" xml:space="preserve">
    <value>Avertissement : ligne trop longue, certains caractères sont ignorés\n</value>
  </data>
  <data name="fsiUse" xml:space="preserve">
    <value>Utilise le fichier spécifié au démarrage en tant qu'entrée initiale</value>
  </data>
  <data name="fsiGui" xml:space="preserve">
    <value>Exécute des interactions dans une boucle d'événements Windows Forms (activé par default)</value>
  </data>
  <data name="shadowCopyReferences" xml:space="preserve">
    <value>Empêche le blocage des références par le processus interactif F#</value>
  </data>
  <data name="fsiBanner3" xml:space="preserve">
    <value>Pour obtenir de l'aide, tapez #help;;</value>
  </data>
  <data name="fsiInputFiles" xml:space="preserve">
    <value>- FICHIERS D'ENTRÉE -</value>
  </data>
  <data name="fsiHelp" xml:space="preserve">
    <value>Affiche ce message d'utilisation (forme abrégée : -?)</value>
  </data>
  <data name="fsiLoad" xml:space="preserve">
    <value>#load le fichier spécifié au démarrage</value>
  </data>
  <data name="fsiExec" xml:space="preserve">
    <value>Sortie de fsi après le chargement des fichiers ou l'exécution du script .fsx spécifié dans la ligne de commande</value>
  </data>
  <data name="fsiExit" xml:space="preserve">
    <value>\n- Quitter...\n</value>
  </data>
  <data name="fsiErrorsAndWarnings" xml:space="preserve">
    <value>- ERREURS ET AVERTISSEMENTS -</value>
  </data>
  <data name="fsiQuiet" xml:space="preserve">
    <value>Supprime l'écriture de fsi dans stdout</value>
  </data>
  <data name="fsiUsage" xml:space="preserve">
    <value>Utilisation : {0} &lt;options&gt; [script.fsx [&lt;arguments&gt;]]</value>
  </data>
</root>