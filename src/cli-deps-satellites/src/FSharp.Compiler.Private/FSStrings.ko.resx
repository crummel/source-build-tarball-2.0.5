<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>'||' 기호</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> 구현 파일</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>'{0}' 멤버는 이름 및 인수 수만 볼 때 고유한 추상 슬롯에 해당하지 않습니다.</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value> 구현된 여러 인터페이스에 이 이름 및 인수 수가 지정된 멤버가 있습니다.</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value> '{0}' 및 '{1}' 인터페이스를 명시적으로 구현하십시오.</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value> 관련 재정의를 나타내기 위해 추가 형식 주석이 필요할 수 있습니다. 이 경고는 '#nowarn "70"' 또는 '--nowarn:70'을 통해 사용할 수 없도록 설정할 수 있습니다.</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>lex 실패</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>'(*)' 기호</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> 람다 식</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>'(' 기호</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>'constructor' 키워드</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> 특성 목록</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>이 값은 변경할 수 없습니다. 변경 가능한 키워드(예: 'let mutable {0} = expression')를 사용하세요.</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>전위 연산자</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>이 업캐스트는 불필요합니다. 형식이 동일합니다.</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>이 같음 식의 결과가 암시적으로 삭제됩니다. 결과를 이름에 바인딩하려면 'let'을 사용하세요(예: 'let result = expression').</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>'{0}'은(는) 이 패턴에서 두 번 바인딩되었습니다.</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>일반적으로 대문자 변수 식별자는 패턴에 사용하지 말아야 합니다. 이러한 식별자는 철자가 잘못된 패턴 이름을 나타낼 수 있습니다.</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> 구분된 공용 구조체 케이스 선언</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>'to' 키워드</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>'if' 키워드</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>'in' 키워드</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>'as' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>'or' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>'of' 키워드</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>'do' 키워드</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>이 식의 결과는 암시적으로 무시됩니다. 'ignore'를 사용하여 이 값을 명시적으로 버리거나(예: 'expr |&gt; ignore'), 'let'을 사용하여 결과를 이름에 바인딩하세요(예: 'let result = expr').</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>'interface' 키워드</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> 모듈 또는 네임스페이스 시그니처</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>#I 지시문은 F# 스크립트 파일(확장명 .fsx 또는 .fsscript)에서만 발생할 수 있습니다. 이 코드를 스크립트 파일로 이동하거나, 이 참조에 대한 '-I' 컴파일러 옵션을 추가하거나, 지시문을 '#if INTERACTIVE'/'#endif'로 구분하세요.</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>'constraint' 키워드</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0}(코드={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> 멤버 정의</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>'finally' 키워드</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> 예외 정의</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value> {0}, {1}, {2} 또는 기타 토큰이 필요합니다.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>':?' 기호</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>형식이 '{0}' 인터페이스를 구현하지만 이 사실이 시그니처에 의해 표시되지 않습니다. 시그니처에 인터페이스를 나열해야 합니다. 이렇게 하면 동적 형식 캐스팅 및/또는 리플렉션을 통해 인터페이스를 검색할 수 있게 됩니다.</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>'public' 키워드</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>'::' 기호</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value> {0}도 참조하십시오.</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>줄 주석</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>포함하는 형식은 'null'을 해당 nullary 공용 구조체 케이스에 대한 표현 값으로 사용할 수 있습니다. null 값에 대해 추상 또는 가상 멤버나 인터페이스 구현을 호출하면 예외가 발생합니다. 필요한 경우 nullary 생성자에 더미 데이터 값을 추가하여 'null'이 이 형식의 표현으로 사용되지 않게 하십시오.</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>'upcast' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>'override' 키워드</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>이 식의 패턴 일치가 완전하지 않습니다.</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> 예를 들어, 값 '{0}'은(는) 패턴에 포함되지 않은 케이스를 나타낼 수 있습니다.</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> 예를 들어, 값 '{0}'은(는) 패턴에 포함되지 않은 케이스를 나타낼 수 있습니다. 그러나 'when' 절이 있는 패턴 규칙은 이 값과 성공적으로 일치할 수 있습니다.</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> 일치하지 않는 요소는 무시됩니다.</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>.NET 이벤트로 컴파일될 정의의 형식이 필요한 형식이 아닙니다. 속성 멤버만 .NET 이벤트로 컴파일될 수 있습니다.</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> if/then/else 식</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>문자열 리터럴</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>'struct' 키워드</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>'static' 키워드</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>']' 기호</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>'}' 기호</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>'-&gt;' 기호</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>')' 기호</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>인용구의 끝</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>필요한 어셈블리 참조가 없습니다. '{0}' 어셈블리에 대한 참조를 추가해야 합니다.</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>인터페이스 구현은 초기 형식 선언 시 지정해야 합니다.</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>'inline' 키워드</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>이 재귀 참조와 정의 대상 개체에 대한 기타 재귀 참조는 런타임에 지연된 참조를 사용하여 초기화 적합성이 확인됩니다. 이는 사용자가 재귀 함수 대신 하나 이상의 재귀적 개체를 정의하기 때문입니다. 이 경고는 '#nowarn "40"' 또는 '--nowarn:40'을 사용하여 표시하지 않을 수 있습니다.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>':?&gt;' 기호</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>가능한 오버로드: '{0}'. {1}.</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>이 필드는 변경할 수 없습니다.</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>'member' 키워드</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>'module' 키워드</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> 값 시그니처</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>'(' 기호</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>인용구의 시작</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>'&lt;-' 기호</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>'downcast' 키워드</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>'{' 기호</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>'[' 기호</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>로컬 값이 아닙니다.</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>이 런타임 강제 변환 또는 형식 테스트(소스:\n    {0} 형식,    \n대상: \n    {1} 형식)를    \n수행하려면 이 프로그램 지점 전의 정보를 기반으로 하는 확인할 수 없는 형식이 필요합니다. 일부 형식의 경우 런타임 형식 테스트가 허용되지 않습니다. 형식 주석이 더 필요합니다.</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>'|]' 기호</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>형식 매개 변수에 제약 조건 '{0}'이(가) 없습니다.</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>키워드 </value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> 패턴</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>'assert' 키워드</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> 형식 인수</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>이 같음 식의 결과가 암시적으로 삭제됩니다. 결과를 이름에 바인딩하려면 'let'을 사용하세요(예: 'let result = expression'). 값을 변경하려면 값을 'mutable'로 표시하고 '&lt;-' 연산자를 사용하세요(예: '{0} &lt;- expression').</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>입력의 끝</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>'{0}' 형식에 {1}개의 형식 인수가 필요한데 {2}개를 받았습니다.</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>내부 더미 토큰</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>형식 유추 변수의 기본 형식 '{0}'을(를) 적용할 때 형식 제약 조건이 일치하지 않았습니다. </value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> 형식 제약 조건을 더 추가하십시오.</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>'delegate' 키워드</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>'extern' 키워드</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>'=' 기호</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>'..' 기호</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>'downto' 키워드</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>'$' 기호</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>런타임 강제 변환 또는 형식 테스트(소스: {0} 형식, 대상: {1} 형식)가 잘못되었습니다.\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>형식이 일치하지 않습니다.\n    '{0}'이(가)    \n필요하지만\n    '{1}'이(가) 지정되었습니다.    {2}\n</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>이 식에는\n    '{1}' 형식이 필요하지만    \n여기에서는\n    '{0}' 형식이 지정되었습니다.    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>바인더 키워드</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> 상호 작용</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>구조적 구문의 시작</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>확대의 인터페이스 구현은 이제 사용되지 않습니다. 인터페이스 구현은 초기 형식 선언 시 지정해야 합니다.</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>이 형식 테스트 또는 다운캐스트는 항상 보류됩니다.</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>'{0}' 멤버에 해당하는 추상 메서드를 재정의하기 위한 올바른 형식이 없습니다.</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> 필요한 시그니처는 '{0}'입니다.</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>'{0}' 멤버에 임의의 지정된 가상 메서드를 재정의하기 위한 올바른 형식이 없습니다.</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>'{0}' 멤버가 'unit'으로 특수화되었지만 'unit'은 반환 형식에 대한 매개 변수가 있는 추상 메서드의 반환 형식으로 사용될 수 없습니다.</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> 지시문</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>'global' 키워드</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> 멤버 시그니처</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>전위 연산자</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>'function' 키워드</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> 바인딩</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value> {0} 또는 기타 토큰이 필요합니다.</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>'interface' 키워드</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>';;' 기호</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (들여쓰기 인식 구문 때문)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>이 전방 참조로 인해 바인딩을 순서에 상관없이 실행할 수 있습니다.</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>기호 </value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>10진 리터럴</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>이 구문은 사용되지 않습니다.</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value> {0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>'default' 키워드</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> 레코드 식</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>이 프로그램 지점 전의 정보를 기반으로 하는 확인할 수 없는 형식의 개체를 대상으로 조회를 수행합니다. 개체의 형식을 제한하기 위해 이 프로그램 지점 전에 형식 주석이 필요할 수 있습니다. 이를 통해 조회가 확인될 수도 있습니다.</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>Thread 정적 및 Context 정적 'let' 바인딩은 사용되지 않습니다. 대신 클래스에 'static val mutable &lt;ident&gt; : &lt;type&gt;' 형식의 선언을 사용하십시오. 값이 각 새 스레드에서 기본값으로 초기화됨을 나타내려면 'DefaultValue' 특성을 추가하십시오.</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>내부 오류: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> 형식 제약 조건</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>연산자 이름</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>'{0}'을(를) 통해 참조되는 형식이 참조되지 않는 어셈블리에 정의되어 있습니다. '{1}' 어셈블리에 대한 참조를 추가해야 합니다.</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}. 이 경고는 '--nowarn:57' 또는 '#nowarn "57"'을 통해 사용할 수 없도록 설정할 수 있습니다.</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>내부 오류: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>구문 분석 오류</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>구문 분석 오류: 예기치 않은 파일의 끝입니다.</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>로드된 파일은 F# 소스 파일(확장명 .fs)일 수만 있습니다. 이 F# 스크립트 파일(.fsx 또는 .fsscript)은 F# 소스 파일로 처리됩니다.</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>형식 '{0}' 및 '{1}'을(를) 통합할 수 없습니다.</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>이름 '{2}'이(가) 이 형식 또는 모듈의 {3} '{4}'과(와) 충돌하므로 {0} '{1}'을(를) 정의할 수 없습니다.</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>{0} '{1}'의 정의가 중복되었습니다.</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> 열려 있는 선언</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>값 '{0}'은(는) 자체 정의의 일부로 계산됩니다.</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>이 값은 결국 자체 정의의 일부로 계산됩니다. 값을 지연 값 또는 함수로 만들어야 할 수 있습니다. 값 '{0}'{1}입니다.</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>컴파일러 생성 리터럴</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>다음 필드에는 값이 필요합니다. {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>비활성 코드</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>'{0}' 형식이 '{1}'{2} 형식과 호환되지 않습니다.</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>'abstract' 키워드</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>'namespace' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>이 지점 또는 이 지점 전의 불완전한 구조적 구문</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>이 같음 식의 결과가 암시적으로 삭제됩니다. 결과를 이름에 바인딩하려면 'let'을 사용하세요(예: 'let result = expression'). 값을 속성으로 설정하려면 '&lt;-' 연산자를 사용하세요(예: '{0}.{1} &lt;- expression').</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value> {0}, {1} 또는 기타 토큰이 필요합니다.</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>'??' 기호</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>구분된 공용 구조체 케이스 및 예외 레이블은 대문자로 된 식별자여야 합니다.</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>이 'or' 패턴의 양쪽이 서로 다른 변수 집합을 바인딩합니다.</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>'{0}' 파일이 없거나 이 파일에 액세스할 수 없으므로 파일을 로드할 수 없습니다.</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>이 식은 함수 값입니다. 즉, 인수가 없습니다. 해당 형식은 {0}입니다.</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>'[' 기호</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>'mutable' 키워드</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> 정의</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>'&gt;|]' 기호</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>공백</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>'private' 키워드</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>#r 지시문은 F# 스크립트 파일(확장명 .fsx 또는 .fsscript)에서만 발생할 수 있습니다. 이 코드를 스크립트 파일로 이동하거나 이 참조를 '-r' 컴파일러 옵션으로 바꾸세요. 이 지시문이 사용자 입력으로 실행되는 경우 지시문을 '#if INTERACTIVE'/'#endif'로 구분할 수 있습니다.</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>문자열 텍스트</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>정수..</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> 필드 선언</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>'{0}' 함수의 사용이 다른 위치에서 유추된 형식과 일치하지 않습니다. 함수의 유추 형식은\n    {1}입니다.    \n여기서 필요한 함수의 형식은\n    {2}입니다.    {3}\n이 오류는 'let rec' 컬렉션 또는 클래스 그룹 내에서 제네릭 재귀와 관련된 제한으로 인해 발생할 수 있습니다. 인수 및 반환 형식 모두에 대한 형식 주석을 비롯하여 재귀적 호출의 대상에 전체 형식 시그니처를 지정하십시오.</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>'{0}' 형식에 적절한 하위 형식이 없으며 해당 형식을 정적 강제 변환의 대상으로 사용할 필요가 없습니다.</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> begin/end 식</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>'{&lt;' 기호</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>':=' 기호</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>'inherit' 키워드</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>'try' 키워드</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>'sig' 키워드</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>'rec' 키워드</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>정수 리터럴</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>'val' 키워드</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>'asr' 키워드</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>'and' 키워드</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>'&amp;' 기호</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>'do' 키워드</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>'new' 키워드</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>'end' 키워드</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>입력의 끝</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>'.' 기호</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>'|' 기호</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>'fun' 키워드</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>'for' 키워드</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>이 구문을 사용하면 코드가 해당 형식 주석에 표시된 것보다 일반적이지 않게 됩니다. '{0}' 또는 이 근처에서 '#', '_' 또는 기타 형식 주석을 사용하여 암시된 형식 변수가 '{1}' 형식으로 제한되었습니다.</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>이 구문을 사용하면 코드가 해당 형식 주석에 표시된 것보다 일반적이지 않게 됩니다. 형식 변수 '{0}'은(는) '{1}' 형식으로 제한되었습니다.</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>이 구문을 사용하면 코드가 해당 형식 주석에 표시된 것보다 일반적이지 않게 됩니다. 측정 단위 변수 '{0}'은(는) 측정값 '{1}'(으)로 제한되었습니다.</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>주석</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>확대의 재정의 구현은 이제 사용되지 않습니다. 재정의 구현은 초기 형식 선언의 일부로 지정해야 합니다.</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>이러한 재귀적 사용은 런타임에 초기화 적합성이 확인됩니다. 이 경고는 일반적으로 무해하며 '#nowarn "21"' 또는 '--nowarn:21'을 사용하여 표시하지 않을 수 있습니다.</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>재정의 구현은 초기 형식 선언의 일부로 지정해야 합니다.</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>포함하는 형식은 'null'을 해당 nullary 공용 구조체 케이스에 대한 표현 값으로 사용할 수 있습니다. 이 멤버는 정적 멤버로 컴파일됩니다.</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>형식 제약 조건이 일치하지 않습니다. \n    '{0}'    \n형식이\n    '{1}' 형식과 호환되지 않습니다.    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>다음에서 '{0}' 파일을 찾을 수 없습니다.\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>형식 적용 </value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>이 지시문은 F# 스크립트 파일(확장명 .fsx 또는 .fsscript)에서만 사용할 수 있습니다. 지시문을 제거하거나, 이 코드를 스크립트 파일로 이동하거나, 지시문을 '#if INTERACTIVE'/'#endif'로 구분하십시오.</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>'{0}' 형식이 '{1}' 형식과 일치하지 않습니다.</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>측정 단위 '{0}'이(가) 측정 단위 '{1}'과(와) 일치하지 않습니다.</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>'internal' 키워드</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>'[&lt;' 기호</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>'&gt;' 기호</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>이 구문은 사용되지 않으며 F# 라이브러리에서만 사용할 수 있습니다.</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>값 제한이 있습니다. 값 '{0}'에 제네릭 형식\n    {1}이(가) 있습니다.    \n'{2}'을(를) 명시적 인수가 포함된 함수로 만들거나, 제네릭 요소로 만들지 않으려는 경우 형식 주석을 추가하십시오.</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>값 제한이 있습니다. 이 멤버는 제네릭 형식\n    {0}을(를) 가지는 것으로 유추되었습니다.    \n생성자 및 속성 getter/setter는 바깥쪽 형식보다 일반적일 수 없습니다. 형식 주석을 추가하여 관련 형식을 정확히 나타내십시오.</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>값 제한이 있습니다. 값 '{0}'에 제네릭 형식\n    {1}이(가) 있습니다.    \n'{2}'에 대한 인수를 명시적으로 만들거나, 제네릭 요소로 만들지 않으려는 경우 형식 주석을 추가하십시오.</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>값 제한이 있습니다. 값 '{0}'은(는) 제네릭 형식\n    {1}을(를) 가지는 것으로 유추되었습니다.    \n'{2}'에 대한 인수를 명시적으로 만들거나, 제네릭 요소로 만들지 않으려는 경우 형식 주석을 추가하십시오.</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>값 제한이 있습니다. 값 '{0}'은(는) 제네릭 형식\n    {1}을(를) 가지는 것으로 유추되었습니다.    \n'{2}'을(를) 단순 데이터 용어로 정의하거나, 명시적 인수가 포함된 함수로 만들거나, 제네릭 요소로 만들지 않으려는 경우 형식 주석을 추가하십시오.</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> 패턴 일치</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>예기치 않은 입력의 끝입니다.</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> 형식 정의</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> 형식 시그니처</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> 시그니처 파일</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> 인용구 리터럴</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>로드된 파일에 하나 이상의 경고가 있습니다.\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>로드된 파일에 하나 이상의 오류가 있습니다.\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>이름이 '{0}'인 멤버 제약 조건에는 F# 컴파일러에 의해 특수한 상태가 지정됩니다(특정 .NET 형식은 이 멤버를 사용하여 암시적으로 확대될 수 있음). 이로 인해 사용자 코드로부터 멤버 제약 조건을 호출할 경우 런타임 오류가 발생할 수 있습니다.</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> 바인딩</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>{0} '{1}'의 정의가 중복되었습니다.</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>'{0}'(이)라는 두 멤버의 시그니처가 같습니다.</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>'instance' 키워드</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>기본 포인터를 사용하면 확인할 수 없는 .NET IL 코드가 생성될 수 있습니다.</value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>'{0}' 형식에 적절한 하위 형식이 없으며 해당 형식을 형식 테스트 또는 런타임 강제 변환의 소스로 사용할 수 없습니다.</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>'{0}' 형식은 형식 테스트 또는 런타임 강제 변환의 소스로 사용할 수 없습니다.</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>'do!' 키워드</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>'_' 기호</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>구조체에 대한 암시적 개체 생성자는 하나 이상의 인수를 사용해야 합니다.</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>'{0}' 기호</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>예약된 키워드</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>'splice' 기호</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>정의 대상 개체에 대한 재귀 참조는 런타임에 지연된 참조를 사용하여 초기화 적합성이 확인됩니다. 멤버 또는 '&lt;ctor-expr&gt; then &lt;expr&gt;' 형식의 후행 식 내에 자기 참조를 배치하십시오.</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>정의 대상 개체에 대한 재귀 참조는 런타임에 지연된 참조를 사용하여 초기화 적합성이 확인됩니다. 생성 시퀀스의 'do' 문 내에서 마지막 'let' 바인딩 다음에 자기 참조를 배치하십시오.</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>':&gt;' 기호</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>이 생성자는 {0}개의 인수에 적용되었지만 {1}개를 필요로 합니다.</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>'function' 키워드</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>이 구문은 사용되지 않습니다. {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>지시문</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>일부 추상 멤버에 구현이 지정되지 않았으므로 이 형식은 'abstract'입니다. 의도적으로 구현을 지정하지 않은 경우에는 형식에 '[&lt;AbstractClass&gt;]' 특성을 추가하십시오.</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value> 이 이름의 구문을 FSharp.PowerPack.dll에서 찾았습니다. 이 DLL에는 일부 이전 버전의 F#에서 암시적으로 참조된 모듈 및 형식이 일부 포함되어 있습니다. 이 코드를 컴파일하려면 이 DLL에 대한 명시적 참조를 추가해야 할 수 있습니다.</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>예기치 않은 {0}입니다.</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>yield!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>yield</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>'?' 기호</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>인용 기호</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>값 형식 \n    {0}을(를)    \n{1} 형식으로 \n    강제 변환하려면    \nboxing이 필요합니다. 대신 'box'를 사용하십시오.</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>식별자</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>'while' 키워드</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>'match' 키워드</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>'-' 기호</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>'with' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>'then' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>'else' 키워드</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>':' 기호</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>',' 기호</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>키워드 'const'</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>'class' 키워드</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>'begin' 키워드</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>부동 소수점 리터럴</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>키워드 '수정됨'</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>'false' 키워드</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>이 지점 또는 이 지점 전에서 구조적 구문이 완전하지 않습니다.</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>'{0}' 모듈에는 {1} '{2}'이(가) 필요합니다.</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> extern 선언</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> 형식</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> 식</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> 공용 구조체 케이스</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>바이트 배열 리터럴</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> '{0}'을(를) 계산합니다.</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>이 규칙은 일치시킬 수 없습니다.</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n{3}.</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\n가능한 최적의 오버로드: '{0}'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>'[|' 기호</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>튜플의 길이가 {0}과(와) {1}(으)로 서로 다릅니다.</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>'type' 키워드</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>'true' 키워드</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>'*' 기호</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value># 기호</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>'when' 키워드</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>'with' 키워드</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>'void' 키워드</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>'&lt;' 기호</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>'lazy' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>'open' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>'fun' 키워드</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>'let' 또는 'use' 키워드</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>'null' 키워드</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>'elif' 키워드</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>'done' 키워드</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>문자 리터럴</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>'base' 키워드</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>어셈블리 참조 '{0}'이(가) 없거나 잘못되었습니다.</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>구문 오류입니다.</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>'{0}' 필드와 '{1}' 필드의 소스 형식이 서로 다릅니다.</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> 형식 이름</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>'&amp;&amp;' 기호</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>{1}에 있는 InternalsVisibleTo 특성의 어셈블리 이름 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>InternalsVisibleTo 특성의 어셈블리 이름 '{0}'이(가) 잘못되었습니다. 어셈블리 파일 이름을 사용할 수 없습니다.</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>이 함수는 너무 많은 인수를 사용하거나 함수가 필요하지 않은 컨텍스트에서 사용되었습니다.</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>이 같음 식의 결과가 암시적으로 삭제됩니다. 결과를 이름에 바인딩하려면 'let'을 사용하세요(예: 'let result = expression'). 값을 변경하려면 '&lt;-' 연산자를 사용하세요(예: '{0} &lt;- expression').</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>정적 강제 변환(소스:\n    {0} 형식,    \n대상: \n    {1} 형식)을    \n수행하려면 이 프로그램 지점 전의 정보를 기반으로 하는 확인할 수 없는 형식이 필요합니다. 일부 형식의 경우 정적 강제 변환이 허용되지 않습니다. 형식 주석이 더 필요합니다.</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>이 구문을 사용하면 확인할 수 없는 .NET IL 코드가 생성될 수 있습니다. 이 경고는 '--nowarn:9' 또는 '#nowarn "9"'를 통해 사용할 수 없도록 설정할 수 있습니다.</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> 정의</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>';' 기호</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>중위 연산자</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> 개체 식</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>'&gt;}' 기호</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>'&gt;]' 기호</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>'exception' 키워드</value>
  </data>
</root>