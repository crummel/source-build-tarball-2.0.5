<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>'||' simgesi</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> uygulama dosyasında</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>'{0}' üyesi yalnızca ada ve bağımsız değişken sayısına dayalı olarak benzersiz bir soyut yuvaya karşılık gelmiyor</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value>. Birden fazla sayıda uygulanmış arabirimde bu ada ve bağımsız değişken sayısına sahip üye var</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value>. '{0}' ve '{1}' arabirimlerini açık olarak uygulamayı düşünün.</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value>. İlgili geçersiz kılmayı belirtmek için yeni tür ek açıklamaları gerekebilir. Bu uyarı, '#nowarn "70"' veya '--nowarn:70' kullanılarak devre dışı bırakılabilir.</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>lex hatası</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>'(*)' simgesi</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> lambda ifadesinde</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>'(' simgesi</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>'constructor' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> öznitelik listesinde</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>Bu değer değiştirilebilir değil. mutable anahtar sözcüğünü (örn. 'let mutable {0} = expression') kullanmayı düşünün.</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>ön ek işleci</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>Bu üst türe çevirme işlemi gereksiz, bu türler özdeş</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>Bu eşitlik ifadesinin sonucu örtük olarak atılmıştır. Sonucu bir ada bağlamak için 'let' kullanmayı düşünün; örneğin, 'let sonuç = deyim'.</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>'{0}' bu desende iki kez bağlandı</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>Büyük harfli değişken tanımlayıcıları desenlerde genel olarak kullanılmamalıdır, yanlış yazılmış bir desen adının göstergesi olabilirler.</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> ayırt edici birleşim durumu bildiriminde</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>'to' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>'if' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>'in' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>'as' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>'or' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>'of' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>'do' anahtar sözcüğü</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>Bu ifadenin sonucu örtük olarak yoksayılır. Bu değeri açıkça atmak için 'ignore' kullanmayı (örn. 'expr |&gt; ignore') veya sonucu bir ada bağlamak için 'let' kullanmayı (örn. 'let result = expr') deneyin.</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>'interface' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> modül veya ad alanı imzasında</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>#I yönergeleri yalnızca F# betik dosyalarında (.fsx veya .fsscript uzantılı) görülebilir. Ya bu kodu bir betik dosyasına taşıyıp bu başvuru için bir '-I' derleyici seçeneği ekleyin ya da yönergeyi '#if INTERACTIVE'/'#endif' ile sınırlandırın.</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>'constraint' anahtar sözcüğü</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0} (Kod={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> üye tanımında</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>'finally' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> özel durum tanımında</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value>. {0}, {1}, {2} veya başka bir belirteç bekleniyordu.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>':?' simgesi</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>Bu tür '{0}' arabirimini uyguluyor ancak bu durum imza ile gösterilmiyor. Arabirim dinamik tür atamaları ve/veya yansıtma aracılığıyla bulunabileceği için arabirimi imzada listelemeniz gerekir.</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>'public' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>'::' simgesi</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value>. Ayrıca bkz. {0}.</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>satır açıklaması</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>Kapsayıcı tür, kendisinin işlenensiz birleşim durumunun temsili değeri olarak 'null' kullanabilir. Null bir değerde soyut veya sanal bir üyeyi ya da bir arabirim uygulamasını çağırmak özel duruma neden olur. Gerekirse bu türün temsili olarak 'null' kullanılmasına engel olmak için işlenensiz oluşturucuya sahte veri değeri ekleyin.</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>'upcast' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>'override' anahtar sözcüğü</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>Bu ifadede eksik desen eşleşmeleri var.</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> Örneğin, '{0}' değeri desenlerin kapsamadığı bir duruma işaret edebilir.</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> Örneğin, '{0}' değeri desenlerin kapsamadığı bir duruma işaret edebilir. Ancak, 'when' yan tümcesinin olduğu bir desen kuralı bu değeri başarıyla eşleştirebilir.</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> Eşleşmeyen öğeler yok sayılacak.</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>.NET olayı olarak derlenecek bir tanım beklenen biçimde değil. Yalnızca özellik üyeleri .NET olayları olarak tanımlanabilir.</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> if/then/else ifadesinde</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>dize sabit değeri</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>'struct' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>'static' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>']' simgesi</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>'}' simgesi</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>'-&gt;' simgesi</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>')' simgesi</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>alıntı sonu</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>Gerekli bir bütünleştirilmiş kod başvurusu eksik. '{0}' bütünleştirilmiş koduna başvuru eklemeniz gerekiyor.</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>Arabirim uygulamaları bir türün ilk bildiriminde verilmelidir.</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>'inline' anahtar sözcüğü</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>Tanımlanmakta olan nesnelere yönelik bu ve diğer özyinelemeli başvurular, gecikmeli başvuru kullanımı aracılığıyla başlatma sağlamlığı açısından çalışma zamanında denetlenecek. Bunun nedeni, özyinelemeli işlev yerine bir veya daha fazla özyinelemeli nesne tanımlamanızdır. Bu uyarı, '#nowarn "40"' veya '--nowarn:40' kullanılarak gizlenebilir.</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>':?&gt;' simgesi</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>Olası aşırı yükleme: '{0}'. {1}.</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>Bu alan değiştirilebilir değil</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>'member' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>'module' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> değer imzasında</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>'(' simgesi</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>alıntı başlangıcı</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>'&lt;-' simgesi</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>'downcast' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>'{' simgesi</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>'[' simgesi</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>Bu değer yerel değil</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>Tür\n    {0}    \n ile \n    {1}    \narasındaki bu çalışma zamanı zorlaması veya tür testi, bu program noktasından önceki bilgilere dayalı olarak belirsiz bir tür içeriyor. Çalışma zamanı tür testlerine bazı türlerde izin verilmez. Yeni tür ek açıklamaları gereklidir.</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>'|]' simgesi</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>Bir tür parametresinde kısıtlama eksik '{0}'</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>anahtar sözcük</value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> desende</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>'assert' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> tür bağımsız değişkenlerinde</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>Bu eşitlik ifadesinin sonucu örtük olarak atılmıştır. Sonucu bir ada bağlamak için 'let' kullanmayı düşünün; örneğin, 'let sonuç = deyim'. Bir değeri değiştirmek istiyorsanız, değeri 'mutable' olarak işaretleyin ve '&lt;-' işlecini kullanın; örneğin, '{0} &lt;- deyim'.</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>girişin sonu</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>'{0}' türü {1} tür bağımsız değişkeni bekliyor ancak {2} verilmiş</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>iç sahte belirteç</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>Tür çıkarma değişkeni için varsayılan '{0}' türü uygulanırken tür kısıtlaması uyuşmazlığı. </value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> Yeni tür kısıtlamaları eklemeyi düşünün</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>'delegate' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>'extern' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>'=' simgesi</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>'..' simgesi</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>'downto' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>'$' simgesi</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>{0} türünden şu türe geçersiz çalışma zamanı zorlaması veya tür testi: {1}\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>Tür uyumsuzluğu. Beklenen şuydu:\n    '{0}'    \nancak şu sağlandı:\n    '{1}'    {2}\n</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>Bu ifadenin\n    '{1}'    \ntüründe olması bekleniyordu ancak buradaki tür\n    '{0}'    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>binder anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> etkileşimde</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>yapılandırılmış yapı başlangıcı</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>Genişletmelerdeki arabirim uygulamaları artık kullanım dışı bırakıldı. Arabirim uygulamaları bir türün ilk bildiriminde verilmelidir.</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>Bu tür testi veya alt türe çevirme işlemi her zaman tutar</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>'{0}' üyesi, ilgili soyut metodu geçersiz kılmak için doğru türe sahip değil.</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> Gereken imza: '{0}'.</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>'{0}' üyesi, verilen herhangi bir metodu geçersiz kılmak için doğru türe sahip değil</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>'{0}' üyesi 'unit' ile özelleştirilmiş ancak 'unit', dönüş türünde parametreleştirilen bir özet metodunun dönüş türü olarak kullanılamaz.</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> yönergede</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>'global' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> üye imzasında</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>ön ek işleci</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>'function' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> bağlamada</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value>. {0} veya başka bir belirteç bekleniyordu.</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>'interface' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>';;' simgesi</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (girinti tanıyan sözdizimine bağlı olarak)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>Bu ileriye doğru başvuru nedeniyle bağlamalar sırasız yürütülebilir.</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>simge</value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>ondalık sabit değeri</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>Bu yapı kullanım dışı</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value>. {0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>'default' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> kayıt ifadesinde</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>Bu program noktasından önceki bilgilere dayalı olarak belirsiz türdeki nesne araması. Bu program noktasından önce nesnenin türünü kısıtlamak için bir tür ek açıklaması gerekebilir. Bu, aramanın çözümlenmesine izin verebilir.</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>Statik iş parçacıklı ve statik bağlamlı 'let' bağlamaları kullanım dışıdır. Onun yerine bir sınıfta 'static val mutable &lt;ident&gt; : &lt;tür&gt;' biçimindeki bildirimi kullanın. Değerin her yeni iş parçacığında varsayılan değerle başlatıldığını belirtmek için bu bildirime 'DefaultValue' özniteliğini ekleyin.</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>iç hata: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> tür kısıtlamasında</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>işleç adı</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>'{0}' aracılığıyla başvurulan tür başvurulmayan bir bütünleştirilmiş kodda tanımlanıyor. '{1}' bütünleştirilmiş koduna başvuru eklemeniz gerekiyor.</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}. Bu uyarı, '--nowarn:57' veya '#nowarn "57"' kullanılarak devre dışı bırakılabilir.</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>iç hata: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>ayrıştırma hatası</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>ayrıştırma hatası: beklenmeyen dosya sonu</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>Yüklenen dosyalar yalnızca F# kaynak dosyaları (.fs uzantılı) olabilir. Bu F# betik dosyasına (.fsx veya .fsscript) F# kaynak dosyası gibi işlem yapılacak</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>'{0}' ve '{1}' türleri birleştirilemez.</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>'{2}' adı bu türde veya modülde {3} '{4}' ile çakıştığı için {0} '{1}' tanımlanamıyor</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>Yinelenen {0} '{1}' tanımı</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> açık bildirimde</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>'{0}' değeri kendi tanımının parçası olarak hesaplanacak</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>Bu değer sonuç olarak kendi tanımının parçası olarak hesaplanacak. Bu değeri geç değer veya işlev yapmanız gerekebilir. Değer: '{0}'{1}.</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>derleyicinin oluşturduğu sabit değer</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>Aşağıdaki alanlar için değerler gerekiyor: {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>pasif kod</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>'{0}' türü '{1}'{2} türüyle uyumlu değil</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>'abstract' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>'namespace' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>bu noktada veya daha önce eksik yapılandırılmış yapı</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>Bu eşitlik ifadesinin sonucu örtük olarak atılmıştır. Sonucu bir ada bağlamak için 'let' kullanmayı düşünün; örneğin, 'let sonuç = deyim'. Bir özelliğin değerini ayarlamak istiyorsanız, '&lt;-' işlecini kullanın; örneğin, '{0}.{1} &lt;- deyim'.</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value>. {0}, {1} veya başka bir belirteç bekleniyordu.</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>'??' simgesi</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>Ayırt edici birleşim durumları ve özel durum etiketleri büyük harfli tanımlayıcılar olmalıdır</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>Bu 'or' deseninin her iki tarafı farklı değişken kümelerini bağlıyor</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>'{0}' dosyası olmadığı veya ona erişilemediği için yüklenemedi</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>Bu ifade bir işlev değeri, yani bağımsız değişkenleri eksik. Türü: {0}.</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>'[' simgesi</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>'mutable' anahtar sözcüğü</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> tanımda</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>'&gt;|]' simgesi</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>whitespace</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>'private' anahtar sözcüğü</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>#r yönergeleri yalnızca F# betik dosyalarında (.fsx veya .fsscript uzantılı) görülebilir. Bu kodu bir betik dosyasına taşıyın veya bu başvuruyu '-r' derleyici seçeneği ile değiştirin. Yönerge kullanıcı girişi olarak yürütülüyorsa, yönergeyi '#if INTERACTIVE'/'#endif' ile sınırlandırabilirsiniz.</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>dize metni</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>tamsayı..</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> alan bildiriminde</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>'{0}' işlevinin kullanımı başka bir yerde çıkarılmış türle eşleşmiyor. İşlevin çıkarılan türü\n    {1}.    \nBu kullanım noktasında gereken işlevin türü\n    {2}    {3}\nBu hata, 'let rec' koleksiyonu veya bir sınıf grubu içindeki genel özyineleme ile ilişkili sınırlamalar nedeniyle olabilir. Hem bağımsız değişken hem de dönüş türleri için tür ek açıklamaları ekleyerek özyinelemeli çağrıların hedefleri için tam tür imzası vermeyi düşünün.</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>'{0}' türünün herhangi bir uygun alt türü yok ve statik zorlama hedefi olarak kullanılması gerekmiyor</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> begin/end ifadesinde</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>'{&lt;' simgesi</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>':=' simgesi</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>'inherit' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>'try' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>'sig' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>'rec' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>tamsayı sabit değeri</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>'val' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>'asr' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>'and' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>'&amp;' simgesi</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>'do' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>'new' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>'end' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>girişin sonu</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>'.' simgesi</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>'|' simgesi</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>'fun' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>'for' anahtar sözcüğü</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>Bu yapı, kodun kendi tür ek açıklamaları ile belirtilenden daha az genel olmasına neden olur. '#', '_' kullanılmasıyla veya '{0}' konumundaki ya da yakınındaki başka bir tür ek açıklamasıyla işaret edilen tür değişkeni '{1}' türü olacak şekilde kısıtlandı.</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>Bu yapı, kodun kendi tür ek açıklamaları ile belirtilenden daha az genel olmasına neden olur. Tür değişkeni '{0}, '{1}' türü olacak şekilde kısıtlandı.</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>Bu yapı, kodun kendi tür ek açıklamaları ile belirtilenden daha az genel olmasına neden olur. Ölçü birimi değişkeni '{0}, '{1}' ölçüsü olacak şekilde kısıtlandı.</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>açıklama</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>Genişletmelerdeki geçersiz kılma uygulamaları artık kullanım dışı bırakıldı. Geçersiz kılma uygulamaları bir türün ilk bildiriminin parçası olarak verilmelidir.</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>Bu özyinelemeli kullanım çalışma zamanında başlatma sağlamlığı açısından denetlenecek. Bu uyarı genellikle zararsızdır ve '#nowarn "21"' veya '--nowarn:21' kullanılarak gizlenebilir.</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>Geçersiz kılma uygulamaları bir türün ilk bildiriminin parçası olarak verilmelidir.</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>Kapsayıcı tür, kendisinin işlenensiz birleşim durumunun temsili değeri olarak 'null' kullanabilir. Bu üye, statik üye olarak derlenecek.</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>Tür kısıtlaması uyumsuzluğu. \n    '{0}'    \ntürü şu türle uyumlu değil:\n    '{1}'    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>'{0}' dosyası şunların hiçbirinde bulunamıyor:\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>tür uygulaması</value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>Bu yönerge yalnızca F# betik dosyalarında (.fsx veya .fsscript uzantılı) kullanılabilir. Ya yönergeyi kaldırıp bu kodu betik dosyasına taşıyın ya da yönergeyi '#if INTERACTIVE'/'#endif' ile sınırlandırın.</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>'{0}' türü '{1}' türü ile eşleşmiyor</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>'{0}' ölçü birimi '{1}' ölçü birimi ile eşleşmiyor</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>'internal' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>'[&lt;' simgesi</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>'&gt;' simgesi</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>Bu yapı kullanım dışıdır: yalnızca F# kitaplığında kullanım içindir</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>Değer kısıtlaması. '{0}' değerinin genel türü:\n    {1}    \nYa açık bağımsız değişkenlerle '{2}' için işlev dönüşümü yapın ya da genel olmasını istemiyorsanız bir tür ek açıklaması ekleyin.</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>Değer kısıtlaması. Bu üyenin şu genel türü olduğu çıkarıldı\n    {0}    \nOluşturucular ve özellik alıcıları/ayarlayıcıları kapsayan türden daha genel olamaz.  Söz konusu türleri tam olarak belirtmek için bir tür ek açıklaması ekleyin.</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>Değer kısıtlaması. '{0}' değerinin genel türü:\n    {1}    \nYa '{2}' bağımsız değişkenlerini açık yapın ya da genel olmasını istemiyorsanız bir tür ek açıklaması ekleyin.</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>Değer kısıtlaması. '{0}' değerinin şu genel türü olduğu çıkarıldı:\n    {1}    \nYa '{2}' bağımsız değişkenlerini açık yapın ya da genel olmasını istemiyorsanız bir tür ek açıklaması ekleyin.</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>Değer kısıtlaması. '{0}' değerinin şu genel türü olduğu çıkarıldı:\n    {1}    \nYa '{2}' tanımını basit veri terimi olarak yaparak onu açık bağımsız değişkenlerle bir işlev yapın ya da genel olmasını istemiyorsanız bir tür ek açıklaması ekleyin.</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> desen eşleştirmede</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>Beklenmeyen giriş sonu</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> tür tanımında</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> tür imzasında</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> imza dosyasında</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> alıntı sabit değerinde</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>Yüklenen dosyada bir veya daha fazla uyarı var.\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>Yüklenen dosyada bir veya daha fazla hata var.\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>Belirli .NET türleri örtük olarak bu üyeyle genişletildiği için '{0}' adlı üye kısıtlamalarına F# derleyicisi tarafından özel durum verildi. Üye kısıtlamasını kendi kodunuzdan çağırmayı denerseniz, bu, çalışma zamanı hatalarıyla sonuçlanabilir.</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> bağlamada</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>Yinelenen {0} '{1}' tanımı</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>'{0}' çağrısı yapan iki üye aynı imzaya sahip</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>'instance' anahtar sözcüğü</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>Yerel işaretçilerin kullanılması doğrulanamayan .NET IL koduyla sonuçlanabilir</value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>'{0}' türünün herhangi bir uygun alt türü yok ve bir tür testinin veya çalışma zamanı zorlamasının kaynağı olarak kullanılamaz.</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>'{0}' türü bir tür testinin veya çalışma zamanı zorlamasının kaynağı olarak kullanılamaz</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>'do!' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>'_' simgesi</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>Yapıların örtük nesne oluşturucuları en az bir bağımsız değişken almalıdır</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>'{0} simgesi</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>ayrılmış anahtar sözcük</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>'splice' simgesi</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>Tanımlanmakta olan nesneye yapılan özyinelemeli başvurular, geç başvuru kullanımı aracılığıyla çalışma zamanında başlatma sağlamlığı açısından denetlenecek. Kendine yapılan başvuruları üyelere veya '&lt;ctor-expr&gt; then &lt;expr&gt;' biçimindeki izleyen ifadenin içine yerleştirmeyi düşünün.</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>Tanımlanmakta olan nesneye yapılan özyinelemeli başvurular, geç başvuru kullanımı aracılığıyla çalışma zamanında başlatma sağlamlığı açısından denetlenecek. Kendine yapılan başvuruları yapı dizisindeki sonuncu 'let' bağlamasından sonra 'do' deyimlerinin içine yerleştirmeyi düşünün.</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>':&gt;' simgesi</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>Bu oluşturucu {0} bağımsız değişkene uygulandı ancak {1} bekliyor</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>'function' anahtar sözcüğü</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>Bu yapı kullanım dışı: {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>yönerge</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>Bazı soyut üyelere bir uygulama verilmediğinden bu bir 'abstract' türdür. Bu bilerek yapıldıysa, türünüze '[&lt;AbstractClass&gt;]' özniteliğini ekleyin.</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value>Bu adlı bir yapı, F# dilinin önceki bazı sürümlerinde örtük olarak başvurulan bazı modül ve türleri içeren FSharp.PowerPack.dll dosyasında bulundu. Bu kodu derleyebilmek için bu DLL'ye açık başvuru eklemeniz gerekebilir.</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>Beklenmeyen {0}</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>yield!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>yield</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>'?' simgesi</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>alıntı simgesi</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>Zorlamanın \n    {0}    \ndeğer türünden \n    {1}    \ntürüne yapılması kutulama gerektirir. Bunun yerine 'box' kullanmayı düşünün</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>tanımlayıcı</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>'while' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>'match' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>'-' simgesi</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>'with' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>'then' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>'else' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>':' simgesi</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>',' simgesi</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>'const' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>'class' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>'begin' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>kayan nokta sabit değeri</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>'fixed' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>'false' anahtar sözcüğü</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>Bu noktada veya daha önce eksik yapılandırılmış yapı</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>'{0}' modülü için {1} '{2}' gerekiyor</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> dış bildirimde</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> türde</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> ifadede</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> birleşim durumunda</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>bayt dizisi sabit değeri</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> '{0}' sonucunu verecek</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>Bu kural hiçbir zaman eşleştirilmeyecek</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \n{3} belirtiliyor.</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\nOlası en iyi aşırı yükleme: '{0}'.</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>'[|' simgesi</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>Demetlerde farklı {0} ve {1} uzunlukları var</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>'type' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>'true' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>'*' simgesi</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value># simgesi</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>'when' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>'with' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>'void' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>'&lt;' simgesi</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>'lazy' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>'open' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>'fun' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>'let' veya 'use' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>'null' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>'elif' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>'done' anahtar sözcüğü</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>karakter sabit değeri</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>'base' anahtar sözcüğü</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>Bütünleştirilmiş kod başvurusu '{0}' bulunamadı veya geçersiz</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>sözdizimi hatası</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>'{0}' ve '{1}' alanları farklı türlerde</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> tür adında</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>'&amp;&amp;' simgesi</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>{1} içindeki InternalsVisibleTo özniteliğinden geçersiz bütünleştirilmiş kod adı '{0}'</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>InternalsVisibleTo özniteliğinden geçersiz bütünleştirilmiş kod adı '{0}' (bütünleştirilmiş kod dosya adı kullanılamıyor)</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>Bu işlev çok fazla bağımsız değişken alıyor veya bir işlev beklenmeyen bağlamda kullanılıyor</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>Bu eşitlik ifadesinin sonucu örtük olarak atılmıştır. Sonucu bir ada bağlamak için 'let' kullanmayı düşünün, örneğin 'let sonuç = deyim'. Bir değeri değiştirmek istiyorsanız, '&lt;-' işlecini kullanın; örneğin, '{0} &lt;- deyim'.</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>Bu program noktasından önceki bilgilere dayalı olarak\n    {0}    \ntüründen \n    {1}    \n türüne statik zorlama belirsiz bir tür içeriyor. Statik zorlamalara bazı türlerde izin verilmez. Yeni tür ek açıklamaları gereklidir.</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>Bu yapının kullanılması doğrulanamayan .NET IL kodunun oluşturulmasıyla sonuçlanabilir. Bu uyarı, '--nowarn:9' veya '#nowarn "9"' kullanılarak devre dışı bırakılabilir.</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> tanımlarda</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>';' simgesi</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>içtakı işleci</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> nesne ifadesinde</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>'&gt;}' simgesi</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>'&gt;]' simgesi</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>'exception' anahtar sözcüğü</value>
  </data>
</root>