<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou na této pozici pro zkratky typu povolené.</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Je možné, že se při statickém propojování nezahrne soubor .exe.</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>Vlastnost {0} se nedá přečíst.</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>Vazby use musí mít notaci use &lt;var&gt; = &lt;expr&gt;.</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler verze {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Pole záznamu, struktury nebo třídy {0} není z tohoto místa v kódu dostupné.</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Neplatný člen {0} u poskytnutého typu {1}. Členové poskytnutého typu musí být veřejné,ne obecné, virtuální nebo abstraktní.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>{{ }} není platný výraz. Záznamy musí obsahovat aspoň jedno pole. Prázdná pořadí se specifikují pomocí Seq.empty nebo prázdného seznamu [].</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Dynamické vyvolání {0} se nepodporuje.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} má atribut StructuralEquality, ale parametr typu {1} nevyhovuje omezení equality. Zvažte možnost přidat k parametru typu omezení equality.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} má atribut StructuralEquality, ale typ komponenty {1} nevyhovuje omezení equality.</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Zvažte možnost použít místo toho samostatný typ záznamu.</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>Adresa proměnné {0} se na tomto místě nedá použít. Metoda nebo funkce možná nebude vracet adresu této místní hodnoty.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Sestavení {0} se nedá přečíst.</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Obecný konstruktor vyžaduje, aby byl typ {0} typem struktura CLI nebo F#.</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Zprostředkovatel typu {0} vrátil u metody GetInvokerExpression hodnotu null.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Víc odkazů na knihovnu {0}.dll se nepovoluje.</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Neshoda v názvu operátoru citace (začíná na {0})</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Označuje metodu, která buď nemá implementaci v typu, ve kterém je deklarovaná, nebo která je virtuální a má výchozí implementaci.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Je možné, že se při statickém propojování nezahrne kombinovaná spravovaná nebo nespravovaná knihovna DLL.</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Omezuje přístup k členovi na kód ve stejném typu nebo modulu.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Typ {0} není v důsledku použití formátovacího řetězce ve stylu printf kompatibilní s žádným z typů {1}.</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Členové rozšíření nemůžou poskytovat přetížení operátorů. Zvažte možnost definovat místo toho operátor v definici typu.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>Proměnná {0} je použitá neplatným způsobem.</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>{0} se dá použít jenom k vytvoření objektových typů.</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Neočekávaný token {0} nebo neúplný výraz</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>Podtržítko se pro název pole použít nedá.</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Zadali jste víc dostupností pro metodu getter nebo setter vlastnosti.</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Konstruktory se musí použít pro argumenty a nejde je použít jako hodnoty první třídy. V případě potřeby použijte anonymní funkci (fun arg1 ... argN -&gt; new Type(arg1,...,argN)).</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Neplatný soubor verze {0}</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Rekurzivní vazby, které obsahují specifikace členů, se dají použít jenom jako přímé rozšíření typu.</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Neplatný rekurzivní odkaz na abstraktní datovou oblast</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Citace nemůžou obsahovat vložený kód sestavení nebo porovnávání vzorů polí.</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Objekty se musí inicializovat pomocí výrazu konstruktoru objektu, který volá zděděný konstruktor objektu a přiřazuje hodnoty ke všem polím.</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Argumenty operátorů dotazu můžou vyžadovat použití závorek, třeba where (x &gt; y) nebo groupBy (x.Length / 10).</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Nastavit úroveň pro upozornění (0–5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Zobrazí tuto zprávu o použití (krátký tvar: -?).</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>Aby bylo možné použít třídy UnknownWrapper\DispatchWrapper, vyžaduje se sestavení System.Runtime.InteropServices.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>modul</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Neplatný výraz nalevo od přiřazení</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Neplatná vložená specifikace</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Odděluje citaci typového kódu.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet se očekává jenom ve stromech pro analýzu.</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Potíže s názvem souboru {0}: neplatné znaky v cestě</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(Načítá se popis...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení comparison, protože je to záznam, sjednocení nebo struktura aspoň s jedním strukturálním typem prvků, který nepodporuje omezení comparison. Buď se u tohoto typu vyhněte použití comparison, nebo k němu přidejte atribut StructuralComparison a s jeho pomocí určete, který typ pole nepodporuje comparison.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení comparison. Nepodporuje třeba rozhraní System.IComparable.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení comparison, protože má atribut NoComparison.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>Atribut System.Diagnostics.ConditionalAttribute je platný jenom u metod nebo tříd atributů.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože se liší reprezentace CLI. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Chyba syntaxe v argumentu typu s popiskem</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Vlastnost nemůže mít explicitní parametry typu. Zvažte místo toho možnost použití metody.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Výstupní zprávy v kódování UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Modul a definice typu s názvem {0} se vyskytují v oboru názvů {1} ve dvou částech tohoto sestavení.</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Název {0} nemá vazbu v kontextu vzoru.</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Konstruktor zprostředkovatele typu vyvolal výjimku: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Při překladu odkazu na poskytnutý typ nebo metodu {1} se objevil neznámý druh statického argumentu {0}.</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>Definice vlastního operátoru {0} nepoužívá platnou kombinaci příznaků atributu.</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: metoda {0} byla vyjádřená jako statická, ale není to odpovídající výraz lambda.</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 8bitová celá čísla bez znaménka.</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Atributy v tomto konstruktoru se ignorovaly.</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>Po {0} musí následovat in. Použití: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IEquatable&lt;_&gt;. Použijte pro tento typ atribut CustomEquality a vytvořte konzistentní implementaci přepsání System.Object.Equals(obj), které není obecné.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Zdrojový soubor je příliš velký pro vložený do souboru PDB typu Portable.</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Konstruktor objektu vyžaduje argument.</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Chyba čtení nebo zápisu metadat pro knihovnu DLL {0} zkompilovanou v F#. Byla knihovna DLL zkompilovaná ve starší verzi kompilátoru F#? (chyba: {1}).</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Rozhraní nemůžou obsahovat definice přepsání členů.</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Pro tento identifikátor jste zadali víc atributů viditelnosti.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura je abstraktní třída, ale implementace ne. Zvažte možnost přidat k implementaci atribut [&lt;AbstractClass&gt;].</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Poskytnutý typ {0} má člena {1} s deklarujícím typem {2}. Očekává se, že deklarující typ bude stejný jako poskytnutý typ.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Nespárované klíčové slovo class, interface nebo struct</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Slouží k přidružení názvu ke skupině souvisejících typů a modulů a jeho logickému oddělení od jiného kódu.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>Není definovaný obor názvů nebo modul {0}.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Tento případ typu union přebírá jeden argument.</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Neočekávaný prázdný seznam typu moduleDefn</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Používá se pro logické podmínky (klauzule when) u porovnávání vzorů a k uvození klauzule omezení parametru obecného typu.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Používá se společně s klíčovým slovem match ve výrazech porovnávání vzorů. Ve výrazech objektů, výrazech kopírování záznamů a rozšířeních typů slouží také k uvození definice člena a obslužných rutin výjimek.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Označuje prázdný typ .NET. Používá se při vzájemné spolupráci s jinými jazyky .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Používá se podmíněných výrazech. Slouží rovněž k provedení vedlejších efektů po konstrukci objektu.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Slouží k deklaraci třídy, záznamu, struktury, rozlišeného sjednocení, výčtového typu, měrné jednotky nebo zkratky typu.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Slouží ke zpřístupnění obsahu oboru názvů nebo modulu bez kvalifikace.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Označuje absenci objektu. Používá se také v omezeních obecných parametrů.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Převede daný typ na typ, který je výše v hierarchii.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Používá se jako název objektu základní třídy.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Slouží k určení výpočtu, který se má provést jen v případě, kdy je zapotřebí výsledek.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Používá se v podmíněném větvení.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Používá se v podmíněném větvení. Krátká forma výrazu else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>V podrobné syntaxi označuje konec bloku kódu ve výrazu cyklu.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Sestavení {1} vyžaduje odkaz na knihovnu DLL {0}. Importovaný typ {2} se nachází v prvním sestavení a nedal se přeložit.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 32bitové číslo s plovoucí desetinnou čárkou.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Definice typu může mít jenom jednu specifikaci inherit a ta musí být první deklarací.</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Hodnota literálu nemůže mít obecné parametry.</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Neočekávaný operátor citace &lt;@ v definici typu. Pokud chcete zprostředkovateli typu předávat doslovný řetězec jako statický argument, vložte mezi znaky &lt; a @ mezeru.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Operátor {0} se nedoporučuje předefinovávat. Pokud chcete definovat přetíženou sémantiku porovnání pro určitý typ, implementujte rozhraní System.IComparable v definici tohoto typu.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Metody s curryfikovanými argumenty nemůžou deklarovat argumenty out, ParamArray, optional, ReflectedDefiniton, byref, CallerLineNumber, CallerMemberName a CallerFilePath.</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>Možnost --pdb vyžaduje použití možnosti --debug.</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>Hodnota {0} má označení inline, ale není svázaná s prostředím optimalizace.</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>Vlastnost {0} je statická.</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} se nedá strukturálně porovnávat, protože parametr typu {1} nevyhovuje omezení comparison. Zvažte možnost přidat k typu {2} atribut NoComparisonto: tak bude jasné, že se typ nedá porovnávat.</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} se nedá strukturálně porovnávat, protože typ {1} nevyhovuje omezení comparison. Zvažte možnost přidat k typu {2} atribut NoComparisonto: tak bude jasné, že se typ nedá porovnávat.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace definuje strukturu, zatímco signatura typ se skrytou reprezentací.</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Poznámka: Optimalizace rozšiřující výraz lambda se kvůli použití této lokálně omezené obecné funkce jako hodnoty první třídy nepoužily. Tuto podmínku můžete ošetřit přidáním omezení typu.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>Použití notace let! x = coll ve výrazech pořadí není povolené. Použijte místo ní notaci for x in coll.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory mutable.</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>Název souboru MDB musí být &lt;název-souboru-sestavení&gt;.mdb. Možnost --pdb se bude ignorovat.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nZkompilovaná reprezentace této metody je statickým členem, ale signatura určuje její zkompilovanou reprezentaci jako člena instance.</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Atribut DllImport se nedal dekódovat.</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Klíčové slovo base je použité neplatným způsobem. Volání base se u ukončení použít nedají. K volání base se dá použít privátní člen.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>U new se musí použít pojmenovaný typ.</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Tato zkratka typu má aspoň jeden parametr deklarovaného typu, který se u zkracovaného typu nevyskytuje. Při zkracování typů se musí použít všechny parametry deklarovaného typu. Zvažte možnost odebrání jednoho nebo víc parametrů typu, nebo použijte konkrétní definici typu, která zabaluje nadřízený typ, třeba type C&lt;'a&gt; = C f ...</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Název souboru odpovědi {0} je prázdný, obsahuje neplatné znaky, má jednotku zadanou bez absolutní cesty nebo je moc dlouhý.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože dostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Nenašla se žádná abstraktní vlastnost, která by odpovídala tomuto přepsání.</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Chyba při analýze vloženého kódu IL</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Provizorní kódy DLLImport nemůžou být vložené.</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Neplatný vzor</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Tady se vyžaduje jednoduchý název metody.</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Definice member val jsou povolené jenom u typů s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>Příznak {0} je nastavený dvakrát.</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Citace nemůžou obsahovat objektové výrazy.</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Hodnota s označením inline má neočekávanou hodnotu.</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>Výrazy match se nedají v dotazech použít.</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>Vlastnost {0} má stejný název jako jiná vlastnost v typu {1}, ale jedna z nich přebírá argumenty indexeru a druhá ne. Je možné, že u jedné z vlastností chybí argument indexeru.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Identifikátory, po kterých následuje {0}, jsou vyhrazené pro budoucí použití.</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Explicitní parametry typu se dají použít jenom u vazeb modulu nebo člena.</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>Vlastnost {0} u poskytnutého typu {1} má CanWrite s hodnotou false, ale metoda GetSetMethod() vrátila metodu.</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Generovat ladicí informace v uvozovkách</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Nezahrnovat výchozí manifest Win32</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>aktivní rozlišovač</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Atribut CompiledName se nedá u tohoto elementu jazyka použít.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Slouží k deklaraci proměnné, což je hodnota, která se může měnit.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Signatura pro soubor nebo modul {0} už je zadaná.</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které nastavují pole případů typu union.</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Tato definice typu zahrnuje okamžitý cyklický odkaz zprostředkovaný zkratkou.</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Neplatná hodnota {0} pro --targetprofile. Platné hodnoty jsou mscorlib, netcore nebo netstandard.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>U primárních konstruktorů nejsou vazby use povolené.</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Struktury můžou u deklarací členů vázat jenom parametr this.</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Všem polím výčtového typu se musí předat hodnota.</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>U objektových výrazů se nepovolují definice member val ani override val.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože signatura skrývá zkratku výjimky. Zkratka musí být viditelná pro ostatní jazyky CLI. Zvažte zviditelnění zkratky v signatuře. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Používá se společně s try k uvození bloku kódu, který se provede bez ohledu na to, jestli dojde k výjimce.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>V kódu F# se nedají zadat vlastní marshallery. Zvažte použití pomocné funkce v C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Žádná implementace {0} nemá správný počet argumentů a parametrů typu. Požadovaná signatura je {1}.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Přepsání metod a implementace rozhraní tady nejsou povolené.</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Atribut FieldOffset se nedal dekódovat.</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Podpisový soubor {0} nemá odpovídající implementační soubor. Pokud implementační soubor existuje, zkontrolujte, jestli se deklarace module a namespace v podpisovém a implementačním souboru shodují.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Operátor {0} se nedá předefinovat. Zvažte možnost použití jiného názvu operátoru.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura má zkratku, ale implementace ne.</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Není definovaný parametr typu {0}.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Slouží k určení základní třídy nebo základního rozhraní.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Je možné, že máte nesprávné odsazení: tento token leží mimo odsazení kontextu, který začíná na pozici {0}. Zkuste tento token odsadit víc nebo použijte standardní konvence formátování.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se zobrazované názvy.</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Tento literálový výraz nebo argument atributu má za následek přetečení aritmetické operace.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Nepovinné argumenty se u vlastních atributů použít nedají.</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Staticky propojit zadané sestavení a všechny odkazované knihovny DLL, které jsou na tomto sestavení závislé. Použít název sestavení, třeba mylib, ne název knihovny DLL</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Konec souboru začal v doslovném řetězci vloženém do komentáře na této pozici nebo před ní.</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nHodnoty nebo atributy literálové konstanty se liší.</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Toto kódování Unicode je platné jenom u řetězcových literálů.</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>{0} se dá použít jenom u volitelných argumentů.</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Tato operace zahrnuje převzetí adresy hodnoty {0} vyjádřené pomocí lokální proměnné nebo jiného speciálního způsobu vyjádření. Tato akce je neplatná.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Neodkazovat ve výchozím nastavení na výchozí sestavení CLI</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>U souboru FSharp.Core se nenašel soubor {0}. Soubor se očekával v {1}. Zvažte upgrade na novější verzi souboru FSharp.Core, kde se tento soubor už nevyžaduje.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura uvádí, že tento typ může jako reprezentaci používat null, ale implementace to neuvádí.</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Konec souboru začal v komentáři na této pozici nebo před ní.</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} nemá žádný argument nebo nastavitelnou návratovou vlastnost {1}. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Nepodporovaný typ konstanty {0}. Citace poskytované zprostředkovateli typu můžou obsahovat jenom jednoduché konstanty. Implementaci zprostředkovatele typu možná bude potřeba upravit přesunutím hodnoty deklarované mimo poskytnutý literál citace do vazby let v literálu citace.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Částečné aktivní vzory můžou generovat jenom jeden výsledek.</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Typ {0} není z tohoto místa v kódu dostupný.</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Tento výraz seznamu překračuje maximální velikost literálů seznamu. Použijte pole pro rozsáhlejší literály a volejte metodu Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typ implementace je zapečetěný, ale signatura uvádí, že není. Zvažte možnost přidat k signatuře atribut [&lt;Sealed&gt;].</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>Pojmenovaný argument {0} neodpovídá žádnému argumentu nebo měnitelné vlastnosti.</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Neplatné omezení: Typ použitý pro toto omezení je zapečetěný. Znamená to, že tomuto omezení může vyhovovat maximálně jedno řešení.</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Neočekávaný znak {0}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože signatura skrývá mapování výjimky CLI. Mapování výjimky musí být viditelné pro ostatní moduly. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Atributy u zkratky modulu se ignorují.</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Očekával se typ, ne měrná jednotka.</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Typ {0} má explicitní implementaci rozhraní System.IComparable, ale neposkytuje žádné odpovídající přepsání Object.Equals. Implementace Object.Equals se poskytla automaticky prostřednictvím rozhraní System.IComparable. Zvažte možnost implementovat přepsání Object.Equals explicitně.</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Sestavení {0} požadované souborem {1} se nedalo přeložit.</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Neplatná mutace konstantního výrazu. Zvažte možnost zkopírovat výraz do lokální proměnné, třeba let mutable x = ...</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Oznamovat konkrétní upozornění jako chyby</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>Převod z {0} na {1} je přetypování nahoru bezpečné v době kompilace, ne přetypování dolů. Zvažte použití parametru upcast namísto downcast.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>Identifikátor {0} je vyhrazený pro budoucí použití v jazyce F#.</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Soubory v knihovnách nebo aplikacích s víc soubory musí začínat deklarací oboru názvů nebo modulu, třeba namespace SomeNamespace.SubNamespace nebo module SomeNamespace.SomeModule. Tato deklarace se dá vynechat jenom u posledního zdrojového souboru aplikace.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Vazba nemůže mít současně označení use i rec.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Neočekávaný konec vstupu v argumentech typu</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je virtuální a druhá ne.</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Tato notace indexeru se už v jazyce F# nepoužívá.</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Typ {0} se používá neplatným způsobem. Hodnota před pozicí {1} má odvozený typ zahrnující {2}: to je neplatný dopředný odkaz.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Duplicitní metoda. Metoda {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako jiná metoda v typu {1}.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Vnitřní chyba nebo chybně vytvořená metadata: při importu byl v rozsahu nedostatečný počet parametrů typu.</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Nesprávný počet argumentů typu pro místní volání</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>Syntaxe module ... : sig .. end se v kódu F# nepoužívá. Zvažte použití syntaxe module ... = begin .. end.</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Očekával se typ rozhraní.</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>({0}) není vhodný název pro člena, protože se mu v knihovně F# prostřednictvím pevných typů předává standardní definice.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Neočekávaný konec vstupu v definici typu</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Neplatná hodnota parametru měrné jednotky {0}</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Neplatná hodnota {0} pro parametr měrné jednotky {1}</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Neplatná notace pro metodu getter vlastnosti. Při použití explicitní syntaxe se vyžaduje aspoň jeden argument ().</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Při nastavení poskytnutého typu se vyskytla nejmíň jedna chyba.</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Výrazy konstruktorů pro rozhraní nepřebírají argumenty.</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Neplatná úroveň pro upozornění {0}</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Případ typu union s názvem {0} koliduje s generovaným typem {1}.</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Člen {0} neodpovídá žádné abstraktní ani virtuální metodě, která by se dala přepsat nebo implementovat.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Neplatná konstrukce záznamu</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se typy polí.</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Popisek {0} se nenašel.</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Typ výsledku aktivního vzoru {0} obsahuje proměnné typu, které nejsou určené vstupem. Příčinou je obvykle chybějící zmínka o rozlišení velkých a malých písmen výsledku, třeba výraz let (|A|B|) (x:int) = A x. Dá se to opravit omezením typu, třeba použitím výrazu let (|A|B|) (x:int) : Choice&lt;int,jednotka&gt; = A x.</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Počet argumentů, které konstruktor členu nebo objektu {0} vyžaduje, je {1}, ale počet těch, které se mu tady předávají, je {2} (nepojmenované) a {3} (pojmenované). Požadovaná signatura je {4}.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Typ nebo modul {0} není konkrétním modulem nebo typem.</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- VÝSTUPNÍ SOUBORY -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Dostupná přetížení jsou uvedená níže (nebo v okně Seznam chyb).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>{0} se používá s nesprávným počtem argumentů. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu. Očekávaný počet argumentů je {1}, ale počet předávaných je {2}.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} není metoda instance.</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Tato notace objektového výrazu se v F# nepoužívá. K definování implementací členů v objektových výrazech použijte member this.MemberName ... = ...</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Neočekávaný výraz v místě rekurzivního odvození</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžadovala abstraktního člena {2}, který ale v implementaci zadaný nebyl.</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>Metodě nebo funkci {0} by se neměly předávat argumenty explicitního typu, protože svoje parametry typu nedeklaruje explicitně.</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Typ {0} má reprezentaci vloženého kódu sestavení.</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Rekurzivní hodnoty se nedají přímo přiřadit k neproměnlivému poli {0} typu {1} v rekurzivní vazbě. Zvažte možnost použít místo toho proměnlivé pole.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Ignoruje upozornění na kompatibilitu s ML.</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Člen operátoru vpony {0} nemá žádné argumenty. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Rozhraní nemůžou obsahovat definice konkrétních členů. Možná bude potřeba definovat u typu konstruktor, který bude vyjadřovat, že jde o třídu.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Za tečkou chybí kvalifikace.</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Instance obecného typu {0} chybí a nedá se ani odvodit od argumentů nebo návratového typu tohoto člena. Zvažte vytvoření instance typu při přístupu k tomuto typu, třeba {1}.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Identifikátory velikosti písmen aktivního vzoru musí začínat velkým písmenem.</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>U tohoto specifikátoru formátu není nutné používat h nebo H. Místo toho můžete použít %d, %x, %o nebo %u. Tyto specifikátory formátu se přetěžují, aby fungovaly se všemi základními celočíselnými typy.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>Notace expr then expr se dá ve výrazu použít jenom v rámci explicitního konstruktoru objektu.</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Hodnoty base se dají použít jenom k přímému volání implementací base přepsaných členů.</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Toto není platný konstantní výraz nebo hodnota vlastního atributu.</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Tato rekurzivní vazba používá neplatnou kombinaci rekurzivních tvarů.</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IComparable&lt;_&gt;. Pro tento typ musíte použít atribut CustomComparison a vytvořit konzistentní implementaci rozhraní System.IComparable, které není obecné.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Neplatné přiřazení</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Konec souboru začal v řetězci na této pozici nebo před ní.</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Typ funkce první třídy nemůže obsahovat parametry typu ByRef.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení equality, protože je to typ funkce.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení equality, protože je to záznam, sjednocení nebo struktura aspoň s jedním strukturálním typem prvků, který nepodporuje omezení equality. Buď se u tohoto typu vyhněte použití equality, nebo k němu přidejte atribut StructuralEquality a s jeho pomocí určete, který typ pole nepodporuje equality.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Typ {0} nepodporuje omezení equality, protože má atribut NoEquality.</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo use!.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Použití syntaxe typu int C nebo C  &lt;int&gt; tady není povolené. Zvažte zapsání tohoto typu v podobě C&lt;int&gt;.</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Příznak předpony (mezera nebo znaménko plus) je nastavený dvakrát.</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Nalezené klíčem registru AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Tento konstruktor se dá použít jenom ve výrazech pořadí nebo výpočtu.</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Chyba při analýze vloženého typu IL</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Hodnotě literálu se nedá předávat atribut [&lt;ThreadStatic&gt;] nebo [&lt;ContextStatic&gt;].</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>Základní atribut TypeProviderAssembly sestavení {0} má neplatnou hodnotu {1}. Hodnotou by měl být platný název sestavení.</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Tato hodnota funkce se používá k vytvoření typu delegáta, jehož signatura obsahuje argument ByRef. Musíte použít explicitní výraz lambda, který přebírá argumenty v počtu {0}.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Zkratky pro výjimky Common IL nemůžou přebírat argumenty.</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Typ {0} není platným výčtovým typem, to znamená, že u něj chybí metoda MoveNext(), která by vracela logickou hodnotu, a vlastnost Current.</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Konec souboru začal v direktivě na této pozici nebo před ní.</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>Formát {0} nepodporuje přesnost.</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Konstruktory pro typ {0} musí přímo nebo nepřímo volat svoje implicitní konstruktory objektu. Místo výrazu záznamu použijte volání implicitního konstruktoru objektu.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>{0} se nepoužívá správně. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Nespárovaná dvojice znaků [&lt;. Očekávala se dvojice znaků &gt;].</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Neplatné použití fixed. fixed se dá použít jenom v deklaraci ve tvaru use x = fixed expr, kde výraz je pole, adresa pole nebo adresa prvku pole nebo řetězce.</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Znak {0} není v názvu poskytnutého typu {1} povolený.</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Statický parametr {0} poskytnutého typu nebo metody {1} vyžaduje hodnotu. Statické parametry pro zprostředkovatele typů je případně možné zadat pomocí pojmenovaných argumentů, třeba {2}&lt;{3}=...&gt;.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Neočekávalo se SynMeasure.Anon.</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>Metoda assert se nedá použít jako hodnota první třídy. Použijte místo ní assert &lt;výraz&gt;.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Z typu proměnné se nedá dědit.</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Případy typu union nebo pole typu {0} nejsou z tohoto místa v kódu dostupné.</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Zápis proměnlivých hodnot funkcí by měl být let mutable f = (fun args -&gt; ...).</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Argumenty hodnoty můžou přebírat jenom typy třídy.</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Neplatné číslo upozornění {0}</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Typ {0} má nestandardní typ delegáta.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Člen {0} nepřijímá správný počet argumentů. Očekávaný počet argumentů je {1}, ale předalo se jich {2}. Požadovaná signatura je {3}.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>proměnná vzoru</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna z nich je finální a druhá ne.</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Delegáti nemůžou mít curryfikované signatury.</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Omezuje platformy, na kterých je možné tento kód spustit: x86, Itanium, x64, anycpu32bitpreferred a anycpu. Výchozí je anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Očekávala se měrná jednotka, ne typ.</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Určuje soubor prostředků Win32 (.res).</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Vazby lokální třídy nemůžou mít označení inline. Zvažte možnost rozšíření definice mimo třídu. V opačném případě neoznačujte jako inline.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(popis není dostupný...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Typ {0} není definovaný v {1}.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Očekával se identifikátor.</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Neočekávaný token {0} ve výrazu preprocesoru</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Za tečkou chybí určení přesnosti.</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Citace nemůže zahrnovat přiřazení k adrese zachycené lokální proměnné nebo její přebírání.</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>Možnost příkazového řádku {0} je určená jenom pro testovací účely.</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Zvažte použití parametru yield! namísto yield.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Zděděný typ není typem objektového modelu.</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Hlavní modul programu je prázdný: při jeho spuštění se nic nestane.</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Zadaná verze {0} je {1}, ale tato hodnota představuje zástupný znak a vy jste požádali o deterministické sestavení, což je v konfliktu.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Předávat kompilátoru soubor .resx ({0}) jako zdrojový soubor je zastaralý postup. Pomocí souboru resgen.exe převeďte soubor .resx na soubor .resources, aby se předával jako možnost --resource. Pokud používáte MSBuild, dá se to udělat prostřednictvím položky &lt;EmbeddedResource&gt; v souboru projektu .fsproj.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Cesta {0} je obor názvů. Zkratka modulu nemůže zkracovat obor názvů.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Deklaraci se může v signatuře předávat hodnota jenom v případě, že má deklarace atribut [&lt;Literal&gt;].</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Při přístupu k {0} poskytnutého typu došlo k výjimce: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Umožňuje určit, že je člen viditelný uvnitř sestavení, ale ne mimo toto sestavení.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Pro direktivu #if nebo #else se nenašla žádná direktiva #endif.</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Zjistila se neplatná signatura člena kvůli dřívější chybě.</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Pojmenované pole {0} koliduje s automaticky generovaným názvem anonymního pole.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Neplatná direktiva. Očekávaná direktiva je #time, #time \"on\" nebo #time \"off\".</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou na této pozici pro typy výčtu povolené.</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Tady atributy nejsou povolené.</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- JAZYK -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Nerozpoznaný typ ladění {0}. Očekávané typy jsou pdbonly nebo full.</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>Za použitím into musí následovat zbytek výpočtu.</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Použití funkce reraise jako výrazu první třídy není povolené.</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Nespárovaná levá závorka &lt;. Očekává se pravá závorka &gt;.</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval hodnotu {2}.</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Obecné funkci {0} se musí předávat explicitní argumenty typu.</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>Vlastnost {0} u poskytnutého typu {1} má CanRead s hodnotou true, ale metoda GetGetMethod() nevrátila žádnou hodnotu.</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Návratový typ metody by obsahoval parametry ByRef a to není povolené.</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>Událost {0} je statická.</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Tento token je vyhrazený pro budoucí použití.</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>Ve skupině rekurzivních deklarací musí být deklarace open v každém modulu první.</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Poskytnutý typ {0} vrátil člena, jehož název je prázdný nebo null.</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Špatný specifikátor formátu (po l nebo L): Očekávaný specifikátor je ld, li, lo, lu, lx nebo lX. V kódu F# můžete místo toho použít %d, %x, %o nebo %u: tyto specifikátory formátu jsou přetěžované, takže fungují se všemi základními celočíselnými typy.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Neplatná hodnota poskytnutého literálu {0}</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Typy rozhraní nemůžou být zapečetěné.</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Literál malými písmeny {0} je zastíněný novým vzorem se stejným názvem. Jako pojmenované vzory se dají používat literály velkými písmeny, kterým předchází modul.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Nedefinovaná hodnota {0}</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Tento konstruktor se dá použít jenom ve výrazech seznamů, polí a pořadí, třeba ve výrazech s formulací seq {{ ... }}, [ ... ] nebo [| ... |]. Tyto výrazy používají syntaxi for ... in ... do ... yield... ke generování elementů.</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Vlastní atribut musí být odkazového typu.</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Použili jste statické pole tam, kde se očekává pole instance.</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Nespárovaná závorka (</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Unikátní přetížení u metody {0} se nedalo určit podle informací o typu před tímto místem v programu. Možná bude potřeba doplnit k typu poznámku.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} není {1}.</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Generuje ladicí informace (krátký tvar: -g).</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>Možnost --keyfile přepisuje atribut System.Reflection.AssemblyKeyFileAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Další možnosti najdete v souboru odpovědi.</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Nespárovaná dvojice závorek {{</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Nespárované klíčové slovo begin</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Tato definice let se v dotazu použít nedá. V dotazech je možné použít jenom definice jednoduchých hodnot.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Volá se chráněný člen nebo se používá base. To je povolené jenom u přímé implementace členů, protože by se tak mohly dostat mimo definiční obor objektu.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Argumenty typu je potřeba zadat bezprostředně za název typu, třeba \"C&lt;'T&gt;\", ne \"C  &lt;'T&gt;\".</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Parametry typu je potřeba zadat bezprostředně za název typu, třeba \"type C&lt;'T&gt;\", ne     type \"C   &lt;'T&gt;\".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Nepovedlo se vyřešit nejednoznačnost vyplývající z použití formátovacího řetězce ve stylu printf.</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Chyba ve vráceném výrazu pro tuto klauzuli let. Důvodem může být nesprávné odsazení.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Nepovedlo se přeložit implicitní vytvoření instance obecného konstruktoru na této pozici nebo blízko ní, protože by se dala přeložit na víc nesouvisejících typů, třeba {0} a {1}. Tuto nejednoznačnost můžete vyřešit pomocí poznámek typu.</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Nepovinné argumenty musí být uvedené na konci seznamu argumentů, tj. až po všech povinných argumentech.</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Proběhl pokus o analýzu jako názvu operátoru, ale tento pokus selhal.</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Odkazovat na sestavení (krátký tvar: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Nalezené klíčem registru AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>Vyžaduje se metoda get, set nebo get,set.</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>{0} není platný argument s plovoucí desetinnou čárkou.</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Možnost příkazového řádku {0} je zastaralá. Použijte místo ní {1}.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Typ s atributem CustomEquality musí mít explicitní implementaci aspoň jednoho z následujících: Object.Equals(obj), System.IEquatable&lt;_&gt;, nebo System.Collections.IStructuralEquatable.</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Neočekávalo se {0} ve výrazu typu.</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Nerozpoznaný cíl atributu. Platné cíle atributu jsou assembly, module, type, method, property, return, param, field, event a constructor.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Chybí tělo funkce.</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Modifikátory dostupnosti tady nejsou povolené, ale předal se modifikátor {0}.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Typy nemůžou obsahovat definice vnořených typů.</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Barevně rozlišená upozornění výstupu a chybové zprávy</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Neplatné použití názvu typu</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Tato hodnota nemá platný typ metody set vlastnosti.</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Adresář hledání {0} není platný.</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Propojí zadaný prostředek s tímto sestavením, kde formát resinfo je &lt;soubor&gt;[,&lt;název řetězce&gt;[,public|private]].</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Jmenovatel nesmí být 0 v exponentu měrné jednotky.</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Deklarace inherit se nedá použít u typů rozhraní. Zvažte místo toho možnost implementovat rozhraní pomocí interface ... with ... end.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Neočekávaný celočíselný literál ve výrazu měrné jednotky</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>{0} se dá použít jenom u pojmenovaných typů.</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Počet argumentů, které přebírá konstruktor členu nebo objektu {0}, je {1}, ale počet těch, které se mu tady předávají, je {2}. Požadovaná signatura je {3}.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>Výchozí rozšíření případu typu union</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Tato hodnota není funkcí a nedá se použít.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Chybí specifikátor formátu.</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Vlastnosti indexeru se musí předávat aspoň jeden argument.</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Nerozpoznaný cíl {0}. Očekávané jsou exe, winexe, library nebo module.</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>Ve výrazu while chybí do. Očekávaná notace je while &lt;výraz&gt; do &lt;výraz&gt;.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Neočekávaný konec vstupu v těle výrazu lambda. Očekávaná notace je fun &lt;cesta&gt; ... &lt;cesta&gt; -&gt; &lt;výraz&gt;.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Soubor dokumentace nemá příponu .xml.</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>Použití -&gt; ve výrazech pořadí a výpočtu je omezené na formu for pat in expr -&gt; expr. Ke generování prvků v komplexnějších výrazech pořadí použijte syntaxi for ... in ... do ... yield...</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Očekává se, že vlastnost getter bude funkcí, třeba get() = ... nebo get(index) = ...</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Neshoda v citaci, která začíná na {0}</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 64bitová celá čísla bez znaménka.</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} {1} – nenašlo se v typu {2} ze sestavení {3}. Možnou příčinou může být nekompatibilita verzí. Možná budete muset vytvořit explicitní odkaz na správnou verzi tohoto sestavení, abyste zajistili, že ji budou používat všechny odkazované součásti.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nObecné parametry v signatuře a implementaci jsou různých druhů. Je možné, že chybí atribut [&lt;Measure&gt;].</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Tento typ se pro pole literálu použít nedá.</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Zapnout nebo vypnout volání funkce Tail</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Výrazy záznamu zkopírování a aktualizace musí zahrnovat aspoň jedno pole.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Konec souboru začal v řetězci vloženém do komentáře na této pozici nebo před ní.</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Vyžaduje se operace vlastního dotazu pro {0}, která ale není zadaná.</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Neplatný literál v typu</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Člen {0} odpovídá více přetížením stejné metody.\nOmezte ho prosím na jedno z následujících: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Pokud je typ sjednocení struktura a obsahuje více než jeden případ, všem polím v tomto typu sjednocení se musí přiřadit jedinečný název.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>Vlastnost {0} u poskytnutého typu {1} není ani čitelná ani zapisovatelná, protože má CanRead s hodnotou false a CanWrite s hodnotou false.</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>generovaná vlastnost</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Statická pole val v typech musí být měnitelná, privátní a označená atributem [&lt;DefaultValue&gt;]. Inicializují se na hodnotu null nebo zero podle jejich typu. Zvažte možnost použít v typu třídy taky vazbu static let mutable.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Tato metoda očekává na této pozici parametr CLI params. Použití parametru params umožňuje předat proměnlivý počet argumentů metodě v jazycích, jako je C#. Zvažte možnost předat tomuto argumentu pole.</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Neinicializovaná pole val musí být měnitelná a musí být označená atributem [&lt;DefaultValue&gt;]. Zvažte možnost použít místo pole val vazbu let.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Vlastnost IsGenericType poskytnutého typu {0} má hodnotu true. Obecné typy se ale nepodporují.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. Všechna práva vyhrazena.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které u polí nastavují výjimečné hodnoty.</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Tento literál bajtového pole obsahuje znaky, které se nekódují jako jednobajtové.</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Správné umístění atributů je před val.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace definuje {2} {3}, ale signatura ne (anebo ano, ale ne ve stejném pořadí).</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Anonymní měrná jednotka se nedá vnořit do jiného výrazu měrné jednotky.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>Signatura a implementace nejsou kompatibilní, protože deklarace parametru typu {0} vyžaduje omezení v podobě {1}.</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>typ nebo modul</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Vnořené poskytnuté typy nepřebírají statické argumenty ani obecné parametry.</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Tato deklarace otevírá modul {0}, který má označení RequireQualifiedAccess. Upravte kód tak, aby místo toho používal kvalifikované odkazy na elementy modulu, třeba místo map použijte List.map. Touto změnou zajistíte, že bude kód funkční i v případě, že se budou do knihoven přidávat nové konstruktory.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Tento element deklarace není u rozšíření povolený.</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Konstruktor objektu {0} přebírá tento počet argumentů: {1}. Tady ale získal jen tento počet: {2}. Vyžadovaná signatura: {3}.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Tento nový člen skrývá abstraktní člen {0}. Změňte jeho název nebo místo toho použijte klíčové slovo override.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Druh typu určeného jeho atributy se neshoduje s druhem odvozeným jeho definicí.</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Při zapisování binárního souboru {0} došlo k potížím: {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Konstanty číselných literálů, které nejsou primitivní, se nedají použít u porovnání vzorů, protože můžou být během použití modulu NumericLiteral mapované na víc různých typů. Zvažte možnost nahrazení proměnnou a na konci klauzule porovnání použijte when &lt;variable&gt; = &lt;constant&gt;.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>Signatura a implementace nejsou kompatibilní, protože parametr typu v třídě nebo signatuře má jiný požadavek za kompilace než parametr u člena nebo implementace.</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Redundantní argumenty se ve funkci {0} ignorují. Očekávalo se tolik argumentů: {1}, ale bylo jich {2}.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Vlastní atribut musí vyvolat konstruktor objektu.</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>Syntaxe expr.id se dá použít jenom u vlastností, polí a popisků záznamů.</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Za touto pozicí se očekával typ.</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Atribut ReferenceEquality se u struktur použít nedá. Zvažte, jestli byste místo něho neměli použít atribut StructuralEquality nebo implementovat přepsání pro System.Object.Equals(obj).</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>Přepsání {0} implementuje víc než jednu abstraktní datovou oblast, třeba {1} a {2}.</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Člen {0} nepřijímá správný počet argumentů. Počet argumentů přijímaných jedním přetížením je {1}, ale předalo se jich {2}. Požadovaná signatura je {3}.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Jako název modulu musíte zadat jednoduchý název, ne cestu.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Pokud chcete tuto vlastnost definovat jako nastavitelnou, použijte syntaxi member val PropertyName = expr with get,set.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Nepovedlo se najít FSharp.Core.dll v adresáři kompilátoru.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože jejich typy mají odlišné základní typy.</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Metodě {0} neodpovídají žádná přetížení.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Toto není konstruktor nebo literál, anebo se konstruktor používá nesprávně.</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Atribut Measure se dá předávat jenom typům, které představují měrné jednotky.</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Očekávaly se argumenty člena instance.</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Tento kód je míň obecný, než požadují jeho poznámky, protože proměnná explicitního typu {0} se nedá zobecnit. Kód se omezil na {1}.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Operátor {0} se nedoporučuje předefinovávat. Pokud chcete definovat sémantiku rovnosti pro typ, přepište člena Object.Equals v definici tohoto typu.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Typ s atributem ReferenceEquality nemůže mít explicitní implementaci Object.Equals(obj), System.IEquatable&lt;_&gt; nebo System.Collections.IStructuralEquatable.</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>Příznak atributu UseNullAsTrueValue se dá použít jenom s typy sjednocení, které mají jeden prázdný případ a aspoň jeden neprázdný případ.</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Nespárované klíčové slovo begin nebo struct</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Přiřadí hodnotu k proměnné.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Konec souboru začal v oddílu #if na této pozici nebo za ní.</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Porovnání rozsahu znaků se už v F# nepoužívá. Zvažte možnost použít místo toho ochrannou vazbu vzoru when.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! by se mělo objevit jenom jako první řádek na začátku souboru.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>V rozšířeních výjimky nejde zadávat konstruktory.</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Vlastnost IsArray poskytnutého typu {0} má hodnotu true. Typy polí se ale nepodporují.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Duplicitní vlastnost. Vlastnost {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako jiná vlastnost v typu {1}.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval modul nebo obor názvů {2}.</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Notace deklarace let ... and ... se pro nerekurzivní vazby v kódu F# nepoužívá. Zvažte použití posloupnosti vazeb let.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.GetHashCode nebo Object.Equals. U tohoto typu musíte použít atribut CustomEquality.</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Neplatné použití konstruktoru delegáta. Použijte syntaxi new Type(args) nebo jenom Type(args).</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>Signatura a implementace nejsou kompatibilní, protože parametr typu {0} má omezení v podobě {1}, ale implementace ne. Buď toto omezení odeberte ze signatury, nebo ho přidejte do implementace.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Odkazované sestavení {0} má atribut {1} na úrovní sestavení, ale nenašly se žádné třídy veřejného zprostředkovatele typu.</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Oznamovat všechna upozornění jako chyby</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>Výraz tabulátoru není v kódu F# povolený, pokud se nepoužije možnost #indent \"off\".</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Neplatný statický argument poskytnutého typu. Očekávaný druh argumentu je {0}.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Označení inline se u proměnlivých hodnot použít nedá.</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Víc než jedno přepsání implementuje {0}.</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Instance tohoto typu se nedají vytvořit, a to buď proto, že je tento typ označený jako abstraktní, nebo proto, že jste neimplementovali všechny metody. Zvažte možnost použít místo toho objektový výraz {{ new ... with ... }}.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>Ve skupině rekurzivních deklarací se musí zkratky modulu nacházet za deklaracemi open a před ostatními deklaracemi.</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Používá se jako kratší alternativa klíčového slova fun a jako porovnávací výraz ve výrazu lambda s porovnáváním vzoru u jednoho argumentu.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se zkompilovanými názvy.</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Toto není platný výraz konstruktoru objektu. Explicitní konstruktor objektu musí buď volat alternativní konstruktor, nebo inicializovat všechna pole objektu a specifikovat volání konstruktoru nadřazené třídy.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Nerozpoznaná platforma {0}. Platné hodnoty jsou x86, x64, Itanium, anycpu32bitpreferred a anycpu.</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>U typů rozhraní se new použít nedá. Zvažte možnost použít místo toho objektový výraz {{ new ... with ... }}.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá zkratku. Zkratka musí být viditelná pro ostatní jazyky CLI. Zvažte zviditelnění zkratky v signatuře.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Neplatná notace pro metodu set vlastnosti. Vyžaduje se aspoň jeden argument.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>Výrazy let!, use! a do! se v dotazech použít nedají.</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Konec souboru začal v doslovném řetězci na této pozici nebo před ní.</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Toto pole je jen pro čtení.</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Atribut StructLayout se nedal dekódovat.</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Typ {0} není delegátem CLI.</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Tento výraz není funkcí a nedá se použít. Nechtěli jste indexer použít spíše pomocí expr.[index]?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Nahradit návrhem: {0}</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Pole struktury nebo třídy {0} není na tomto místě v kódu dostupné.</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Používá se ve výrazu výpočtu k připojení výsledku daného výpočetního výrazu ke kolekci výsledků obsahujícího výrazu výpočtu.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Neplatný výraz {0}</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>U tohoto parametru typu se nedá vytvořit instance Nullable. Toto omezení má zabránit situaci, ve které by byl význam null v některých jazycích CLI zavádějící v případě, že se použije ve spojení s hodnotami Nullable.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Implementace souboru nebo modulu {0} už je zadaná.</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Zprostředkovatel typu {0} poskytnul konstruktor, který není uvedený mezi konstruktory jeho deklarujícího typu {1}.</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Rozhraní zděděná jinými rozhraními by se měla deklarovat pomocí inherit ... a ne pomocí interface...</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Funkce označená atributem EntryPointAttribute musí být poslední deklarací v posledním souboru v sekvenci kompilace.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Typ záznamu {0} neobsahuje popisek {1}.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Neuzavřený blok</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Tato vlastnost nebo pole se u tohoto typu vlastního atributu nenašla.</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Obor názvů a modul s názvem {0} se oba vyskytují ve dvou částech tohoto sestavení.</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Zadejte profil cílového rozhraní tohoto sestavení. Platné hodnoty jsou mscorlib, netcore nebo netstandard. Výchozí je mscorlib.</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>Od jazyka F# 4.1 se dostupnost zkratek typů kontroluje při kompilaci. Zvažte možnost změnit dostupnost zkratek typů. Pokud budete toto upozornění ignorovat, může to mít za následek chyby za běhu.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>Direktiva #endif musí být uvedená jako první neprázdný znak na řádku.</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Neplatná struktura parametru RSAParameters – očekává se {{0}}</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} nepodporuje strukturální rovnost, protože parametr typu {1} nevyhovuje omezení equality. Zvažte možnost přidat k typu {2} atribut NoEquality: tak bude jasné, že typ nepodporuje strukturální rovnost.</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} nepodporuje strukturální rovnost, protože typ {1} nevyhovuje omezení equality. Zvažte možnost přidat k typu {2} atribut NoEquality: tak bude jasné, že typ nepodporuje strukturální rovnost.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Tento atribut není platný pro použití u tohoto elementu jazyka. Atributy sestavení by měly být připojené k deklaraci do (), v případě potřeby v modulu F#.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Proměnné, které jsou statické na úrovni vlákna nebo kontextu, musí být statické a musí se jim předávat atribut [&lt;DefaultValue&gt;]. Tím se určí, že se hodnota v každém novém vláknu inicializuje na výchozí hodnotu.</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Adresa prvku pole se na tomto místě použít nedá.</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Chyba syntaxe: neočekávaná specifikace parametru typu</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Atribut DefaultAugmentation se nedal dekódovat.</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Typ pole, které používá atribut DefaultValue, musí připouštět výchozí inicializaci, tj. mít null jako správnou hodnotu nebo být typu struktura, jejíž všechna pole připouštějí výchozí inicializaci. Tuto kontrolu můžete vypnout pomocí DefaultValue(false).</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Slouží k implementaci verze abstraktní nebo virtuální metody, která se odlišuje od základní verze.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>U poskytnutého typu {0}, člena {1} došlo k neočekávané výjimce: {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Proměnná typu je omezená více různými typy tříd. Proměnná typu může mít jenom jedno omezení třídy.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Tato zadaná metoda vyžaduje statické parametry.</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Není definovaný konstruktor, modul nebo obor názvů {0}.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Tento typ není na tomto místě v kódu dostupný.</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Atributy tohoto typu určují pro typ víc druhů.</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Tato operace přistupuje k proměnlivé hodnotě na nejvyšší úrovni definované v jiném sestavení nepodporovaným způsobem. K hodnotě se nedá přistupovat prostřednictvím její adresy. Zvažte následující postup: zkopírujte výraz do lokální proměnné, třeba let mutable x = ..., a po dokončení operace přiřaďte v případě potřeby znovu původní hodnotu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu try. Očekávaná notace je try &lt;výraz&gt; with &lt;pravidla&gt; nebo try &lt;výraz&gt; finally &lt;výraz&gt;.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu for. Očekávaná notace je for &lt;vzor&gt; in &lt;výraz&gt; do &lt;výraz&gt;.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší reprezentace.</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Citace nemůžou obsahovat tento druh porovnávání vzorů.</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Neočekávaný konec typu. Za touto pozicí se očekává název.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Zprostředkovatel typu {0} oznámil chybu: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Generování souboru MDB selhalo. Nenašel se kompatibilní člen {0}.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Zkratky typů nemůžou mít deklarace rozhraní.</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>Atribut StructuralEquality je potřeba použít ve spojení s atributem NoComparison nebo StructuralComparison.</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Operátory spojení výrazů je možné použít jenom uvnitř citace.</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>Direktivě #endif neodpovídá žádná direktiva #if.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Tento atribut není platný pro použití u tohoto elementu jazyka.</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Generovat kontroly přetečení</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Volně distribuováno pod licencí Apache 2.0 Open Source License</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} nepřebírá argumenty ({1}). Zjistilo se, že počet argumentů přebíraných přetížením je {2}.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Atribut sestavení {0} odkazuje na navržené sestavení {1}, které se nedá načíst nebo neexistuje. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>U člena {0} poskytnutého typu {1}, člena {2} došlo k neočekávané výjimce: {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Zprostředkovatel typu implementuje metodu GetStaticParametersForMethod, ale metoda ApplyStaticArgumentsForMethod se neimplementovala nebo je neplatná.</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- PROSTŘEDKY -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Kód v tomto sestavení využívá literály citace. Je možné, že při statickém propojování se komponenty využívající literály citace nezahrnou, pokud nejsou všechna sestavení zkompilovaná v F# ve verzi alespoň 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>{0} se musí umístit za klauzuli výběru for a pak musí následovat zbytek dotazu. Syntaxe: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>Možnost --delaysign přepisuje atribut System.Reflection.AssemblyDelaySignAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Přebírání adresy pole literálu je neplatné.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 32bitová celá čísla se znaménkem.</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Nespárovaná dvojice znaků [|</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} není {1}. K soukromým členům se dá přistupovat jenom z deklarujícího typu. K chráněným členům se dá přistupovat jenom z rozšiřujícího typu a nedá se k nim přistupovat z vnitřních výrazů lambda.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Metoda nebo konstruktor objektu {0} nejsou statické.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>Kód v sestavení {0} využívá literály citace. Je možné, že při statickém propojování se komponenty využívající literály citace nezahrnou, pokud nejsou všechna sestavení zkompilovaná v F# ve verzi alespoň 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>{0} není platný název souboru.</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Vytvoří veřejný podpis sestavení jenom s využitím veřejné části klíče silného názvu a označí sestavení jako podepsané.</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 16bitová celá čísla bez znaménka.</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Zprostředkovatel typu {0} vrátil u metody ApplyStaticArguments neplatný typ. Očekával se typ s názvem {1}, ale vrácený typ má název {2}.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Místní proměnná {0} se implicitně přiděluje jako odkazovaná buňka, protože ji zachytilo zavření. Toto upozornění slouží jenom k informativním účelům a ukazuje, kde k implicitním přidělením dochází.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>V kódu F# můžete použít syntaxi expr.[expr]. Je možné, že bude potřeba zadat poznámku typu k určení prvního výrazu v poli.</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Rozhraní nemůžou obsahovat definice konstruktorů objektu.</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Neplatná verze {0} pro --subsystemversion. Správná verze je 4.00 nebo vyšší.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Pojmenované argumenty musí být umístěné až za všemi ostatními argumenty.</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>Proměnná {0} je vázaná v citaci, ale používá se jako součást spojeného výrazu. To není povolené, protože se tak proměnná může dostat mimo definiční obor.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením enum na této pozici nebo blízko ní.</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Žádný adresář podpisu</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Neočekávaný operátor vpony ve výrazu měrné jednotky. Platnými operátory jsou znaky *, / a ^.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>vlastnost</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Zapečetěný typ nejde zdědit.</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Tento konstruktor je jako součást výrazu pořadí nejednoznačný. Vnořené výrazy jde zapsat pomocí notace let _ = (...) a vnořená pořadí pomocí notace yield! seq {{... }}.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IStructuralEquatable. Použijte pro tento typ atribut CustomEquality.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Tento člen není u implementace objektu povolený.</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>Importované sestavení používá typ {0}, který ale není veřejný.</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- RŮZNÉ -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Modul nebo obor názvů {0} z kompilační jednotky {1} neobsahoval obor názvů, modul nebo typ {2}.</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Rezidentní kompilační služba se nepoužila, protože došlo k potížím při komunikaci se serverem.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Deklarace pole nebo hodnoty tady není povolená.</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Omezení new musí přebírat jeden argument typu unit a vracet konstruovaný typ.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Použít rezidentní službu kompilace na pozadí ke zlepšení časů spuštění kompilátoru</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Neplatné omezení</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace uvádí, že tento typ může jako reprezentaci používat null, ale signatura to neuvádí.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Při použití statických argumentů u poskytnuté metody došlo k chybě.</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Vložit zadaný spravovaný prostředek</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Při sestavování výrazu fixed se mezi odkazy nepovedlo najít metodu System.Runtime.CompilerServices.OffsetToStringData.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Vazba členské i lokální třídy má název {0}.</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>Po {0} musí následovat název proměnné. Použití: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Test tohoto typu s poskytnutým typem {0} není povolený, protože tento poskytnutý typ se při běhu vymaže na {1}.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace je abstraktní třída, ale signatura ne. Zvažte možnost přidat k signatuře atribut [&lt;AbstractClass&gt;].</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Neshoda v délce argumentů</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Tato hodnota není funkce a nedá se použít. Nezapomněli jste ukončit deklaraci?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Člen {0} se k implementaci {1} použít nedá. Požadovaná signatura je {2}.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Tento typ implementuje stejné rozhraní u různých obecných instancí {0} a {1}. To není v této verzi F# povolené.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>Možnost --keycontainer přepisuje atribut System.Reflection.AssemblyNameAttribute předaný ve zdrojovém souboru nebo přidaném modulu.</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Požadoval se systémový typ {0}, ale žádná odkazovaná systémová knihovna DLL tento typ neobsahovala.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Slouží k označení výrazu výpočtu, který po vyhodnocení poskytne výsledek obsahujícího výrazu výpočtu.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Člen operátoru vpony {0} má curryfikované argumenty navíc. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Tento člen není v implementaci rozhraní povolený.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Člen operátoru vpony {0} má počáteční argumenty v počtu {1}. Očekávala se řazená kolekce členů se třemi argumenty.</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>Atribut FieldOffset jde použít jenom pro členy typů s deklarací StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Konstruktor nemůže mít parametry explicitního typu. Zvažte možnost použít místo toho metodu statické konstrukce.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>Vlastnost {0} u poskytnutého typu {1} má CanRead s hodnotou false, ale metoda GetGetMethod() vrátila metodu.</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>V dotazech musí {0} použít jednoduchý vzor.</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Const_bytearray se neočekávalo.</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Neočekávaný výraz Expr.TyChoose</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Neočekávaný konec vstupu u členů objektu</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>Metoda {0} má curryfikované argumenty, ale má stejný název jako jiná metoda v typu {1}. Metody s curryfikovanými argumenty se nedají přetěžovat. Zvažte použití metody, která přebírá argumenty s řazenou kolekcí členů.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>Třída {0} definovala verzi {1}, ale tato hodnota není platná a ignoruje se.</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Parametr typu se jako konstruktor typu použít nedá.</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Měnitelné proměnné nemůžou opustit svoji metodu.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Deklarace míry můžou mít jenom statické členy.</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Operátor {0} se nedoporučuje předefinovávat. Zvažte použití jiného názvu operátoru.</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Hodnota typu ByRef {0} se na tomto místě použít nedá.</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Adresář hledání {0} se nedal najít.</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Tento konstruktor je jako součást výrazu výpočtu nejednoznačný. Vnořené výrazy jde zapsat pomocí notace let _ = (...) a vnořené výpočty pomocí notace let! res = builder {{ ... }}.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura definuje {2} {3}, ale implementace ne (anebo ano, ale ne ve stejném pořadí).</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Úplný název</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Výstupní zprávy s plně kvalifikovanou cestou</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože pole {2} se nacházelo v implementaci, ale v signatuře ne.</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Nekopírujte FSharp.Core.dll k vytvářeným binárním souborům.</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Obecný konstruktor vyžaduje, aby byl typ {0} nespravovaným typem.</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.Equals. Zvažte možnost implementace odpovídajícího přepsání pro Object.GetHashCode().</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Explicitní deklarace typu pro konstruktory musí mít formulaci ty1 * ... * tyN -&gt; resTy. Je možné, že výraz resTy bude potřeba uzavřít do závorek.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Slouží k označení toho, že funkce je rekurzivní.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Slouží k označení hodnoty v signatuře nebo v určitých situacích k deklarování člena v daném typu.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Používá se místo výrazu let u hodnot, které k uvolnění prostředků vyžadují volání funkce Dispose.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Slouží k uvození bloku kódu, který může vygenerovat výjimku. Používá se společně s with nebo finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Slouží k deklaraci, definici nebo vyvolání konstruktoru, který vytvoří nebo dokáže vytvořit objekt. V omezeních obecných parametrů označuje, že nějaký typ musí mít určitý konstruktor.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Ve skutečnosti nejde o klíčové slovo. Kombinace not struct se ale používá jako omezení obecného parametru.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Slouží k přidružení (neboli svázání) názvu k hodnotě nebo funkci.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Používá se ve výrazech lambda, známých také pod označením anonymní funkce.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Používá se v konstruktorech cyklů.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Označuje konec sekce definic členů v definicích typů a rozšířeních typů. V podrobné syntaxi se používá k určení konce bloku kódu, který začíná klíčovým slovem begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Metody getter a setter vlastnosti musí být stejného typu. Vlastnost {0} má metodu get typu {1}, ale metodu set typu {2}.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Počet argumentů typu se neshodoval: počet předaných je {0}, ale počet očekávaných je {1}. Může to souviset s dřív hlášenou chybou.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Toto pole vyžaduje název.</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>generovaný typ</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Neplatný řetězec verze {0}</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Argumenty typu tady nejde zadat.</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro nativní celá čísla se znaménkem.</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Test tohoto typu nebo jeho přetypování směrem dolů vymaže poskytnutý typ {0} na typ {1}.</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Deklarace inherit nemůžou mít vazby as. Pro přístup ke členům základní třídy při přepisování metody se dá použít syntaxe base.SomeMember, kde base je klíčové slovo. Tuto vazbu as odeberte.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Slouží k deklaraci delegáta.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Konstruktor metody nebo objektu {0} se nenašel.</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Chybná šířka ve specifikátoru formátu</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Typy s atributem AllowNullLiteral můžou dědit jenom od typů, které umožňují použít taky literál s hodnotou null, nebo tyto typy můžou implementovat.</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Statický inicializátor vyžaduje argument.</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Chyba syntaxe: neočekávaný symbol ?</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Neplatné použití typu rozhraní</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Po sobě jdoucí vzory by měly být oddělené mezerami nebo by měly být řazenou kolekcí členů.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>Požadovaná signatura je {0}.</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>Metoda System.Environment.Exit neprovedla ukončení.</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Podmínky statické optimalizace se používají jenom v knihovně F#.</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Všechny elementy výrazu konstruktoru pole musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Parametr deklarovaného typu {0} se tady použít nedá, protože parametr typu nejde přeložit za kompilace.</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>{0} není platný název sestavení.</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Toto není platný název aktivního vzoru.</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>Ve výrazu if chybí větev else. Větev then je typu {0}. Protože if je výraz a ne příkaz, přidejte větev else, která vrátí hodnotu stejného typu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Neočekávaný konec vstupu v signatuře typu</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Duplicitní metoda. Metoda {0} má stejný název a signaturu jako jiná metoda v typu {1}.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Tato metoda je v parametrech typu příliš omezená.</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Chybějící proměnná {0}</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u typů kódu vložených sestavení povolené.</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Reflektované definice nemůžou obsahovat použití operátoru spojení předpon %.</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Měrné jednotky se nedají použít jako argumenty předpony typu. Přepište je na argumenty přípony v lomených závorkách.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Omezení struct a not struct jsou nekonzistentní.</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>V tomto vzoru literálu se nedají zadat argumenty.</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Neplatná syntaxe deklarace</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Žádný z typů {0} nepodporuje operátor {1}.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Typy delegátů jsou vždycky zapečetěné.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Za touto pozicí se očekává výraz.</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Typ {0} je méně dostupný než hodnota, člen nebo typ {1}, ve kterém se používá.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Vytvoří deterministické sestavení (včetně GUID verze modulu a časového razítka).</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Poskytnutý typ {0}, člen {1} vrátil neočekávanou návratovou hodnotu null.</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>V rozhraní IDisposable se nenašla metoda Dispose nebo je tato metoda přetížená.</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Nerozpoznané nastavení ochrany osobních údajů {0} pro spravovaný prostředek. Platné možnosti jsou public a private.</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Hodnota s označením inline se nedá vložit.</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Obecný konstruktor vyžaduje, aby měl typ {0} veřejný výchozí konstruktor.</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} není člen instance.</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Citace nemůžou obsahovat tento druh konstanty.</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Zprostředkovatel typu {0} použil ve výrazu ParameterExpression neplatný parametr: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Použili jste obecný člen {0} v neuniformní instanci před tímto místem v programu. Zvažte možnost změnit pořadí členů tak, aby se tento uvedl jako první. Případně specifikujte úplný typ člena explicitně, včetně typů argumentů, návratového typu a všech dalších obecných parametrů a omezení.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Typ by uložil hodnotu typu ByRef. To ale Common IL nepovoluje.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Nezadali jste žádné implementační soubory.</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se vloženými příznaky.</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Neplatný název oboru názvů, modulu, typu nebo případu typu union</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Zkratky typů nemůžou mít členy.</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>Klíčové slovo rec je v tomto modulu odvozené od vnější deklarace rec a ignoruje se.</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Tento typ není typem záznamu. Hodnoty typů třída a struktura se musí vytvořit pomocí volání konstruktorů objektu.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Očekává se typ podporující operátor {0}, ale předává se typ funkce. Možná, že u funkce chybí argument.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Obory názvů nemůžou obsahovat hodnoty. K uložení deklarací hodnot můžete použít modul.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Pro typ delegáta se nenašly žádné metody Invoke.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Neúplná podmínka. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Vlastní operace se ve spojení s operátory use, try/with, try/finally, if/then/else nebo match v tomto výrazu výpočtu použít nedají.</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>Atribut StructuralComparison je potřeba použít ve spojení s atributem StructuralEquality.</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Neplatné použití klíčového slova rec</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Výčty nemůžou mít členy.</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>Není definovaný popisek záznamů nebo obor názvů {0}.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Citace nemůžou obsahovat použití obecných výrazů.</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Možnost příkazového řádku {0} je zastaralá.</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Slouží v asynchronních pracovních postupech k vytvoření vazby názvu s výsledkem asynchronního výpočtu. V jiných výrazech výpočtu se používá k vytvoření vazby názvu s výsledkem, který je výpočetního typu.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Počet volání</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>Direktivě #else neodpovídá žádná direktiva #if.</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Používá se k přepsání umístění, kde kompilátor hledá knihovnu mscorlib.dll a komponenty rozhraní.</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Počet argumentů typu, které konstruktor členu nebo objektu {0} přebírá, je {1}, ale počet těch, které se mu tady předávají, je {2}. Požadovaná signatura je {3}.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} {1} – nenašlo se v sestavení {2}. Možnou příčinou může být nekompatibilita verzí. Možná budete muset vytvořit explicitní odkaz na správnou verzi tohoto sestavení, abyste zajistili, že ji budou používat všechny odkazované součásti.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Neplatná syntaxe ve výrazu typu</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro tento celočíselný typ.</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Aktivní vzor {0} není funkce.</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>Metody get a set vlastnosti {0} typu {1} si neodpovídají. Pokud je jedna z nich abstraktní, musí být abstraktní i ta druhá.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>V dotazech použijte notaci for x in n .. m do ..., která zajistí rozsah napříč celočíselnými typy.</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Konec souboru začal v řetězci v trojitých uvozovkách na této pozici nebo před ní.</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Neočekávaný konec vstupu v definici hodnoty, funkce nebo člena</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Konstruktor objektu {0} přebírá tento počet argumentů: {1}. Tady ale získal jen tento počet: {2}. Vyžadovaná signatura: {3}. Pokud je účelem některých argumentů přiřazování hodnot k vlastnostem, zvažte oddělení těchto argumentů čárkou (,).</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>{0} se musí použít pro argument typu {1}, ale použil se pro argument typu {2}.</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Nejde vytvořit rozšíření zapečetěného typu.</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Pro tuto klauzuli let se nenašel žádný odpovídající výraz in.</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Atribut viditelnosti {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vždycky privátní.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Není běžné, aby typ s atributem NoComparison měl explicitní implementaci System.IComparable, System.IComparable&lt;_&gt; nebo System.Collections.IStructuralComparable. Pokud je to záměr s cílem dosáhnout interoperability, pak toto upozornění vypněte.</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Tento konstruktor se dá použít jenom ve výrazech výpočtu. Pokud chcete vracet hodnotu z běžné funkce, napište jednoduše výraz bez return.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Definice vlastností se nedají deklarovat jako měnitelné. Pokud chcete tuto vlastnost definovat jako nastavitelnou, použijte syntaxi member val PropertyName = expr with get,set.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- UPŘESNIT -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory static.</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>Zkompilovaná forma případu typu union</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Došlo k selhání překladu sestavení na této pozici nebo blízko ní.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se signatura a implementace liší pořadím polí.</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Abstraktní členové se v rozšíření nepovolují – musí se definovat v samotném typu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve větvi then podmínky. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu match nebo try</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve větvi else podmínky. Očekávaná notace je if &lt;výraz&gt; then &lt;výraz&gt; nebo if &lt;výraz&gt; then &lt;výraz&gt; else &lt;výraz&gt;.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Při vytváření hodnoty záznamu nejde zadávat argumenty.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Identifikátory obsahující znak @ jsou vyhrazené pro použití při generování kódu F#.</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Toto vyhledávání se tady nedá použít.</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Členové, kteří rozšiřují typy rozhraní, delegáta nebo výčtu, musí být umístěné v modulu odděleně od definice typu. Tento modul musí mít buď atribut AutoOpen, nebo musí být otevřený explicitně klientským kódem, aby se člen rozšíření vložil do oboru.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Implementace rozhraní se s výrazy konstrukcí nedají předávat.</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Tento kód není dostatečně obecný. Proměnná typu {0} se nedá zobecnit, protože by se tak dostala mimo svůj definiční obor.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Konec souboru začal v oddílu IF-OCAML na této pozici nebo před ní.</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Atribut AbstractClass se dá předávat jenom třídám.</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>System.Void se dá v F# použít jenom jako typeof&lt;System.Void&gt;.</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>Syntaxe (typ,...,typ) ident se v kódu F# nepoužívá. Zvažte možnost použít místo ní syntaxi ident&lt;typ,...,typ&gt;.</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Typy struktury nemůžou obsahovat abstraktní členy.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Tento nový člen skrývá po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů abstraktní člen {0}. Změňte jeho název nebo místo toho použijte klíčové slovo override.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Neočekávané dekódování InterfaceDataVersionAttribute</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Tokeny | oddělující pravidla tohoto porovnávacího vzoru nejsou zarovnané o jeden sloupec. Zvažte úpravu zarovnání kódu nebo použití většího odsazení.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nPro tuto hodnotu se neodvodila arita.</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Ve stromu syntaxe se neočekávala specifikace vlastnosti na úrovni zdroje.</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Nadbytečným polím se předaly hodnoty.</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Slouží k převodu na typ, který je na nižší pozici v řetězu dědičnosti.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nPro jeden nebo více argumentů se vyžaduje typ řazené kolekce členů. Zvažte možnost uzavřít dané argumenty do dodatečných závorek nebo zkontrolovat definici rozhraní.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Neočekávaná rozměrná racionální konstanta</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Chybný formát image</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>Našel se prázdný obor názvů od zprostředkovatele typu {0}. Pro globální obor názvů použijte null.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se názvy.</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} proměnná v kolekci {1} (outerKey = innerKey). Poznámka: Za {2} se vyžadují závorky.</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>Očekává se in nebo =.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Neočekávané dekódování InternalsVisibleToAttribute</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Neúplný výraz preprocesoru</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: zpožděné</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Přímý odkaz na generovaný typ {0} není povolený. Místo něj použijte definici typu, třeba type TypeAlias = &lt;cesta&gt;. Ta označuje, že zprostředkovatel typu přidává k sestavení generované typy.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Chyba syntaxe. Chybně vnořená direktiva #endif. Před výrazem it jsou neočekávané tokeny.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Povolit specifická upozornění, která můžou být ve výchozím nastavení vypnutá</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} je aktivní vzorek a není možné s ním zacházet jako s rozlišeným případem typu union s pojmenovanými poli.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Typy záznamu jsou vždycky zapečetěné.</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Neplatná signatura pro člena sady</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>Výraz while se v dotazu použít nedá.</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Toto není platný znakový literál.</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Návratové hodnoty nemůžou mít názvy.</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Nejde dědit z vymazaného poskytnutého typu.</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Poskytovatel {0} vrátil negenerovaný typ {1} v kontextu sady generovaných typů. Zvažte možnost upravit zprostředkovatele typu tak, aby vracel jenom generované typy.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Omezení enum musí mít notaci enum&lt;type&gt;.</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je abstraktní a druhá ne.</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>({0}) není vhodný název pro člena. Pokud chcete definovat sémantiku rovnosti pro typ, přepište člena Object.Equals. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro desítkové literály.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Příliš mnoho statických parametrů. Maximální očekávaný počet parametrů je {0}, ale počet přijatých parametrů je {1} (nepojmenované) a {2} (pojmenované).</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>Po deklaraci namespace nemůže následovat symbol =.</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Typy System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate a System.Array se v objektovém výrazu nebo ve třídě objektu nedají použít jako nadřazené.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Tento soubor obsahuje víc deklarací v podobě module SomeNamespace.SomeModule. V souboru se povoluje jenom jedna deklarace v této podobě. Upravte soubor tak, aby používal počáteční deklaraci oboru názvů, nebo použijte k definování modulů deklaraci v podobě module ModuleName = ...</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Nejde dědit z typu rozhraní. Použijte místo toho výraz interface ... with.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Povoluje nebo zakazuje optimalizaci mezi moduly.</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Používá se ve výrazech dotazu k určení, která pole nebo sloupce se mají extrahovat. Toto klíčové slovo je kontextové, což znamená, že se ve skutečnosti nejedná o rezervované slovo a jako klíčové slovo funguje jen v příslušném kontextu.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>Adresa pole {0} se na tomto místě použít nedá.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením unmanaged na této pozici nebo blízko ní.</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Tato definice typu nemůže mít atribut CLIMutable. Ten můžou mít jenom typy záznamu.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 64bitová celá čísla se znaménkem.</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u polí výčtového typu povolené.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší počet {2}.</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Neplatné rozšíření typu</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Problém s názvem souboru {0}: {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>Pro direktivu #else se vyžaduje direktiva #endif.</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Slouží k deklaraci typu struktury. Používá se také v omezeních obecných parametrů. V definicích modulů se používá kvůli kompatibilitě s OCaml.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Slouží k označení metody nebo vlastnosti, kterou lze volat bez instance typu, nebo člena hodnoty, který se sdílí mezi všemi instancemi typu.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>Atribut EntryPointAttribute se dá použít jenom u definic funkcí v modulech.</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Výchozí hodnota má jiný typ než argument. Atribut DefaultParameterValue a případné volitelné atributy se budou ignorovat. Poznámka: null je potřeba anotovat správným typem, např. DefaultParameterValue(null:obj).</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Nesprávná obecná instance. Žádný člen {0} s názvem {1} nepřebírá obecné argumenty v počtu {2}.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Obory názvů nemůžou obsahovat členy rozšíření (to jde jenom ve stejném souboru a skupině deklarací oboru názvů, kde je definovaný i typ). K uložení deklarací členů rozšíření můžete použít modul.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Slouží k označení hodnoty, která vznikne jako výsledek výrazu výpočtu.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>Hodnota {0} není z tohoto místa v kódu dostupná.</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Odsazení tohoto tokenu in není ve vztahu k odpovídající klauzuli let správné.</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Tady se vyžaduje typ {0}, který ale není dostupný. Je potřeba přidat odkaz na sestavení {1}.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>Operátor {0} nepodporuje použití klíčového slova into.</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} není statický člen.</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Anonymní typy proměnných nejsou v této deklaraci povolené.</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Tento záznam obsahuje pole z nekonzistentních typů.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>Vazby let a do se musí v definicích typů umístit před definice členů a rozhraní.</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Direktivy uvnitř modulů se ignorují.</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 16bitová celá čísla se znaménkem.</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Problém se znakovou stránkou {0}: {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Výrazy atributu musí být volání konstruktorů objektů.</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Konstruktoru delegáta se musí předávat jediná hodnota funkce.</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Počet argumentů, které tento indexer očekává, je {0}, ale počet těch, které se mu tady předávají, je {1}.</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>Aby se splnily požadavky na typ kontextu, musí mít výraz if typ {0}. V tuto chvíli má typ {1}.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Zkráceným typům se nedá předávat atribut Sealed.</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Povolit optimalizace (krátký tvar: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Toto přepsání přebírá jiný počet argumentů vzhledem k odpovídajícímu abstraktnímu členovi. Našli se následující abstraktní členové: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Nespárovaná závorka [</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Hodnota literálu nemůže mít označení inline.</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>Atribut NoEquality je potřeba použít ve spojení s atributem NoComparison.</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které vyžadují ukazatele na parametry ByRef.</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>V typu se neočekávalo lomítko (/).</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Typy kódu sestavení jsou vždycky zapečetěné.</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Nezadali jste žádné vstupy.</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>U nenulových konstant nemůžou být obecné jednotky. Obecný nulový zápis je 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Neplatná metoda getter nebo setter vlastnosti</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura deklaruje {2}, ale implementace deklaruje {3}.</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Znak {0} není v názvu poskytnutého oboru názvů {1} povolený.</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Neplatná direktiva. Očekávaná direktiva je #I \"&lt;cesta&gt;\".</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 32bitová celá čísla bez znaménka.</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>Vlastnost {0} má stejný název jako metoda v typu {1}.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>událost</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>pole</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Rekurzivně definované hodnoty se nedají použít přímo jako součást konstrukce hodnoty řazené kolekce členů v rekurzivní vazbě.</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Možnost příkazového řádku {0} je zastaralá. Generování dokumentu HTML je teď součástí knihovny F# Power Pack a je přístupné prostřednictvím nástroje FsHtmlDoc.exe.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Atributy nejsou u vazeb Let ve výrazech povolené.</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se odpovídajícím počtem parametrů typu.</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Tento člen není dostatečně obecný.</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Používá se jako logický literál.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Citace nemůžou obsahovat sestupné smyčky for.</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Základní adresa knihovny, která se má vytvořit</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Problém při čtení sestavení {0}: {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Poskytnutý typ {0} vrátil člena s hodnotou null.</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Odkaz na typ {0} se v sestavení {1} našel, ale tento typ se v něm najít nepovedlo.</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Parametr obecného typu se použil tak, že ho to omezuje, aby vždycky byl {0}.</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je označená jako přepsání a druhá ne.</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Očekávaný počet výrazů je {0}. Počet předaných je {1}.</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Minimálně jeden parametr deklarovaného typu u tohoto rozšíření typu neobsahuje omezení typu nebo má nesprávné omezení typu, které se neshoduje s původními omezeními typu na {0}.</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Nejmíň jedno přepsání neimplementovalo správně odpovídající abstraktní člen.</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Třída AssemblyVersionAttribute se ignorovala, protože jste verzi zadali pomocí možnosti příkazového řádku.</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>Atribut DefaultValue se dá použít jenom u deklarací val.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Typy struktury jsou vždycky zapečetěné.</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Typy nemůžou dědit od více konkrétních typů.</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Neočekávané argumenty typu</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžaduje, aby typ podporoval rozhraní {2}, které se ale neimplementovalo.</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- GENEROVÁNÍ KÓDU -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Const_uint16array se neočekávalo.</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Člen {0} se používá neplatným způsobem. Použití {1} se odvozuje před definicí {2}. To je neplatný dopředný odkaz.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>je</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Tento atribut se v této verzi F# nedá použít.</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Atributy nejsou ve vzorech se povolené.</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Zděděný člen {0} se nedá přepsat, protože je zapečetěný.</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Tento typ nemá žádné vnořené typy.</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>V názvu soboru {0} je neplatný znak {1}.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Není definované pole, konstruktor nebo člen {0}.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Výrazy [&lt;ReflectedDefinition&gt;] nemůžou obsahovat použití operátoru spojení předpon %.</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Neshoda v délce instance typu</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Vlastnost setter může mít maximálně dvě skupiny argumentů.</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Zakázat specifická upozornění</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Potlačí zprávu o autorských právech kompilátoru.</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Typ {0} je označený jako typ s explicitním rozložením, ale u pole {1} chybí atribut FieldOffset.</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se typy.</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Použití operátoru spojení výrazů se u první třídy nepovoluje.</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Toto přetypování směrem dolů vymaže typ {0} poskytnutý typu {1}.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Typ {0} obsahuje člen {1}, ale není to virtuální nebo abstraktní metoda, která by se dala přepsat nebo implementovat.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>Atribut {0} se vyskytuje jak v implementaci, tak v signatuře, ale argumenty atributu se liší. Do kompilovaného kódu se zahrne jenom atribut ze signatury.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Operátor {0} se nedá přeložit. Zvažte možnost otevření modulu Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Nerozpoznaná možnost: {0}</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>rozšíření</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože pole {0} se nacházelo v implementaci, ale v signatuře ne. Modul obsahuje definici výjimky\n    {1},    \nale jeho signatura definuje\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Typ {0} má metodu {1} (celý název je {2}), ale ta není statická.</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Volání reraise se může vyskytovat jenom přímo v obslužné rutině try-with.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Typy výčtu jsou vždycky zapečetěné.</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Typy argumentů se neshodují.</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Použití l nebo L je u tohoto specifikátoru formátu nadbytečné. V kódu F# můžete místo toho použít %d, %x, %o nebo %u: tyto specifikátory formátu jsou přetěžované, takže fungují se všemi základními celočíselnými typy.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Umožňuje přístup ke členovi zvnějška typu.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>Typ {0} nemá null jako správnou hodnotu. Pokud chcete u typu s možnou hodnotou null vytvořit hodnotu null, použijte System.Nullable().</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Rekurzivní hodnota ValValue {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Typ {0} je neplatný, protože T v byref&lt;T&gt; nemůže obsahovat typy ByRef.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Definuje symboly podmíněné kompilace (krátký tvar: -d).</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Atributy u deklarací inherit nejsou povolené.</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>Vlastnost {0} u poskytnutého typu {1} má CanWrite s hodnotou true, ale metoda GetSetMethod() nevrátila žádnou hodnotu.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože se liší deklarace výjimek. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>V FSharp.Core se nenašel soubor FSharp.Core.sigdata. Soubor se očekával v {0}. Zvažte upgrade na novější verzi FSharp.Core, kde se tento soubor už nevyžaduje.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Očekával se jednořádkový komentář nebo konec řádku.</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Zprostředkovatel typu vrátil hodnotu null, která není platnou návratovou hodnotou {0}.</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>Za direktivou #if by měl bezprostředně následovat identifikátor.</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>{0} nemá žádnou implementaci. Všechny členy rozhraní je potřeba implementovat a uvést pod příslušnou deklarací interface, třeba takto: interface ... with member ...</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Blok, který následuje po tomto {0}, není dokončený. Každý blok kódu je výraz a musí mít výsledek. {1} nemůže být konečný element kódu v bloku. Zvažte, že tomuto bloku dáte explicitní výsledek.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu while. Očekávaná notace je while &lt;výraz&gt; do &lt;výraz&gt;.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Definice míry nemůžou mít parametry typu.</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>Aby se knihovna DLL {0} zkompilovaná v F# dala použít v této verzi F#, musí se znovu zkompilovat.</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Neočekávaný konec vstupu ve výrazu match. Očekávaná notace je match &lt;výraz&gt; with | &lt;cesta&gt; -&gt; &lt;výraz&gt; | &lt;cesta&gt; -&gt; &lt;výraz&gt; </value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Typy rozhraní a typy delegátů nemůžou obsahovat pole.</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Přípony .ml a .mli zajišťují kompatibilitu s ML.</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>obor názvů</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} vyžaduje argumenty ({1}). Požadovaná signatura je {2}.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Deklarace míry můžou mít jenom statické členy: Konstruktory dostupné nejsou.</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Rozhraní nemůžou obsahovat definice statických inicializátorů.</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Vnitřní obecné funkce nejsou ve výrazech v uvozovkách povolené. Dokud bude tato funkce obecná, zvažte přidání některých omezení typu.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Neznámý argument --test: {0}</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Problém s odvozením typu proměnných: příliš složité (dosáhli jste maximální možné hloubky iterace). Zvažte přidání dalších poznámek typu.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>Není definovaný obor názvů, hodnota, typ nebo modul {0}.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se odpovídající počty datových polí.</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Struktury nemůžou obsahovat vazby do, protože výchozí konstruktor pro struktury by tyto vazby neprovedl.</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Slouží k převodu na typ, který je na vyšší pozici v řetězu dědičnosti.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} proměnná v kolekci {1} (outerKey = innerKey) do skupiny. Poznámka: Za {2} se vyžadují závorky.</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Výchozí konstruktor s nulovou inicializací typu struktura se dá použít jenom v případě, že všechna pole typu struktura připouštějí výchozí inicializaci.</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Obecným typům se nemůže předávat atribut StructLayout.</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Explicitní konstruktor objektu by měl používat syntaxi new(args) = expr.</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Odděluje citaci netypového kódu</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Struktury nemůžou obsahovat definice hodnot, protože výchozí konstruktor pro struktury tyto vazby neprovede. Zvažte možnost přidat k primárnímu konstruktoru pro tento typ další argumenty.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro 8bitová celá čísla se znaménkem.</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Neplatný člen {0} u poskytnutého typu {1}. Povolují se jenom vlastnosti, metody a konstruktory.</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Poli {0} typu {1} se nepředalo žádné přiřazení.</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Typ {0} nepodporuje operátor {1}.</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>Adresa statického pole {0} se na tomto místě použít nedá.</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Tato deklarace otevírá obor názvů nebo modul {0} prostřednictvím částečně kvalifikované cesty. Upravte tento kód tak, aby používal úplnou cestu oboru názvů. Touto změnou zajistíte, že bude kód funkční i v případě, že se budou do knihoven F# a CLI přidávat nové konstruktory.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>Klíčové slovo do! se ve výrazech pořadí nedá použít.</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Implementace souboru nebo modulu {0} už je zadaná. V F# záleží na pořadí kompilace, a to kvůli odvození typů proměnných. Pořadí souborů můžete upravit a podpisový soubor umístit před implementaci. Ve Visual Studiu se typ souborů kontroluje v tom pořadí, ve kterém se soubory objeví v souboru projektu, který se dá upravit ručně nebo pomocí Průzkumníka řešení.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>Neplatný obor názvů pro poskytnutý typ</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Tato definice typu zahrnuje okamžitý cyklický odkaz zprostředkovaný polem struktury nebo vztahem dědičnosti.</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Tato hodnota není literálová a nedá se ve vzoru použít.</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Všem argumentům primárního konstruktoru pro strukturu se musí předávat typ, třeba pomocí notace type S(x1:int, x2: int) = ... Tyto argumenty určují pole struktury.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Proměnlivé hodnoty nemůžou mít obecné parametry.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Nepovedlo se vyřešit nejednoznačnost v použití obecného konstruktoru s omezením delegate na této pozici nebo blízko ní.</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Určení delegátů musí mít notaci typ -&gt; typ.</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute se nedá použít pro člena instance u typu struktura, protože člen instance přebírá implicitní parametr this typu ByRef.</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>Vyžaduje se metoda get nebo set.</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>{0} nepodporuje příznak předpony {1}.</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Tento parametr typu se použil způsobem, který ho omezuje v tom smyslu, že musí být vždycky {0}.</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Pojmenované argumenty nejde předávat voláním vlastností členů.</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Zadaná verze rozhraní .NET Framework {0} není podporovaná. Zadejte hodnotu z výčtu Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Pokud se definuje taky hodnota konstanty, třeba val x : int = 1, může být deklarací jenom atribut [&lt;Literal&gt;].</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Soubor {0} má nerozpoznanou příponu. Zdrojový soubor musí mít příponu .fs, .fsi, .fsx, .fsscript, .ml nebo .mli.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Tato deklarace inherit specifikuje zděděný typ, ale ne argumenty. Zvažte možnost poskytnutí argumentů, třeba inherit BaseType(args).</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Pojmenovat výstupní ladicí soubor</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Určuje adresář pro cestu vložených souborů, který se použije k překladu zdrojových souborů a sestavení (krátký tvar: -I).</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Vytisknout odvozené rozhraní sestavení do souboru</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Vytvoří modul, který se dá přidat do jiného sestavení</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Znak | není u identifikátorů velikosti písmen aktivních vzorů povolený.</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u tohoto člena povolené. Abstraktní datové oblasti mají vždycky stejnou viditelnost jako nadřazený typ.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Pro oddělení hodnot v záznamech se používá znak ; (středník). Zvažte nahrazení znaků , (čárka) znaky ; (středník).</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Nepovedlo se vyřešit nejednoznačnost vyplývající z použití operátoru {0} na tomto místě v programu nebo blízko něho. Tuto nejednoznačnost můžete vyřešit pomocí poznámek typu.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Není definovaný typ {0}.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Slouží k označení funkce, která se má integrovat přímo do kódu volajícího.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Toto není platný název případu výčtu.</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Tento člen instance vyžaduje, aby parametr představoval objekt, který se vyvolává. Upravte člena tak, aby byl statický, nebo použijte notaci member x.Member(args) =</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Neexistuje žádný statický parametr s názvem {0}.</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Není běžné, aby typ s atributem NoEquality měl explicitní implementaci Object.Equals(obj). Pokud je to záměr s cílem dosáhnout interoperability, pak toto upozornění vypněte.</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Hodnota se zkopírovala pro případ, že by se v důsledku této operace původní hodnota změnila.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Jedna nebo víc proměnných explicitní třídy nebo typu funkce pro tuto vazbu se nedala zobecnit, protože má omezení na jiné typy.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Kandidáti: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Nespárovaný nebo špatně formátovaný blok with</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Všechny elementy výrazu konstruktoru seznamu musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Explicitní specifikace typu se nedají použít u konstruktorů výjimek.</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Typ záznamu pro pole záznamu {0} se definoval pomocí atributu RequireQualifiedAccessAttribute. Do jména, které používáte, přidejte název typu záznamu ({1}).</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>Odpovídající formální argument není nepovinný.</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Neplatná hodnota</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>Hodnota {0} se nepoužívá.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Možnost vyžaduje parametr: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Neplatná deklarace</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro nativní celá čísla bez znaménka.</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Není definovaný rozlišovací prvek vzorů {0}.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Neočekávaný konec vstupu</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Dva moduly s názvem {0} se vyskytují ve dvou částech tohoto sestavení.</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Pro typ delegáta se našla víc než jedna metoda Invoke.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Tato hodnota není funkcí a nedá se použít. Nechtěli jste indexer použít spíše pomocí {0}.[index]?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Parametr {0} je odvozený jako parametr typu ByRef. Parametrům typu ByRef se musí předávat explicitní poznámka typu, třeba x1: byref&lt;int&gt;. V případě jejího použití se k parametru typu ByRef přistoupí implicitně přes ukazatel.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Tento statický člen by neměl mít parametr this. Zvažte použití notace member Member(args) = ...</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Obecný konstruktor vyžaduje, aby byl typ {0} neabstraktní.</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Zahrňte jenom informace o optimalizaci nutné k implementaci vložených konstruktorů. Deaktivuje se vkládání napříč moduly, ale zlepší se kompatibilita binárních souborů.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>Signatura reprezentaci tohoto typu skrývá. Charakteristiku typu je potřeba určit pomocí atributu, jako je třeba [&lt;Sealed&gt;], [&lt;Class&gt;] nebo [&lt;Interface&gt;].</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>Formát {0} nepodporuje příznak 0.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Odvození typu proměnné způsobilo, že se proměnná typu {0} dostala mimo svůj rozsah. Zvažte přidání explicitní deklarace parametru typu nebo upravení kódu, aby byl méně obecný.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Zadejte typ ladění: full, portable, embedded, pdbonly. ({0} je výchozí hodnota v případě, že není zadaný žádný typ ladění, a umožňuje připojení ladicího programu ke spuštěnému programu, portable je formát pro různé platformy, embedded je formát pro různé platformy vložený do výstupního souboru).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Před první deklarací namespace se dají použít jenom direktivy kompilátoru #.</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>Lokální hodnota {0} se během optimalizace nenašla.</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Zprostředkovatel typu {0} poskytnul metodu s názvem {1} a tokenem metadat {2}, která není uvedená mezi metodami jeho deklarujícího typu {3}.</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Neplatná syntaxe pro {0}. Použití: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Neplatné číslo s plovoucí desetinnou čárkou</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Konstruktory nejsou povolené jako členy rozšíření – musí být definované v rámci původní definice typu.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Konstruktor objektu {0} nemá žádné argumenty nebo návratovou vlastnost {1}, která by šla nastavit. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>Platforma anycpu32bitpreferred se dá použít jenom s cíli EXE. Místo ní je potřeba použít anycpu.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se názvy.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je statická a druhá ne.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typ implementace není zapečetěný, ale signatura uvádí, že je. Zvažte možnost přidat k implementaci atribut [&lt;Sealed&gt;].</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>Výrazy try/with se u výrazů pořadí použít nedají.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože abstraktní člen {2} se nacházel v implementaci, ale v signatuře ne.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} explicitně implementuje Object.GetHashCode. Zvažte implementaci odpovídajícího přepsání pro Object.Equals(obj).</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Slouží k deklaraci vlastnosti nebo metody v objektovém typu.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Slouží k přidružení názvu ke skupině souvisejících typů, hodnot a funkcí a jeho logickému oddělení od jiného kódu.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se typy.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší odpovídajícím počtem parametrů typu.</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Specifikace delegátů nesmí být curryfikované typy. Pro delegáty, kteří mají víc argumentů, použijte typ * ... * typ -&gt; typ a pro delegáty, kteří vrací hodnoty funkcí, použijte typ -&gt; (typ -&gt; typ).</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>Hodnota {0} má označení inline, ale její implementace využívá interní nebo privátní funkci, ke které není dostatečný přístup.</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>Vlastnost {0} není statická.</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Neplatný výraz objektu, pořadí nebo záznamu</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Parametry typu odvozené pro tuto hodnotu nejsou v případě vymazání zkratek typů stabilní. To je způsobené použitím zkratek typu, které vypouštějí nebo mění pořadí parametrů typu, třeba pomocí notace\n\ttype taggedInt&lt;'a&gt; = int nebo\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nZvažte deklarování parametrů typu pro tuto hodnotu explicitně, třeba pomocí notace\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IStructuralComparable. Použijte pro tento typ atribut CustomComparison.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Chyba syntaxe</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Neplatná relace spojení v {0}. Očekávaná notace je expr &lt;op&gt; expr, kde &lt;op&gt; je =, =?, ?= nebo ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Vazba pole musí být v podobě id = expr;</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>Událost {0} není statická.</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} proměnná v kolekci</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Používá se ve výrazu pořadí k vytvoření hodnoty pořadí.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>Výraz try/finally se nedá použít v dotazech.</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Doporučuje se, aby se objekty, které podporují rozhraní IDisposable, vytvářely pomocí syntaxe new Type(args) a ne Type(args) nebo Type jako hodnota funkce představující konstruktor. Tím se určí, že prostředky může vlastnit generovaná hodnota.</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Hodnota literálu nemůže mít označení mutable.</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Uvozuje konstruktor cyklu.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} není statická metoda.</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Atributy nejsou u implementací rozhraní povolené.</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Tato notace výrazu se dá použít jenom ve výrazech pořadí a výpočtu.</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které načítají indexy případů typu union.</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>V podrobné syntaxi označuje začátek definice třídy.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>V podrobné syntaxi označuje začátek bloku kódu.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Volání konstruktorů objektu u parametrů typu se nedají předávat argumenty.</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Používá se k větvení porovnáním hodnoty s určitým vzorem.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Neočekávaná podmínka v importovaném sestavení: nepovedlo se dekódovat atribut AttributeUsage.</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Tento případ typu union nepřebírá argumenty.</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Slouží k odkazu na obor názvů .NET na nejvyšší úrovni.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Tento řídicí konstruktor se dá použít jenom v případě, že tvůrce výrazu výpočtu definuje metodu {0}.</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Za lomítkem (/) následuje implicitní vytvoření míry.</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Neplatné poskytnuté pole. Poskytnutá pole vymazaných poskytnutých typů musí být literálová.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Toto je neznámý operátor dotazu. Operátory dotazu jsou identifikátory jako třeba select, where, sortBy, thenBy, groupBy, groupValBy, join, groupJoin, sumBy nebo averageBy, které jsou definované pomocí odpovídajících metod v typu QueryBuilder.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}.</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Měrné jednotky se podporují jenom u typů float, float32, decimal a signed integer.</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Pole {0} není statické.</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Soubory by měly začínat buď oborem názvů, nebo deklarací modulu, třeba namespace SomeNamespace.SubNamespace nebo module SomeNamespace.SomeModule, nejde ale použít obojí. Pokud chcete definovat modul uvnitř oboru názvů, použijte syntaxi module SomeModule = ...</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>Signatura pro tuto externí funkci obsahuje parametry typu. Omezte argument a návratové typy tak, aby zahrnovaly typy odpovídající funkce C.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Všechny větve výrazu porovnání vzorů musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>Metoda {0} je zapečetěná a nedá se přepisovat.</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Nespárovaný výraz {0}</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Toto není proměnná, konstanta, aktivní rozlišovač nebo literál.</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Poli {0} se předala hodnota, která se ale nenachází v typu {1}.</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které načítají statická pole.</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Statické definice hodnot se dají použít jenom u typů s primárním konstruktorem. Zvažte přidání argumentů do definice typu, třeba type X(args) = ...</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Nedá se najít cíl kódu pro tento atribut. Možná je to proto, že kód za tímto atributem je neúplný.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Neplatný název modulu nebo oboru názvů</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>vlastní operace</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Slouží k ověření kódu během ladění.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Deklarace z tohoto souboru se umístí do implicitního modulu {0} založeného na názvu souboru {1}. To ale není platný identifikátor F#, takže obsah nebude dostupný z jiných souborů. Zvažte přejmenování souboru nebo přidání deklarace modulu nebo oboru názvů na jeho začátek.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Soubor klíče {0} se nedal otevřít.</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>V citacích nemůže být zahrnuté porovnávání vzorů polí.</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Jeden typ řazené kolekce členů je struktura, ten druhý je řazená kolekce členů odkazu.</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} vyžaduje další argumenty ({1}). Požadovaná signatura je {2}. Některé názvy chybějících argumentů jsou {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} vyžaduje argumenty ({1}). Požadovaná signatura je {2}. Některé názvy chybějících argumentů jsou {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0} vyžaduje další argumenty ({1}). Požadovaná signatura je {2}.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo let!.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Očekával se argument typu nebo statický argument.</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Zadali jste kolidující možnosti: win32manifest a win32res. Dá se použít jenom jedna z nich.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Duplicitní vlastnost. Vlastnost {0} má stejný název a signaturu jako jiná vlastnost v typu {1}.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Zadejte preferovaný název jazykové verze (např. es-ES, ja-JP).</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>Ve výrazech pořadí se výsledky generují pomocí yield.</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Určuje soubor klíče se silným názvem.</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Neočekávaný identifikátor: {0}</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Neplatné číslo řádku: {0}</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Nepovinné argumenty tady nejsou povolené.</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Tento konstruktor je experimentální.</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Rozšíření nejsou u typu delegáta moduleDefns povolená.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>{0} není platný celočíselný argument.</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>Pokud se na knihovnu mscorlib.dll nebo FSharp.Core.dll odkazuje explicitně, musí se předávat taky možnost {0}.</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Poznámky typu u metod getter nebo setter vlastnosti se musí předávat až po get() nebo set(v). Příklad: with get() : string = </value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Vytvoří spustitelný soubor systému Windows.</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Název výstupního souboru (krátký tvar: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Přepínač --sourcelink se podporuje jenom při generování souboru PDB typu Portable (--debug:portable nebo --debug:embedded).</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>Atribut CallerMemberNameAttribute použitý pro parametr {0} nebude mít žádný účinek. Přepisuje ho atribut CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Pojmenované statické argumenty se musí umístit až za všechny nepojmenované statické argumenty.</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Vytvoří spustitelný soubor konzoly.</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Všechna implementovaná rozhraní by se měla deklarovat při počáteční deklaraci typu.</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Neočekávaná specifikace vlastnosti na úrovni zdroje</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Nejde volat abstraktní základní člen: {0}.</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>Atribut ConditionalAttribute se dá použít jenom u členů.</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Typ s atributem CustomComparison musí mít explicitní implementaci buď aspoň System.IComparable, nebo aspoň System.Collections.IStructuralComparable.</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se názvy členů CLI.</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Metoda implementovaná touto výchozí třídou je nejednoznačná.</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# podporuje rozměry polí od 1 do 32. Hodnota {0} není povolená.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Citace nemůžou obsahovat tento druh typu.</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>V objektových výrazech se dají specifikovat jenom přepsání abstraktních a virtuálních členů.</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Zapsat xmldoc sestavení do daného souboru</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože pole {2} se nacházelo v implementaci, ale v signatuře ne. Typy Struct teď musí zobrazovat svoje pole v signatuře typu. Přesto můžou mít pole označení private nebo internal.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Případ typu union {0} není z tohoto místa v kódu dostupný.</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>O atributy ReferenceEquality, StructuralEquality a StructuralComparison se dají rozšířit jenom typy záznam, sjednocení, výjimka a struktura.</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Neplatná velikost podpisu</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Zadat soubor manifestu Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Neplatný výraz indexeru</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Název typu nemůže být prázdný.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Zdrojový soubor {0} se nenašel.</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Očekával se nadřazený prvek modulu nebo oboru názvů {0}.</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Ve výrazech konstrukcí se dají použít jenom jednoduché vazby s notací id = expr.</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Označuje, že deklarovaný element programu je definovaný v jiném binárním souboru nebo sestavení.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Informační soubor zdrojového odkazu, který se má vložit do souboru PDB typu Portable</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>Klíčové slovo new se dá použít jenom s konstruktory objektů.</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Tento kód je míň obecný, než udávají jeho poznámky. U měrné jednotky specifikované pomocí podtržítka (_) se určila hodnota 1, tj. bezrozměrná. Zvažte zobecnění kódu nebo odebrání podtržítka (_).</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Toto není platný literálový výraz. Atribut [&lt;Literal&gt;] se bude ignorovat.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura uvádí, že tento typ může jako hodnotu navíc používat null, ale implementace to neuvádí.</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>Výrazy try/with se u dotazů použít nedají.</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Staticky propojit knihovnu F# a všechny odkazované knihovny DLL, které jsou na ní závislé, do právě generovaného sestavení</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>Atribut AutoOpen(\"{0}\") v sestavení {1} neodkazoval na platný modul nebo obor názvů v tomto sestavení a ignoroval se.</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Toto pole není měnitelné.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože typy jsou různého druhu.</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Výčty nemůžou mít deklarace rozhraní.</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Vytvoří knihovnu (krátký tvar: -a).</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Sestavení {0} se nedalo přeložit.</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Konstruktor členu nebo objektu {0}, který přebírá argumenty ({1}), není na tomto místě v kódu dostupný. Počet argumentů přebíraných všemi přístupnými verzemi metody {2} je {3}.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Krátký tvar pro {0}</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Výchozí implementace tohoto rozhraní už se přidala, protože jste v definici typu nezadali explicitní implementaci tohoto rozhraní.</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Pojmenované pole {0} se používá víc než jednou.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Deterministická sestavení podporují jenom soubory PDB typu Portable (--debug:portable nebo --debug:embedded).</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Neplatný objektový výraz. U objektů bez přepsání nebo rozhraní by se měl výraz formulovat pomocí notace new Type(args) bez složených závorek.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>z: {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Slouží k počítání pozpátku ve výrazu for.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Tento typ není typem záznamu.</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Citace nemůžou obsahovat výrazy, které přebírají adresu pole.</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} implementuje explicitně rozhraní System.IComparable. Pro tento typ musíte použít atribut CustomComparison.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Výraz if/then/else se nedá použít v dotazech. Zvažte možnost použít místo toho výraz if/then nebo výraz pořadí.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Statický parametr {0} už hodnotu převzal.</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Vloží konkrétní zdrojové soubory do přenosného souboru PDB.</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>Proměnná {0} typu ByRef se používá neplatným způsobem. Proměnné typu ByRef nejde zachytávat ukončením nebo předávat vnitřní funkci.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Vlastnost {0} se nedá nastavit.</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Tato vlastnost se nedá nastavit.</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Použití operátorů address-of jako výrazů první třídy není povolené.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je konstruktorem nebo vlastností a druhá ne.</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Výrazy konstruktoru objektu se dají použít jenom k implementaci konstruktorů v typech tříd.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože signatura vyžadovala pole {0}, které ale implementace nedefinuje. Modul obsahuje definici výjimky\n    {1},    \nale jeho signatura definuje \n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Tento číselný literál vyžaduje, aby modul {0} definující funkce FromZero, FromOne, FromInt32, FromInt64 a FromString byl v definičním oboru.</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Pro tento typ nejde definovat konstruktory.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura vyžadovala pole {2}, které ale v implementaci zadané nebylo.</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Nepovinné argumenty jsou povolené jenom u členů typu.</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>U odkazu na poskytnutý typ chybí hodnota pro statický parametr {0}. Možná bude potřeba znovu zkompilovat jedno nebo víc odkazovaných sestavení.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Všechny větve výrazu if musí mít stejný typ. Očekávalo se, že tento výraz bude mít typ {0}, ale tady je typu {1}.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Vymazáno</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Tato hodnota, typ nebo metoda očekává parametry typu v počtu {0}, ale počet předaných je {1}.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože se signatura a implementace liší pořadím polí. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Vlastní operace se nedají použít ve spojení s vazbou let, která je bez hodnoty nebo rekurzivní a nachází se v jiné části tohoto výrazu výpočtu.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Člen {0} nemá správný počet parametrů typu metody. Požadovaná signatura je {1}.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá reprezentaci typu CLI.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} má atribut StructuralComparison, ale parametr typu {1} nevyhovuje omezení comparison. Zvažte možnost přidat k parametru typu omezení comparison.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Typ struktura, záznam nebo sjednocení {0} má atribut StructuralComparison, ale typ komponenty {1} nevyhovuje omezení comparison.</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>Adresa proměnné {0} se na tomto místě použít nedá.</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>případ typu union</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Globální mezipaměť sestavení</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Duplicitní nebo nadbytečné rozhraní</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Neplatný soubor odpovědi {0} ({1})</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Vazby use! musí mít notaci use! &lt;var&gt; = &lt;expr&gt;.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože signatura skrývá reprezentaci typu.</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Neplatný výraz záznamu, pořadí nebo výpočtu. Výrazy pořadí by měly mít notaci seq {{ ... }}.</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>Událost {0} u poskytnutého typu {1} nepřebírá žádnou hodnotu od GetAddMethod().</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Slouží k deklaraci a implementaci rozhraní.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je členem rozšíření a druhá ne.</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Metody set vlastnosti musí být definované pomocí syntaxe set value = , set idx value = nebo set (idx1,...,idxN) value = ... </value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Neplatný argument popisku parametrizovaného vzoru</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Neplatná bitová délka</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>Direktiva #if musí být uvedená jako první neprázdný znak na řádku.</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Existuje víc statických parametrů s názvem {0}.</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Pole s modifikátorem volatile musí mít označení mutable a nemůžou být statická na úrovni vlákna.</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Návratové typy případů typu union musí být identické s typem, který se definuje, a to až po zkratky.</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u implementací rozhraní nebo přepsání povolené.</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Zvažte možnost použít místo toho soubor s příponou .ml nebo .mli.</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Tato hodnota přepisuje nebo implementuje abstraktní vlastnost, která ale nemá odpovídající metodu {0}.</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Chyba kompilátoru: neočekávaná nerealizovaná hodnota</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>U odkazu na poskytnutý typ je hodnota {0} pro statický parametr neplatná. Možná bude potřeba znovu zkompilovat jedno nebo víc odkazovaných sestavení.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Definice výjimek nejsou kompatibilní, protože zkratky výjimek v signatuře a implementaci se liší. Modul obsahuje definici výjimky\n    {0},    \nale jeho signatura definuje\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Neplatná hodnota vlastního atributu (není to konstanta nebo literál)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Zkratky výjimek by neměly mít seznamy argumentů.</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Tato vlastnost je neplatného typu. Vlastnosti, které přebírají víc argumentů indexeru, by měly mít typy s notací ty1 * ty2 -&gt; ty3. Vlastnosti, které vrací funkce, by měly mít typy s notací (ty1 -&gt; ty2).</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Hodnota typu ByRef by se uložila tady. Hodnoty ByRef s vazbou na let na nejvyšší úrovni nejsou povolené.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Pro tento identifikátor jste zadali víc atributů viditelnosti. Vazby let ve třídách jsou vždycky privátní, stejně jako kterákoli vazba let ve výrazu.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Citace nemůžou obsahovat definice funkcí, které jsou odvozené nebo deklarované jako obecné. Zvažte přidání některých omezení typu, abyste vytvořili platný citovaný výraz.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Chybná přesnost ve specifikátoru formátu</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Pro tento typ nejsou dostupné žádné konstruktory objektu.</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Typ {0} od zprostředkovatele typu {1} má prázdný obor názvů. Pro globální obor názvů použijte null.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože implementace uvádí, že tento typ může jako hodnotu navíc používat null, ale signatura to neuvádí.</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Tento konstruktor objektu vyžaduje argumenty.</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou v deklaracích inherits povolené.</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Teto typ vyžaduje definici.</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Pole literálů se nedají nastavit.</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Slouží k označení rozsahu v cyklech.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Používá se v logických podmínkách jako logický operátor or. Ekvivalent ||. Používá se také v omezeních členů.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Slouží k označení typu kategorií hodnot v rozlišených sjednoceních a v deklaracích delegování a výjimek.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Používá se v konstruktorech podmíněného větvení.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Používá se ve výrazech pořadí a v podrobné syntaxi k oddělení výrazů od vazeb.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Slouží k pojmenování objektu aktuální třídy. Používá se také k pojmenování celého vzoru v rámci porovnávání vzorů.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Používá se v konstruktorech cyklů nebo k provádění imperativního kódu.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se atributy proměnlivosti.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Zkratky pro typy výjimek Common IL musí mít odpovídající konstruktor objektu.</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Toto není platný číselný literál. Mezi platné číselné literály patří 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>Atribut CustomEquality je potřeba použít ve spojení s atributem NoComparison nebo CustomComparison.</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Vlastnost getter může mít maximálně jednu skupinu argumentů.</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Člen, funkce nebo hodnota se nedá deklarovat jako inline.</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Neplatný operátor předpony</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Středník se na této pozici neočekává.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>{0} se nepoužívá správně. Použití: {1}. Toto je vlastní operace v tomto výrazu dotazu nebo výpočtu.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>Přepsání {0} bylo nejednoznačné.</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Určuje kontejner klíče se silným názvem.</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Operátor expr.[idx] jste použili u objektu neurčitého typu založeného na informacích před tímto místem v programu. Zvažte přidání dalších omezení typu.</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- CHYBY A UPOZORNĚNÍ -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Přeložit odkazy na sestavení pomocí pravidel založených na adresáři, ne pomocí MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Duplicitní metoda. Abstraktní metoda {0} má po vymazání řazených kolekcí členů, funkcí, měrných jednotek a poskytnutých typů stejný název a signaturu jako abstraktní metoda ve zděděném typu.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Měrná jednotka se v použití konstruktoru typu použít nedá.</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Výrazy konstruktoru objektu (třeba výrazy záznamu se specifikací dědičnosti) se dají použít jenom k implementaci konstruktorů v typech objektového modelu. K vytvoření instancí typů objektového modelu mimo konstruktory použijte new ObjectType(args).</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>Znak {0} není v názvech operátorů povolený: je vyhrazený pro budoucí použití.</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>Výrazy use se v dotazech použít nedají.</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Typ {0} není typem, u kterého by se dal pomocí této syntaxe vytvořit výčet hodnot, tj. není kompatibilní s seq&lt;_&gt;, IEnumerable&lt;_&gt; ani IEnumerable a nemá metodu GetEnumerator.</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Neočekávaný prázdný dlouhý identifikátor</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Neplatná direktiva. Očekávaná direktiva je #r \"&lt;file-or-assembly&gt;\".</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Odvození typu proměnné způsobilo, že se proměnná typu odvození dostala mimo svůj rozsah. Zvažte přidání anotací typu, aby byl kód méně obecný.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Typ {0} nepodporuje převod na typ {1}.</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Možnost příkazového řádku --cliroot je zastaralá. Použijte místo ní explicitní odkaz na specifickou kopii knihovny mscorlib.dll.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Definice {0} v signatuře a implementaci nejsou kompatibilní, protože se liší názvy. Typ se v souboru signatury nazývá {1}, ale v implementaci se nazývá {2}.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Neplatný argument pro methodhandleof při generování kódu</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Neočekávaný symbol = ve výrazu. Neměli jste v úmyslu použít místo toho for x in y .. z do?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Pro typ {0} nejsou k dispozici žádné konstruktory.</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Duplicitní specifikace rozhraní</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Sestavení {0} se v sadě závislostí cílového binárního souboru nenašlo. Staticky propojená kořenová umístění by se měla specifikovat pomocí názvu sestavení bez přípony DLL nebo EXE. Pokud se na toto sestavení odkazovalo explicitně, pak je možné, že ho generovaný binární soubor ve skutečnosti nevyžadoval, a v tom případě by se nemělo propojovat staticky.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Typ {0} implementuje rozhraní System.IComparable. Zvažte možnost přidat taky explicitní přepsání Object.Equals.</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Používá se ve vzájemně rekurzivních vazbách, v deklaracích vlastností a s několika omezeními u generických parametrů.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Toto není platný konstantní výraz.</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Soubor odpovědi {0} se nenašel v {1}.</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>Není definovaný obor názvů {0}.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Žádný z typů {0} nepodporuje operátor {1}. Zvažte otevření modulu Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u vazeb do povolené, ale předal se modifikátor {0}.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Neočekávaný znak {0} ve výrazu preprocesoru</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Povoluje se nanejvýš jedno rozšíření with.</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Parametr s atributy vyžaduje taky název, třeba [&lt;atribut&gt;] Name : Type.</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Tyto popisky pole a očekávaný typ tohoto výrazu záznamu nebo vzoru neurčují jednoznačně odpovídající typ záznamu.</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Argumenty můžou přebírat jenom aktivní vzory, které vracejí právě jeden výsledek.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Člen operátoru vpony {0} má počáteční argumenty v počtu {1}. Očekávala se řazená kolekce členů se dvěma argumenty, třeba statický člen (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>argument</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Tento konstruktor je určený pro kompatibilitu ML. {0}. Toto upozornění můžete pomocí --mlcompatibility nebo --nowarn:62 vypnout.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Modifikátor formátu # je v jazyce F# neplatný.</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Vytvoří zpožděný podpis sestavení jenom s využitím veřejné části klíče silného názvu.</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Slouží k deklaraci typu výjimky.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Minimálně jedno přetížení této metody má curryfikované argumenty. Zvažte úpravu návrhu těchto členů tak, aby přebíraly argumenty v podobě řazené kolekce členů.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>Výraz global se dá použít jenom jako první název v kvalifikované cestě.</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Literálový výčet musí být typu int, uint, int16, uint16, int64, uint64, byte, sbyte nebo char.</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Nastala chyba při čtení uzlu metadat F# na pozici {0} v tabulce {1} sestavení {2}. Tento uzel nemá žádnou odpovídající deklaraci. Předejte toto upozornění dál. Sestavení F#, které používáte, může být potřeba znovu kompilovat.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Chyba při otevírání binárního souboru {0}: {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Neplatný název člena. Členové nemůžou mít název .ctor nebo .cctor.</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Špatný specifikátor formátu: {0}</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Toto pole není literál a nedá se použít ve vzoru.</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Označení mutable můžou mít jenom pole záznamu a jednoduché, nerekurzivní vazby let.</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Neplatná direktiva. Očekávaná direktiva je #load \"&lt;soubor&gt;\" ... \"&lt;soubor&gt;\".</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Typ {0} má metodu {1} (celý název je {2}), ale ta je statická.</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Nenašel se žádný abstraktní člen nebo člen rozhraní, který by odpovídal tomuto přepsání.</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Toto není platný vzor.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>Ve výrazu for chybí klíčové slovo do. Očekávaná notace je for &lt;cesta&gt; in &lt;výraz&gt; do &lt;výraz&gt;.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Při přepisování obecné abstraktní metody musíte explicitně deklarovat buď všechny, nebo žádné parametry typu.</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>U zprostředkovatele typu se vyskytl neplatný výraz {0}. Pokud jste autorem tohoto zprostředkovatele typu, zvažte možnost upravit ho tak, aby poskytoval jiný poskytnutý výraz.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Zadejte verzi subsystému tohoto sestavení.</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Neočekávané použití proměnné typu ByRef.</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Nepovedlo se vložit hodnotu {0} s označením inline: možná proto, že jste jako inline označili rekurzivní hodnotu.</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>Odděluje argumenty a návratové hodnoty v typech funkcí. Nabývá výrazu (ve výrazech pořadí); ekvivalent klíčového slova yield. Používá se v porovnávacích výrazech.</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Struktury nemůžou mít konstruktor objektu bez argumentů. Toto je omezení, které platí u všech jazyků CLI vzhledem k tomu, že struktury automaticky podporují výchozí konstruktor.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Neplatné algId – očekává se Exponent</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Zvažte použití parametru return! namísto return.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>Operátor ! se používá k přístupu k buňce ref přes ukazatel. Zvažte možnost použít tady not expr.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Nepřidávat prostředek do generovaného sestavení, které obsahuje metadata specifická pro F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Neočekávaný operátor vpony ve výrazu typu</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Přepínač --embed se podporuje jenom při generování souboru PDB typu Portable (--debug:portable nebo --debug:embedded).</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Neplatná definice operátora. Definice operátorů předpon musí používat platné názvy těchto operátorů.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Nepojmenované argumenty netvoří předponu argumentů volané metody.</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>Neplatný úplný název poskytnutého typu</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>Direktiva #else musí být uvedená jako první neprázdný znak na řádku.</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Pole {0} výjimky nebo případu typu union se nedá použít víc než jednou.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou u případů typu union povolené. Pomocí notace type U = internal ... nebo type U = private ... předejte dostupnost celé reprezentaci.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Vytvoření instance typu zahrnuje typ ByRef. To ale pravidla Common IL nepovolují.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Neznámý případ typu union</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>({0}) není vhodný název pro člena. Pokud chcete definovat sémantiku porovnání pro typ, implementujte rozhraní System.IComparable. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Zkratky typů nemůžou mít rozšíření.</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Modul obsahuje konstruktor\n    {0},    \nale jeho signatura definuje\n    {1}.    \nDostupnost zadaná v signatuře přesahuje dostupnost zadanou v implementaci.</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nArity v signatuře a implementaci se liší. Signatura určuje, že {3} je definice funkce nebo výraz lambda přijímající argumenty aspoň v počtu {4}, ale implementace je vypočítaná hodnota funkce. Pokud chcete deklarovat vypočítanou hodnotu funkce jako povolenou implementaci, jednoduše ohraničte její typ v signatuře závorkami, třeba pomocí notace\n\tval {5}: int -&gt; (int -&gt; int),\nkterá nahradí notaci\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>a další přetížení ({0})</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Typ {0} není typu výčtu CLI.</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Jako zkratku modulu musíte zadat jednoduchý název, ne cestu.</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Rekurzivní hodnoty nejde použít přímo jako konstrukce typu {0} v rekurzivní vazbě. Tato funkce je už z jazyka F# odebraná. Zvažte možnost použít místo ní záznam.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Kompilátor jazyka F# pro F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Pojmenovaný argument má přiřazenou víc než jednu hodnotu.</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Při statickém propojování se ignoruje kombinované spravované nebo nespravované sestavení {0}.</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Atribut StructLayout se dá předávat jenom strukturám a třídám bez primárních konstruktorů.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Očekával se parametr typu, ne parametr měrné jednotky.</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Označuje implementaci abstraktní metody; společně s deklarací abstraktní metody se používá k vytvoření virtuální metody.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Konec souboru začal v řetězci v trojitých uvozovkách vloženém do komentáře na této pozici nebo před ní.</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Povolit technologii ASLR s vysokou entropií</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Očekává se privátní klíč</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>výsledek aktivního vzoru</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Tato deklarace se ve skupinách rekurzivních deklarací nepodporuje.</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Chybějící token {0} ve výrazu preprocesoru</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Ukončení – příliš mnoho chyb</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Člen {0} nemá správný počet argumentů. Požadovaná signatura je {1}.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Tento typ používá neplatnou kombinaci atributů NoEquality, ReferenceEquality, StructuralEquality, NoComparison a StructuralComparison.</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Tato definice se dá použít jenom u typu s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Typ atributu {0} má nastavení AllowMultiple=false. K elementu s jedním jazykem se nedá připojit víc instancí tohoto atributu.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>Ve výrazech pořadí se víc výsledků generuje pomocí yield!.</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Typ {0} nepodporuje operátor {1}. Zvažte otevření modulu Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Struktury, rozhraní, výčty ani delegáti nemůžou dědit z jiných typů.</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Neplatný počet obecných argumentů pro typ {0} u poskytnutého typu. Očekávaný počet argumentů je: {1}, počet předaných je: {2}.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Metoda {0} není na tomto místě v kódu dostupná.</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Neplatná hodnota Magic v záhlaví CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Neplatné nepovinné přiřazení k vlastnosti nebo poli</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}. Pojmenovaný argument {3} neodpovídá žádnému argumentu ani nastavitelné návratové vlastnosti u žádného přetížení.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Žádný konstruktor členu nebo objektu {0} s názvem {1} nepřebírá argumenty v počtu {2}. Kromě toho poskytuje volání tohoto členu taky pojmenované argumenty ({3}).</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Neplatný popisek pole</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Atribut MarshalAs se nedal dekódovat.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší reprezentace IL.</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>U typu {0}, který není obecný, se neočekávají žádné argumenty typu, ale tady se mu argumenty typu předávají ({1}).</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>Není definovaný konstruktor, hodnota, obor názvů nebo typ {0}.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>obor názvů nebo modul</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Rekurzivní hierarchie tříd u typu {0}</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Rekurzivní odkaz na objekt {0} se nepoužívá. Přítomnost rekurzivního odkazu na objekt přidává ke členům tohoto a odvozených typů kontroly inicializace za běhu. Zvažte odebrání tohoto rekurzivního odkazu na objekt.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Typ nemůže mít zároveň atribut ReferenceEquality a StructuralEquality nebo StructuralComparison.</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Tento konstruktor se dá použít jenom ve výrazech výpočtu.</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Hodnota musí být proměnlivá, aby se dal změnit obsah nebo aby se dala převzít adresa typu hodnoty, třeba let mutable x = ...</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Zkratky výjimek musí odkazovat na existující výjimky nebo typy F# odvozené od třídy System.Exception.</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Vložit všechny zdrojové soubory do souboru PDB typu Portable</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Vazbu v konstruktorech let rec můžou mít jenom vzory s jednoduchými proměnnými.</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Po sobě jdoucí argumenty by měly být oddělené mezerami nebo by měly být řazenou kolekcí členů a argumenty zahrnující použití funkcí nebo metod by měly být v závorkách.</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Není výjimka.</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Vnitřní chyba. Neplatný index pro pole aktivního vzoru</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Na sestavení {0} se odkazovalo přechodně a nedalo se přeložit automaticky. Statické propojování bude předpokládat, že tato knihovna DLL nemá žádné závislosti na knihovně F# nebo jiných staticky propojených knihovnách DLL. Zvažte možnost přidat explicitní odkaz na tuto knihovnu DLL.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Chyba při generování atributu System.Reflection.AssemblyCultureAttribute: Spustitelné soubory nemůžou být satelitní sestavení. Jazyková verze by měla být vždycky prázdná.</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Rozhraní mají vždycky stejnou viditelnost jako nadřazený typ.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nJedna je funkcí typu a druhá ne. Signatura vyžaduje explicitní parametry typu (pokud se v implementaci vyskytují).</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>Syntaxe module ... = struct .. end se v kódu F# nepoužívá. Zvažte použití syntaxe module ... = begin .. end.</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>Atribut VolatileField se dá v třídách použít jenom u vazeb let.</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Modul obsahuje pole\n    {0},    \nale jeho signatura definuje\n    {1}.    \nLiší se modifikátory literal.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Definice {0} pro typ {1} v signatuře a implementaci nejsou kompatibilní, protože se liší zkratky: {2} oproti {3}</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Explicitní statický inicializátor by měl používat syntaxi static new(args) = expr.</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Označení inline můžou mít jenom funkce.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Tento typ není typem rozhraní.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Typ {0} není typ rozhraní.</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Konstruktory objektu nemůžou použít try/with a try/finally přímo, dokud se objekt neinicializuje. To zahrnuje i konstrukce, jako je třeba for x in ..., které se dají na použití těchto konstruktorů rozpracovat. Toto je omezení mezijazyka Common IL.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>V dotazech se nedá použít return! ani return.</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Modifikátory dostupnosti nejsou v polích záznamů povolené. Pomocí type R = internal ... nebo type R = private ... předejte dostupnost celé reprezentaci.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Používá se místo výrazu let! v asynchronních pracovních postupech a jiných výrazech výpočtu pro hodnoty, které k uvolnění prostředků vyžadují volání funkce Dispose.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Zděděná deklarace tady není povolená.</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>U informací o členu {1} poskytnutého typu {0} má deklarující typ hodnotu null.</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Zprostředkovatel typu {0} vrátil z metody ApplyStaticArgumentsForMethod neplatnou metodu. Očekávala se metoda s názvem {1}, ale vrátila se metoda s názvem {2}.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} není platná znaková řídicí sekvence Unicode.</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Existuje víc typů s názvem {0}, které přebírají různý počet obecných parametrů. Pro jednoznačné rozlišení typu vytvořte instanci typu, třeba {1}.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Atributy oboru názvů nebo modulu se v signatuře a implementaci liší.</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>Rozhraní {0} je zahrnuté v několika explicitně implementovaných typech rozhraní. Přidejte explicitní implementaci tohoto rozhraní.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>Událost {0} je nestandardního typu. Pokud je tato událost deklarovaná v jiném jazyce CLI, bude možná potřeba k této události přistoupit pomocí jejích explicitních metod {1} a {2}. Pokud je tato událost deklarovaná v jazyce F#, vytvořte její typ jako instanci buď IDelegateEvent&lt;_&gt;, nebo IEvent&lt;_,_&gt;.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>Syntaxe type X with ... je vyhrazená pro rozšíření. Typy, které mají skrytou reprezentaci, ale mají členy, se teď v signaturách deklarují pomocí notace type X = ... Je možné, že k definici typu v signatuře bude potřeba přidat taky atribut [&lt;Sealed&gt;].</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Možná budete potřebovat něco z tohoto:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>Nemáte definovaný popisek záznamů {0}.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Test tohoto typu nebo jeho přetypování směrem dolů bude ignorovat měrnou jednotku {0}.</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Neplatný objekt blob veřejného klíče</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Když se generuje sestavení, které se odkazuje na System.Runtime (třeba sestavení .NET Core nebo přenosné sestavení), nejde pro sestavení, které se odkazuje na knihovnu mscorlib (třeba sestavení rozhraní .NET Framework), použít statické propojování.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nPočet obecných parametrů v signatuře a implementaci se liší (signatura deklaruje {3}, ale implementace {4}).</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Člen {0} nemá správný druh obecných parametrů. Požadovaná signatura je {1}.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>Signatura a implementace nejsou kompatibilní, protože se liší počtem příslušných parametrů typu.</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>typ, výjimka nebo modul</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Tento výraz seznamu nebo pole zahrnuje element s formulací if ... then ... else. Ohraničte tento výraz závorkami, aby bylo jasné, že jde o samostatný prvek seznamu nebo pole. Odlišíte ho tak od seznamu generovaného pomocí výrazu pořadí.</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Typ {0} nemá null jako správnou hodnotu.</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Modifikátory dostupnosti by se měly umístit bezprostředně před identifikátor, který pojmenovává konstruktor.</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Neúplná definice hodnoty. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo use.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Neúplná definice hodnoty nebo funkce. Pokud je tato definice ve výrazu, musí být tělo tohoto výrazu odsazené na stejnou úroveň jako klíčové slovo let.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Výjimka nebo případ typu union {0} nemá pole s názvem {1}.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>({0}) není vhodný název pro člena. Pokud definujete statického člena, který se má použít z jiných jazyků CLI, použijte místo toho název {1}.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Zprostředkovatel typu nemá platný konstruktor. Očekávaný konstruktor nemá přebírat buď žádné argumenty, nebo jeden argument typu TypeProviderConfig.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Typy záznam, sjednocení, zkratka a struktura nemůžou mít atribut AllowNullLiteral.</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>Notace {{ expr with ... }} se dá ve výrazech použít jenom u typů záznamu. Pokud chcete vytvořit objektové typy, použijte formulaci {{ new Type(...) with ... }}.</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>{0} nemá žádnou implementaci.</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Tento případ typu union očekává argumenty v počtu {0} v podobě řazené kolekce členů.</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Dvě definice typu s názvem {0} se vyskytují v oboru názvů {1} ve dvou částech tohoto sestavení.</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Neplatný název modulu</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>Převod z {0} na {1} je přetypování nahoru bezpečné v době kompilace, ne přetypování dolů. Zvažte použití operátoru :&gt; (upcast) namísto :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Specifikátory pozice nejsou v řetězcích formátu povolené.</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>Vlastní operace {0} odkazuje na metodu, která je přetěžovaná. Implementace vlastních operací se nemůžou přetěžovat.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>V modulech nejsou vazby use povolené. Zpracují se jako vazby let.</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Určuje znakovou stránku, která se používá ke čtení zdrojových souborů.</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Zpracování tohoto operátoru teď provádí přímo kompilátor F# a jeho význam se nedá předefinovat.</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Převede daný typ na typ, který je níže v hierarchii.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Nedala se přečíst verze souboru mscorlib.dll.</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Zprostředkovatel typu {0} oznámil chybu v kontextu poskytnutého typu {1} a člena {2}: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Při použití statických argumentů u poskytnutého typu došlo k chybě.</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- VSTUPNÍ SOUBORY -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Celočíselná smyčka for musí používat jednoduchý identifikátor.</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Toto číslo je mimo povolený rozsah pro šestnáctková 8bitová celá čísla se znaménkem.</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Ochrana porovnání vzorů musí být typu bool, ale tento výraz when je typu {0}.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Definice typu vyžaduje jeden nebo víc členů nebo jiné deklarace. Pokud máte v úmyslu definovat prázdnou třídu, strukturu nebo rozhraní, použijte formulaci type ... = class end, interface end nebo struct end.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Obecný konstruktor vyžaduje, aby měl typ {0} sémantiku odkazu. To ale nemá: je to struktura.</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nLiší se názvy.</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>Zkratka typu obsahuje parametry Byref. To F# nepovoluje.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Nedají se vygenerovat ladicí informace MDB. Načtení typu MonoSymbolWriter ze sestavení Mono.CompilerServices.SymbolWriter.dll selhalo.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Při vytváření souboru ladicích informací {0} došlo k neočekávané chybě.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Očekával se parametr měrné jednotky, ne parametr typu. Explicitní parametry měrných jednotek musí být označené atributem [&lt;Measure&gt;].</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Formátovací řetězec {0} se nedá parsovat.</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Neočekávané dekódování AutoOpenAttribute</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Citace nemůže zahrnovat výrazy, které volají omezení členů, ani nemůže používat operátory, které se na volání omezení členů implicitně překládají.</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Soubory v knihovnách nebo aplikacích s víc soubory musí začínat deklarací oboru názvů nebo modulu. Pokud na začátku souboru použijete deklaraci modulu, není povolený znak =. Pokud to je modul nejvyšší úrovně, zvažte odebrání znaku = pro vyřešení této chyby.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Pole {0} se v tomto výrazu záznamu nebo vzoru vyskytuje dvakrát.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Očekával se poskytnutý typ s názvem {0}, ale Name u poskytnutého typu má hodnotu {1}.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Očekával se poskytnutý typ s cestou {0}, ale cesta poskytnutého typu je {1}.</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Počet argumentů pro vlastní atribut neodpovídá očekávanému počtu argumentů pro konstruktor atributu.</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Člen {0} je použitý neplatným způsobem. Použití členu {1} se odvozuje před jeho definicí na pozici {2} nebo blízko ní. To je neplatný dopředný odkaz.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>Událost {0} u poskytnutého typu {1} nepřebírá žádnou hodnotu od GetRemoveMethod().</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Očekává se klíč RSA</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Všechny typy záznam, sjednocení a struktura v knihovně FSharp.Core.dll musí mít explicitní označení StructuralComparison nebo NoComparison.</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Typ sjednocení pro případ sjednocení {0} se definoval pomocí atributu RequireQualifiedAccessAttribute. Do jména, které používáte, přidejte název typu sjednocení ({1}).</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Aktivní vzory nemůžou vracet víc než 7 možností.</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>Není definovaná hodnota nebo konstruktor {0}.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Deklarace inherit má argumenty, ale není v typu s primárním konstruktorem. Zvažte možnost přidat do definice typu argumenty, třeba type X(args) = ...</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Typy rozlišených sjednocení jsou vždycky zapečetěné.</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Neočekávaná poznámka GetSet u vlastnosti</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Toto není platná hodnota pro literál výčtu.</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Neplatný modul/výraz/typ</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} přetížení</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 přetížení</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Očekává se typ podporující operátor {0}, ale předává se typ řazené kolekce členů.</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>Sestavení {0} je uvedené na příkazovém řádku. Sestavení by se měla odkazovat pomocí příznaků příkazového řádku, jako je třeba -r.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>Název {0} poskytnutého typu má hodnotu null nebo je prázdný.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Duplicitní metoda. Abstraktní metoda {0} má stejný název a signaturu jako abstraktní metoda ve zděděném typu.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>taky z: {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Metodu pole {0} poskytuje modul runtime a nedá se v kódu použít přímo. U operací s prvky polí zvažte možnost použití skupiny funkcí GetArray/SetArray z modulu LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Atribut přístupu {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vždycky privátní.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Poskytnuté typy generované tímto použitím zprostředkovatele typu možná nepůjde použít v jiných sestaveních F# a měly by se označit jako interní nebo privátní. Zvažte použití notace type internal TypeName = ... nebo type private TypeName = ...</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Přidejte . pro přístup indexeru.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Vazby DLLImport musí být statickými členy v definici třídy nebo funkce v modulu.</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>Funkce nebo člen {0} se používá způsobem, který vyžaduje, aby se k jeho definici doplnily další poznámky typu. Je to kvůli zajištění konzistence odvozených typů. Odvozená signatura je {1}.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Tato metoda už má výchozí implementaci.</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Modul {0} obsahuje hodnotu\n    {1},    \nale jeho signatura definuje hodnotu\n    {2}.    \nZkompilovaná reprezentace této metody je členem instance, ale signatura určuje její zkompilovanou reprezentaci jako statického člena.</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Toto není platný bajtový literál.</value>
  </data>
</root>