<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fsiUnexpectedThreadAbortException" xml:space="preserve">
    <value>- 事件處理時發生未預期的 ThreadAbortException (Ctrl-C): 正嘗試重新啟動...</value>
  </data>
  <data name="fsiProductNameCommunity" xml:space="preserve">
    <value>適用於 F# {0} 的 F# Interactive</value>
  </data>
  <data name="fsiDidAHashrWithLockWarning" xml:space="preserve">
    <value>--&gt; 參考的 '{0}' (檔案可能已被 F# Interactive 處理序鎖定)</value>
  </data>
  <data name="fsiTimeInfoMainString" xml:space="preserve">
    <value>實際: {0}，CPU: {1}，GC {2}</value>
  </data>
  <data name="fsiReadline" xml:space="preserve">
    <value>支援主控台中的 TAB 鍵自動完成 (預設為開啟)</value>
  </data>
  <data name="fsiIntroTextHashloadInfo" xml:space="preserve">
    <value>載入指定的檔案，視為已編譯及已參考</value>
  </data>
  <data name="fsiFailedToResolveAssembly" xml:space="preserve">
    <value>無法解析組件 '{0}'</value>
  </data>
  <data name="fsiIntroTextHeader2commandLine" xml:space="preserve">
    <value>  F# Interactive 命令列選項: </value>
  </data>
  <data name="fsiIntroTextHashquitInfo" xml:space="preserve">
    <value>結束</value>
  </data>
  <data name="fsiRemaining" xml:space="preserve">
    <value>將其餘引數視為命令列引數，使用 fsi.CommandLineArgs 存取</value>
  </data>
  <data name="fsiEmitDebugInfoInQuotations" xml:space="preserve">
    <value>發出在引號內的偵錯資訊</value>
  </data>
  <data name="fsiAbortingMainThread" xml:space="preserve">
    <value>- 正在中止主執行緒...</value>
  </data>
  <data name="fsiAdvanced" xml:space="preserve">
    <value>- 進階 -</value>
  </data>
  <data name="fsiIntroTextHashrInfo" xml:space="preserve">
    <value>參考 (以動態方式載入) 所指定的 DLL</value>
  </data>
  <data name="fsiDidAHashI" xml:space="preserve">
    <value>--&gt; 已將 '{0}' 加入程式庫 Include 路徑</value>
  </data>
  <data name="fsiDidAHashr" xml:space="preserve">
    <value>--&gt; 參考的 '{0}'</value>
  </data>
  <data name="fsiIntroTextHashtimeInfo" xml:space="preserve">
    <value>切換計時開/關</value>
  </data>
  <data name="fsiIntroTextHashIInfo" xml:space="preserve">
    <value>加入所參考 DLL 的指定搜尋路徑</value>
  </data>
  <data name="fsiIntroTextHeader1directives" xml:space="preserve">
    <value>  F# Interactive 指示詞: </value>
  </data>
  <data name="fsiLoadingFilesPrefixText" xml:space="preserve">
    <value>正在載入</value>
  </data>
  <data name="stoppedDueToError" xml:space="preserve">
    <value>已因錯誤而停止\n</value>
  </data>
  <data name="fsiInterrupt" xml:space="preserve">
    <value>\n- 中斷\n</value>
  </data>
  <data name="fsiInvalidAssembly" xml:space="preserve">
    <value>'{0}' 不是有效的組件名稱</value>
  </data>
  <data name="fsiExceptionDuringPrettyPrinting" xml:space="preserve">
    <value>\n\n美化顯示期間發生例外狀況。\n請回報此問題以便修正。\n追蹤: {0}\n</value>
  </data>
  <data name="fsiTurnedTimingOff" xml:space="preserve">
    <value>--&gt; 計時現已關閉</value>
  </data>
  <data name="fsiDidAHashrWithStaleWarning" xml:space="preserve">
    <value>--&gt; 已參考 '{0}' (已經從這個位置參考有不同時間戳記的組件，請重設 fsi 以載入更新的組件)</value>
  </data>
  <data name="fsiLanguage" xml:space="preserve">
    <value>- 語言 -</value>
  </data>
  <data name="fsiMiscellaneous" xml:space="preserve">
    <value>- 其他 -</value>
  </data>
  <data name="fsiConsoleProblem" xml:space="preserve">
    <value>啟動 F# Interactive 處理序時發生問題。這可能是因為背景處理序主控台對於支援某些 Windows 系統上具備 Unicode 支援功能之應用程式的已知問題所造成。請嘗試選取 [工具] -&gt; [選項] -&gt; [F# Interactive for Visual Studio]，然後輸入 '--fsi-server-no-unicode'。</value>
  </data>
  <data name="fsiIntroTextHashhelpInfo" xml:space="preserve">
    <value>顯示說明</value>
  </data>
  <data name="fsiTurnedTimingOn" xml:space="preserve">
    <value>--&gt; 計時現已開啟</value>
  </data>
  <data name="fsiIntroTextHeader3" xml:space="preserve">
    <value>      相關選項請參閱 '{0}'</value>
  </data>
  <data name="fsiExceptionRaisedStartingServer" xml:space="preserve">
    <value>啟動遠端處理伺服器時發生例外狀況。\n{0}</value>
  </data>
  <data name="fsiInvalidDirective" xml:space="preserve">
    <value>無效的指示詞 '#{0} {1}'</value>
  </data>
  <data name="fsiProductName" xml:space="preserve">
    <value>Microsoft (R) F# Interactive 版本 {0}</value>
  </data>
  <data name="fsiBindingSessionTo" xml:space="preserve">
    <value>正在將工作階段繫結到 '{0}'...</value>
  </data>
  <data name="fsiCodeGeneration" xml:space="preserve">
    <value>- 程式碼產生 -</value>
  </data>
  <data name="fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration" xml:space="preserve">
    <value>gen</value>
  </data>
  <data name="fsiDirectoryDoesNotExist" xml:space="preserve">
    <value>目錄 '{0}' 不存在</value>
  </data>
  <data name="fsiCouldNotInstallCtrlCHandler" xml:space="preserve">
    <value>無法安裝 ctrl-c 處理常式，Ctrl-C 處理將無法使用。錯誤為:\n\t{0}</value>
  </data>
  <data name="fsiLineTooLong" xml:space="preserve">
    <value>警告: 行太長，將忽略某些字元\n</value>
  </data>
  <data name="fsiUse" xml:space="preserve">
    <value>啟動時使用所指定的檔案做為初始輸入</value>
  </data>
  <data name="fsiGui" xml:space="preserve">
    <value>在 Windows Form 事件迴圈上執行互動 (預設為開啟)</value>
  </data>
  <data name="shadowCopyReferences" xml:space="preserve">
    <value>避免參考遭 F# 互動式處理序封鎖</value>
  </data>
  <data name="fsiBanner3" xml:space="preserve">
    <value>如需說明，請輸入 #help;;</value>
  </data>
  <data name="fsiInputFiles" xml:space="preserve">
    <value>- 輸入檔 -</value>
  </data>
  <data name="fsiHelp" xml:space="preserve">
    <value>顯示此訊息 (簡短形式: -?)</value>
  </data>
  <data name="fsiLoad" xml:space="preserve">
    <value>#load 啟動時指定的檔案</value>
  </data>
  <data name="fsiExec" xml:space="preserve">
    <value>載入檔案或執行命令列上指定的 .fsx 指令碼後結束 fsi</value>
  </data>
  <data name="fsiExit" xml:space="preserve">
    <value>\n- 結束...\n</value>
  </data>
  <data name="fsiErrorsAndWarnings" xml:space="preserve">
    <value>- 錯誤和警告 -</value>
  </data>
  <data name="fsiQuiet" xml:space="preserve">
    <value>禁止 fsi 寫入 stdout</value>
  </data>
  <data name="fsiUsage" xml:space="preserve">
    <value>使用方式: {0} &lt;options&gt; [script.fsx [&lt;arguments&gt;]]</value>
  </data>
</root>