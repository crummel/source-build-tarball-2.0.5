<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 형식 약어에 대해 이 위치에 허용되지 않습니다.</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>정적 링크에는 .EXE를 포함할 수 없습니다.</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>'{0}' 속성은 읽을 수 없습니다.</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>'use' 바인딩의 형식은 'use &lt;var&gt; = &lt;expr&gt;'이어야 합니다.</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler 버전 {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>레코드, 구조체 또는 클래스 필드 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>제공된 '{1}' 형식에 잘못된 멤버('{0}')가 있습니다. 제공된 형식 멤버는 공용이어야 하며 제네릭, 가상 또는 추상 멤버여서는 안 됩니다.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}'는 올바른 식이 아닙니다. 레코드에는 하나 이상의 필드를 포함해야 합니다. 빈 시퀀스는 Seq.empty 또는 빈 목록 '[]'를 사용하여 지정합니다.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>{0}을(를) 동적으로 호출하는 작업은 지원되지 않습니다.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralEquality' 특성이 있지만 형식 매개 변수 '{1}'이(가) 'equality' 제약 조건을 만족하지 않습니다. 형식 매개 변수에 'equality' 제약 조건을 추가하십시오.</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralEquality' 특성이 있지만 구성 요소 형식 '{1}'이(가) 'equality' 제약 조건을 만족하지 않습니다.</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>대신 별도의 레코드 형식을 사용하십시오.</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>지금은 '{0}' 변수의 주소를 사용할 수 없습니다. 메서드 또는 함수가 이 로컬 값의 주소를 반환할 수 없습니다.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>'{0}' 어셈블리를 읽을 수 없습니다.</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>제네릭 구문을 사용하려면 '{0}' 형식이 CLI 또는 F# 구조체 형식이어야 합니다.</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>'{0}' 형식 공급자가 GetInvokerExpression에서 null을 반환했습니다.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>'{0}.dll'에 대한 다중 참조는 허용되지 않습니다.</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>짝이 맞지 않는 인용구 연산자 이름('{0}'(으)로 시작)입니다.</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>선언된 형식에 구현이 없는 메서드 또는 기본 구현이 있는 가상 메서드를 나타냅니다.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>정적 링크에는 관리되는/관리되지 않는 형식이 혼합된 DLL을 포함할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>동일한 형식 또는 모듈에서 코딩하기 위해 멤버에 대한 액세스를 제한합니다.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>’{0}' 형식은 printf 스타일의 서식 문자열을 사용함으로 인해 발생하는 어떤 {1} 형식과도 호환되지 않습니다.</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>확장 멤버가 연산자 오버로드를 제공할 수 없습니다.  대신 연산자를 형식 정의의 일부분으로 정의하십시오.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' 변수가 잘못된 방식으로 사용되었습니다.</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}'은(는) 개체 형식을 생성하는 데에만 사용할 수 있습니다.</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>예기치 않은 토큰 '{0}' 또는 불완전한 식</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>필드 이름에는 '_'을(를) 사용할 수 없습니다.</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>속성 getter 또는 setter에 대해 여러 액세스 가능성이 지정되었습니다.</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>생성자는 인수에 적용해야 하며 첫 번째 클래스 값으로 사용할 수 없습니다. 필요한 경우 익명 함수 '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'을 사용하십시오.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>버전 파일 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>멤버 지정을 포함하는 재귀적 바인딩은 형식의 직접 확대로만 발생할 수 있습니다.</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>추상 슬롯에 대한 재귀 참조가 잘못되었습니다.</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>인용구에는 인라인 어셈블리 코드 또는 배열에 대한 패턴 일치를 포함할 수 없습니다.</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>개체는 상속된 개체 생성자를 호출하고 각 필드에 값을 할당하는 개체 생성 식으로 초기화해야 합니다.</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>쿼리 연산자의 인수에는 'where (x &gt; y)' 또는 'groupBy (x.Length / 10)'과 같이 괄호가 필요할 수 있습니다.</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>경고 수준(0-5)을 설정합니다.</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>이 사용법 메시지를 표시합니다(약식: -?).</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>UnknownWrapper\DispatchWrapper 클래스를 사용하려면 System.Runtime.InteropServices 어셈블리가 필요합니다.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>모듈</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>할당 왼쪽에 잘못된 식이 있습니다.</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>인라인 지정이 잘못되었습니다.</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>형식이 지정된 코드 인용을 구분합니다.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet은 구문 분석 트리에만 필요합니다.</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>파일 이름 '{0}'에 문제가 있습니다. 경로에 잘못된 문자가 있습니다.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(설명 로드 중...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>'{0}' 형식은 'comparison' 제약 조건을 지원하지 않는 하나 이상의 구조적 요소 형식을 포함하는 레코드, 공용 구조체 또는 구조체이므로 'comparison' 제약 조건을 지원하지 않습니다. 이 형식의 경우 비교를 사용하지 말거나 형식에 'StructuralComparison' 특성을 추가하여 비교를 지원하지 않는 필드 형식을 확인하십시오.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>'{0}' 형식은 'comparison' 제약 조건을 지원하지 않습니다. 예를 들어, 이 형식은 'System.IComparable' 인터페이스를 지원하지 않습니다.</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>'{0}' 형식은 'NoComparison' 특성을 가지므로 'comparison' 제약 조건을 지원하지 않습니다.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>'System.Diagnostics.ConditionalAttribute' 특성은 메서드 또는 특성 클래스에만 사용할 수 있습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>CLI 표현이 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>레이블이 지정된 형식 인수에 구문 오류가 있습니다.</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>속성에는 명시적 형식 매개 변수를 지정할 수 없습니다. 대신 메서드를 사용하십시오.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>UTF-8 인코딩으로 메시지를 출력합니다.</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>이 어셈블리의 두 부분에서 네임스페이스 '{1}'에 '{0}'(이)라는 모듈 및 형식 정의가 발생합니다.</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>이름 '{0}'은(는) 패턴 컨텍스트에 바인딩되지 않았습니다.</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>형식 공급자 생성자에서 예외가 발생했습니다. {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>제공된 형식 또는 메서드 '{1}'에 대한 참조를 확인할 때 알 수 없는 정적 인수 종류('{0}')가 발견되었습니다.</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>사용자 지정 연산자 '{0}'의 정의에서 올바른 특성 플래그 조합을 사용하지 않습니다.</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0}이(가) 정적 메서드로 표시되었지만 적절한 람다 식이 아니었습니다.</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>이 숫자는 부호 없는 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>특성은 이 구문에서 무시되었습니다.</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' 뒤에는 'in'이 와야 합니다. 사용법: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IEquatable&lt;_&gt;' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomEquality' 특성을 적용하고 제네릭이 아닌 재정의 'System.Object.Equals(obj)'에 대한 일관된 구현을 제공하십시오.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>소스 파일이 너무 커서 이식 가능한 PDB에 포함할 수 없습니다.</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>개체 생성자를 사용하려면 인수가 필요합니다.</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>F# 컴파일 DLL '{0}'에 대한 메타데이터를 읽는/쓰는 동안 오류가 발생했습니다. DLL이 이전 버전의 F# 컴파일러를 사용하여 컴파일되었습니까?(오류: '{1}')</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>인터페이스에는 멤버 재정의의 정의를 포함할 수 없습니다.</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>이 식별자에 대해 다중 표시 유형 특성이 지정되었습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>시그니처가 추상 클래스이지만 구현은 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 구현에 [&lt;AbstractClass&gt;] 특성을 추가하세요.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>제공된 '{0}' 형식에 포함된 멤버 '{1}'의 선언 형식이 '{2}'입니다. 제공된 형식과 같은 선언 형식이 필요합니다.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class', 'interface' 또는 'struct'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>관련 형식 및 모듈 그룹과 이름을 연결하기 위해 사용되며, 다른 코드와 논리적으로 구별하기 위해 사용됩니다.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>'{0}' 네임스페이스 또는 모듈이 정의되지 않았습니다.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>이 공용 구조체 케이스는 하나의 인수를 사용합니다.</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>예기치 않은 빈 형식 moduleDefn 목록입니다.</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>패턴 일치의 부울 조건(가드 시)으로 사용되며, 제네릭 형식 매개 변수에 대한 제약 조건 절을 지정하는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>패턴 일치 식에서 일치 키워드와 함께 사용됩니다. 또한 개체 식, 레코드 복사 식, 형식 확장에 사용되어 멤버 정의를 지정하고 예외 처리기를 지정합니다.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>.NET void 형식을 나타냅니다. 다른 .NET 언어와 상호 운용할 때 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>조건식에 사용됩니다. 또한 개체 생성 후 파생 작업을 수행하는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>클래스, 레코드, 구조체, 구분된 공용 구조체, 열거형 형식, 측정 단위 또는 형식 약어를 선언하는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>한정자 없이 사용할 수 있는 네임스페이스 또는 모듈의 콘텐츠를 만드는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>개체가 없음을 나타냅니다. 제네릭 매개 변수 제약 조건에서도 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>계층 구조에서 더 높은 형식으로 형식을 변환합니다.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>기본 클래스 개체의 이름으로 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>결과가 필요한 경우에만 수행되는 계산을 지정하는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>조건부 분기에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>조건부 분기에 사용됩니다. else if의 약식입니다.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>자세한 구문에서 루프 식의 코드 블록 끝을 나타냅니다.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>{1} 어셈블리에 {0} DLL에 대한 참조가 필요합니다. 가져온 형식 {2}은(는) 첫 번째 어셈블리에 있으며 확인할 수 없습니다.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>이 숫자는 32비트 부동 수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>형식 정의에는 하나의 'inherit' 지정만 있을 수 있으며 이것이 첫 번째 선언이어야 합니다.</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>리터럴 값에는 제네릭 매개 변수를 지정할 수 없습니다.</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>형식 정의에 예기치 않은 인용구 연산자 '&lt;@'가 있습니다. 축자 문자열을 정적 인수로 형식 공급자에 전달하려면 '&lt;'와 '@' 문자 사이에 공백을 추가하십시오.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 특정 형식에 대한 오버로드된 비교 의미 체계를 정의하려면 해당 형식의 정의에서 'System.IComparable' 인터페이스를 구현하십시오.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>커리된 인수가 있는 메서드는 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' 또는 'CallerFilePath' 인수를 선언할 수 없습니다.</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>'--pdb' 옵션을 사용하려면 '--debug' 옵션을 사용해야 합니다.</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>값 '{0}'이(가) inline으로 표시되었지만 최적화 환경에 바인딩되지 않았습니다.</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>'{0}'은(는) 정적 속성입니다.</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>형식 매개 변수 {1}이(가) 'comparison' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'을(를) 구조적으로 비교할 수 없습니다. '{2}' 형식에 'NoComparison' 특성을 추가하여 해당 형식을 비교할 수 없음을 명확히 하십시오.</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>'{1}' 형식이 'comparison' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'을(를) 구조적으로 비교할 수 없습니다. '{2}' 형식에 'NoComparison' 특성을 추가하여 해당 형식을 비교할 수 없음을 명확히 하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>구현이 구조체를 정의하지만 시그니처는 숨겨진 표현이 있는 형식을 정의하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>참고: 로컬 제약 조건이 있는 이 제네릭 함수를 첫 번째 클래스 값으로 사용했으므로 람다 리프팅 최적화가 적용되지 않았습니다. 형식 제약 조건을 추가하면 이 상황이 해결될 수 있습니다.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>'let! x = coll'은 시퀀스 식에 사용할 수 없습니다. 대신 'for x in coll'을 사용하십시오.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'mutable' 한정자가 서로 다릅니다.</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>MDB 파일의 이름은 &lt;어셈블리 파일 이름&gt;.mdb여야 합니다. --pdb 옵션은 무시됩니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 메서드의 컴파일 표현이 정적 멤버이지만 시그니처는 해당 컴파일 표현이 인스턴스 멤버임을 나타냅니다.</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DllImport 특성을 디코딩할 수 없습니다.</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>'base' 키워드가 잘못된 방식으로 사용되었습니다. 기본 호출은 클로저에 사용할 수 없습니다. 전용 멤버를 사용하여 기본 호출을 수행하십시오.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new'는 명명된 형식에 사용해야 합니다.</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>이 형식 약어에는 간략화되는 형식에 나타나지 않는 하나 이상의 선언된 형식 매개 변수가 있습니다. 형식 약어는 간략화되는 형식에 있는 모든 선언된 형식 매개 변수를 사용해야 합니다. 하나 이상의 형식 매개 변수를 제거하거나 내부 형식을 래핑하는 구체적인 형식 정의(예: 'type C&lt;'a&gt; = C of ...')를 사용하십시오.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>지시 파일 이름 '{0}'이(가) 비어 있거나, 잘못된 문자를 포함하거나, 드라이브 사양에 절대 경로가 없거나, 길이가 너무 깁니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>이 재정의에 해당하는 추상 속성을 찾을 수 없습니다.</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>포함된 IL을 구문 분석하는 동안 오류가 발생했습니다.</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>DLLImport 스텁은 인라인할 수 없습니다.</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>패턴이 잘못되었습니다.</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>단순 메서드 이름이 여기에 필요합니다.</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>'member val' 정의는 기본 생성자가 포함된 형식에서만 허용됩니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보십시오.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>'{0}' 플래그를 두 번 설정했습니다.</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>인용구에는 개체 식을 포함할 수 없습니다.</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>'inline'으로 표시된 값에 예기치 않은 값이 있습니다.</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>'match' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>'{0}' 속성의 이름이 '{1}' 형식의 다른 속성과 같지만 하나는 인덱서 인수를 사용하고 다른 하나는 그렇지 않습니다. 속성 중 하나에 대한 인덱서 인수가 없을 수 있습니다.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>식별자 다음에 '{0}'이(가) 있는 형식은 나중에 사용할 수 있도록 예약되었습니다.</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>명시적 형식 매개 변수는 모듈 또는 멤버 바인딩에 대해서만 사용할 수 있습니다.</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>제공된 '{1}' 형식의 '{0}' 속성에서 CanWrite=fa인데 GetSetMethod()에서 메서드를 반환했습니다.</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>인용구의 디버그 정보를 내보냅니다.</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>기본 Win32 매니페스트를 포함하지 마십시오.</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>활성 인식기</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>'CompiledName' 특성은 이 언어 요소에 사용할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>변경될 수 있는 값인 변수를 선언하는 데 사용됩니다.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>'{0}' 파일 또는 모듈의 시그니처가 이미 지정되었습니다.</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>인용구에는 공용 구조체 케이스 필드를 설정하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>이 형식 정의에는 약어를 통해 직접 순환 참조가 사용됩니다.</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>'--targetprofile'에 대한 값 '{0}'이(가) 잘못되었습니다. 올바른 값은 'mscorlib' 또는 'netstandard'입니다.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>'use' 바인딩은 기본 생성자에서 허용되지 않습니다.</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>구조체는 멤버 선언에서만 'this' 매개 변수를 바인딩할 수 있습니다.</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>모든 열거형 필드에는 값을 지정해야 합니다.</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>개체 식에는 'member val' 또는 'override val' 정의를 사용할 수 없습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>시그니처에 의해 예외 약어가 숨겨져 있으므로 예외 정의가 호환되지 않습니다. 약어는 다른 CLI 언어에 표시되어야 합니다. 시그니처에서 약어를 표시하십시오. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>예외 발생 여부에 상관없이 실행되는 코드 블록을 지정하기 위해 try와 함께 사용됩니다.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>사용자 지정 마샬러는 F# 코드에 지정할 수 없습니다. C# 도우미 함수를 사용하십시오.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>'{0}'의 구현 중 올바른 수의 인수 및 형식 매개 변수를 포함하는 구현이 없습니다. 필요한 시그니처는 '{1}'입니다.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>메서드 재정의 및 인터페이스 구현은 여기에 허용되지 않습니다.</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>FieldOffset 특성을 디코딩할 수 없습니다.</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>시그니처 파일 '{0}'에 해당하는 구현 파일이 없습니다. 구현 파일이 있는 경우 시그니처 파일과 구현 파일의 'module' 및 'namespace' 선언이 일치하는지 확인하십시오.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>'{0}' 연산자를 다시 정의할 수 없습니다. 다른 연산자 이름을 사용하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>시그니처에 약어가 있지만 구현에는 없으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>형식 매개 변수 '{0}'이(가) 정의되지 않았습니다.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>기본 클래스 또는 기본 인터페이스를 지정하는 데 사용됩니다.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>들여쓰기가 잘못되었을 수 있습니다. 이 토큰은 {0} 위치에서 시작된 컨텍스트를 벗어납니다. 이 토큰을 더 들여쓰거나 표준 서식 규칙을 사용하십시오.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에는 다음이 포함되어 있습니다.\n    {1}    \n하지만 해당 시그니처는 다음을 지정합니다.\n    {2}    \n표시 이름이 다릅니다.</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>이 리터럴 식 또는 특성 인수를 사용하면 산술 연산 오버플로가 발생합니다.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>선택적 인수는 사용자 지정 특성에 사용할 수 없습니다.</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>지정한 어셈블리 및 이 어셈블리에 종속된 모든 참조 DLL을 정적으로 링크합니다. DLL 이름이 아니라 어셈블리 이름을 사용하십시오(예: mylib).</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>주석에 포함된 축자 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n리터럴 상수 값 및/또는 특성이 서로 다릅니다.</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>이 유니코드 인코딩은 문자열 리터럴에서만 올바릅니다.</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}'은(는) 선택적 인수에만 적용할 수 있습니다.</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>이 작업을 수행하려면 지역 변수 또는 기타 특수 표현을 사용하여 표시된 값 '{0}'의 주소를 사용해야 합니다. 이는 올바르지 않습니다.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>기본 CLI 어셈블리를 기본적으로 참조하지 마십시오.</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>FSharp.Core에서 '{0}' 파일을 찾을 수 없습니다. 파일이 {1}에 있어야 합니다. 이 파일이 더 이상 필요하지 않은 최신 버전의 FSharp.Core로의 업그레이드를 고려해 보세요.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>시그니처가 이 형식에서 null을 표현으로 사용할 수 있다고 하지만 구현은 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>주석의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'에 인수 또는 설정 가능한 반환 속성 '{1}'이(가) 없습니다. {2}</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>지원되지 않는 상수 형식 '{0}'입니다. 형식 공급자가 제공하는 인용에는 간단한 상수만 포함될 수 있습니다. 인용구 리터럴 내에서 'let' 바인딩이 되려면 선언된 값을 제공된 인용구 리터럴 밖으로 이동시켜 형식 공급자의 구현을 조정해야 합니다.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>부분 활성 패턴은 하나의 결과만 생성할 수 있습니다.</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>'{0}' 형식은 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>이 목록 식은 목록 리터럴의 최대 크기를 초과합니다. 보다 큰 리터럴을 위한 배열을 사용하고 Array.ToList를 호출하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>구현 형식이 봉인되어 있지만 시그니처는 봉인되어 있지 않음을 암시하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 시그니처에 [&lt;Sealed&gt;] 특성을 추가하세요.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>명명된 인수 '{0}'이(가) 어떠한 인수 또는 변경할 수 있는 속성과도 일치하지 않습니다.</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>제약 조건이 잘못되었습니다. 제약 조건에 사용된 형식이 봉인되었습니다. 즉, 최대 하나의 솔루션을 통해서만 해당 제약 조건을 만족시킬 수 있습니다.</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>예기치 않은 '{0}' 문자입니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>시그니처에 의해 CLI 예외 매핑이 숨겨져 있으므로 예외 정의가 호환되지 않습니다. 예외 매핑은 다른 모듈에 표시되어야 합니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>모듈 약어의 특성을 무시합니다.</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>측정 단위가 아니라 형식이 필요합니다.</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>'{0}' 형식이 'System.IComparable'을 명시적으로 구현하지만 'Object.Equals'에 해당하는 재정의를 제공하지 않습니다. 'System.IComparable'을 통해 구현된 'Object.Equals'의 구현이 자동으로 제공되었습니다. 재정의 'Object.Equals'를 명시적으로 구현하십시오.</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>'{1}'에 필요한 '{0}' 어셈블리를 확인할 수 없습니다.</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>상수 식을 잘못 변경했습니다. 식을 변경할 수 있는 로컬로 복사하십시오(예: 'let mutable x = ...').</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>특정 경고를 오류로 보고합니다.</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>{0}에서 {1}(으)로의 변환은 컴파일 시간에 안전한 업캐스트이며 다운캐스트가 아닙니다. '다운캐스트'가 아닌 '업캐스트'를 사용해 보세요.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>'{0}' 식별자는 F#에서 나중에 사용할 수 있도록 예약되었습니다.</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>라이브러리 또는 다중 파일 응용 프로그램의 파일은 네임스페이스 또는 모듈 선언으로 시작해야 합니다(예: 'namespace SomeNamespace.SubNamespace' 또는 'module SomeNamespace.SomeModule'). 응용 프로그램의 마지막 소스 파일만 선언이 없어도 됩니다.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>바인딩을 'use'와 'rec' 모두로 표시할 수 없습니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>형식 인수에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 가상 요소이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>이 인덱서 표기법은 F# 언어에서 제거되었습니다.</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' 형식이 잘못된 방식으로 사용되었습니다. '{1}' 앞에 있는 값에 '{2}'을(를) 사용하는 유추 형식이 있습니다. 이는 잘못된 전방 참조입니다.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>메서드가 중복되었습니다. '{0}' 메서드의 이름 및 시그니처가 '{1}' 형식의 다른 메서드와 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>내부 오류 또는 잘못된 형식의 메타데이터: 가져오기 작업을 수행하는 동안 범위 내의 형식 매개 변수가 부족했습니다.</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>로컬 호출에 대한 형식 인수 수가 잘못되었습니다.</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>'module ... : sig .. end' 구문은 F# 코드에서 사용되지 않습니다. 'module ... = begin .. end'를 사용하십시오.</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>인터페이스 형식이 필요합니다.</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>이름 '({0})'에는 고정 형식에 대한 F# 라이브러리의 표준 정의가 지정되어 있으므로 해당 이름을 멤버 이름으로 사용하면 안 됩니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>형식 정의에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>측정 단위 매개 변수 '{0}'의 값이 잘못되었습니다.</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>측정 단위 매개 변수 '{1}'의 값 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>속성 getter의 형식이 잘못되었습니다. 명시적 구문을 사용할 때는 하나 이상의 '()' 인수가 필요합니다.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>제공된 형식을 설정하는 동안 하나 이상의 오류가 확인되었습니다.</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>인터페이스에 대한 생성자 식에는 인수가 사용되지 않습니다.</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>경고 수준 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>이름이 '{0}'인 공용 구조체가 생성된 형식 '{1}'과(와) 충돌합니다.</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>'{0}' 멤버는 재정의 또는 구현할 수 있는 어떠한 추상 또는 가상 메서드에도 해당하지 않습니다.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>레코드 생성이 잘못되었습니다.</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n필드의 형식이 서로 다릅니다.</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>{0} 레이블을 찾을 수 없습니다.</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>활성 패턴 '{0}'에 입력으로 확인되지 않는 형식 변수가 포함된 결과 형식이 있습니다. 이는 일반적으로 결과 케이스가 지정되지 않은 경우 발생합니다(예 'let (|A|B|) (x:int) = A x'). 이 문제는 형식 제약 조건을 지정하여 해결할 수 있습니다(예: 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x').</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요하지만 여기에서는 {2}개의 명명되지 않은 인수와 {3}개의 명명된 인수가 지정되었습니다. 필요한 시그니처는 '{4}'입니다.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>'{0}' 형식/모듈이 구체적인 모듈 또는 형식이 아닙니다.</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- 출력 파일 -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>사용 가능한 오버로드가 아래 또는 [오류 목록] 창에 표시됩니다.</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}'에 사용된 인수의 수가 잘못되었습니다. 이 항목은 이 쿼리나 계산 식의 사용자 지정 연산입니다. {1}개의 인수가 필요한데 {2}개가 제공되었습니다.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0}은(는) 인스턴스 메서드가 아닙니다.</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>이러한 형식의 개체 식은 F#에서 사용되지 않습니다. 'member this.MemberName ... = ...'을 사용하여 개체 식에 멤버 구현을 정의하십시오.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>재귀적 유추 지점에 예기치 않은 식이 있습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>추상 멤버 '{2}'이(가) 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>'{0}' 메서드 또는 함수는 해당 형식 매개 변수를 명시적으로 선언하지 않으므로 이 함수에 명시적 형식 인수를 지정하면 안 됩니다.</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>'{0}' 형식에 인라인 어셈블리 코드 표현이 있습니다.</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>재귀 값은 재귀적 바인딩 내에서 '{1}' 형식의 변경할 수 없는 필드 '{0}'에 직접 할당할 수 없습니다. 대신 변경할 수 있는 필드를 사용하십시오.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>ML 호환성 경고를 무시합니다.</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>중위 연산자 멤버 '{0}'에 인수가 없습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>인터페이스에는 구체적인 멤버의 정의를 포함할 수 없습니다. 사용자 형식에 대한 생성자를 정의하여 해당 형식이 클래스임을 나타내야 할 수 있습니다.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>'.' 뒤에 한정자가 없습니다.</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>제네릭 형식 '{0}'의 인스턴스가 없으며 이 멤버의 반환 형식 또는 인수로부터 해당 인스턴스를 유추할 수 없습니다. 이 형식에 액세스할 때 형식 인스턴스를 제공하십시오(예: '{1}').</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>활성 패턴 케이스 식별자는 대문자로 시작해야 합니다.</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>이 서식 지정자에서 'h' 또는 'H'는 불필요합니다. 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>식 형식 'expr then expr'은 명시적 개체 생성자의 일부로만 사용할 수 있습니다.</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>'base' 값은 재정의된 멤버의 기본 구현에 대한 직접 호출을 수행하는 데에만 사용할 수 있습니다.</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>올바른 상수 식 또는 사용자 지정 특성 값이 아닙니다.</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>이 재귀적 바인딩은 잘못된 재귀적 형식 조합을 사용합니다.</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IComparable&lt;_&gt;' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용하고 제네릭이 아닌 인터페이스 System.IComparable에 대한 일관된 구현도 제공해야 합니다.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>할당이 잘못되었습니다.</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>첫 번째 클래스 함수의 형식에는 byref를 포함할 수 없습니다.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>'{0}' 형식은 함수 형식이므로 'equality' 제약 조건을 지원하지 않습니다.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>'{0}' 형식은 'equality' 제약 조건을 지원하지 않는 하나 이상의 구조적 요소 형식을 포함하는 레코드, 공용 구조체 또는 구조체이므로 'equality' 제약 조건을 지원하지 않습니다. 이 형식의 경우 같음 조건을 사용하지 말거나 형식에 'StructuralEquality' 특성을 추가하여 같음 조건을 지원하지 않는 필드 형식을 확인하십시오.</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>'{0}' 형식은 'NoEquality' 특성을 가지므로 'equality' 제약 조건을 지원하지 않습니다.</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'use!' 키워드와 같은 열로 들여써야 합니다.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>형식 구문 'int C' 및 'C  &lt;int&gt;'는 여기에 허용되지 않습니다. 이 형식이 'C&lt;int&gt;' 형식으로 작성되도록 조정하십시오.</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>접두사 플래그(' ' 또는 '+')를 두 번 설정했습니다.</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>AssemblyFolders 레지스트리 키로 찾았습니다.</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>이 생성자는 시퀀스 또는 계산 식 내에서만 사용할 수 있습니다.</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>포함된 IL 형식을 구문 분석하는 동안 오류가 발생했습니다.</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>리터럴 값에는 [&lt;ThreadStatic&gt;] 또는 [&lt;ContextStatic&gt;] 특성을 지정할 수 없습니다.</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>'{0}' 어셈블리에 포함된 TypeProviderAssembly 특성의 값('{1}')이 잘못되었습니다. 값은 올바른 어셈블리 이름이어야 합니다.</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>이 함수 값은 시그니처에 byref 인수가 포함된 대리자 형식을 생성하는 데 사용되고 있습니다. {0}개의 인수를 사용하는 명시적 람다 식을 사용해야 합니다.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>공통 IL 예외에 대한 약어에는 인수를 사용할 수 없습니다.</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>'{0}' 형식은 올바른 열거자 형식이 아닙니다(예: 부울을 반환하는 'MoveNext()' 메서드와 'Current' 속성이 포함되어 있지 않음).</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>지시문의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>'{0}' 형식은 정밀도를 지원하지 않습니다.</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>'{0}' 형식에 대한 생성자는 직접 또는 간접적으로 해당 암시적 개체 생성자를 호출해야 합니다. 레코드 식 대신 암시적 개체 생성자에 대한 호출을 사용하십시오.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}'이(가) 잘못 사용되었습니다. 이 항목은 이 쿼리 또는 계산 식의 사용자 지정 연산입니다.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>'[&lt;'가 일치하지 않습니다. 닫는 '&gt;]'가 필요합니다.</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>'fixed'를 잘못 사용했습니다. 'fixed'는 식이 배열, 필드의 주소, 배열 요소 또는 문자열의 주소인 경우 'use x = fixed expr' 형식의 선언에만 사용할 수 있습니다.</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>제공된 형식 이름 '{1}'에는 '{0}' 문자를 사용할 수 없습니다.</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>제공된 형식 또는 메서드 '{1}'의 정적 매개 변수 '{0}'에 값이 필요합니다. 명명된 인수(예: '{2}&lt;{3}=...&gt;')를 사용하여 형식 공급자에 대한 정적 매개 변수를 선택적으로 지정할 수 있습니다.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>예기치 않은 SynMeasure.Anon입니다.</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert'는 첫 번째 클래스 값으로 사용할 수 없습니다. 대신 'assert &lt;expr&gt;'을 사용하십시오.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>변수 형식에서 상속할 수 없습니다.</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>'{0}' 형식의 공용 구조체 케이스 또는 필드는 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>변경할 수 있는 함수 값은 'let mutable f = (fun args -&gt; ...)'로 작성해야 합니다.</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>클래스 형식만 값 인수를 사용할 수 있습니다.</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>경고 번호 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>'{0}' 형식은 비표준 대리자 형식을 가집니다.</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>'{0}' 멤버가 올바른 수의 인수를 적용하지 않습니다. {1}개의 인수가 필요하지만 {2}개 지정되었습니다. 필요한 시그니처는 '{3}'입니다.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 최종 요소이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>대리자는 커리된 시그니처를 가질 수 없습니다.</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>이 코드를 실행할 수 있는 플랫폼을 x86, Itanium, x64, anycpu32bitpreferred 또는 anycpu로 제한합니다. 기본값은 anycpu입니다.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>형식이 아니라 측정 단위가 필요합니다.</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Win32 리소스 파일(.res)을 지정합니다.</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>지역 클래스 바인딩은 inline으로 표시할 수 없습니다. 정의를 클래스 밖으로 이동하거나 inline으로 표시하지 마십시오.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(설명 없음...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>'{0}' 형식이 '{1}'에 정의되어 있지 않습니다.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>식별자가 필요합니다.</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>전처리기 식에 예기치 않은 토큰 '{0}'이(가) 있습니다.</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>'.' 뒤에 정밀도가 없습니다.</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>인용구에 할당을 포함하거나 캡처된 로컬 변수의 주소를 사용할 수 없습니다.</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>명령줄 옵션 '{0}'은(는) 테스트를 위해서만 사용됩니다.</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>'yield'가 아닌 'yield!'를 사용하세요.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>상속된 형식이 개체 모델 형식이 아닙니다.</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>프로그램의 주 모듈이 비어 있습니다. 프로그램 실행 시 아무 작업도 수행되지 않습니다.</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>{0}이(가) '{1}' 버전을 지정했지만, 이 값은 와일드카드인데 사용자가 결정적 빌드를 요청하여 문제가 발생했습니다.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>더 이상 .resx 파일({0})이 컴파일러에 소스 파일로 사용되지 않습니다. resgen.exe를 사용하여 .resx 파일을 .resources 파일로 변환해 --resource 옵션으로 전달하십시오. MSBuild를 사용하는 경우 .fsproj 프로젝트 파일의 &lt;EmbeddedResource&gt; 항목을 통해 이 작업을 수행할 수 있습니다.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>'{0}' 경로가 네임스페이스입니다. 모듈 약어가 네임스페이스의 약어가 아닐 수 있습니다.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>선언에 [&lt;Literal&gt;] 특성이 있는 경우에만 선언의 시그니처에 값을 지정할 수 있습니다.</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>제공된 형식 {1}의 '{0}'에 액세스하는 동안 예외가 발생했습니다.</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>멤버가 어셈블리 안에서는 보이지만 어셈블리 밖에서는 보이지 않도록 지정하는 데 사용됩니다.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>#if 또는 #else에 대한 #endif를 찾을 수 없습니다.</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>이전 오류로 인해 잘못된 멤버 시그니처가 발생했습니다.</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>명명된 필드 '{0}'이(가) 자동 생성된 익명 필드 이름과 충돌합니다.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>지시문이 잘못되었습니다. '#time', '#time \"on\"' 또는 '#time \"off\"'가 필요합니다.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 열거형 형식에 대해 이 위치에 허용되지 않습니다.</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>특성은 여기에 허용되지 않습니다.</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- 언어 -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>인식할 수 없는 디버그 형식 '{0}'입니다. 'pdbonly' 또는 'full'이 필요합니다.</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>'into'를 사용하는 경우 뒤에 나머지 계산 부분이 와야 합니다.</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>'reraise' 함수의 첫 번째 클래스 사용은 허용되지 않습니다.</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;'가 일치하지 않습니다. 닫는 '&gt;'가 필요합니다.</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 val '{2}'이(가) 없습니다.</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>제네릭 함수 '{0}'에는 명시적 형식 인수를 지정해야 합니다.</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>제공된 '{1}' 형식의 '{0}' 속성에서 CanRead=true인데 GetGetMethod()의 값이 없습니다.</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>메서드 반환 형식에 허용되지 않는 byref가 포함됩니다.</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>'{0}'은(는) 정적 이벤트입니다.</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>이 토큰은 나중에 사용할 수 있도록 예약되었습니다.</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>재귀 선언 그룹에서 'open' 선언은 각 모듈에서 맨 앞에 있어야 합니다.</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>제공된 '{0}' 형식에서 멤버 이름이 비어 있거나 null인 멤버를 반환했습니다.</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>l 또는 L 뒤에서 서식 지정자가 잘못되었습니다. ld, li, lo, lu, lx 또는 lX이(가) 필요합니다. F# 코드에서는 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>제공된 '{0}' 리터럴 값이 잘못되었습니다.</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>인터페이스 형식은 봉인할 수 없습니다.</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>소문자 리터럴 '{0}'이(가) 이름이 같은 새 패턴에서 섀도 처리되고 있습니다. 모듈이 접두사로 붙은 대문자 리터럴만 명명된 패턴으로 사용될 수 있습니다.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>정의되지 않은 값 '{0}'입니다.</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>이 생성자는 목록, 배열 및 시퀀스 식 내에서만 사용할 수 있습니다(예: 'seq {{ ... }}', '[ ... ]' 또는 '[| ... |]' 형식의 식). 이러한 식은 'for ... in ... do ... yield...' 구문을 사용하여 요소를 생성합니다.</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>사용자 지정 특성은 참조 형식이어야 합니다.</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>인스턴스 필드가 필요한데 정적 필드가 사용되었습니다.</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'('의 짝이 맞지 않습니다.</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>이 프로그램 지점 전의 형식 정보를 기반으로 '{0}' 메서드에 대한 고유 오버로드를 결정할 수 없습니다. 형식 주석이 필요할 수 있습니다.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'은(는) {1}이(가) 아닙니다.</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>디버그 정보를 내보냅니다(약식: -g).</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>'--keyfile' 옵션은 소스 파일 또는 추가 모듈에 지정된 'System.Reflection.AssemblyKeyFileAttribute' 특성을 재정의합니다.</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>추가 옵션을 보려면 지시 파일을 읽으세요.</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>이 'let' 정의는 쿼리에서 사용할 수 없습니다. 단순 값 정의만 쿼리에서 사용할 수 있습니다.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>보호된 멤버가 호출되었거나 'base'가 사용되고 있습니다. 이는 멤버를 직접 구현할 경우에만 허용됩니다. 이 경우 멤버가 개체 범위를 벗어날 수 있습니다.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>형식 인수는 형식 이름 바로 옆에 배치해야 합니다(예: \"C  &lt;'T&gt;\"가 아니라 \"C&lt;'T&gt;\").</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>형식 매개 변수는 형식 이름 바로 옆에 배치해야 합니다(예: type \"C   &lt;'T&gt;\"가 아니라 \"type C&lt;'T&gt;\").</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>'printf' 스타일의 서식 문자열 사용과 관련하여 본질적으로 발생하는 모호성을 해결할 수 없습니다.</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>이 'let'에 대한 반환 식에 오류가 있습니다. 들여쓰기가 잘못되었을 수 있습니다.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>관련되지 않은 여러 형식(예: '{0}'과(와) '{1}')으로 확인될 수 있으므로 이 지점 또는 이 지점 근처에서 제네릭 구문의 암시적 인스턴스를 확인할 수 없습니다. 형식 주석을 사용하여 모호성을 해결하십시오.</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>선택적 인수는 비선택적 인수 다음의 인수 목록 끝에 와야 합니다.</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>이 항목을 연산자 이름으로 구문 분석하려고 했지만 실패했습니다.</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>어셈블리를 참조합니다(약식: -r).</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>AssemblyFoldersEx 레지스트리 키로 찾았습니다.</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get', 'set' 또는 'get,set'이 필요합니다.</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}'은(는) 올바른 부동 소수점 인수가 아닙니다.</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>명령줄 옵션 '{0}'은(는) 사용되지 않습니다. 대신 '{1}'을(를) 사용하십시오.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>특성 'CustomEquality'가 지정된 형식에는 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' 또는 'System.Collections.IStructuralEquatable' 중 하나 이상에 대한 명시적 구현이 있어야 합니다.</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>형식 식에 예기치 않은 {0}이(가) 있습니다.</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>인식할 수 없는 특성 대상입니다. 올바른 특성 대상은 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'입니다.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>함수 본문이 없습니다.</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>액세스 가능성 한정자는 여기에 허용되지 않지만, '{0}'이(가) 지정되었습니다.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>형식에는 중첩 형식 정의를 포함할 수 없습니다.</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>경고 및 오류 메시지를 색으로 구분하여 출력</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>형식 이름을 잘못 사용했습니다.</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>이 값에는 올바른 속성 setter 형식이 없습니다.</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>검색 디렉터리 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>resinfo 형식이 &lt;file&gt;[,&lt;string name&gt;[,public|private]]인 경우 지정한 리소스를 이 어셈블리에 링크합니다.</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>측정 단위 지수에서 분모는 0일 수 없습니다.</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'inherit'은 인터페이스 형식에 대해 사용할 수 없습니다. 대신 'interface ... with ... end'를 사용하여 인터페이스를 구현하십시오.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>측정 단위 식에 예기치 않은 정수 리터럴이 있습니다.</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}'은(는) 명명된 형식에만 사용할 수 있습니다.</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>공용 구조체 케이스의 기본 확대</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>이 값은 함수가 아니며 적용할 수 없습니다.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>서식 지정자가 없습니다.</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>인덱서 속성에는 하나 이상의 인수가 지정되어야 합니다.</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>인식할 수 없는 대상 '{0}'입니다. 'exe', 'winexe', 'library' 또는 'module'이 필요합니다.</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'while' 식에서 'do'가 누락되었습니다. 'while &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>람다 식 본문에 예기치 않은 입력의 끝이 있습니다. 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>문서 파일에 .xml 접미사가 없습니다.</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>'-&gt;'를 시퀀스 및 계산 식에 사용할 때는 'for pat in expr -&gt; expr' 형식을 사용해야 합니다. 'for ... in ... do ... yield...' 구문을 사용하면 보다 복잡한 시퀀스 식에서 요소를 생성할 수 있습니다.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>getter 속성은 함수여야 합니다(예: 'get() = ...' 또는 'get(index) = ...').</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>짝이 맞지 않는 인용구('{0}'(으)로 시작)입니다.</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>이 숫자는 부호 없는 64비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>'{3}' 어셈블리의 '{2}' 형식에서 {0} '{1}'을(를) 찾을 수 없습니다. 가능한 원인은 버전이 호환되지 않기 때문일 수 있습니다. 참조된 모든 구성 요소에서 올바른 버전을 사용할 수 있게 하려면 이 어셈블리의 올바른 버전을 명시적으로 참조해야 할 수 있습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처와 구현의 제네릭 매개 변수 종류가 서로 다릅니다. [&lt;Measure&gt;] 특성이 없는 것 같습니다.</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>이 형식은 리터럴 필드에 사용할 수 없습니다.</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>마무리 호출을 사용하거나 사용하지 않습니다.</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>레코드 복사 및 업데이트 식에는 적어도 하나의 필드가 포함되어야 합니다.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>주석에 포함된 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>'{0}'에 대한 사용자 지정 쿼리 연산이 필요한데 지정되지 않았습니다.</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>형식의 리터럴이 잘못되었습니다.</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>'{0}' 멤버는 동일한 메서드의 여러 오버로드와 일치합니다.\n다음 중 하나로 제한하세요. {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>공용 구조체 형식이 둘 이상의 case를 포함하고 구조체인 경우 공용 구조체 형식 내의 모든 필드에 고유한 이름을 지정해야 합니다.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>제공된 '{1}' 형식의 '{0}' 속성은 CanRead=false이고 CanWrite=false이므로 읽거나 쓸 수 없습니다.</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>생성된 속성</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>형식의 정적 'val' 필드는 변경할 수 있어야 하고 Private이어야 하며 '[&lt;DefaultValue&gt;]' 특성으로 표시되어야 합니다. 이러한 필드는 해당 형식에 맞게 'null' 또는 '0' 값으로 초기화됩니다. 클래스 형식에 'static let mutable' 바인딩도 사용하십시오.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>이 메서드에서는 이 위치에 CLI 'params' 매개 변수가 필요합니다. 'params'는 다양한 수의 인수를 C#과 같은 언어의 메서드에 전달하는 방법입니다. 이 인수에 대한 배열을 전달하십시오.</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>초기화되지 않은 'val' 필드는 변경할 수 있어야 하며 '[&lt;DefaultValue&gt;]' 특성으로 표시되어야 합니다. 'val' 필드 대신 'let' 바인딩을 사용해 보십시오.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>제공된 '{0}' 형식의 'IsGenericType'이 true인데 제네릭 형식이 지원되지 않습니다.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. All rights reserved.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>인용구에는 예외 값에 필드를 설정하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>이 바이트 배열 리터럴에는 단일 바이트로 인코딩되지 않는 문자가 포함되어 있습니다.</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>특성은 'val' 앞에 배치해야 합니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>구현이 {2} '{3}'을(를) 정의하지만 시그니처는 그렇지 않거나 그렇더라도 순서가 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>익명 측정 단위는 다른 측정 단위 식 내에 중첩할 수 없습니다.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>형식 매개 변수 '{0}'의 선언을 사용하려면 {1} 형식의 제약 조건이 필요하므로 시그니처와 구현이 호환되지 않습니다.</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>형식 또는 모듈입니다.</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>제공된 중첩 형식은 정적 인수 또는 제네릭 매개 변수를 사용하지 않습니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>식에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>이 선언은 'RequireQualifiedAccess'로 표시된 '{0}' 모듈을 엽니다. 대신 모듈의 요소에 대해 한정된 참조를 사용하도록 코드를 조정하십시오(예: 'map' 대신 'List.map'). 이렇게 변경하면 라이브러리에 새 구문이 추가될 때 코드가 견고성을 잃지 않게 됩니다.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>이 선언 요소는 확대에서 허용되지 않습니다.</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만, 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>이 새 멤버는 추상 멤버 '{0}'을(를) 숨깁니다. 멤버의 이름을 바꾸거나 대신 'override'를 사용하십시오.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>해당 특성으로 지정된 형식의 종류가 해당 정의에 의해 암시된 종류와 일치하지 않습니다.</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>이진 파일 '{0}'을(를) 쓰는 동안 오류가 발생했습니다. {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>기본 형식이 아닌 숫자 리터럴 상수는 NumericLiteral 모듈을 사용하여 다양한 형식에 매핑될 수 있으므로 패턴 일치에 사용할 수 없습니다. 변수로 바꾸고 일치 절의 끝에 'when &lt;variable&gt; = &lt;constant&gt;'를 사용하십시오.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>클래스/시그니처에 있는 형식 매개 변수의 컴파일 시간 요구 사항이 멤버/구현에 있는 형식 매개 변수와 다르므로 시그니처와 구현이 호환되지 않습니다.</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>중복 인수는 함수 '{0}'에서 무시되고 있습니다. {1}(을)를 예상했으나 {2} 인수를 받았습니다.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>사용자 지정 특성은 개체 생성자를 호출해야 합니다.</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>'expr.id' 구문은 레코드 레이블, 속성 및 필드에만 사용할 수 있습니다.</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>이 지점 뒤에 형식이 필요합니다.</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>'ReferenceEquality' 특성은 구조체에 대해 사용할 수 없습니다. 대신 'StructuralEquality' 특성을 사용하거나 'System.Object.Equals(obj)'의 재정의를 구현하십시오.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>재정의 '{0}'이(가) 둘 이상의 추상 슬롯을 구현합니다(예: '{1}' 및 '{2}').</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>'{0}' 멤버가 올바른 수의 인수를 받지 못했습니다. 하나의 오버로드는 {1}개의 인수를 받지만 {2}개가 주어졌습니다. 필요한 시그니처는 '{3}'입니다.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>모듈 이름은 경로가 아니라 단순 이름이어야 합니다.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>이 속성을 설정할 수 있도록 표시하려면 'member val PropertyName = expr with get,set'을 사용하십시오.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>컴파일러의 디렉터리에서 FSharp.Core.dll을 찾을 수 없습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>형식의 기본 형식이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>'{0}' 메서드와 일치하는 오버로드가 없습니다.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>생성자 또는 리터럴이 아니거나 생성자가 잘못된 방식으로 사용되고 있습니다.</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>측정 단위를 나타내는 형식에만 'Measure' 특성을 지정할 수 있습니다.</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>인스턴스 멤버에 대한 인수가 필요합니다.</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>명시적 형식 변수 '{0}'을(를) 일반화할 수 없으므로 이 코드는 해당 주석에 필요한 것보다 일반적이지 않습니다. 해당 변수는 '{1}'(으)로 제한되었습니다.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 형식에 대한 같음 의미 체계를 정의하려면 해당 형식의 정의에서 'Object.Equals' 멤버를 재정의하십시오.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>특성 'ReferenceEquality'가 지정된 형식에는 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' 또는 'System.Collections.IStructuralEquatable'에 대한 명시적 구현이 있을 수 없습니다.</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>'UseNullAsTrueValue' 특성 플래그는 하나의 nullary 케이스와 하나 이상의 nullary가 아닌 케이스를 포함하는 공용 구조체 형식에만 사용할 수 있습니다.</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' 또는 'struct'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>변수에 값을 할당합니다.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>#if 섹션의 파일 끝이 여기에서 또는 여기 뒤에서 시작되었습니다.</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>문자 범위 일치는 F#에서 제거되었습니다. 대신 'when' 패턴 가드를 사용하세요.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#!는 파일 시작의 첫 번째 줄에만 나타날 수 있습니다.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>생성자는 예외 확대에 지정할 수 없습니다.</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>제공된 '{0}' 형식의 'IsArray'가 true인데 배열 형식이 지원되지 않습니다.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>속성이 중복되었습니다. '{0}' 속성의 이름 및 시그니처가 '{1}' 형식의 다른 속성과 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 '{2}' 모듈/네임스페이스가 없습니다.</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>비재귀적 바인딩을 위한 선언 형식 'let ... and ...'는 F# 코드에서 사용되지 않습니다. 대신 'let' 바인딩 시퀀스를 사용하십시오.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.GetHashCode' 또는 'Object.Equals'의 명시적 구현이 있습니다. 형식에 'CustomEquality' 특성을 적용해야 합니다.</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>대리 생성자를 잘못 사용했습니다. 'new Type(args)' 구문을 사용하거나 'Type(args)'만 사용하십시오.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>형식 매개 변수 '{0}'에 {1} 형식의 제약 조건이 있지만 구현에는 없으므로 시그니처와 구현이 호환되지 않습니다. 이 제약 조건을 시그니처에서 제거하거나 구현에 추가하십시오.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>참조된 '{0}' 어셈블리에 어셈블리 수준 특성 '{1}'이(가) 있지만 공용 형식 공급자 클래스는 없습니다.</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>모든 경고를 오류로 보고합니다.</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>#indent \"off\" 옵션을 사용하지 않는 한 TAB은 F# 코드에서 허용되지 않습니다.</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>제공된 형식에 대한 정적 인수가 잘못되었습니다. '{0}' 종류의 인수가 필요합니다.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>변경할 수 있는 값은 'inline'으로 표시할 수 없습니다.</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>둘 이상의 재정의가 '{0}'을(를) 구현합니다.</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>이 형식의 인스턴스가 abstract로 표시되었거나 메서드 중 일부에 구현이 지정되지 않았으므로 해당 인스턴스를 만들 수 없습니다. 대신 개체 식 '{{ new ... with ... }}'를 사용하십시오.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>재귀 선언 그룹에서 모듈 약어는 모든 'open' 선언의 뒤에 있으면서 다른 선언의 앞에 있어야 합니다.</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>단일 인수에 패턴 일치가 있는 람다 식에서 fun 키워드 및 일치 식에 대한 간단한 대체로 사용됩니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에는 다음이 포함되어 있습니다.\n    {1}    \n하지만 해당 시그니처는 다음을 지정합니다.\n    {2}    \n컴파일된 이름이 다릅니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>올바른 개체 생성 식이 아닙니다. 명시적 개체 생성자에서는 대체 생성자를 호출하거나 개체의 모든 필드를 초기화한 후 상위 클래스 생성자에 대한 호출을 지정해야 합니다.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>인식할 수 없는 플랫폼 '{0}'입니다. 올바른 값은 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' 및 'anycpu'입니다.</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'new'는 인터페이스 형식에 대해 사용할 수 없습니다. 대신 개체 식 '{{ new ... with ... }}'를 사용하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>시그니처에 의해 약어가 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 약어는 다른 CLI 언어에 표시되어야 합니다. 시그니처에서 약어를 표시하세요.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>속성 setter의 형식이 잘못되었습니다. 하나 이상의 인수가 필요합니다.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>'let!', 'use!' 및 'do!' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>축자 문자열의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>이 필드는 읽기 전용입니다.</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>StructLayout 특성을 디코딩할 수 없습니다.</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>'{0}' 형식은 CLI 대리자 형식이 아닙니다.</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>이 식은 함수가 아니며 적용할 수 없습니다. 대신 expr.[index]를 통해 인덱서에 액세스하려고 했나요?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>'{0}'(으)로 바꾸기</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>구조체 또는 클래스 필드 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>포함하는 계산 식의 결과 모음에 제공된 계산 식의 결과를 추가하기 위해, 계산 식에 사용됩니다.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>'{0}' 식이 잘못되었습니다.</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>이 형식 매개 변수는 'Nullable'로 인스턴스화할 수 없습니다. 이는 'Nullable' 값과 함께 사용할 때 일부 CLI 언어에서 'null'의 의미가 혼동되지 않도록 하기 위한 제한입니다.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>'{0}' 파일 또는 모듈에 대한 구현이 이미 지정되었습니다.</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>선언 형식('{1}')의 생성자로부터 보고되지 않은 생성자를 형식 공급자 '{0}'에서 제공했습니다.</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>다른 인터페이스에서 상속된 인터페이스는 'interface ...' 대신 'inherit ...'를 사용하여 선언해야 합니다.</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>'EntryPointAttribute' 특성을 사용하여 레이블이 지정된 함수는 컴파일 시퀀스에서 마지막 파일의 마지막 선언이어야 합니다.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>레코드 종류 '{0}'에 '{1}' 레이블이 포함되어 있지 않습니다.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>블록이 닫히지 않았습니다.</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>이 속성 또는 필드를 이 사용자 지정 특성 형식에서 찾을 수 없습니다.</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>이 어셈블리의 두 부분에서 '{0}'(이)라는 네임스페이스와 모듈이 모두 발생합니다.</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>이 어셈블리의 대상 프레임워크 프로필을 지정하세요. 올바른 값은 mscorlib, netcore 또는 netstandard입니다. 기본값은 - mscorlib입니다.</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>F# 4.1부터 형식 약어의 액세스 가능성은 컴파일 시간에 확인합니다. 형식 약어의 액세스 가능성을 변경하세요. 이 경고를 무시하면 런타임 오류가 발생할 수 있습니다.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>#endif 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>잘못된 RSAParameters 구조 - '{{0}}'이(가) 필요합니다.</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>형식 매개 변수 {1}이(가) 'equality' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'이(가) 구조적 같음을 지원하지 않습니다. '{2}' 형식에 'NoEquality' 특성을 추가하여 해당 형식이 구조적 같음을 지원하지 않음을 명확히 하십시오.</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>'{1}' 형식이 'equality' 제약 조건을 만족하지 않으므로 구조체, 레코드 또는 공용 구조체 형식 '{0}'이(가) 구조적 같음을 지원하지 않습니다. '{2}' 형식에 'NoEquality' 특성을 추가하여 해당 형식이 구조적 같음을 지원하지 않음을 명확히 하십시오.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>이 특성은 이 언어 요소에 사용할 수 없습니다. 어셈블리 특성은 필요한 경우 F# 모듈 내에서 'do ()' 선언에 연결해야 합니다.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Thread 정적 및 Context 정적 변수는 정적이어야 하며 값이 각 새 스레드에서 기본값으로 초기화됨을 나타내기 위해 [&lt;DefaultValue&gt;] 특성을 가져야 합니다.</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>배열 요소의 주소를 현재 사용할 수 없습니다.</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>구문 오류: 예기치 않은 형식 매개 변수 지정입니다.</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DefaultAugmentation 특성을 디코딩할 수 없습니다.</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>'DefaultValue' 특성을 사용하는 필드의 형식은 기본 초기화를 허용해야 합니다. 즉, 이러한 형식은 적절한 값으로 'null'을 가지거나 필드가 모두 기본 초기화를 허용하는 구조체 형식이어야 합니다. 'DefaultValue(false)'를 사용하여 이 검사를 사용하지 않을 수 있습니다.</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>기본 버전과 다른, 추상 메서드 또는 가상 메서드의 버전을 구현하는 데 사용됩니다.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>제공된 형식 '{0}' 멤버 '{1}'에서 예기치 않은 예외가 발생했습니다. {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>형식 변수가 여러 클래스 형식에 의해 제약을 받습니다. 형식 변수의 클래스 제약 조건은 하나여야 합니다.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>이 제공된 메서드는 정적 매개 변수가 필요합니다.</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>'{0}' 생성자, 모듈 또는 네임스페이스가 정의되지 않았습니다.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>이 형식은 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>이 형식의 특성은 형식에 대한 많은 종류를 지정합니다.</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>이 작업은 다른 어셈블리에 정의된 변경할 수 있는 최상위 값에 지원되지 않는 방식으로 액세스합니다. 이 값은 해당 주소를 통해 액세스할 수 없습니다. 식을 변경할 수 있는 로컬 변수로 복사하고(예: 'let mutable x = ...') 필요한 경우 작업이 완료된 후에 값을 다시 할당하십시오.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>'try' 식에 예기치 않은 입력의 끝이 있습니다. 'try &lt;expr&gt; with &lt;rules&gt;' 또는 'try &lt;expr&gt; finally &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>'for' 식에 예기치 않은 입력 끝이 있습니다. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>표현이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>인용구에는 이러한 종류의 패턴 일치를 포함할 수 없습니다.</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>예기치 않은 형식의 끝입니다. 이 지점 뒤에 이름이 필요합니다.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>'{0}' 형식 공급자가 오류를 보고했습니다. {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>MDB를 생성하지 못했습니다. 호환 멤버 {0}을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>형식 약어에는 인터페이스 선언을 지정할 수 없습니다.</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>'StructuralEquality' 특성은 'NoComparison' 또는 'StructuralComparison' 특성과 함께 사용해야 합니다.</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>expression-splicing 연산자는 인용구 내에서만 사용할 수 있습니다.</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif와 짝이 맞는 #if가 없습니다.</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>이 특성은 이 언어 요소에 사용할 수 없습니다.</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>오버플로 검사를 생성합니다.</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>MIT 오픈 소스 라이선스에 따라 무료로 배포되었습니다. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지 않습니다. {2}개의 인수를 사용하는 오버로드를 찾았습니다.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>'{0}' 어셈블리 특성이 로드할 수 없거나 존재하지 않는 디자이너 어셈블리'{1}'을(를) 참조합니다. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>제공된 형식 '{1}' 멤버 '{2}'의 멤버 '{0}'에서 예기치 않은 예외가 발생했습니다. {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>형식 공급자는 GetStaticParametersForMethod를 구현하지만 ApplyStaticArgumentsForMethod는 구현되지 않거나 유효하지 않습니다.</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- 리소스 -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>이 어셈블리의 코드에서 따옴표로 묶인 리터럴을 사용합니다. 정적 링크에서는 모든 어셈블리가 최소 F# 4.0으로 컴파일된 경우가 아니라면 따옴표로 묶인 리터럴을 사용하는 구성 요소를 포함할 수 없습니다.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' 앞에는 'for' 선택 절이 와야 하고 뒤에는 나머지 쿼리 부분이 와야 합니다. 구문: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>'--delaysign' 옵션은 소스 파일이나 추가 모듈에 지정된 'System.Reflection.AssemblyDelaySignAttribute' 특성을 재정의합니다.</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>리터럴 필드의 주소를 사용하는 것은 올바르지 않습니다.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>이 숫자는 부호 있는 32비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'은(는) {1}이(가) 아닙니다. 전용 멤버는 선언 형식 내에서만 액세스할 수 있습니다. 보호된 멤버는 확장 형식에서만 액세스할 수 있으며 내부 람다 식에서는 액세스할 수 없습니다.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>메서드 또는 개체 생성자 '{0}'이(가) 정적이 아닙니다.</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>어셈블리 '{0}'의 코드에서 따옴표로 묶인 리터럴을 사용합니다. 정적 링크에서는 모든 어셈블리가 최소 F# 4.0으로 컴파일된 경우가 아니라면 따옴표로 묶인 리터럴을 사용하는 구성 요소를 포함할 수 없습니다.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}'은(는) 올바른 파일 이름이 아닙니다.</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>강력한 이름 키의 공개 부분만 사용하여 어셈블리를 공개 서명하고, 어셈블리를 서명됨으로 표시합니다.</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>이 숫자는 부호 없는 16비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>형식 공급자 '{0}'이(가) 'ApplyStaticArguments'에서 잘못된 형식을 반환했습니다. 이름이 '{1}'인 형식이 필요한데 이름이 '{2}'인 형식이 반환되었습니다.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>변경할 수 있는 로컬 '{0}'이(가) 암시적으로 참조 셀로 할당되었습니다. 닫기에서 캡처되었기 때문입니다. 이 경고는 정보 제공 목적으로만 발생하며 암시적 할당이 수행되는 위치에 나타납니다.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>F# 코드에서는 'expr.[expr]'을 사용할 수 있습니다. 첫 번째 식이 배열임을 나타내기 위해 형식 주석이 필요할 수 있습니다.</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>인터페이스에는 개체 생성자의 정의를 포함할 수 없습니다.</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>'--subsystemversion'의 버전 '{0}'이(가) 잘못되었습니다. 버전은 4.00 이상이어야 합니다.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>명명된 인수는 다른 모든 인수 뒤에 나타나야 합니다.</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>'{0}' 변수가 인용구 내에 바인딩되어 있지만 스플라이스된 식의 일부로 사용되었습니다. 범위를 벗어날 수 있으므로 이는 허용되지 않습니다.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>이 위치 또는 이 위치 근처에서 'enum' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>서명 디렉터리가 없습니다.</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>측정 단위 식에 예기치 않은 중위 연산자가 있습니다. 올바른 연산자는 '*', '/' 및 '^'입니다.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>속성</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>봉인 형식을 상속할 수 없습니다.</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>이 구문은 시퀀스 식의 일부로서 모호합니다. 중첩 식은 'let _ = (...)', 중첩 시퀀스는 'yield! seq {{... }}'를 사용하여 작성할 수 있습니다.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IStructuralEquatable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomEquality' 특성을 적용하십시오.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>이 멤버는 개체 구현에서 허용되지 않습니다.</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>가져온 어셈블리가 '{0}' 형식을 사용하지만 해당 형식이 public이 아닙니다.</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- 기타 -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>컴파일 단위 '{1}'의 '{0}' 모듈/네임스페이스에 '{2}' 네임스페이스, 모듈 또는 형식이 없습니다.</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>서버와 통신하는 동안 문제가 발생하여 상주 컴파일 서비스를 사용하지 않았습니다.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>필드/val 선언은 여기에 허용되지 않습니다.</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>'new' 제약 조건은 'unit' 형식의 인수 하나를 사용하고 생성된 형식을 반환해야 합니다.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>컴파일러 시작 시간을 단축하기 위해 상주 백그라운드 컴파일 서비스를 사용합니다.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>제약 조건이 잘못되었습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>구현이 이 형식에서 null을 표현으로 사용할 수 있다고 하지만 시그니처는 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>제공된 메서드에 정적 인수를 적용하는 동안 오류가 발생했습니다.</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>지정한 관리되는 리소스를 포함합니다.</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>'fixed' 식을 빌드할 때 참조에서 System.Runtime.CompilerServices.OffsetToStringData 메서드를 찾을 수 없습니다.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>멤버와 지역 클래스 바인딩 모두에 이름 '{0}'이(가) 있습니다.</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' 뒤에는 변수 이름이 와야 합니다. 사용법: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>제공된 형식 '{0}'이(가) 포함된 이 형식 테스트는 허용되지 않습니다. 이 제공된 형식은 런타임에 '{1}'(으)로 지워집니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>구현이 추상 클래스이지만 시그니처는 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 시그니처에 [&lt;AbstractClass&gt;] 특성을 추가하세요.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>인수 길이가 일치하지 않습니다.</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>이 값은 함수가 아니며 적용할 수 없습니다. 선언을 종료해야 합니다.</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>'{0}' 멤버를 사용하여 '{1}'을(를) 구현할 수 없습니다. 필요한 시그니처는 '{2}'입니다.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>이 형식은 서로 다른 제네릭 인스턴스 '{0}' 및 '{1}'에서 같은 인터페이스를 구현합니다. 이는 이 버전의 F#에서 허용되지 않습니다.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>'--keycontainer' 옵션은 소스 파일이나 추가 모듈에 지정된 'System.Reflection.AssemblyNameAttribute' 특성을 재정의합니다.</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>시스템 형식 '{0}'이(가) 필요했지만, 참조된 시스템 DLL에 이 형식이 포함되어 있지 않습니다.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>계산할 때, 포함하는 계산 식의 결과를 제공하는 계산 식을 나타내는 데 사용됩니다.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>중위 연산자 멤버 '{0}'에 커리된 추가 인수가 있습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>이 멤버는 인터페이스 구현에서 허용되지 않습니다.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>중위 연산자 멤버 '{0}'에 {1}개의 초기 인수가 있습니다. 3개 인수의 튜플이 필요합니다.</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>FieldOffset 특성은 StructLayout(LayoutKind.Explicit)으로 표시된 형식의 멤버에만 배치할 수 있습니다.</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>생성자에는 명시적 형식 매개 변수를 지정할 수 없습니다. 대신 정적 생성 메서드를 사용하십시오.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>제공된 '{1}' 형식의 '{0}' 속성에서 CanRead=false인데 GetGetMethod()에서 메서드를 반환했습니다.</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>쿼리에서 '{0}'은(는) 단순 패턴을 사용해야 합니다.</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>예기치 않은 Const_bytearray입니다.</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>예기치 않은 Expr.TyChoose입니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>개체 멤버에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>'{0}' 메서드에 커리된 인수가 있지만 '{1}' 형식의 다른 메서드와 이름이 같습니다. 커리된 인수가 있는 메서드를 오버로드할 수 없습니다. 튜플된 인수를 포함하는 메서드를 사용하세요.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>AssemblyVersionAttribute에 {0} 버전 '{1}'이(가) 지정되었지만 이 값이 잘못되어 무시되었습니다.</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>형식 매개 변수는 형식 생성자로 사용할 수 없습니다.</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>변경할 수 있는 변수는 해당 메서드를 벗어날 수 없습니다.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>측정값 선언에는 정적 멤버만 있을 수 있습니다.</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>'{0}' 연산자는 일반적으로 다시 정의하면 안 됩니다. 다른 연산자 이름을 사용하십시오.</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>byref 형식의 값 '{0}'을(를) 현재 사용할 수 없습니다.</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>검색 디렉터리 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>이 구문은 계산 식의 일부로서 모호합니다. 중첩 식은 'let _ = (...)', 중첩 계산은 'let! res = builder {{ ... }}'를 사용하여 작성할 수 있습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>시그니처가 {2} '{3}'을(를) 정의하지만 구현은 그렇지 않거나 그렇더라도 순서가 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>전체 이름</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>정규화된 경로를 사용하여 메시지를 출력합니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>'{2}' 필드가 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>FSharp.Core.dll을 생성된 바이너리와 함께 복사하지 않음</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>제네릭 구문을 사용하려면 '{0}' 형식이 관리되지 않은 형식이어야 합니다.</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.Equals'의 명시적 구현이 있습니다. 'Object.GetHashCode()'에 대해 일치하는 재정의를 구현하십시오.</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>생성자에 대한 명시적 형식 선언의 형식은 'ty1 * ... * tyN -&gt; resTy'여야 합니다. 'resTy'를 괄호로 묶어야 할 수 있습니다.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>함수가 재귀적임을 나타내는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>시그니처에 사용되어 값을 나타내거나 형식에 사용되어 제한된 상황에서 멤버를 선언합니다.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>무료 리소스로 호출하기 위해 Dispose가 필요한 값에 대해 let 대신 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>예외를 생성할 수 있는 코드 블록을 지정하는 데 사용됩니다. with 또는 finally와 함께 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>개체를 생성하거나 생성할 수 있는 생성자를 선언하거나 정의하거나 호출하는 데 사용됩니다. 형식에 특정 생성자가 있어야 함을 나타내기 위해 제네릭 매개 변수 제약 조건에서도 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>실제로 키워드가 아니지만, 조합의 not struct는 제네릭 매개 변수 제약 조건으로 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>값 또는 함수에 이름을 연결하거나 바인딩하기 위해 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>익명 함수라고도 하는 람다 식에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>루프 구문에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>형식 정의 및 형식 확장에서 멤버 정의 섹션의 끝을 나타냅니다. 자세한 구문에서 begin 키워드로 시작하는 코드 블록의 끝을 지정하는 데 사용됩니다.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>속성의 getter 및 setter는 형식이 같아야 합니다. '{0}' 속성의 getter 형식은 '{1}'인데 setter 형식은 '{2}'입니다.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>형식 인수의 수가 일치하지 않습니다. '{0}'개가 제공되었는데 '{1}'개가 필요합니다. 이전에 보고된 오류와 관련된 현상일 수 있습니다.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>이 필드에는 이름이 필요합니다.</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>생성된 형식</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>버전 문자열 '{0}'이(가) 잘못되었습니다.</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>형식 인수는 여기에 지정할 수 없습니다.</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>이 숫자는 부호 있는 원시 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>이 형식 테스트 또는 다운캐스트는 제공된 '{0}' 형식을 '{1}' 형식으로 지웁니다.</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>'inherit' 선언에는 'as' 바인딩을 지정할 수 없습니다. 메서드를 재정의할 때 기본 클래스의 멤버에 액세스하려면 'base.SomeMember' 구문을 사용할 수 있습니다. 'base'는 키워드입니다. 이 'as' 바인딩을 제거하십시오.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>대리자를 선언하는 데 사용됩니다.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>메서드 또는 개체 생성자 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>서식 지정자의 너비가 잘못되었습니다.</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>'AllowNullLiteral' 특성이 지정된 형식은 null 리터럴도 사용할 수 있는 형식을 구현하거나 이 형식에서 상속되어야 합니다.</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>정적 이니셜라이저를 사용하려면 인수가 필요합니다.</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>구문 오류 - 예기치 않은 '?' 기호입니다.</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>인터페이스 형식을 잘못 사용했습니다.</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>연속된 패턴은 공백으로 구분하거나 튜플해야 합니다.</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>필요한 시그니처는 {0}입니다.</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit이 종료되지 않았습니다.</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>정적 최적화 조건은 F# 라이브러리 내에서만 사용해야 합니다.</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>배열 생성자의 모든 요소는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>선언된 형식 매개 변수 '{0}'은(는) 컴파일 시간에 확인할 수 없으므로 여기에 사용할 수 없습니다.</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}'은(는) 올바른 어셈블리 이름이 아닙니다.</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>활성 패턴에 대한 올바른 이름이 아닙니다.</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>'if' 식에 'else' 분기가 누락되었습니다. 'then' 분기의 형식은 '{0}'입니다. 'if'는 문이 아니라 식이므로 동일한 형식의 값을 반환하는 'else' 분기를 추가하세요.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>형식 서명에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>메서드가 중복되었습니다. '{0}' 메서드의 이름 및 시그니처가 '{1}' 형식의 다른 메서드와 같습니다.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>이 메서드는 해당 형식 매개 변수에서 과다하게 제약 조건이 적용되었습니다.</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>'{0}' 변수가 없습니다.</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 인라인 어셈블리 코드 형식에서 허용되지 않습니다.</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>반영된 정의에는 접두사 스플라이스 연산자 '%'을(를) 포함할 수 없습니다.</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>측정 단위는 형식에 대한 접두사 인수로 사용할 수 없습니다. 꺾쇠 괄호 안에 후위 인수로 다시 작성하십시오.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>제약 조건 'struct'와 'not struct'는 서로 일관되지 않습니다.</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>이 리터럴 패턴은 인수를 사용하지 않습니다.</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>선언 구문이 잘못되었습니다.</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>'{0}' 형식에서 '{1}' 연산자를 지원하지 않습니다.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>대리자 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>이 지점 뒤에 식이 필요합니다.</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>'{0}' 형식은 사용되는 '{1}' 값, 멤버 또는 형식보다 액세스하기 어렵습니다.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>결정적 어셈블리(모듈 버전 GUID 및 타임스탬프 포함) 생성</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>제공된 형식 '{0}' 멤버 '{1}'에 예기치 않은 'null' 반환 값이 있습니다.</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>IDisposable에서 Dispose를 찾을 수 없거나 Dispose가 오버로드되었습니다.</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>관리되는 리소스에 대해 인식할 수 없는 개인 정보 보호 설정 '{0}'입니다. 올바른 옵션은 'public' 및 'private'입니다.</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>'inline'으로 표시된 값은 인라인할 수 없습니다.</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>제네릭 구문을 사용하려면 '{0}' 형식에 public 기본 생성자가 있어야 합니다.</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0}은(는) 인스턴스 멤버가 아닙니다.</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>인용구에는 이러한 종류의 상수를 포함할 수 없습니다.</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>'{0}' 형식 공급자가 ParameterExpression에서 잘못된 매개 변수를 사용했습니다. {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>제네릭 멤버 '{0}'이(가) 이 프로그램 지점 전의 비균일 인스턴스화에 사용되었습니다. 이 멤버가 처음에 오도록 멤버들을 다시 정렬해 보십시오. 또는, 인수 형식, 반환 형식 및 추가 제네릭 매개 변수와 제약 조건을 포함한 멤버의 전체 형식을 명시적으로 지정하십시오.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>형식에 byref 형식의 값이 저장됩니다. 이는 공통 IL에서 허용되지 않습니다.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>지정된 구현 파일이 없습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n인라인 플래그가 서로 다릅니다.</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>네임스페이스, 모듈, 형식 또는 공용 구조체 케이스 이름이 잘못되었습니다.</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>형식 약어에는 멤버를 지정할 수 없습니다.</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>이 모듈에 대한 'rec'는 외부 'rec' 선언에 의해 암시되며 무시됩니다.</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>이 형식은 레코드 형식이 아닙니다. 클래스 및 구조체 형식의 값은 개체 생성자에 대한 호출을 사용하여 만들어야 합니다.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>'{0}' 연산자를 지원하는 형식이 필요하지만 함수 형식이 지정되었습니다. 함수에 대한 인수가 없을 수 있습니다.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>네임스페이스에는 값을 포함할 수 없습니다. 모듈을 사용하여 값 선언을 저장하십시오.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>대리자 형식에 대해 Invoke 메서드를 찾지 못했습니다.</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>조건이 잘못되었습니다. 'if &lt;expr&gt; then &lt;expr&gt;' 또는 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>이 계산 식 내에서 사용자 지정 연산을 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' 연산자와 함께 사용할 수 없습니다.</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>'StructuralComparison' 특성은 'StructuralEquality' 특성과 함께 사용해야 합니다.</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>'rec' 키워드를 잘못 사용했습니다.</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>열거에는 멤버를 지정할 수 없습니다.</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>레코드 레이블 또는 네임스페이스 '{0}'이(가) 정의되지 않았습니다.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>인용구에는 제네릭 식을 포함할 수 없습니다.</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>명령줄 옵션 '{0}'은(는) 사용되지 않습니다.</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>비동기 워크플로에 사용되어 비동기 계산 결과에 이름을 바인딩하거나, 기타 계산 식에서 계산 형식인 결과에 이름을 바인딩하는 데 사용됩니다.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>호출</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else와 짝이 맞는 #if가 없습니다.</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>컴파일러가 mscorlib.dll 및 프레임워크 구성 요소를 찾는 위치를 재정의하는 데 사용합니다.</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'은(는) {1}개의 형식 인수를 사용하지만 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>'{2}' 어셈블리에서 {0} '{1}'을(를) 찾을 수 없습니다. 가능한 원인은 버전이 호환되지 않기 때문일 수 있습니다. 참조된 모든 구성 요소에서 올바른 버전을 사용할 수 있게 하려면 이 어셈블리의 올바른 버전을 명시적으로 참조해야 할 수 있습니다.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>형식 식의 구문이 잘못되었습니다.</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>이 숫자는 이 정수 형식에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>활성 패턴 '{0}'이(가) 함수가 아닙니다.</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>'{1}' 형식의 '{0}' 속성에 일치하지 않는 getter와 setter가 있습니다. 하나가 추상 요소인 경우 다른 하나도 추상 요소여야 합니다.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>쿼리에서 정수 범위를 지정하려면 'for x in n .. m do ...' 형식을 사용하십시오.</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>3중 따옴표 문자열의 파일 끝이 여기나 그 앞에서 시작됩니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>값, 함수 또는 멤버 정의에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>개체 생성자 '{0}'은(는) {1}개의 인수를 사용하지만, 여기에서는 {2}개가 지정되었습니다. 필요한 시그니처는 '{3}'입니다. 여러 인수로 속성에 값을 할당하는 경우 해당 인수를 쉼표(',')로 구분하세요.</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}'은(는) '{1}' 형식의 인수에 적용되어야 하지만 '{2}' 형식의 인수에 적용되었습니다.</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>봉인 형식의 확장을 만들 수 없습니다.</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>이 'let'과 짝이 맞는 'in'을 찾을 수 없습니다.</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>'{0}' 표시 유형 특성이 모듈 약어에서 허용되지 않습니다. 모듈 약어는 항상 Private입니다.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>특성 'NoComparison'이 지정된 형식에는 일반적으로 'System.IComparable', 'System.IComparable&lt;_&gt;' 또는 'System.Collections.IStructuralComparable'에 대한 명시적 구현이 있으면 안 됩니다. 상호 운용성을 위해 의도적으로 이러한 구현을 사용한 경우에는 이 경고를 사용하지 마십시오.</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>이 생성자는 계산 식 내에서만 사용할 수 있습니다. 일반 함수에서 값을 반환하려면 단순히 'return' 없이 식을 작성하십시오.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>속성 정의는 mutable로 선언할 수 없습니다. 이 속성을 설정할 수 있도록 표시하려면 'member val PropertyName = expr with get,set'을 사용하십시오.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- 고급 -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'static' 한정자가 서로 다릅니다.</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>공용 구조체 케이스의 컴파일 형식</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>이 위치 또는 이 위치 근처에서 어셈블리를 확인하지 못했습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>시그니처와 구현에서 필드의 순서가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>추상 멤버는 확대에서 허용되지 않으며 형식 자체의 일부로 정의해야 합니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>조건식의 'then' 분기에 예기치 않은 입력의 끝이 있습니다. 'if &lt;expr&gt; then &lt;expr&gt;' 또는 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>'match' 또는 'try' 식에 예기치 않은 입력의 끝이 있습니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>조건식의 'else' 분기에 예기치 않은 입력의 끝이 있습니다. 'if &lt;expr&gt; then &lt;expr&gt;' or 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>레코드 값을 생성할 때는 인수를 지정할 수 없습니다.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>'@'을 포함하는 식별자는 F# 코드 생성에 사용할 수 있도록 예약되었습니다.</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>이 조회는 여기에 사용할 수 없습니다.</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>인터페이스, 대리자 또는 열거형 형식을 확장하는 멤버는 형식의 정의와 별도로 모듈에 배치해야 합니다. 이 모듈은 확장 멤버를 범위 내로 가져오기 위해 AutoOpen 특성을 가지거나 클라이언트 코드를 통해 명시적으로 열어야 합니다.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>인터페이스 구현은 생성 식에서 지정할 수 없습니다.</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>이 코드는 충분히 일반적이지 않습니다. 형식 변수 {0}을(를) 일반화하면 범위를 벗어나게 되므로 일반화할 수 없습니다.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>IF-OCAML 섹션의 파일 끝이 여기에서 또는 여기 앞에서 시작되었습니다.</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>클래스에만 'AbstractClass' 특성을 지정할 수 있습니다.</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void'는 F#에서 'typeof&lt;System.Void&gt;'로만 사용할 수 있습니다.</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>'(typ,...,typ) ident' 구문은 F# 코드에서 사용되지 않습니다. 대신 'ident&lt;typ,...,typ&gt;'를 사용하십시오.</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>구조체 형식에는 추상 멤버를 포함할 수 없습니다.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>이 새 멤버는 튜플, 함수, 측정 단위 및/또는 제공된 형식이 지워지면 추상 멤버 '{0}'을(를) 숨깁니다. 멤버의 이름을 바꾸거나 대신 'override'를 사용하십시오.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>예기치 않은 InterfaceDataVersionAttribute의 디코딩입니다.</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>이 패턴 일치의 규칙을 구분하는 '|' 토큰의 한 열이 잘못 맞춤되어 있습니다. 코드를 다시 맞추거나 들여쓰기를 더 사용하십시오.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 값에 대한 인자 수가 유추되지 않았습니다.</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>구문 트리에 예기치 않은 소스 수준 속성 지정이 있습니다.</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>잘못 사용된 필드에 값이 지정되었습니다.</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>상속 체인에서 더 낮은 형식으로 변환하는 데 사용됩니다.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\n하나 이상의 인수에 튜플 형식이 필요합니다. 지정된 인수를 추가 괄호로 래핑하거나 인터페이스의 정의를 검토하세요.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>예기치 않은 큰 유리 상수입니다.</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>잘못된 이미지 형식</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>형식 공급자 '{0}'에 빈 네임스페이스가 있습니다. 전역 네임스페이스에 대해 'null'을 사용하십시오.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n이름이 서로 다릅니다.</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>그룹에 {0} var in collection {1} (outerKey = innerKey). '{2}' 다음에 괄호가 필요합니다.</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' 또는 '='가 필요합니다.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>예기치 않은 InternalsVisibleToAttribute의 디코딩입니다.</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>전처리기 식이 불완전합니다.</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: 지연되었습니다.</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>생성된 형식 '{0}'을(를) 직접 참조할 수는 없습니다. 형식 정의를 사용하십시오(예: 'type TypeAlias = &lt;path&gt;'). 이 정의는 형식 공급자가 생성된 형식을 어셈블리에 추가함을 나타냅니다.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>구문 오류입니다. 잘못된 중첩 #endif가 있으며 이 앞에 예기치 않은 토큰이 있습니다.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>특정 경고 사용(기본적으로 해제됨)</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0}은(는) 활성 패턴이며 명명된 필드가 있는 구분된 공용 구조체 케이스로 처리될 수 없습니다.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>레코드 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>집합 멤버의 시그니처가 잘못되었습니다.</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>'while' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>올바른 문자 리터럴이 아닙니다.</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>반환 값에는 이름을 지정할 수 없습니다.</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>지워진 제공된 형식에는 상속될 수 없습니다.</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>'{0}' 공급자가 생성된 형식 컨텍스트에 생성되지 않은 형식 '{1}'을(를) 반환했습니다. 생성된 형식만 반환하도록 형식 공급자를 조정하십시오.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>'enum' 제약 조건의 형식은 'enum&lt;type&gt;'이어야 합니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 추상 요소이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 형식에 대한 같음 의미 체계를 정의하려면 'Object.Equals' 멤버를 재정의하십시오. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하십시오.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>이 숫자는 10진 리터럴에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>어셈블리 '{0}'의 F# 메타데이터를 읽는 동안 오류가 발생했습니다. 예약된 구문이 사용되었습니다. F# 컴파일러를 업그레이드하거나 특정 구문을 사용하지 않는 이전 버전의 어셈블리를 사용해야 할 수 있습니다.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>정적 매개 변수가 너무 많습니다. 최대 {0}개의 매개 변수가 필요한데 명명되지 않은 매개 변수 {1}개와 명명된 매개 변수 {2}개가 있습니다.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>'namespace' 선언 뒤에 '=' 기호가 오면 안 됩니다.</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate 및 System.Array 형식은 개체 식 또는 클래스에서 상위 형식으로 사용할 수 없습니다.</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>이 파일에는 'module SomeNamespace.SomeModule' 형식의 선언이 여러 개 포함되어 있습니다. 이러한 형식의 선언은 파일당 하나만 허용됩니다. 초기 네임스페이스 선언을 사용하도록 파일을 변경하거나 'module ModuleName = ...'을 사용하여 모듈을 정의하십시오.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>인터페이스 형식에서 상속할 수 없습니다. 대신 interface ... with를 사용하십시오.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>크로스 모듈을 최적화하거나 최적화하지 않습니다.</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>추출할 필드 또는 열을 지정하기 위해 쿼리 식에 사용됩니다. 이것은 상황별 키워드입니다. 즉 실제로 예약어가 아니며, 적절한 컨텍스트에서 키워드처럼만 작동합니다.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>'{0}' 필드의 주소를 현재 사용할 수 없습니다.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>이 위치 또는 이 위치 근처에서 'unmanaged' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>이 형식 정의는 'CLIMutable' 특성을 포함할 수 없습니다. 레코드 형식만 이 특성을 포함할 수 있습니다.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>이 숫자는 부호 있는 64비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 열거 필드에서 허용되지 않습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>{2} 수가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>형식 확장이 잘못되었습니다.</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>파일 이름 '{0}'에 문제가 있습니다. {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#endif에 #else가 필요합니다.</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>구조체 형식을 선언하는 데 사용됩니다. 제네릭 매개 변수 제약 조건에서도 사용됩니다. 모듈 정의에서 OCaml 호환성에 대해 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>형식의 인스턴스 없이 호출될 수 있는 메서드나 속성, 또는 모든 형식의 인스턴스 간 공유되는 값 멤버를 나타내는 데 사용됩니다.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>'EntryPointAttribute' 특성은 모듈의 함수 정의에 대해서만 사용할 수 있습니다.</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>기본값에 인수와 같은 형식이 없습니다. DefaultParameterValue 특성 및 모든 Optional 특성은 무시됩니다. 참고: 'null'은 올바른 형식으로 주석이 추가되어야 합니다(예: 'DefaultParameterValue(null:obj)').</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>제네릭 인스턴스가 잘못되었습니다. 이름이 '{1}'인 {0} 멤버 중 {2}개의 제네릭 인수를 사용하는 멤버가 없습니다.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>형식이 정의된 것과 같은 파일 및 네임스페이스 선언 그룹을 제외하고 네임스페이스는 확장 멤버를 포함할 수 없습니다. 모듈을 사용하여 확장 멤버의 선언을 저장하세요.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>계산 식의 결과로 제공하는 값을 나타내는 데 사용됩니다.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>값 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>이 'in' 토큰의 들여쓰기가 해당하는 'let'과 관련하여 올바르지 않습니다.</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>'{0}' 형식이 여기에 필요하지만 사용할 수 없습니다. '{1}' 어셈블리에 대한 참조를 추가해야 합니다.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>'{0}' 연산자에서는 'into'를 사용할 수 없습니다.</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0}은(는) 정적 멤버가 아닙니다.</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>익명 형식 변수는 이 선언에서 허용되지 않습니다.</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>이 레코드에는 일관성이 없는 형식의 필드가 포함되어 있습니다.</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>'let' 및 'do' 바인딩은 형식 정의에서 멤버 및 인터페이스 정의 앞에 와야 합니다.</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>모듈 내의 지시문은 무시됩니다.</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>이 숫자는 부호 있는 16비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>코드 페이지 '{0}'에 문제가 있습니다. {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>특성 식은 개체 생성자에 대한 호출이어야 합니다.</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>대리 생성자에는 단일 함수 값을 전달해야 합니다.</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>이 인덱서에 {0}개의 인수가 필요하지만 여기에서는 {1}개가 지정되었습니다.</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>'if' 식은 컨텍스트 형식 요구 사항을 충족하기 위해 '{0}' 형식이 필요하지만 현재 형식은 '{1}'입니다.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>간략화된 형식에는 'Sealed' 특성을 지정할 수 없습니다.</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>최적화를 사용합니다(약식: -O).</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>이 재정의는 해당하는 추상 멤버와 다른 수의 인수를 사용합니다. 다음 추상 멤버를 찾았습니다. {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'['의 짝이 맞지 않습니다.</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>리터럴 값은 'inline'으로 표시할 수 없습니다.</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>'NoEquality' 특성은 'NoComparison' 특성과 함께 사용해야 합니다.</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>인용구에는 byref 포인터를 필요로 하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>형식에 예기치 않은 /가 있습니다.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>어셈블리 코드 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>지정한 입력이 없습니다.</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>0이 아닌 상수에는 제네릭 단위를 지정할 수 없습니다. 제네릭 0을 사용하려면 0.0&lt;_&gt;을 작성하십시오.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>속성 getter 또는 setter가 잘못되었습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>시그니처가 {2}을(를) 선언하지만 구현은 {3}을(를) 선언하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>제공된 네임스페이스 이름 '{1}'에는 '{0}' 문자를 사용할 수 없습니다.</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>지시문이 잘못되었습니다. '#I \"&lt;path&gt;\"'가 필요합니다.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>이 숫자는 부호 없는 32비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>'{0}' 속성의 이름이 '{1}' 형식의 메서드와 같습니다.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>이벤트</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>필드</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>재귀적으로 정의된 값은 재귀적 바인딩 내에서 튜플 값의 구성 요소에 대한 일부로 직접 나타날 수 없습니다.</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>명령줄 옵션 '{0}'은(는) 사용되지 않습니다. HTML 문서 생성은 이제 FsHtmlDoc.exe를 통해 F# Power Pack에 포함됩니다.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>특성은 식의 'let' 바인딩에서 허용되지 않습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n각각의 형식 매개 변수 수가 서로 다릅니다.</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>이 멤버는 충분히 일반적이지 않습니다.</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>부울 리터럴로 사용됩니다.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>인용구에는 루프의 내림차순을 포함할 수 없습니다.</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>빌드할 라이브러리의 기준 주소</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>'{0}' 어셈블리를 읽는 중 오류가 발생했습니다. {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>제공된 '{0}' 형식에서 null 멤버를 반환했습니다.</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>'{1}' 어셈블리에서 '{0}' 형식에 대한 참조를 찾았지만 이 어셈블리에서 해당 형식을 찾을 수 없습니다.</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>제네릭 형식 매개 변수가 항상 '{0}'이(가) 되도록 제한하는 방식으로 해당 매개 변수가 사용되었습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 override로 표시되어 있고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>{0}개의 식이 필요한데 {1}개를 받았습니다.</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>이 형식 확장에 대해 선언된 하나 이상의 형식 매개 변수에 형식 제약 조건이 없거나 잘못되어 '{0}'의 원본 형식 제약 조건과 일치하지 않습니다.</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>하나 이상의 재정의가 해당하는 추상 멤버를 올바르게 구현하지 않았습니다.</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>명령줄 옵션을 사용하여 버전을 지정했기 때문에 'AssemblyVersionAttribute'가 무시되었습니다.</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>'DefaultValue' 특성은 'val' 선언에 대해서만 사용할 수 있습니다.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>구조체 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>형식은 여러 구체적인 형식에서 상속될 수 없습니다.</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>예기치 않은 형식 인수입니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>시그니처를 사용하려면 형식이 {2} 인터페이스를 지원해야 하지만 이 인터페이스가 구현되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- 코드 생성 -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>예기치 않은 Const_uint16array입니다.</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' 멤버가 잘못된 방식으로 사용되었습니다. '{2}'이(가) 정의되기 전에 '{1}'의 사용이 유추되었습니다. 이는 잘못된 전방 참조입니다.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>은(는)</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>이 특성은 이 버전의 F#에서 사용할 수 없습니다.</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>특성은 패턴 내에서 허용되지 않습니다.</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>상속된 '{0}' 멤버는 봉인되어 있으므로 재정의할 수 없습니다.</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>이 형식에는 중첩 형식이 없습니다.</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>파일 이름 '{0}'에 잘못된 문자('{1}')가 있습니다.</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>'{0}' 필드, 생성자 또는 멤버가 정의되지 않았습니다.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>[&lt;ReflectedDefinition&gt;] 용어에는 접두사 스플라이스 연산자 '%'을(를) 포함할 수 없습니다.</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>형식 인스턴스 길이가 일치하지 않습니다.</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>setter 속성에는 최대 2개의 인수 그룹이 있을 수 있습니다.</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>특정 경고 메시지를 사용하지 않습니다.</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>컴파일러 저작권 메시지를 표시하지 않습니다.</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>'{0}' 형식이 명시적 레이아웃을 포함한다고 표시되어 있지만 '{1}' 필드가 'FieldOffset' 특성으로 표시되어 있지 않습니다.</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n형식이 서로 다릅니다.</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>expression-splicing 연산자의 첫 번째 클래스 사용은 허용되지 않습니다.</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>이 다운캐스트는 제공된 '{0}' 형식을 '{1}' 형식으로 지웁니다.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>{0} 형식에 '{1}' 멤버가 포함되어 있지만 이 멤버는 재정의 또는 구현할 수 있는 가상 또는 추상 메서드가 아닙니다.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>'{0}' 특성이 구현과 시그니처 모두에 나타나지만 특성 인수가 다릅니다. 컴파일된 코드에는 시그니처에 있는 특성만 포함됩니다.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>'{0}' 연산자를 확인할 수 없습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보십시오.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>인식할 수 없는 옵션: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>확장</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>'{0}' 필드가 구현에 있었지만 시그니처에는 없었으므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{2}을(를) 지정합니다.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>'{0}' 형식에 '{1}' 메서드(전체 이름: '{2}')가 있지만 정적 메서드가 아닙니다.</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>'reraise'에 대한 호출은 try-with의 처리기 내에서 직접 발생할 수만 있습니다.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>열거형 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>인수 형식이 일치하지 않습니다.</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>이 서식 지정자에서 'l' 또는 'L'은 불필요합니다. F# 코드에서는 모든 기본 정수 형식과 함께 사용할 수 있도록 오버로드되는 %d, %x, %o 또는 %u을(를) 대신 사용할 수 있습니다.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>형식 외부에서 멤버에 대한 액세스를 허용합니다.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>'{0}' 형식은 적절한 값으로 'null'을 가지지 않습니다. Nullable 형식에 null 값을 만들려면 'System.Nullable()'을 사용하십시오.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>재귀 ValValue {0}입니다.</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>byref&lt;T&gt;에서 T는 byref 형식을 포함할 수 없으므로 '{0}' 형식은 잘못되었습니다.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>조건부 컴파일 기호를 정의합니다(약식: -d).</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>특성은 'inherit' 선언에서 허용되지 않습니다.</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>제공된 '{1}' 형식의 '{0}' 속성에서 CanWrite=true인데 GetSetMethod()의 값이 없습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>예외 선언이 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core에서 FSharp.Core.sigdata를 찾을 수 없습니다. 파일이 {0}에 있어야 합니다. 이 파일이 더 이상 필요하지 않은 최신 버전의 FSharp.Core로의 업그레이드를 고려해 보세요.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>한 줄로 된 주석이나 줄 끝이 필요합니다.</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>형식 공급자가 'null'을 반환했습니다. 이 값은 '{0}'(으)로부터의 올바른 반환 값이 아닙니다.</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>#if 바로 다음에는 식별자가 있어야 합니다.</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>'{0}'에 대해 지정된 구현이 없습니다. 모든 인터페이스 멤버가 구현되어 적절한 'interface' 선언에 나열되어야 합니다(예: 'interface ... with member ...').</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>이 '{0}' 뒤에 오는 블록이 완료되지 않았습니다. 모든 코드 블록은 식이며 결과가 있어야 합니다. '{1}'이(가) 블록의 최종 코드 요소가 될 수 없습니다. 이 블록에 명시적 결과를 제공하세요.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>'while' 식에 예기치 않은 입력의 끝이 있습니다. 'while &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>측정값 정의에는 형식 매개 변수를 지정할 수 없습니다.</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>F# 컴파일 DLL '{0}'을(를) 이 버전의 F#에 사용하려면 다시 컴파일해야 합니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>'match' 식에 예기치 않은 입력의 끝이 있습니다. 'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...'이 필요합니다.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>인터페이스 형식 및 대리자 형식에는 필드를 포함할 수 없습니다.</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>파일 확장명 '.ml' 및 '.mli'는 ML 호환성을 위한 것입니다.</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>네임스페이스</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요합니다. 필요한 시그니처는 '{2}'입니다.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>측정값 선언에는 정적 멤버만 있을 수 있습니다. 생성자는 사용할 수 없습니다.</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>인터페이스에는 정적 이니셜라이저의 정의를 포함할 수 없습니다.</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>내부 제네릭 함수는 따옴표 붙은 식에 허용되지 않습니다. 이 함수가 더 이상 제네릭 형식이 아닐 때까지 형식 제약 조건을 추가하십시오.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>알 수 없는 --test 인수입니다. '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>형식 유추 문제가 너무 복잡합니다(최대 반복 깊이에 도달함). 형식 주석을 더 추가하십시오.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>'{0}' 값, 네임스페이스, 형식 또는 모듈이 정의되지 않았습니다.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n각각의 데이터 필드 수가 서로 다릅니다.</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>구조체의 기본 생성자는 이러한 바인딩을 실행하지 않으므로 구조체에는 'do' 바인딩을 포함할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>상속 체인에서 더 높은 형식으로 변환하는 데 사용됩니다.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey). '{2}' 다음에 괄호가 필요합니다.</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>구조체 형식의 기본 0 초기화 생성자는 구조체 형식의 모든 필드가 기본 초기화를 허용하는 경우에만 사용할 수 있습니다.</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>제네릭 형식에는 'StructLayout' 특성을 지정할 수 없습니다.</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>명시적 개체 생성자는 'new(args) = expr' 구문을 사용해야 합니다.</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>형식이 지정되지 않은 코드 인용을 구분합니다.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>구조체의 기본 생성자는 이러한 바인딩을 실행하지 않으므로 구조체에는 값 정의를 포함할 수 없습니다. 형식의 주 생성자에 인수를 더 추가하십시오.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>이 숫자는 부호 있는 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>제공된 형식 '{1}'의 '{0}' 멤버가 잘못되었습니다. 속성, 메서드 및 생성자만 허용됩니다.</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>'{1}' 형식의 '{0}' 필드에 대해 지정된 할당이 없습니다.</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>'{0}' 형식은 '{1}' 연산자를 지원하지 않습니다.</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>정적 필드 '{0}'의 주소를 현재 사용할 수 없습니다.</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>이 선언은 부분적으로 정규화된 경로를 통해 '{0}' 네임스페이스 또는 모듈을 엽니다. 네임스페이스의 전체 경로가 사용되도록 이 코드를 조정하십시오. 이렇게 변경하면 F# 및 CLI 라이브러리에 새 구문이 추가될 때 코드가 더 견고해집니다.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!'는 시퀀스 식 내에 사용할 수 없습니다.</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>'{0}' 파일 또는 모듈에 대한 구현이 이미 지정되었습니다. 형식 유추로 인해 F#에서는 컴파일 순서가 중요합니다. 구현하기 전에 시그니처 파일을 배치하기 위해 파일의 순서를 조정해야 할 수 있습니다. Visual Studio에서는 파일이 프로젝트 파일에 나타나는 순서대로 형식이 검사되며 이 순서는 수동으로 편집하거나 솔루션 탐색기를 사용하여 조정할 수 있습니다.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>제공된 형식의 네임스페이스가 잘못되었습니다.</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>이 형식 정의에는 구조체 필드 또는 상속 관계를 통해 직접 순환 참조가 사용됩니다.</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>이 값은 리터럴이 아니며 패턴에 사용할 수 없습니다.</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>구조체의 주 생성자에 대한 각 인수에는 형식을 지정해야 합니다(예: 'type S(x1:int, x2: int) = ...'). 이러한 인수는 구조체의 필드를 결정합니다.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>변경할 수 있는 값에는 제네릭 매개 변수를 지정할 수 없습니다.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>이 위치 또는 이 위치 근처에서 'delegate' 제약 조건을 사용하여 제네릭 구문 사용의 모호성을 해결할 수 없습니다.</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>대리자 지정의 형식은 'typ -&gt; typ'여야 합니다.</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute를 구조체 형식 인스턴스 멤버에 적용할 수 없습니다. 해당 인스턴스 멤버가 암시적 'this' byref 매개 변수를 사용합니다.</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get' 및/또는 'set'이 필요합니다.</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}'은(는) 접두사 '{1}' 플래그를 지원하지 않습니다.</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>이 형식 매개 변수가 항상 '{0}'이(가) 되도록 제한하는 방식으로 해당 매개 변수가 사용되었습니다.</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>명명된 인수는 멤버 특성 호출에 지정할 수 없습니다.</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>지정한 .NET Framework 버전 "{0}"은(는) 지원되지 않습니다. Microsoft.Build.Utilities.TargetDotNetFrameworkVersion 열거형의 값을 지정하세요.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>상수 값도 지정된 경우(예: 'val x : int = 1') 선언은 [&lt;Literal&gt;] 특성일 수만 있습니다.</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>'{0}'의 파일 확장명을 인식할 수 없습니다. 소스 파일의 확장명은 .fs, .fsi, .fsx, .fsscript, .ml 또는 .mli여야 합니다.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>이 'inherit' 선언은 상속된 형식을 지정하지만 인수는 지정하지 않습니다. 인수를 제공하십시오(예: 'inherit BaseType(args)').</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>출력 디버그 파일의 이름입니다.</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>소스 파일 및 어셈블리를 확인하는 데 사용되는 포함 경로의 디렉터리를 지정합니다(약식: -I).</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>어셈블리의 유추된 인터페이스를 파일에 출력합니다.</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>다른 어셈블리에 추가될 수 있는 모듈을 빌드합니다.</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>'|' 문자는 활성 패턴 케이스 식별자에 허용되지 않습니다.</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>액세스 가능성 한정자는 이 멤버에서 허용되지 않습니다. 추상 슬롯의 표시 유형은 항상 바깥쪽 형식과 같습니다.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>';'은 레코드에서 필드 값을 구분하는 데 사용됩니다. ','를 ';'으로 바꾸세요.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>’{0}' 연산자 사용과 관련하여 이 프로그램 지점 또는 이 지점 근처에서 본질적으로 발생하는 모호성을 해결할 수 없습니다. 형식 주석을 사용하여 모호성을 해결하세요.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>'{0}' 형식이 정의되지 않았습니다.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>호출자의 코드로 바로 통합되어야 하는 함수를 나타내는 데 사용됩니다.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>열거형 케이스에 대한 올바른 이름이 아닙니다.</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>이 인스턴스 멤버에는 호출하는 개체를 나타내는 매개 변수가 필요합니다. 멤버를 정적 요소로 만들거나 'member x.Member(args) = ...' 표기법을 사용하십시오.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>이름이 '{0}'인 정적 매개 변수가 없습니다.</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>특성 'NoEquality'가 지정된 형식에는 일반적으로 'Object.Equals(obj)'에 대한 명시적 구현이 있으면 안 됩니다. 상호 운용성을 위해 의도적으로 이러한 구현을 사용한 경우에는 이 경고를 사용하지 마십시오.</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>이 작업에 의해 원래 값이 변경되지 않도록 값이 복사되었습니다.</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>이 바인딩에 대한 하나 이상의 명시적 클래스 또는 함수 형식 변수가 다른 형식의 제약을 받으므로 해당 변수를 일반화할 수 없습니다.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>후보: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>'with'의 짝이 맞지 않거나 'with' 블록의 형식이 잘못되었습니다.</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>목록 생성자의 모든 요소는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>명시적 형식 지정은 예외 생성자에 대해 사용할 수 없습니다.</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>레코드 필드 '{0}'에 대한 레코드 타입은 RequireQualifiedAccessAttribute로 정의됩니다. 사용 중인 이름에 레코드 타입('{1}') 이름을 포함하세요.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>해당하는 형식 인수는 필수입니다.</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>값이 잘못되었습니다.</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>시그니처 '{0}' 및 구현 '{1}'의 인수 이름이 서로 일치하지 않습니다. 시그니처 파일의 인수 이름이 사용되며, 이로 인해 디버깅 또는 프로파일링 시 문제가 발생할 수 있습니다.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>값 '{0}'을(를) 사용하지 않습니다.</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>옵션에 필요한 매개 변수: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>선언이 잘못되었습니다.</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>이 숫자는 부호 없는 원시 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>패턴 판별자 '{0}'이(가) 정의되지 않았습니다.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>예기치 않은 입력의 끝입니다.</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>이 어셈블리의 두 부분에서 '{0}'(이)라는 두 개의 모듈이 발생합니다.</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>대리자 형식에 대해 둘 이상의 Invoke 메서드를 찾았습니다.</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>이 식은 함수가 아니며 적용할 수 없습니다. 대신 {0}.[index]를 통해 인덱서에 액세스하려고 했나요?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>'{0}' 매개 변수가 byref 형식으로 유추되었습니다. byref 형식의 매개 변수에는 명시적인 형식 주석(예: 'x1: byref&lt;int&gt;')이 지정되어야 합니다. byref 매개 변수는 사용될 경우 암시적으로 역참조됩니다.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>이 정적 멤버에는 'this' 매개 변수가 있으면 안 됩니다. 'member Member(args) = ...' 표기법을 사용하십시오.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>제네릭 구문을 사용하려면 '{0}' 형식이 비추상 형식이어야 합니다.</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>인라인 구문을 구현하는 데 반드시 필요한 최적화 정보만 포함합니다. 크로스 모듈 인라인 처리가 금지되지만 이진 호환성은 개선됩니다.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>이 형식의 표현은 시그니처에 의해 숨겨져 있습니다. 특징을 나타내기 위해 이 형식에는 [&lt;Sealed&gt;], [&lt;Class&gt;] 또는 [&lt;Interface&gt;]와 같은 특성을 지정해야 합니다.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>'{0}' 형식은 '0' 플래그를 지원하지 않습니다.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>형식 유추로 인해 형식 변수 {0}이(가) 범위를 벗어났습니다. 명시적인 형식 매개 변수 선언을 추가하거나 덜 일반적인 코드로 조정해 보세요.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>디버깅 형식(full, portable, embedded, pdbonly)을 지정합니다. '{0}'은(는) 디버깅 형식을 지정하지 않은 경우 기본값이며 디버거를 실행 중인 프로그램에 연결할 수 있습니다. 'portable'은 플랫폼 간 형식이고, 'embedded'는 출력 파일에 포함된 플랫폼 간 형식입니다.</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>'#' 컴파일러 지시문만 첫 번째 'namespace' 선언 앞에 발생할 수 있습니다.</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>최적화하는 동안 로컬 값 {0}을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>'{0}' 형식 공급자가 이름이 '{1}'이고 메타데이터 토큰이 '{2}'인 메서드를 제공했는데, 이는 해당 선언 형식 '{3}'의 메서드에서 보고되지 않습니다.</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>'{0}' 구문이 잘못되었습니다. 사용법: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>부동 소수점 수가 잘못되었습니다.</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>생성자는 확장 멤버로 사용할 수 없으며 원래 형식 정의의 일부로 정의되어야 합니다.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>개체 생성자 '{0}'에 인수 또는 설정 가능한 반환 속성 '{1}'이(가) 없습니다. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>'anycpu32bitpreferred' 플랫폼은 EXE 대상에만 사용할 수 있습니다. 대신 'anycpu'를 사용해야 합니다.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n이름이 서로 다릅니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 정적 요소이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>구현 형식이 봉인되어 있지 않지만 시그니처는 봉인되어 있음을 암시하므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 구현에 [&lt;Sealed&gt;] 특성을 추가하세요.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>'try'/'with'는 시퀀스 식 내에 사용할 수 없습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>추상 멤버 '{2}'이(가) 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'Object.GetHashCode'의 명시적 구현이 있습니다. 'Object.Equals(obj)'에 대해 일치하는 재정의를 구현하십시오.</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>개체 형식에서 속성 또는 메서드를 선언하는 데 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>관련 형식, 값 및 함수 그룹과 이름을 연결하기 위해 사용되며, 다른 코드와 논리적으로 구별하기 위해 사용됩니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n형식이 서로 다릅니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>각각의 형식 매개 변수 수가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>대리자 지정은 커리된 형식이어서는 안 됩니다. 다중 인수 대리자의 경우 'typ * ... * typ -&gt; typ', 함수 값을 반환하는 대리자의 경우 'typ -&gt; (typ -&gt; typ)'를 사용하십시오.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>값 '{0}'이(가) inline으로 표시되었지만 해당 구현이 충분히 액세스할 수 없는 내부 또는 개인 함수를 사용합니다.</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>'{0}'은(는) 정적 속성이 아닙니다.</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>개체, 시퀀스 또는 레코드 식이 잘못되었습니다.</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>이 값에 대해 유추된 형식 매개 변수는 형식 약어를 지울 경우 불안정적인 상태가 됩니다. 이는 형식 매개 변수를 삭제 또는 다시 정렬하는 형식 약어를 사용했기 때문입니다(예: \n\ttype taggedInt&lt;'a&gt; = int 또는 \n\ttype swap&lt;'a,'b&gt; = 'b * 'a).\n이 값에 대한 형식 매개 변수를 명시적으로 선언하십시오(예: \n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x)).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IStructuralComparable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용하십시오.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>구문 오류</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>'{0}'의 조인 관계가 잘못되었습니다. 'expr &lt;op&gt; expr'이 필요합니다. 여기서 &lt;op&gt;는 =, =?, ?= 또는 ?=?입니다.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>필드 바인딩의 형식은 'id = expr;'이어야 합니다.</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>'{0}'은(는) 정적 이벤트가 아닙니다.</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} var in collection</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>시퀀스에 대한 값을 생성하기 위해 시퀀스 식에 사용됩니다.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>'try/finally' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>IDisposable 인터페이스를 지원하는 개체는 생성 값이 리소스를 소유할 수도 있다는 것을 표시하기 위해 생성자를 나타내는 함수 값으로 'Type(args)' 또는 'Type'이 아니라 'new Type(args)' 구문을 사용하여 만드는 것이 좋습니다.</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>리터럴 값은 'mutable'로 표시할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>루프 구문을 지정합니다.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0}은(는) 정적 메서드가 아닙니다.</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>특성은 인터페이스 구현에서 허용되지 않습니다.</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>이 식 형식은 시퀀스 및 계산 식에만 사용할 수 있습니다.</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>인용구에는 공용 구조체 케이스 인덱스를 페치하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>자세한 구문에서 클래스 정의의 시작을 나타냅니다.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>자세한 구문에서 코드 블록의 시작을 나타냅니다.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>형식 매개 변수의 개체 생성자에 대한 호출에는 인수를 지정할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>패턴에 대한 값을 비교하여 분기하는 데 사용됩니다.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>가져온 어셈블리에 예기치 않은 상황이 발생했습니다. AttributeUsage 특성을 디코딩하지 못했습니다.</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>이 공용 구조체 케이스는 인수를 사용하지 않습니다.</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>최상위 .NET 네임스페이스를 참조하는 데 사용됩니다.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>계산 식 작성기가 '{0}' 메서드를 정의하는 경우에만 이 제어 구문을 사용할 수 있습니다.</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>/ 다음의 측정값에 대한 암시적 곱입니다.</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>제공된 필드가 잘못되었습니다. 지워진 제공된 형식의 제공된 필드는 리터럴이어야 합니다.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>알려진 쿼리 연산자가 아닙니다. 쿼리 연산자는 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' 및 'averageBy' 등의 식별자로, 'QueryBuilder' 형식에서 해당하는 메서드를 사용하여 정의됩니다.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다.</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>측정 단위는 float, float32, decimal 및 부호 있는 정수 형식에 대해서만 지원됩니다.</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>'{0}'은(는) 정적 필드가 아닙니다.</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>파일은 네임스페이스 또는 모듈 선언으로 시작해야 하지만(예: 'namespace SomeNamespace.SubNamespace' 또는 'module SomeNamespace.SomeModule') 둘 다로 시작할 수는 없습니다. 네임스페이스 내에 모듈을 정의하려면 'module SomeModule = ...'을 사용하십시오.</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>이 외부 함수의 시그니처에 형식 매개 변수가 포함되어 있습니다. 인수 및 반환 형식을 제한하여 해당하는 C 함수의 형식을 나타내십시오.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>패턴 일치 식의 모든 분기는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>'{0}' 메서드는 봉인되어 재정의할 수 없습니다.</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}'의 짝이 맞지 않습니다.</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>변수, 상수, 활성 인식기 또는 리터럴이 아닙니다.</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>'{0}' 필드에 값이 지정되었지만 해당 필드가 '{1}' 형식에 없습니다.</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>인용구에는 정적 필드를 페치하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>정적 값 정의는 기본 생성자가 포함된 형식에서만 사용할 수 있습니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보십시오.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>이 특성에 대한 코드 대상을 찾을 수 없습니다. 특성 뒤의 코드가 완료되지 않았습니다.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>모듈 또는 네임스페이스 이름이 잘못되었습니다.</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>사용자 지정 연산</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>디버그 중 코드를 확인하는 데 사용됩니다.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>이 파일의 선언은 파일 이름 '{1}'을(를) 기반으로 암시적 모듈 '{0}'에 배치됩니다. 그러나 이는 올바른 F# 식별자가 아니므로 다른 파일에서 내용에 액세스할 수 없게 됩니다. 파일의 이름을 바꾸거나 파일의 맨 위에 'module' 또는 'namespace' 선언을 추가하세요.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>키 파일 '{0}'을(를) 열 수 없습니다.</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>인용구에는 배열 패턴 일치를 포함할 수 없습니다.</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>한 튜플 형식은 구조체 튜플이고 다른 튜플 형식은 참조 튜플입니다.</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 더 필요합니다. 필요한 시그니처는 '{2}'입니다. 누락된 인수의 이름에는 {3} 등이 있습니다.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 필요합니다. 필요한 시그니처는 '{2}'입니다. 누락된 인수의 이름에는 {3} 등이 있습니다.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>멤버 또는 개체 생성자 '{0}'을(를) 사용하려면 {1}개의 인수가 더 필요합니다. 필요한 시그니처는 '{2}'입니다.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'let!' 키워드와 같은 열로 들여써야 합니다.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>형식 인수 또는 정적 인수가 필요합니다.</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>지정된 옵션 'win32manifest'와 'win32res'가 충돌합니다. 둘 중 하나만 사용할 수 있습니다.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>속성이 중복되었습니다. '{0}' 속성의 이름 및 시그니처가 '{1}' 형식의 다른 속성과 같습니다.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>기본 출력 언어 문화권 이름 지정(예: es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>시퀀스 식에서는 'yield'를 사용하여 결과가 생성됩니다.</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>강력한 이름의 키 파일을 지정합니다.</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>예기치 않은 식별자입니다. '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>줄 번호가 잘못되었습니다. '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>선택적 인수는 여기에 허용되지 않습니다.</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>이 구문은 실험적입니다.</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>확대는 대리자 형식 moduleDefns에서 허용되지 않습니다.</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}'은(는) 올바른 정수 인수가 아닙니다.</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>mscorlib.dll 또는 FSharp.Core.dll이 명시적으로 참조될 경우 {0} 옵션도 전달해야 합니다.</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>속성 getter 및 setter에 대한 형식 주석은 'get()' 또는 'set(v)' 뒤에 지정해야 합니다(예: 'with get() : string = ...').</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Windows 실행 파일을 빌드합니다.</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>출력 파일의 이름입니다(약식: -o).</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>--sourcelink 스위치는 이식 가능한 PDB를 내보낼 때만 지원됩니다(--debug:portable 또는 --debug:embedded).</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>'{0}' 매개 변수에 적용된 CallerMemberNameAttribute는 효과가 없습니다. CallerFilePathAttribute로 재정의됩니다.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>명명되지 않은 모든 정적 인수 뒤에는 명명된 정적 인수가 와야 합니다.</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>콘솔 실행 파일을 빌드합니다.</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>구현된 모든 인터페이스는 초기 형식 선언 시 선언해야 합니다.</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>예기치 않은 소스 수준 속성 지정입니다.</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>추상 기본 멤버를 호출할 수 없습니다. '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>'ConditionalAttribute' 특성은 멤버에 대해서만 사용할 수 있습니다.</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>특성 'CustomComparison'이 지정된 형식에는 'System.IComparable' 또는 'System.Collections.IStructuralComparable' 중 하나 이상에 대한 명시적 구현이 있어야 합니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \nCLI 멤버 이름이 서로 다릅니다.</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>이 기본값으로 구현된 메서드가 모호합니다.</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F#에서는 1에서 32까지의 배열 순위를 지원합니다. {0} 값은 사용할 수 없습니다.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>인용구에는 이러한 종류의 형식을 포함할 수 없습니다.</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>추상 및 가상 멤버의 재정의만 개체 식에 지정할 수 있습니다.</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>지정한 파일에 어셈블리의 xmldoc를 씁니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>'{2}' 필드가 구현에 있었지만 시그니처에는 없었으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다. 이제 구조체 형식은 시그니처에서 형식에 대해 필드를 표시해야 하지만 필드의 레이블은 계속 'private' 또는 'internal'로 지정할 수 있습니다.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>공용 구조체 케이스 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>레코드, 공용 구조체, 예외 및 구조체 형식만 'ReferenceEquality', 'StructuralEquality' 및 'StructuralComparison' 특성으로 확대할 수 있습니다.</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>잘못된 서명 크기</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Win32 매니페스트 파일을 지정합니다.</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>인덱서 식이 잘못되었습니다.</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>형식 이름은 비워 둘 수 없습니다.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>소스 파일 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>모듈 또는 네임스페이스 부모 {0}이(가) 필요합니다.</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>'id = expr' 형식의 단순 바인딩만 생성 식에 사용할 수 있습니다.</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>선언된 프로그램 요소가 다른 이진 또는 어셈블리에 정의됨을 나타냅니다.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>이식 가능한 PDB 파일에 포함할 소스 링크 정보 파일</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new'는 개체 생성자에만 사용할 수 있습니다.</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>이 코드는 해당 주석에 표시된 것보다 일반적이지 않습니다. '_'을 사용하여 지정된 측정 단위는 '1', 즉 차원이 없는 것으로 결정되었습니다. 코드를 제네릭 형식으로 만들거나 '_'을 사용하지 마십시오.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>올바른 리터럴 식이 아닙니다. [&lt;Literal&gt;] 특성은 무시됩니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>시그니처가 이 형식에서 null을 추가 값으로 사용할 수 있다고 하지만 구현은 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>'try/with' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>F# 라이브러리 및 이 라이브러리에 종속된 모든 참조 DLL을 생성되는 어셈블리에 정적으로 링크합니다.</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>'{1}' 어셈블리의 특성 'AutoOpen(\"{0}\")'이 해당 어셈블리의 올바른 모듈 또는 네임스페이스를 참조하지 않아 무시되었습니다.</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>이 필드는 변경할 수 없습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>형식의 종류가 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>열거에는 인터페이스 선언을 지정할 수 없습니다.</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>라이브러리를 빌드합니다(약식: -a).</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>'{0}' 어셈블리를 확인할 수 없습니다.</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>{1}개의 인수를 사용하는 멤버 또는 개체 생성자 '{0}'은(는) 이 코드 위치에서 액세스할 수 없습니다. '{2}' 메서드의 액세스할 수 있는 모든 버전은 {3}개의 인수를 사용합니다.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>'{0}'의 약식입니다.</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>형식을 정의할 때 인터페이스의 명시적 구현이 지정되지 않았으므로 이 인터페이스의 기본 구현이 이미 추가되었습니다.</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>명명된 필드 {0}이(가) 두 번 이상 사용되었습니다.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>결정적 빌드는 이식 가능한 PDB만 지원합니다(--debug:portable 또는 --debug:embedded).</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>개체 식이 잘못되었습니다. 재정의 또는 인터페이스가 없는 개체는 중괄호 없이 식 형식 'new Type(args)'을 사용해야 합니다.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>소스: {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>for 식에서 역으로 계산할 때 사용됩니다.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>이 형식은 레코드 형식이 아닙니다.</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>인용구에는 필드의 주소를 사용하는 식을 포함할 수 없습니다.</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'은(는) 'System.IComparable' 인터페이스를 명시적으로 구현합니다. 형식에 'CustomComparison' 특성을 적용해야 합니다.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>if/then/else 식은 쿼리 내에서 사용할 수 없습니다. 대신 if/then 식을 사용하거나 시퀀스 식을 사용해 보십시오.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>정적 매개 변수 '{0}'에 이미 값이 제공되었습니다.</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>이식 가능한 PDB 파일에 특정 소스 파일을 포함합니다.</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>byref 형식의 변수 '{0}'이(가) 잘못된 방식으로 사용되었습니다. byref는 클로저로 캡처하거나 내부 함수로 전달할 수 없습니다.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>'{0}' 속성은 설정할 수 없습니다.</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>이 속성은 설정할 수 없습니다.</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>address-of 연산자의 첫 번째 클래스 사용은 허용되지 않습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 생성자/속성이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>개체 생성 식은 클래스 형식의 생성자를 구현하는 데에만 사용할 수 있습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>'{0}' 필드가 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{2}을(를) 지정합니다.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>이 숫자 리터럴을 사용하려면 FromZero, FromOne, FromInt32, FromInt64 및 FromString 함수를 정의하는 '{0}' 모듈이 범위 내에 있어야 합니다.</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>생성자는 이 형식에 대해 지정할 수 없습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>'{2}' 필드가 시그니처에 필요했지만 구현에 의해 지정되지 않았으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>선택적 인수는 형식 멤버에 대해서만 허용됩니다.</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>제공된 형식에 대한 참조에서 정적 매개 변수 '{0}'의 값이 누락되었습니다. 참조되는 어셈블리를 하나 이상 다시 컴파일해야 할 수 있습니다.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>'if' 식의 모든 분기는 동일한 형식이어야 합니다. 이 식에는 '{0}' 형식이 필요하지만 여기에서는 '{1}' 형식이 지정되었습니다.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>지운 시간</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>이 값, 형식 또는 메서드에는 {0}개의 형식 매개 변수가 필요한데 {1}개를 받았습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>시그니처와 구현에서 필드의 순서가 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>사용자 지정 연산은 이 계산 식의 다른 부분에 있는 값이 아니거나 재귀적인 'let' 바인딩과 함께 사용할 수 없습니다.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>'{0}' 멤버에 올바른 수의 메서드 형식 매개 변수가 없습니다. 필요한 시그니처는 '{1}'입니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>시그니처에 의해 CLI 형식 표현이 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralComparison' 특성이 있지만 형식 매개 변수 '{1}'이(가) 'comparison' 제약 조건을 만족하지 않습니다. 형식 매개 변수에 'comparison' 제약 조건을 추가하십시오.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>구조체, 레코드 또는 공용 구조체 형식 '{0}'에 'StructuralComparison' 특성이 있지만 구성 요소 형식 '{1}'이(가) 'comparison' 제약 조건을 만족하지 않습니다.</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>'{0}' 변수의 주소를 현재 사용할 수 없습니다.</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>공용 구조체 케이스</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>전역 어셈블리 캐시</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>인터페이스가 중복되었습니다.</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>잘못된 지시 파일 '{0}'('{1}')</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>'use!' 바인딩은 'use! &lt;var&gt; = &lt;expr&gt;' 형식이어야 합니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>시그니처에 의해 형식 표현이 숨겨져 있으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>레코드, 시퀀스 또는 계산 식이 잘못되었습니다. 시퀀스 식의 형식은 'seq {{ ... }}'여야 합니다.</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>제공된 형식 '{1}'에 대한 이벤트 '{0}'에 GetAddMethod()의 값이 없습니다.</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>인터페이스를 선언하고 구현하는 데 사용됩니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 확장 멤버이고 다른 하나는 그렇지 않습니다.</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>속성 setter는 'set value = ', 'set idx value = ' 또는 'set (idx1,...,idxN) value = ... '를 사용하여 정의해야 합니다.</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>매개 변수가 있는 패턴 레이블에 대한 인수가 잘못되었습니다.</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>잘못된 비트 길이</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>#if 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>이름이 '{0}'인 정적 매개 변수가 여러 개 있습니다.</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>volatile 필드는 'mutable'로 표시해야 하며 Thread 정적일 수 없습니다.</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>공용 구조체 케이스의 반환 형식은 약어까지 정의 대상 형식과 동일해야 합니다.</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 재정의 또는 인터페이스 구현에서 허용되지 않습니다.</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>대신 확장명이 '.ml' 또는 '.mli'인 파일을 사용해 보십시오.</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>이 속성은 추상 속성을 재정의하거나 구현하지만 추상 속성에 해당하는 {0}이(가) 없습니다.</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>컴파일러 오류: 예기치 않은 구현되지 않은 값이 있습니다.</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>제공된 형식에 대한 참조의 값('{0}')이 정적 매개 변수에 대해 잘못되었습니다. 참조되는 어셈블리를 하나 이상 다시 컴파일해야 할 수 있습니다.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>시그니처와 구현에서 예외 약어가 서로 다르므로 예외 정의가 호환되지 않습니다. 모듈에 예외 정의\n    {0}이(가) 포함되어 있지만    \n해당 시그니처는\n\t{1}을(를) 지정합니다.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>사용자 지정 특성 값이 잘못되었습니다(상수 또는 리터럴이 아님).</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>예외 약어에는 인수 목록을 지정하면 안 됩니다.</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>이 속성에는 잘못된 형식이 있습니다. 다중 인덱서 인수를 사용하는 속성에는 'ty1 * ty2 -&gt; ty3'과 같은 형식이 있어야 합니다. 함수를 반환하는 속성에는 '(ty1 -&gt; ty2)'와 같은 형식이 있어야 합니다.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>byref 형식의 값이 여기에 저장됩니다. 최상위 let 바인딩 byref 값은 허용되지 않습니다.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>이 식별자에 대해 다중 표시 유형 특성이 지정되었습니다. 클래스의 'let' 바인딩은 식 안의 모든 'let' 바인딩과 마찬가지로 항상 Private입니다.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>인용구에는 제네릭 형식으로 유추되거나 선언되는 함수 정의를 포함할 수 없습니다. 형식 제약 조건을 추가하여 올바른 따옴표 붙은 식으로 만드십시오.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>서식 지정자의 정밀도가 잘못되었습니다.</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>이 형식에는 액세스 가능한 개체 생성자가 없습니다.</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>형식 공급자 '{1}' 의 형식 '{0}'에 빈 네임스페이스가 있습니다. 전역 네임스페이스에 대해 'null'을 사용하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>구현이 이 형식에서 null을 추가 값으로 사용할 수 있다고 하지만 시그니처는 그렇지 않으므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>이 개체 생성자에는 인수가 필요합니다.</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>액세스 가능성 한정자는 'inherits' 선언에서 허용되지 않습니다.</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>이 형식을 사용하려면 정의가 필요합니다.</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>리터럴 필드를 설정할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>범위를 나타내기 위해 루프에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>부울 또는 연산자로 부울 조건과 함께 사용됩니다. ||와 같습니다. 멤버 제약 조건에도 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>구분된 공용 구조체에 사용되어 값 범주의 형식을 나타내고, 대리자 및 예외 선언에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>조건부 분기 구문에 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>바인딩에서 식을 구분하기 위해 시퀀스 식과 자세한 구문에서 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>현재 클래스 개체 및 개체 이름을 제공하는 데 사용됩니다. 패턴 일치 내의 전체 패턴에 이름을 제공하는 데에도 사용됩니다.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>루프 구문에 사용되거나 명령형 코드를 실행하기 위해 사용됩니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n변경 가능성 특성이 서로 다릅니다.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>공통 IL 예외 형식에 대한 약어에는 일치하는 개체 생성자가 있어야 합니다.</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>유효한 숫자 리터럴이 아닙니다. 유효한 숫자 리터럴로는 1, 0x1, 0b0001(int), 1u(uint32), 1L(int64), 1UL(uint64), 1s(int16), 1y(sbyte), 1uy(byte), 1.0(float), 1.0f(float32), 1.0m(decimal), 1I(BigInteger) 등이 있습니다.</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>'CustomEquality' 특성은 'NoComparison' 또는 'CustomComparison' 특성과 함께 사용해야 합니다.</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>getter 속성에는 인수 그룹이 최대 하나만 있을 수 있습니다.</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>이 멤버, 함수 또는 값 선언은 'inline'으로 선언할 수 없습니다.</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>잘못된 전위 연산자</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>여기서는 세미콜론이 필요하지 않습니다.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}'이(가) 잘못 사용되었습니다. 사용법: {1}. 이 항목은 이 쿼리 또는 계산 식의 사용자 지정 연산입니다.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>'{0}'의 재정의가 모호합니다.</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>강력한 이름의 키 컨테이너를 지정합니다.</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>'expr.[idx]' 연산자가 이 프로그램 지점 전의 정보를 기반으로 하는 확인할 수 없는 형식의 개체에 사용되었습니다. 형식 제약 조건을 더 추가하십시오.</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- 오류 및 경고 -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>MSBuild 확인이 아니라 디렉터리 기반의 규칙을 사용하여 어셈블리 참조를 확인합니다.</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>메서드가 중복되었습니다. 추상 메서드 '{0}'의 이름 및 시그니처가 상속된 형식의 추상 메서드와 같습니다(튜플, 함수, 측정 단위 및/또는 제공된 형식을 지울 경우).</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>측정 단위는 형식 생성자 적용 시 사용할 수 없습니다.</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>개체 생성 식, 즉 상속 지정이 있는 레코드 식은 개체 모델 형식의 생성자를 구현하는 데에만 사용할 수 있습니다. 'new ObjectType(args)'을 사용하여 생성자 외부에 개체 모델 형식의 인스턴스를 생성하십시오.</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}'은(는) 연산자 이름에서 허용되는 문자가 아니며 나중에 사용할 수 있도록 예약되었습니다.</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>'use' 식은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>'{0}' 형식은 이 구문을 사용하여 열거할 수 있는 값을 포함하는 형식이 아닙니다. 즉, seq&lt;_&gt;, IEnumerable&lt;_&gt; 또는 IEnumerable과 호환되지 않으며 GetEnumerator 메서드를 가지지 않습니다.</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>예기치 않은 빈 긴 식별자입니다.</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>지시문이 잘못되었습니다. '#r \"&lt;file-or-assembly&gt;\"'가 필요합니다.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>형식 유추로 인해 유추 형식 변수가 범위를 벗어났습니다. 형식 주석을 추가하여 덜 일반적인 코드로 만들어 보세요.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>'{0}' 형식은 '{1}' 형식으로의 변환을 지원하지 않습니다.</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>명령줄 옵션 '--cliroot'는 사용되지 않습니다. mscorlib.dll의 특정 복사본에 대한 명시적 참조를 대신 사용하십시오.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>이름이 서로 다르므로 시그니처 및 구현의 {0} 정의가 호환되지 않습니다. 시그니처 파일의 형식은 '{1}'이지만 구현의 형식은 '{2}'입니다.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>코드 생성 중에 'methodhandleof'에 대한 잘못된 인수가 발견되었습니다.</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>식에 예기치 않은 '=' 기호가 있습니다. 대신 'for x in y .. z do'를 사용하려고 했나요?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>'{0}' 형식에 대해 사용할 수 있는 생성자가 없습니다.</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>인터페이스가 중복 지정되었습니다.</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>대상 이진 파일의 종속성 집합에서 어셈블리 '{0}'을(를) 찾지 못했습니다. 정적으로 링크된 루트는 DLL 또는 EXE 확장명이 없는 상태로 어셈블리 이름을 사용하여 지정해야 합니다. 이 어셈블리가 명시적으로 참조된 경우 생성된 이진 파일에서 실제로 필요하지 않을 수 있습니다. 이런 경우에는 정적으로 링크하지 마십시오.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>'{0}' 형식이 'System.IComparable'을 구현합니다. 'Object.Equals'에 대한 명시적 재정의도 추가하십시오.</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>상호 재귀적 바인딩과 속성 선언에 사용되며 제네릭 매개 변수의 여러 제약 조건과 함께 사용됩니다.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>올바른 상수 식이 아닙니다.</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>'{1}'에서 지시 파일 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>'{0}' 네임스페이스가 정의되지 않았습니다.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>'{0}' 형식에서 '{1}' 연산자를 지원하지 않습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보십시오.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 'do' 바인딩에서 허용되지 않지만, '{0}'이(가) 지정되었습니다.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>전처리기 식에 예기치 않은 문자 '{0}'이(가) 있습니다.</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>최대 하나의 'with' 확대가 허용됩니다.</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>특성이 지정된 매개 변수에는 이름도 지정해야 합니다(예: '[&lt;Attribute&gt;] Name : Type').</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>이 레코드 식 또는 패턴의 필요한 형식 및 필드 레이블이 해당하는 레코드 형식을 고유하게 확인하지 않습니다.</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>하나의 결과를 반환하는 활성 패턴만 인수를 사용할 수 있습니다.</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>중위 연산자 멤버 '{0}'에 {1}개의 초기 인수가 있습니다. 2개 인수의 튜플이 필요합니다(예: 정적 멤버 (+) (x,y) = ...).</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>인수</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>이 구문은 ML 호환성을 위해 사용됩니다. {0}. 이 경고가 나타나지 않게 하려면 '--mlcompatibility' 또는 '--nowarn:62'를 사용합니다.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>F#에서는 # 서식 지정 한정자를 사용할 수 없습니다.</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>강력한 이름 키의 공개 부분만 사용하여 어셈블리 서명을 연기합니다.</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>예외 형식을 선언하는 데 사용됩니다.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>이 메서드에 대한 하나 이상의 오버로드에 커리된 인수가 있습니다. 튜플된 형식의 인수를 사용하려면 이러한 멤버를 다시 디자인하십시오.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global'은 정규화된 경로에서 첫 번째 이름으로만 사용할 수 있습니다.</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>리터럴 열거형의 형식은 int, uint, int16, uint16, int64, uint64, byte, sbyte 또는 char이어야 합니다.</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>어셈블리 '{2}' 테이블 '{1}'의 {0} 위치에서 F# 메타데이터 노드를 읽는 중 오류가 발생했습니다. 노드에 일치하는 선언이 없습니다. 이 경고를 보고해 주세요. 사용하고 있는 F# 어셈블리를 다시 컴파일해야 할 수 있습니다.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>이진 파일 '{0}'을(를) 여는 동안 오류가 발생했습니다. {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>멤버 이름이 잘못되었습니다. 멤버 이름은 '.ctor' 또는 '.cctor'일 수 없습니다.</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>서식 지정자가 잘못되었습니다. '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>이는 리터럴 필드가 아니며 패턴에 사용할 수 없습니다.</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>레코드 필드 및 단순, 비재귀적 'let' 바인딩만 mutable로 표시할 수 있습니다.</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>지시문이 잘못되었습니다. '#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"'이 필요합니다.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>'{0}' 형식에 '{1}' 메서드(전체 이름: '{2}')가 있지만 정적 메서드입니다.</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>이 재정의에 해당하는 추상 또는 인터페이스 멤버를 찾을 수 없습니다.</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>올바른 패턴이 아닙니다.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'for' 식에서 'do'가 누락되었습니다. 'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;'이 필요합니다.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>제네릭 추상 메서드를 재정의할 때는 모든 형식 매개 변수를 명시적으로 선언하거나 형식 매개 변수를 선언하지 않아야 합니다.</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>형식 공급자의 '{0}' 식은 지원되지 않습니다. 이 형식 공급자의 작성자인 경우 제공된 다른 식을 제공하도록 조정하십시오.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>이 어셈블리의 하위 시스템 버전을 지정하십시오.</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>예기치 않은 byref 형식 변수의 사용입니다.</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>'inline'으로 표시된 값 '{0}'을(를) 인라인하지 못했습니다. 재귀 값이 'inline'으로 표시된 것 같습니다.</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>함수 형식에서 인수와 반환 값을 구분합니다. 시퀀스 식에서 식을 만들며, yield 키워드와 동일합니다. 일치 식에서 사용됩니다.</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>구조체에는 인수가 없는 개체 생성자를 지정할 수 없습니다. 이는 구조체가 기본 생성자를 자동으로 지원하기 때문에 모든 CLI 언어에 적용되는 제한입니다.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>잘못된 algId - '지수'가 필요합니다.</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>'return'이 아니라 'return!'를 사용하세요.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>'!' 연산자는 참조 셀을 역참조하는 데 사용됩니다. 여기에 'not expr' 사용을 고려하세요.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>F# 관련 메타데이터를 포함하는 생성 어셈블리에 리소스를 추가하지 마세요.</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>형식 식에 예기치 않은 중위 연산자가 있습니다.</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>--embed 스위치는 이식 가능한 PDB를 내보낼 때만 지원됩니다(--debug:portable 또는 --debug:embedded).</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>잘못된 연산자 정의입니다. 전위 연산자 정의에서는 유효한 전위 연산자 이름을 사용해야 합니다.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>명명되지 않은 인수는 호출된 메서드의 인수에 대한 접두사를 형성하지 않습니다.</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>제공된 형식의 전체 이름이 잘못되었습니다.</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>#else 지시문은 줄에서 공백이 아닌 첫 번째 문자로 나타나야 합니다.</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>공용 구조체 케이스/예외 필드 '{0}'은(는) 두 번 이상 사용할 수 없습니다.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 공용 구조체 케이스에서 허용되지 않습니다. 표현 전체에 액세스 가능성을 지정하려면 'type U = internal ...' 또는 'type U = private ...'을 사용하십시오.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>형식 인스턴스에 byref 형식이 포함되어 있습니다. 이는 공통 IL의 규칙에서 허용되지 않습니다.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>알 수 없는 공용 구조체 케이스입니다.</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 형식에 대한 비교 의미 체계를 정의하려면 'System.IComparable' 인터페이스를 구현하십시오. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하십시오.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>형식 약어에는 확대를 지정할 수 없습니다.</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>모듈에\n    {0} 생성자가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n시그니처에 지정된 액세스 가능성이 구현에 지정된 액세스 가능성보다 높습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처와 구현의 인자 수가 서로 다릅니다. 시그니처는 '{3}'이(가) {4}개 이상의 인수를 적용하는 함수 정의 또는 람다 식임을 지정하지만 구현은 계산된 함수 값입니다. 계산된 함수 값이 허용되는 구현임을 선언하려면 시그니처에서 해당 형식을 괄호로 묶기만 하면 됩니다(예: \n\tval {6}: int -&gt; int -&gt; int\n대신\n\tval {5}: int -&gt; (int -&gt; int)).</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>및 기타 오버로드 {0}개</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>'{0}' 형식은 CLI 열거형 형식이 아닙니다.</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>모듈 약어는 경로가 아니라 단순 이름이어야 합니다.</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>재귀 값은 재귀적 바인딩 내에서 '{0}' 형식의 구성 요소로 직접 나타날 수 없습니다. 이 기능은 F# 언어에서 제거되었습니다. 대신 레코드를 사용하십시오.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>F# {0}에 대한 F# 컴파일러</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>명명된 인수에 둘 이상의 값이 할당되었습니다.</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>정적 링크 중에 관리되는/관리되지 않는 어셈블리가 혼합된 '{0}'을(를) 무시합니다.</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>기본 생성자가 없는 구조체 및 클래스에만 'StructLayout' 특성을 지정할 수 있습니다.</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>측정 단위 매개 변수가 아니라 형식 매개 변수가 필요합니다.</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>추상 메서드의 구현을 나타냅니다. 추상 메서드 선언과 함께 사용하여 가상 메서드를 만듭니다.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>주석에 포함된 3중 따옴표 문자열의 파일 끝이 여기나 그 앞에서 시작됩니다.</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>높은 엔트로피 ASLR 사용</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>개인 키가 필요합니다.</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>활성 패턴 결과</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>이 선언은 재귀 선언 그룹에서는 지원되지 않습니다.</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>전처리기 식에 토큰 '{0}'이(가) 없습니다.</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>끝내는 중 - 오류가 너무 많습니다.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>'{0}' 멤버에 올바른 수의 인수가 없습니다. 필요한 시그니처는 '{1}'입니다.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>이 형식은 잘못된 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' 및 'StructuralComparison' 특성의 조합을 사용합니다.</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>이 정의는 기본 생성자가 포함된 형식에서만 사용할 수 있습니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보십시오.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>특성 형식 '{0}'에 'AllowMultiple=false'가 있습니다. 이 특성의 여러 인스턴스를 단일 언어 요소에 연결할 수 없습니다.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>시퀀스 식에서는 'yield!'를 사용하여 다중 결과가 생성됩니다.</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>'{0}' 형식은 '{1}' 연산자를 지원하지 않습니다. 'Microsoft.FSharp.Linq.NullableOperators' 모듈을 열어 보십시오.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>구조체, 인터페이스, 열거형 및 대리자는 다른 형식에서 상속될 수 없습니다.</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>제공된 형식에서 '{0}' 형식에 대한 제네릭 인수의 수가 잘못되었습니다. '{1}'개의 인수가 필요한데 '{2}'개가 제공되었습니다.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>'{0}' 메서드는 이 코드 위치에서 액세스할 수 없습니다.</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>CLR 헤더의 잘못된 매직 값</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>속성 또는 필드에 대한 선택적 할당이 잘못되었습니다.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다. 명명된 인수 '{3}'은(는) 오버로드에 대한 어떠한 인수 또는 설정 가능한 반환 속성에도 해당하지 않습니다.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>이름이 '{1}'인 {0} 멤버 또는 개체 생성자 중 {2}개의 인수를 사용하는 요소가 없습니다. 이 멤버를 호출하면 {3}개의 명명된 인수도 제공됩니다.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>필드 레이블이 잘못되었습니다.</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>MarshalAs 특성을 디코딩할 수 없습니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>IL 표현이 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>제네릭이 아닌 형식 '{0}'에는 형식 인수가 필요하지 않지만 여기에서는 {1}개의 형식 인수가 지정되었습니다.</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>'{0}' 값, 생성자, 네임스페이스 또는 형식이 정의되지 않았습니다.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>네임스페이스/모듈</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>'{0}' 형식에 재귀적 클래스 계층 구조가 있습니다.</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>재귀적 개체 참조 '{0}'을(를) 사용하지 않습니다. 재귀적 개체 참조가 있으면 이 형식 및 파생 형식의 멤버에 대한 런타임 초기화 검사가 추가됩니다. 이 재귀적 개체 참조를 제거하십시오.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>형식에 'ReferenceEquality' 특성과 'StructuralEquality' 또는 'StructuralComparison' 특성을 모두 지정할 수는 없습니다.</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>이 생성자는 계산 식 내에서만 사용할 수 있습니다.</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>내용을 변경하거나 값 형식의 주소를 사용하려면 값을 변경할 수 있어야 합니다(예: 'let mutable x = ...').</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>예외 약어는 기존 예외 또는 System.Exception에서 파생되는 F# 형식을 참조해야 합니다.</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>이식 가능한 PDB 파일에 모든 소스 파일 포함</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>단순 변수 패턴만 'let rec' 구문에 바인딩할 수 있습니다.</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>연속된 인수는 공백으로 구분하거나 튜플해야 하며 함수 또는 메서드 적용과 관련된 인수는 괄호로 묶어야 합니다.</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>예외가 아닙니다.</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>내부 오류입니다. 활성 패턴 배열에 대한 인덱스가 잘못되었습니다.</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>어셈블리 '{0}'이(가) 타동적으로 참조되었으며 어셈블리를 자동으로 확인할 수 없습니다. 정적 링크에서는 이 DLL에 F# 라이브러리나 다른 정적 링크 DLL에 대한 종속성이 없다고 가정합니다. 이 DLL에 대한 명시적 참조를 추가하는 것이 좋습니다.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>'System.Reflection.AssemblyCultureAttribute' 특성을 내보내는 동안 오류 발생 -- '실행 파일은 위성 어셈블리일 수 없습니다. 문화권은 항상 비어 있어야 합니다.'</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>인터페이스의 표시 유형은 항상 바깥쪽 형식과 같습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n하나는 형식 함수이고 다른 하나는 그렇지 않습니다. 명시적 형식 매개 변수가 구현에 있는 경우 시그니처에도 해당 형식 매개 변수가 필요합니다.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>'module ... = struct .. end' 구문은 F# 코드에서 사용되지 않습니다. 'module ... = begin .. end'를 사용하십시오.</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>'VolatileField' 특성은 클래스의 'let' 바인딩에 대해서만 사용할 수 있습니다.</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>모듈에\n    {0} 필드가 포함되어 있지만    \n해당 시그니처는\n    {1}을(를) 지정합니다.    \n'literal' 한정자가 서로 다릅니다.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>약어가 {2}과(와) {3}(으)로 서로 다르므로 시그니처 및 구현의 '{1}' 형식에 대한 {0} 정의가 호환되지 않습니다.</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>명시적 정적 이니셜라이저는 'static new(args) = expr' 구문을 사용해야 합니다.</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>함수만 'inline'으로 표시할 수 있습니다.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>이 형식은 인터페이스 형식이 아닙니다.</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>'{0}' 형식은 인터페이스 형식이 아닙니다.</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>개체 생성자는 개체 초기화 전에 try/with 및 try/finally를 직접 사용할 수 없습니다. 여기에는 이러한 구문의 사용을 자세히 설명할 수 있는 'for x in ...'과 같은 구문이 포함됩니다. 이는 공통 IL의 제한입니다.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' 및 'return!'은 쿼리에서 사용할 수 없습니다.</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>액세스 가능성 한정자는 레코드 필드에서 허용되지 않습니다. 표현 전체에 액세스 가능성을 지정하려면 'type R = internal ...' 또는 'type R = private ...'을 사용하십시오.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>무료 리소스로 호출하기 위해 Dispose가 필요한 값에 대해 기타 계산 식 및 비동기 워크플로에서 let! 대신 사용됩니다.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>상속 선언은 여기에 허용되지 않습니다.</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>제공된 '{0}' 형식의 멤버 정보('{1}')에 null 선언 형식이 있습니다.</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>'{0}' 형식 공급자가 잘못된 메서드를 'ApplyStaticArgumentsForMethod'에서 반환했습니다. '{1}'라는 메서드를 예상했지만 '{2}'라는 메서드가 반환되었습니다.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0}은(는) 유효한 유니코드 문자 이스케이프 시퀀스가 아닙니다.</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>'{0}'(이)라는 형식이 여러 개 있으며 이러한 형식에 서로 다른 수의 제네릭 매개 변수가 사용되고 있습니다. 형식 확인을 구분하기 위한 형식 인스턴스를 제공하십시오(예: '{1}').</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>네임스페이스 또는 모듈 특성이 시그니처와 구현 간에 서로 다릅니다.</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>'{0}' 인터페이스가 명시적으로 구현된 다중 인터페이스 형식에 포함되어 있습니다. 이 인터페이스의 명시적 구현을 추가하십시오.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>'{0}' 이벤트에 비표준 형식이 있습니다. 이 이벤트가 다른 CLI 언어로 선언된 경우 이벤트에 대한 명시적 {1} 및 {2} 메서드를 사용하여 이 이벤트에 액세스해야 할 수 있습니다. 이 이벤트가 F#으로 선언된 경우에는 이벤트의 형식을 'IDelegateEvent&lt;_&gt;' 또는 'IEvent&lt;_,_&gt;'의 인스턴스로 만드십시오.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>'type X with ...' 구문은 확대를 위해 예약되었습니다. 표현이 숨겨져 있지만 멤버를 가지고 있는 형식은 이제 'type X = ...'를 사용하여 시그니처에 선언됩니다. 시그니처에 있는 형식 정의에 '[&lt;Sealed&gt;] 특성을 추가해야 할 수도 있습니다.</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>다음 중 하나가 필요할 수 있습니다.</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>레코드 레이블 '{0}'이(가) 정의되지 않았습니다.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>이 형식 테스트 또는 다운캐스트는 '{0}' 측정 단위를 무시합니다.</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>잘못된 공개 키 Blob</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>System.Runtime을 참조하는 어셈블리(예: .NET Core 또는 이식 가능한 어셈블리)를 생성할 때 mscorlib를 참조하는 어셈블리(예: .NET Framework 어셈블리)에서 정적 링크를 사용할 수 없습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n시그니처와 구현의 제네릭 매개 변수 수가 서로 다릅니다. 시그니처는 {3}개를 선언하지만 구현은 {4}개를 선언합니다.</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>'{0}' 멤버에 올바른 종류의 제네릭 매개 변수가 없습니다. 필요한 시그니처는 '{1}'입니다.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>각각의 형식 매개 변수 수가 서로 다르므로 시그니처와 구현이 호환되지 않습니다.</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>형식, 예외 또는 모듈입니다.</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>이 목록 또는 배열 식에는 'if ... then ... else' 형식의 요소가 포함되어 있습니다. 식이 목록 또는 배열의 개별 요소임을 나타내고 이를 시퀀스 식을 사용하여 생성된 목록과 구분하려면 이 식을 괄호로 묶으십시오.</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>'{0}' 형식은 적절한 값으로 'null'을 가지지 않습니다.</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>액세스 가능성 한정자는 구문의 이름을 지정하는 식별자 바로 앞에 와야 합니다.</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>값 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'use' 키워드와 같은 열로 들여써야 합니다.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>값 또는 함수 정의가 불완전합니다. 해당 항목이 식인 경우 식 본문을 'let' 키워드와 같은 열로 들여써야 합니다.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>공용 구조체 케이스/예외 '{0}'에 이름이 '{1}'인 필드가 없습니다.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>이름 '({0})'은(는) 멤버 이름으로 사용하면 안 됩니다. 다른 CLI 언어를 통해 사용할 정적 멤버를 정의하는 경우에는 이름 '{1}'을(를) 대신 사용하십시오.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>형식 공급자에 올바른 생성자가 없습니다. 인수를 사용하지 않거나 'TypeProviderConfig' 형식의 인수 하나를 사용하는 생성자가 필요합니다.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>레코드, 공용 구조체, 약어 및 구조체 형식에는 'AllowNullLiteral' 특성을 지정할 수 없습니다.</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>식 형식 {{ expr with ... }}는 레코드 형식에만 사용할 수 있습니다. 개체 형식을 빌드하려면 {{ new Type(...) with ... }}를 사용하십시오.</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>'{0}'에 대해 지정된 구현이 없습니다.</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>이 공용 구조체 케이스에는 튜플된 형식의 인수 {0}개가 필요합니다.</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>이 어셈블리의 두 부분에서 네임스페이스 '{1}'에 '{0}'(이)라는 두 개의 형식 정의가 발생합니다.</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>모듈 이름이 잘못되었습니다.</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>{0}에서 {1}(으)로의 변환은 컴파일 시간에 안전한 업캐스트이며 다운캐스트가 아닙니다. :?&gt;(다운캐스트) 연산자가 아닌 :&gt;(업캐스트) 연산자를 사용하세요.</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>위치 지정자는 서식 문자열에 허용되지 않습니다.</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>사용자 지정 연산 '{0}'에서 오버로드된 메서드를 참조합니다. 사용자 지정 연산의 구현은 오버로드될 수 없습니다.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>'use' 바인딩은 모듈에서 허용되지 않으며 'let' 바인딩으로 처리됩니다.</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>소스 파일을 읽는 데 사용되는 코드 페이지를 지정합니다.</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>이 연산자의 처리는 이제 F# 컴파일러에 의해 직접 수행되며 해당 의미를 다시 정의할 수 없습니다.</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>계층 구조에서 더 낮은 형식으로 형식을 변환합니다.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>mscorlib.dll에서 버전을 읽을 수 없습니다.</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>'{0}' 형식 공급자가 제공된 형식 '{1}', 멤버 '{2}'의 컨텍스트에서 오류를 보고했습니다. 오류는 {3}입니다.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>제공된 형식에 정적 인수를 적용하는 동안 오류가 발생했습니다.</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- 입력 파일 -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>루프의 정수에는 단순 식별자를 사용해야 합니다.</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>이 숫자는 부호 있는 16진수 8비트 정수에 대해 허용 가능한 범위를 벗어납니다.</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>패턴 일치 가드의 형식은 'bool'이어야 하지만 'when' 식의 형식은 '{0}'입니다.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>형식 정의에는 하나 이상의 멤버 또는 기타 선언이 필요합니다. 빈 클래스, 구조체 또는 인터페이스를 정의하려는 경우에는 'type ... = class end', 'interface end' 또는 'struct end'를 사용하십시오.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>제네릭 구문을 사용하려면 '{0}' 형식에 참조 의미 체계가 있어야 하지만 없습니다. 즉, 형식이 구조체입니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이름이 서로 다릅니다.</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>형식 약어에 byref가 포함되어 있습니다. 이는 F#에서 허용되지 않습니다.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>MDB 디버그 정보를 생성할 수 없습니다. 'Mono.CompilerServices.SymbolWriter.dll' 어셈블리에서 'MonoSymbolWriter' 형식을 로드하지 못했습니다.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>디버그 정보 파일 '{0}'을(를) 만드는 동안 예기치 않은 오류가 발생했습니다.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>형식 매개 변수가 아니라 측정 단위 매개 변수가 필요합니다. 명시적 측정 단위 매개 변수는 [&lt;Measure&gt;] 특성으로 표시해야 합니다.</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>서식 문자열 '{0}'을(를) 구문 분석할 수 없습니다.</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>예기치 않은 AutoOpenAttribute의 디코딩입니다.</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>인용구에는 멤버 제약 조건을 호출하는 식 또는 암시적으로 멤버 제약 조건 호출로 확인되는 연산자 사용을 포함할 수 없습니다.</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>라이브러리 또는 다중 파일 응용 프로그램의 파일은 네임스페이스 또는 모듈 선언으로 시작해야 합니다. 파일 시작에 모듈 선언을 사용하는 경우 '=' 기호를 사용할 수 없습니다. 최상위 모듈인 경우 =를 제거하여 이 오류를 해결하세요.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>'{0}' 필드가 이 레코드 식 또는 패턴에 두 번 나타납니다.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>이름이 '{0}'인 제공된 형식이 필요한데 제공된 형식의 'Name' 값은 '{1}'입니다.</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>경로가 '{0}'인 제공된 형식이 필요한데 제공된 형식의 경로는 '{1}'입니다.</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>사용자 지정 특성에 대한 인수 수가 특성 생성자에 필요한 인수 수와 일치하지 않습니다.</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>’{0}' 멤버가 잘못된 방식으로 사용되었습니다. '{1}'이(가) 정의되기 전에 '{2}' 또는 그 근처에서 해당 사용이 유추되었습니다. 이는 잘못된 전방 참조입니다.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>제공된 형식 '{1}'에 대한 이벤트 '{0}'에 GetRemoveMethod()의 값이 없습니다.</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>RSA 키가 필요합니다.</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>FSharp.Core.dll의 레코드, 공용 구조체 및 구조체 형식에는 'StructuralComparison' 또는 'NoComparison'을 사용하여 명시적으로 레이블을 지정해야 합니다.</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>공용 구조체 케이스 '{0}'에 대한 공용 구조체 형식은 RequireQualifiedAccessAttribute로 정의됩니다. 사용 중인 이름에 공용 구조체 형식('{1}') 이름을 포함하세요.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>활성 패턴은 7개가 넘는 가능성을 반환할 수 없습니다.</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>'{0}' 값 또는 생성자가 정의되지 않았습니다.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>이 'inherit' 선언은 인수를 포함하지만 기본 생성자가 포함된 형식이 아닙니다. 'type X(args) = ...'와 같이 형식 정의에 인수를 추가해 보십시오.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>구분된 공용 구조체 형식은 항상 봉인됩니다.</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>속성에 예기치 않은 GetSet 주석이 있습니다.</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>열거형 리터럴에 대한 올바른 값이 아닙니다.</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>모듈/식/형식이 잘못되었습니다.</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} 오버로드</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+1개 오버로드</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>'{0}' 연산자를 지원하는 형식이 필요한데 튜플 형식을 지정했습니다.</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>'{0}' 어셈블리가 명령줄에 나열되어 있습니다. '-r'과 같은 명령줄 플래그를 사용하여 어셈블리를 참조해야 합니다.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>제공된 형식의 '{0}'이 null이거나 비어 있습니다.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>메서드가 중복되었습니다. 추상 메서드 '{0}'의 이름 및 시그니처가 상속된 형식의 추상 메서드와 같습니다.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>공동 소스: {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>배열 메서드 '{0}'은(는) 런타임에서 제공되며 코드에 직접 사용할 수 없습니다. 배열 요소를 사용하는 작업에서는 LanguagePrimitives.IntrinsicFunctions 모듈의 GetArray/SetArray 함수 패밀리를 사용하십시오.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>'{0}' 액세스 가능성 특성이 모듈 약어에서 허용되지 않습니다. 모듈 약어는 항상 Private입니다.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>이런 방법으로 형식 공급자를 사용하여 생성된 제공된 형식은 다른 F# 어셈블리에서 사용할 수 없으므로 내부 또는 개인 형식으로 표시해야 합니다. 'type internal TypeName = ...' 또는 'type private TypeName = ...'을 사용하십시오.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>인덱서 액세스의 경우 . 추가</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>DLLImport 바인딩은 모듈의 클래스 또는 함수 정의에서 정적 멤버여야 합니다.</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>'{0}' 함수 또는 멤버는 유추된 형식의 일관성을 유지하기 위해 해당 정의에서 형식 주석을 더 추가해야 하는 방식으로 사용됩니다. 유추된 서명은 '{1}'입니다.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>이 메서드에 이미 기본 구현이 있습니다.</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>'{0}' 모듈에\n    {1}이(가) 포함되어 있지만    \n해당 시그니처는\n    {2}을(를) 지정합니다.    \n이 메서드의 컴파일 표현이 인스턴스 멤버이지만 시그니처는 해당 컴파일 표현이 정적 멤버임을 나타냅니다.</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>올바른 바이트 리터럴이 아닙니다.</value>
  </data>
</root>