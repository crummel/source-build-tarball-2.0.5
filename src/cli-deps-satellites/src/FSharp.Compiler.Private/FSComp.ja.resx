<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>型略称のこの位置にアクセシビリティ修飾子は使用できません</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>静的リンクでは、.EXE がインクルードされない可能性があります</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>プロパティ '{0}' は読み取り可能ではありません</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>'use' 束縛の形式は 'use &lt;var&gt; = &lt;expr&gt;' にしてください</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler バージョン {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>レコード、構造体、またはクラスのフィールド '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>指定された型 '{1}' に無効なメンバー '{0}' が含まれています。指定された型のメンバーはパブリックである必要があり、汎用メンバー、仮想メンバー、および抽象メンバーは無効です。</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' は有効な式ではありません。レコードには 1 つ以上のフィールドを含める必要があります。空のシーケンスを指定するには、Seq.empty または空のリスト '[]' を使用してください。</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>{0} の動的呼び出しはサポートされません</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' に 'StructuralEquality' 属性がありますが、型パラメーター '{1}' は 'equality' 制約を満たしていません。型パラメーターに 'equality' 制約を追加してください。</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' に 'StructuralEquality' 属性がありますが、コンポーネント型 '{1}' は 'equality' 制約を満たしていません。</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>代わりに別のレコード型を使用してください</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>変数 '{0}' のアドレスはこのポイントでは使用できません。メソッドまたは関数がこのローカル値のアドレスを返さない可能性があります。</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>アセンブリ '{0}' を読み取れません</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>ジェネリック コンストラクトの型 '{0}' は、CLI または F# の構造体型にする必要があります</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>型プロバイダー '{0}' が、GetInvokerExpression から null を返しました。</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>'{0}.dll' に対する複数の参照は許可されていません</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>'{0}' で始まる演算子名の引用符が対応しません</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>宣言された型に実装がないメソッド、または既定の実装がある仮想のメソッドを示します。</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>静的リンクでは、混合マネージ/アンマネージ DLL がインクルードされない可能性があります</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>メンバーに対して、同じ型やモジュールのコードへのアクセスを制限します。</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>型 '{0}' は、printf 形式の書式指定文字列の使用によって生じる型 {1} のいずれとも互換性がありません</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>拡張メンバーでは演算子のオーバーロードを実行できません。代わりに型定義の一部として演算子を定義してください。</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>変数 '{0}' の使用方法に誤りがあります</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' は、オブジェクト型を構築するときにのみ使用できます</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>予期しないトークン '{0}' または不完全な式です</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' はフィールド名に使用できません</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>プロパティのゲッターまたはセッターに指定されたアクセシビリティが複数あります</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>コンストラクターは引数に割り当てる必要があります。また、コンストラクターをファーストクラスの値として使用することはできません。必要に応じて、匿名関数 '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))' を使用してください。</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>バージョン ファイル '{0}' が無効です</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>メンバーの指定を含む再帰的束縛は、型の直接的な拡張としてのみ実行できます</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>抽象スロットに対する再帰的参照が無効です</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>引用符内にインライン アセンブラー コードまたは配列のパターン マッチを含めることはできません</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>オブジェクトを初期化するには、継承したオブジェクト コンストラクターを呼び出し、値を各フィールドに割り当てるオブジェクト構築式を使用してください。</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>クエリ演算子に対する引数には、たとえば 'where (x &gt; y)' や 'groupBy (x.Length / 10)' のように、かっこが必要です</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>警告レベル (0 ～ 5) を設定します</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>この使用方法に関するメッセージを表示します (短い形式: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>UnknownWrapper\DispatchWrapper クラスを使用するには、System.Runtime.InteropServices アセンブリが必要です。</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>モジュール</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>代入式の左辺が無効です</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>インラインの指定が無効です</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>型指定されたコード引用符を区切ります。</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>解析ツリーに使用できるのは MemberKind.PropertyGetSet のみです</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>ファイル名 '{0}' に問題があります: パスに無効な文字が含まれています。</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(説明を読み込んでいます...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>型 '{0}' は、'comparison' 制約をサポートしない 1 個または複数の構造体の要素型を持つレコード、共用体、または構造体なので、'comparison' 制約をサポートしません。この型では comparison を使用しないようにするか、または、comparison をサポートしないフィールド型を決定するために、'StructuralComparison' 属性を型に追加してください。</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>型 '{0}' は 'comparison' 制約をサポートしません。たとえば、'System.IComparable' インターフェイスをサポートしません。</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>型 '{0}' は 'NoComparison' 属性があるため、'comparison' 制約をサポートしません</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>属性 'System.Diagnostics.ConditionalAttribute' はメソッド クラスまたは属性クラスでのみ有効です</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>CLI 表現が異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>ラベル付き型引数に構文エラーが見つかりました</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>プロパティには明示的な型パラメーターを使用できません。代わりにメソッドを使用してください。</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>UTF-8 エンコードでメッセージを出力します</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>'{0}' というモジュールおよび型の定義が、このアセンブリの 2 か所の名前空間 '{1}' で発生しています</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>名前 '{0}' がパターン コンテキストにバインドされていません</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>型プロバイダー コンストラクターが例外をスローしました: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>指定された型またはメソッド '{1}' への参照を解決する際に、不明な静的引数の種類 '{0}' が検出されました</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>カスタム演算子 '{0}' の定義で使用されている属性フラグの組み合わせが無効です</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} は静的メソッドとして表現されましたが、適切なラムダ式ではありません</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>この数値は、8 ビット符号なし整数に使用できる範囲から外れています</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>このコンストラクトの属性は無視されました</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' の後には 'in' が必要です。使い方: {1}。</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型の '{0}' は、インターフェイス 'System.IEquatable&lt;_&gt;' を明示的に実装しています。この型には 'CustomEquality' 属性を適用し、さらに整合性のある非ジェネリック オーバーライド 'System.Object.Equals(obj)' の実装を用意してください。</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>ソース ファイルが大きすぎるので、ポータブル PDB 内に埋め込めません</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>オブジェクト コンストラクターには引数が必要です</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>F# でコンパイルした DLL '{0}' のメタデータの読み取り/書き込み中にエラーが発生しました。旧バージョンの F# コンパイラーでコンパイルした DLL ですか? (エラー: '{1}')</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>インターフェイスにメンバーのオーバーライドの定義を含めることはできません</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>この識別子に複数の可視属性が指定されました</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>シグネチャは抽象クラスですが、実装は抽象クラスではないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。実装に [&lt;AbstractClass&gt;] 属性を追加してください。</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>指定された型 '{0}' のメンバー '{1}' に、宣言する型 '{2}' が含まれています。宣言する型は、指定された型と同じである必要があります。</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>'class'、'interface'、または 'struct' が対応しません</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>関連する型とモジュールのグループに名前を関連付け、その他のコードと論理的に分離するために使用します。</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>名前空間またはモジュール '{0}' が定義されていません。</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>この共用体ケースには 1 つの引数を指定します</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>予期しない空の型の moduleDefn リストです:</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>パターン マッチでのブール条件 (when ガード) で、ジェネリック型パラメーターの制約句を開始するために使用します。</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>パターン マッチング式で match キーワードを指定して使用します。メンバー定義と例外ハンドラーを導入するため、オブジェクト式、レコード コピー式、および型拡張でも使用します。</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>.NET の void 型を示します。他の .NET 言語と相互運用するときに使用します。</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>条件分岐で使用します。オブジェクトの構築後の副作用の実行にも使用します。</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>クラス、レコード、構造体、判別された共同体、列挙型、数量単位、型の省略形の宣言に使用します。</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>修飾子を使用せずに名前空間またはモジュールのコンテンツを利用可能にするために使用します。</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>オブジェクトがないことを示します。ジェネリック パラメーターの制約にも使用します。</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>型を階層の上位にある型に変換します。</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>基底クラス オブジェクトの名前として使用します。</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>結果が必要な場合にのみ実行するコンピュテーションを指定するために使用します。</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>条件分岐で使用します。</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>条件分岐で使用します。else if の短い形式です。</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>冗語構文で、ループ式のコード ブロックの末尾を示します。</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>アセンブリ {1} には DLL {0} に対する参照が必要です。インポートされた型 {2} は最初のアセンブリにあり、解決できませんでした。</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>この数値は、32 ビット浮動小数点に使用できる範囲から外れています</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>型定義に含めることができる 'inherit' 指定は 1 つのみであり、これを最初の宣言にする必要があります。</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>リテラル値にジェネリック パラメーターを指定することはできません</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>型定義に予期しない引用演算子 '&lt;@' が見つかりました。verbatim 文字列を静的引数として型プロバイダーに渡す場合は、'&lt;' と '@' の間に空白を挿入してください。</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>通常、'{0}' 演算子は再定義できません。特定の型について、オーバーロードされた比較セマンティクスを定義するには、その型の定義で 'System.IComparable' インターフェイスを実装してください。</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>カリー化された引数を使用したメソッドでは、'out'、'ParamArray'、'optional'、'ReflectedDefinition'、'byref'、'CallerLineNumber'、'CallerMemberName'、または 'CallerFilePath' の各引数を宣言できません</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>'--pdb' オプションでは '--debug' オプションを使用する必要があります</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>値 '{0}' は 'inline' とマークされましたが、最適化環境ではバインドされません</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>プロパティ '{0}' は静的です</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>型パラメーター {1} が 'comparison' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造的に比較できません。型 '{2}' に 'NoComparison' 属性を追加して、型が比較できないことを明確にしてください。</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>型 {1} が 'comparison' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造的に比較できません。型 '{2}' に 'NoComparison' 属性を追加して、型が比較できないことを明確にしてください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>実装では構造体を定義していますが、シグネチャでは隠ぺいされた表現で型を定義しているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>注意: ファースト クラス値としてこのローカルの制約付きジェネリック関数が使用されているため、ラムダリフティングの最適化は適用されませんでした。型制約を追加することで、この状態を解決できる可能性があります。</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>シーケンス式では 'let! x = coll' を使用できません。代わりに 'for x in coll' を使用してください。</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'mutable' 修飾子が異なります。</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>MDB ファイルの名前は、&lt;アセンブリ ファイルの名前&gt;.mdb にする必要があります。--pdb オプションは無視されます。</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。このメソッドのコンパイル済み表現は静的メンバーとして指定されていますが、シグネチャが示すコンパイル済み表現はインスタンス メンバーです。</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DllImport 属性をデコードできませんでした</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>'base' キーワードの使用方法に誤りがあります。'base' の呼び出しはクロージャに使用できません。'base' の呼び出しを行うには、プライベート メンバーを使用してください。</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>名前付き型には 'new' を使用してください</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>この型略称では、省略される型に出現しない型パラメーターが 1 つまたは複数宣言されました。型略称には、省略される型のすべての宣言済み型パラメーターを使用する必要があります。1 つまたは複数のパラメーターを削除するか、基底となる型をラップする具象型定義を使用してください (たとえば、'type C&lt;'a&gt; = C of ...')。</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>応答ファイル名 '{0}' は、空であるか、正しくない文字が含まれているか、ドライブ指定があるが絶対パスがないか、あるいは長すぎます</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>シグネチャに指定されたアクセシビリティが実装の指定よりも高いため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>このオーバーライドに対応する抽象プロパティが見つかりませんでした</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>埋め込まれた IL の解析中にエラーが発生しました</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>DLLImport スタブはインライン展開できません</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>パターンが正しくありません</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>ここでは単純なメソッド名が必要です</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>'member val' 定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>'{0}' フラグが 2 回設定されました</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>引用符内には、オブジェクト式を含めることはできません</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>'inline' とマークされた値に予期しない値が含まれます</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>'match' 式はクエリ内で使用できません</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>プロパティ '{0}' は型 '{1}' の別のプロパティと名前が同じですが、一方はインデクサー引数を使用し、もう一方は使用していません。一方のプロパティでインデクサー引数を失う可能性があります。</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>'{0}' が続く識別子は将来利用するために予約されています</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>明示的な型パラメーターを使用できるのは、モジュールまたはメンバーの束縛のみです</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>指定された型 '{1}' のプロパティ '{0}' で CanWrite=false となっていますが、GetSetMethod() がメソッドを返しました</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>デバッグ情報を引用符で囲んで生成します</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>既定の Win32 マニフェストを含めないでください</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>アクティブ レコグナイザー</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>この言語要素では、'CompiledName' 属性を使用できません</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>変更可能な値である変数の宣言に使用します。</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>ファイルまたはモジュール '{0}' のシグネチャは指定済みです</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>引用符内には、共用体ケースのフィールドを設定する式を含めることはできません</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>この型定義では、省略形による直接的な循環参照が発生します</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>'--targetprofile' の値 '{0}' が無効です。有効な値は 'mscorlib'、'netcore'、'netstandard' のいずれかです。</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>プライマリ コンストラクターに 'use' 束縛は使用できません</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>構造体は、メンバーの宣言の 'this' パラメーターのみをバインドできます</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>すべての enum フィールドに値を指定する必要があります</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>オブジェクト式では 'member val' 定義も 'override val' 定義も使用できません。</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>例外の省略形がシグネチャによって隠ぺいされているため、例外の定義に互換性がありません。省略形は他の CLI 言語から参照できるようにする必要があります。シグネチャ内の省略形を参照できるようにしてください。モジュールには例外の定義\n    {0}    \nがありますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>例外が発生するかどうかに関係なく実行されるコード ブロックを開始するために、try と一緒に使用します。</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>F# コードではカスタム マーシャラーを指定できません。C# ヘルパー関数を使用してください。</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>正しい数の引数と型パラメーターが指定された '{0}' の実装がありません。必要なシグネチャは '{1}' です。</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>ここでメソッドのオーバーライドおよびインターフェイスの実装は許可されていません</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>FieldOffset 属性をデコードできませんでした</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>シグネチャ ファイル '{0}' に対応する実装ファイルがありません。実装ファイルが存在する場合、シグネチャ ファイルおよび実装ファイル内の 'module' 宣言や 'namespace' 宣言が一致することを確認してください。</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>'{0}' 演算子は再定義できません。別の演算子名を使用してください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>シグネチャには省略形がありますが、実装にはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>型パラメーター {0} が定義されていません。</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>基底クラスまたは基底インターフェイスを指定するために使用します。</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>インデントが正しくない可能性があります。このトークンは位置 {0} から開始されるコンテキストのオフサイドになります。このトークンのインデントを増やすか、標準的な書式規則を使用してください。</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれていますが、シグネチャには\n    {2}    \nが指定されています。表示名が異なります。</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>この定数式または属性引数の演算結果は、オーバーフローになります。</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>カスタム属性にはオプションの引数を使用できません</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>指定したアセンブリと、そのアセンブリに依存するすべての参照 DLL を静的にリンクします。DLL 名ではなく、アセンブリ名 (たとえば、mylib) を使用してください。</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>この位置以前に始まったコメントに埋め込まれた verbatim 文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。リテラル定数値、属性、またはその両方が異なります。</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>この Unicode エンコーディングが有効なのはリテラル文字列内のみです</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' の適用対象にできるのはオプションの引数だけです</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>この操作には、ローカル変数または他の特殊な表現を使用して表された値 '{0}' のアドレスが使用されています。これは無効です。</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>既定では、既定の CLI アセンブリを参照しません</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>FSharp.Core と同じ場所にファイル '{0}' が見つかりません。ファイルは {1} にある必要があります。このファイルを必要としない、より新しいバージョンの FSharp.Core にアップグレードすることをご検討ください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>シグネチャでは表現としてこの型に null を使用できると指定していますが、実装では指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>この位置以前に始まったコメントの途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には、引数または設定可能な戻り値のプロパティ '{1}' がありません。{2}</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>サポートされない定数型 '{0}'。型プロバイダーで提供される引用に含められるのは単純定数のみです。型プロバイダーの実装は、指定された引用リテラル外部で宣言された値を移動して、引用リテラル内部の 'let' バインドにすることによって調整することが必要な場合があります。</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>パーシャル アクティブ パターンで生成できる結果は 1 個のみです</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>型 '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>このリスト式は、リスト リテラルの最大サイズを超えています。より大きなリテラルの配列を使用し、Array.ToList を呼び出してください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>実装の型はシールされていますが、シグネチャではシールされていないと考えられるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。シグネチャに [&lt;Sealed&gt;] 属性を追加してください。</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>名前付き引数 '{0}' と一致する引数または変更可能なプロパティがありませんでした</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>無効な制約: 制約に使用された型が sealed です。つまり、制約を満たすことができるのは、最高でも 1 つの解です。</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>予期しない文字 '{0}'</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>CLI の例外のマッピングがシグネチャによって隠ぺいされているため、例外の定義に互換性がありません。例外のマッピングは他のモジュールから参照できるようにする必要があります。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>モジュールの省略形にある属性を無視します</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>単位ではなく型を指定してください</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>型 '{0}' は 'System.IComparable' を明示的に実装していますが、'Object.Equals' に対応するオーバーライドを提供していません。'Object.Equals' の実装は自動的に提供され、'System.IComparable' を介して実装されます。明示的にオーバーライド 'Object.Equals' を実装してください。</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>'{1}' に必要なアセンブリ '{0}' を解決できませんでした</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>定数式の変更は無効です。変更可能なローカルに式をコピーしてください (たとえば、'let mutable x = ...')。</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>指定した警告をエラーとして報告する</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>{0} から {1} への変換は、コンパイル時のダウンキャストではなく、セーフ アップキャストです。'downcast' の代わりに 'upcast' を使うことを検討してください。</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>識別子 '{0}' は F# で将来利用するために予約されています</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>ライブラリまたは複数ファイル アプリケーション内のファイルは、名前空間またはモジュールの宣言から開始する必要があります (例: 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'。アプリケーションの最後のソース ファイルのみ、このような宣言を省略できます。</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>束縛に 'use' と 'rec' の両方をマークすることはできません</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>型引数に予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は仮想ですが、もう一方は違います。</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>このインデクサー表記は F# 言語から削除されました</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>型 '{0}' の使用方法に誤りがあります。'{1}' の前の値に、'{2}' と推論されるような型があります。これは無効な前方参照です。</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>重複したメソッド。メソッド '{0}' は、タプル、関数、測定単位、指定された型が消去されると、名前とシグネチャが型 '{1}' の他のメソッドと同じになります。</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>内部エラーまたはメタデータの形式エラー: インポート中のスコープに含まれる型パラメーターが足りません</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>ローカルの呼び出しに対する型引数の数が正しくありません</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>F# コードでは 'module ... : sig .. end' という構文は使用されません。'module ... = begin .. end' を使用してください。</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>インターフェイスの型を指定してください</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>名前 '({0})' はメンバー名として使用しないでください。固定の型に関して、F# ライブラリではこの名前は標準的な定義が指定されています。</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>型定義に予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>測定単位のパラメーター '{0}' の値が無効です</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>測定単位のパラメーター '{1}' の値 '{0}' は無効です</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>プロパティのゲッターの形式が無効です。明示的な構文を使用する場合、少なくとも 1 つの '()' 引数が必要です。</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>指定された型のセットアップ中にエラーが発生しました</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>インターフェイスのコンストラクター式には引数を使用できません</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>警告レベル '{0}' が無効です</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>'{0}' という名前の共用体ケースが、生成された型 '{1}' と競合します</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>メンバー '{0}' は、無視または実装に使用できるどの抽象メソッドまたは仮想メソッドにも対応していません。</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>レコードの構造が無効です</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。フィールドの型が異なります。</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>ラベル {0} が見つかりません</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>アクティブ パターン '{0}' に、入力によって決定されない型変数を含む結果の型があります。一般的な原因は、結果の型が記述されていないことです (例: 'let (|A|B|) (x:int) = A x')。この場合は、型の制約によって問題を解決できます (例: 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x')。</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、名前がない引数が {2} 個、名前付き引数が {3} 個です。必要なシグネチャは '{4}' です。</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>型/モジュール '{0}' は具象モジュールまたは具象型ではありません</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- 出力ファイル -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>使用できるオーバーロードを以下に示します (または [エラー一覧] ウィンドウを参照してください)。</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' で使用されている引数の数が正しくありません。これはこのクエリのカスタム操作であるか、コンピュテーション式です。適正な引数の数は {1} 個ですが、渡されたのは {2} 個でした。</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} はインスタンス メソッドではありません</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>この形式のオブジェクト式は F# では使用されません。オブジェクト式でメンバーの実装を定義するには、'member this.MemberName ... = ...' を使用してください。</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>再帰的推論ポイントに予期しない式があります:</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>シグネチャには抽象メンバー '{2}' が必要ですが、実装では指定されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>メソッドまたは関数 '{0}' は、型パラメーターを明示的に宣言していないため、明示的な型引数を指定しないでください</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>型 '{0}' にはインライン アセンブラー コード表現があります</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>再帰的な値は、再帰的な束縛内の型 '{1}' の変更可能ではないフィールド '{0}' に直接割り当てることはできません。代わりに変更可能なフィールドを使用してください。</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>ML 互換性に関する警告を無視します</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>挿入演算子メンバー '{0}' に引数がありません。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>インターフェイスに具象メンバーの定義を含めることはできません。必要に応じて、型にコンストラクターを定義して、型がクラスであることを示してください。</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>'.' の後に修飾子がありません</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>ジェネリック型 '{0}' のインスタンス化がありません。また、このメンバーの引数または戻り値の型から推論できません。この型にアクセスするときは型のインスタンス化を指定してください (たとえば、'{1}')。</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>アクティブ パターンのケース識別子は先頭を大文字にする必要があります</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>この書式指定子に 'h' または 'H' は不要です。代わりに %d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>明示的なオブジェクト コンストラクターの一部としてのみ、'expr then expr' という形式の式を使用できます</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>'base' 値を使用できるのは、オーバーライドされたメンバーの基本実装に対して直接呼び出しを行う場合のみです。</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>これは有効な定数式でもカスタム属性値でもありません</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>この再帰的束縛に使用されている再帰形式の混合は無効です</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型の '{0}' は、インターフェイス 'System.IComparable&lt;_&gt;' を明示的に実装しています。この型には 'CustomComparison' 属性を適用し、さらに整合性のある非ジェネリック インターフェイス System.IComparable の実装を用意する必要があります。</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>割り当てが無効です</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>この位置以前に始まった文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>ファーストクラス関数の型に byref を含むことはできません</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>型 '{0}' は関数型なので、'equality' 制約をサポートしません</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>型 '{0}' は、'equality' 制約をサポートしない 1 個または複数の構造体の要素型を持つレコード、共用体、または構造体なので、'equality' 制約をサポートしません。この型を持つ equality を使用しないでください。または、equality をサポートしないフィールド型を決定するために、'StructuralEquality' 属性を型に追加してください。</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>型 '{0}' は 'NoEquality' 属性があるため、'equality' 制約をサポートしません</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>値の定義が不完全です。これが式の中にある場合、式の本体を 'use!' キーワードと同じ列にインデントする必要があります。</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>'int C' および 'C  &lt;int&gt;' という型の構文は、ここでは使用できません。'C&lt;int&gt;' という形式でこの型を記述してください。</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>プレフィックスのフラグ (' ' または '+') が 2 回設定されました</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>AssemblyFolders レジストリ キーによって検出されました</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>このコンストラクトはシーケンス式およびコンピュテーション式内でのみ使用できます</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>埋め込まれた IL 型の解析中にエラーが発生しました</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>リテラル値に [&lt;ThreadStatic&gt;] 属性または [&lt;ContextStatic&gt;] 属性を指定することはできません</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>アセンブリ '{0}' の TypeProviderAssembly 属性に、無効な値 '{1}' が含まれています。この値は有効なアセンブリ名であることが必要です</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>この関数値は、byref 引数を含むシグネチャのデリゲート型を構築するために使用されます。{0} 個の引数を使用する明示的なラムダ式を使用する必要があります。</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Common IL の例外型の場合、省略形には引数を使用できません</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>型 '{0}' は有効な列挙子の型ではありません。つまり、ブール値を返す 'MoveNext()' メソッドと 'Current' プロパティが含まれていません</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>この位置以前に始まったディレクティブの途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>'{0}' 形式は精度をサポートしていません</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>型 '{0}' のコンストラクターはその暗黙的なオブジェクト コンストラクターを直接、または間接的に呼び出す必要があります。レコード式ではなく、暗黙的なオブジェクト コンストラクターの呼び出しを使用してください。</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' の使用方法が正しくありません。これは、このクエリまたはコンピュテーション式のカスタム操作です。</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>'[&lt;' が対応しません。対応する '&gt;]' が必要です</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>'fixed' の使い方が正しくありません。'fixed' を使用できるのは書式 'use x = fixed expr' の宣言内だけで、この式は配列、フィールドのアドレス、配列要素のアドレス、または文字列です</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>指定された型名 '{1}' には、文字 '{0}' を使用することはできません</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>指定された型またはメソッド '{1}' の静的パラメーター '{0}' には値が必要です。型プロバイダーの静的パラメーターは、名前付き引数 (例: '{2}&lt;{3}=...&gt;') を使用してオプションで指定できます。</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>予期しない SynMeasure.Anon です:</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert' はファースト クラス値として使用できません。代わりに 'assert &lt;expr&gt;' を使用してください。</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>変数型から継承できません</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>型 '{0}' の共用体ケースまたはフィールドは、このコードの場所からアクセスできません</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>変更可能な関数値は 'let mutable f = (fun args -&gt; ...)' と記述してください</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>値の引数を使用できるのはクラス型のみです</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>警告番号 '{0}' が無効です</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>型 '{0}' には標準ではないデリゲート型があります</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>メンバー '{0}' の引数の数が正しくありません。{1} 個の引数が必要ですが、指定されたのは {2} 個です。必要な署名は '{3}' です。{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar </value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は final ですが、もう一方は違います。</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>カリー化されたシグネチャを含むデリゲートは許可されていません</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>このコードが実行されるプラットフォームの制限: x86、Itanium、x64、anycpu32bitpreferred、または anycpu。既定は anycpu です。</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>型ではなく単位を指定してください</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Win32 リソース ファイル (.res) を指定します</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>ローカル クラスの束縛に 'inline' とマークすることはできません。クラスから定義を取り除くか、'inline' とマークしないでください。</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(説明はありません...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>'{1}' で型 '{0}' が定義されていません。</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>識別子がありません</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>プリプロセッサの式に予期しないトークン '{0}' があります</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>'.' の後に精度がありません</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>キャプチャされたローカル変数のアドレスの割り当てまたは取得は引用符で囲まれない場合があります</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>コマンド ライン オプション '{0}' はテスト目的でのみ使用できます</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>'yield' の代わりに 'yield!' を使うことを検討してください。</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>継承された型はオブジェクト モデル型ではありません</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>プログラムのメイン モジュールが空です。実行しても何も処理されません</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>An {0} specified version '{1}', but this value is a wildcard, and you have requested a deterministic build, these are in conflict.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>.resx ファイル ({0}) をソース ファイルとしてコンパイラに渡す処理は使用できなくなりました。resgen.exe を使用して、.resx ファイルを .resources ファイルに変換し、--resource オプションで渡してください。MSBuild を使用する場合は、.fsproj プロジェクト ファイル内の &lt;EmbeddedResource&gt; 項目を使用して、この変換を実行できます。</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>パス '{0}' は名前空間です。モジュールの省略形は名前空間の省略形にはできません。</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>宣言に [&lt;Literal&gt;] 属性がある場合、その宣言に指定できるのはシグネチャ内の値のみです。</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>指定された型の '{0}' にアクセスする際に例外が発生しました: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>アセンブリの外部では表示されず、内部でのみ表示されるメンバーを指定するために使用します。</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>#if または #else の #endif が見つかりません</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>前に発生しているエラーのために、メンバーのシグネチャが無効です</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>名前付きフィールド '{0}' が、匿名フィールドのために自動生成された名前と競合しています。</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>ディレクティブが無効です。'#time'、'#time \"on\"'、または '#time \"off\"' という形式で指定する必要があります。</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>enum 型のこの位置にアクセシビリティ修飾子は使用できません</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>ここでは属性を使用できません</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- 言語 -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>認識されないデバッグの種類 '{0}'。'pdbonly' または 'full' を指定してください。</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>'into' を使用する場合、その後に残りの計算を配置する必要があります</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>'reraise' 関数のファーストクラスの使用は許可されていません</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>'&lt;' が対応しません。対応する '&gt;' が必要です</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、val '{2}' が含まれません</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>ジェネリック関数 '{0}' に明示的な型引数を指定する必要があります</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>指定された型 '{1}' のプロパティ '{0}' で CanRead=true となっていますが、GetGetMethod() からの値が存在しません</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>メソッドの戻り値の型に許可されていない byref が含まれています</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>イベント '{0}' は静的です</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>このトークンは将来利用するために予約されています</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>再帰的な宣言グループでは、'open' 宣言は各モジュールの先頭になければなりません</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>指定された型 '{0}' が返したメンバーのメンバー名が null または空です</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>(l または L の後の) 書式指定子に誤りがあります。ld、li、lo、lu、lx、または lX を指定してください。F# コードでは、代わりに %d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>指定されたリテラル値 '{0}' が無効です</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>インターフェイス型を sealed にすることはできません</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>小文字のリテラル '{0}' は、同じ名前の新しいパターンによりシャドウされています。大文字かモジュール プレフィックスのリテラルのみ名前付きパターンとして使用できます。</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>未定義の値 '{0}'</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>このコンストラクトは、リスト式、配列式、およびシーケンス式内でのみ使用できます (たとえば、'seq {{ ... }}'、'[ ... ]'、'[| ... |]' などの形式の式)。この場合、要素を生成するには 'for ... in ... do ... yield...' という構文を使用します。</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>カスタム属性は参照型にする必要があります</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>インスタンス フィールドが必要な場所に静的フィールドが使用されました</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>'(' が対応しません</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>このプログラム ポイントよりも前の型情報に基づいて、メソッド '{0}' の固有のオーバーロードを決定することができませんでした。型の注釈が必要な場合があります。</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' は {1} ではありません</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>デバッグ情報を生成します (短い形式: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyKeyFileAttribute' 属性は、'--keyfile' オプションでオーバーライドされます</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>その他のオプションを、応答ファイルから読み取ります</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>'{{' が対応しません</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>'begin' が対応しません</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>この 'let' 定義は、クエリ内では使用できません。クエリで使用できるのは単純な値の定義のみです。</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>プロテクト メンバーが呼び出されたか、'base' が使用されています。この操作が許可されているのはメンバーの直接実装の場合のみです。直接実装ではオブジェクトのスコープを回避できます。</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>型引数と型名は隣接している必要があります。たとえば、\"C  &lt;'T&gt;\" ではなく \"C&lt;'T&gt;\" と指定します。</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>型パラメーターと型名は隣接している必要があります。たとえば、type \"C   &lt;'T&gt;\" ではなく \"type C&lt;'T&gt;\" と指定します。</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>'printf' 形式の書式指定文字列の使用に関して、あいまいな継承を解決できませんでした</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>この 'let' の return 式にエラーが見つかりました。インデントが正しくない可能性があります。</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>この場所またはその付近にあるジェネリック コンストラクトの暗黙的なインスタンス化を解決できませんでした。これは、関連性のない複数の型に解決される可能性があるためです (たとえば、'{0}' と '{1}')。あいまいさを解決するために、型の注釈を使用してください。</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>オプションの引数は、オプションではないすべての引数の後で、引数リストの末尾に指定する必要があります。</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>これを演算子名として解析しようとしましたが、失敗しました</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>アセンブリを参照します (短い形式: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>AssemblyFoldersEx レジストリ キーによって検出されました</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get'、'set'、または 'get,set' が必要です</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' は有効な浮動小数点引数ではありません</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>コマンド ライン オプション '{0}' は使用されなくなりました。代わりに '{1}' を使用してください。</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>'CustomEquality' 属性を持つ型には、’Object.Equals(obj)’、'System.IEquatable&lt;_&gt;' または 'System.Collections.IStructuralEquatable' の少なくとも 1 つの明示的な実装が必要です</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>型式に予期しない {0} があります:</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>認識されない属性のターゲットです。有効な属性のターゲットは、'assembly'、'module'、'type'、'method'、'property'、'return'、'param'、'field'、'event'、および 'constructor' です。</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>関数の本体がありません</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>ここではアクセシビリティ修飾子を使用できませんが、'{0}' が指定されました。</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>型に入れ子の型定義を含めることはできません</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>警告メッセージとエラー メッセージを色つきで表示します</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>型名の使用方法に誤りがあります</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>この値には、有効なプロパティの set アクセス操作子の型がありません</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>検索ディレクトリ '{0}' が無効です</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>指定したリソースをこのアセンブリにリンクします。このとき、リソース情報の形式は &lt;ファイル&gt;[,&lt;文字列名&gt;[,public|private]] です。</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>分母は単位指数で、0 以外でなければなりません</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>インターフェイス型に 'inherit' は使用できません。代わりに 'interface ... with ... end' を使用してインターフェイスを実装してください。</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>単位式に予期しない整数リテラルが見つかりました:</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' を使用できるのは、名前付き型のみです</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、{2} 個です。必要なシグネチャは '{3}' です。</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>共用体ケースの既定の拡張</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>この値は関数ではないため、適用できません。</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>書式指定子がありません</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>インデクサーのプロパティに 1 つ以上の引数を指定する必要があります</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>認識されないターゲット '{0}'。'exe'、'winexe'、'library'、または 'module' を指定してください。</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'while' 式に 'do' がありません。'while &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>ラムダ式の本体に予期しない入力の終わりが見つかりました。'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>ドキュメント ファイルに .xml サフィックスがありません</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>シーケンス式およびコンピュテーション式で、'-&gt;' の使用は 'for pat in expr -&gt; expr' の形式に制限されています。より複雑なシーケンス式で要素を生成するには、構文 'for ... in ... do ... yield...' を使用してください。</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>ゲッターのプロパティは関数にする必要があります (たとえば、'get() = ...'、'get(index) = ...')</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>'{0}' で始まる引用符が対応しません</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>この数値は、64 ビット符号なし整数に使用できる範囲から外れています</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' がアセンブリ '{3}' の '{2}' 型に見つかりません。バージョンの互換性がないことが原因の可能性があります。すべての参照コンポーネントが正しいバージョンを使用できるように、このアセンブリの正しいバージョンを明示的に参照しなければならない可能性があります。</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。シグネチャと実装のジェネリック パラメーターは種類が異なります。[&lt;Measure&gt;] 属性を指定していない可能性があります。</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>リテラル フィールドにこの型は使用できません</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>tail の呼び出しを有効または無効にします</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>copy-and-update レコード式には 1 つ以上のフィールドを含める必要があります。</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>この位置以前に始まったコメントに埋め込まれた文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>'{0}' に対するカスタム クエリ操作が必要ですが、指定されていません</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>型のリテラルが無効です</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>メンバー '{0}' は同じメソッドの複数のオーバーロードと一致しています。\n次のいずれかに制限してください: {1}。</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>共用体型が複数のケースを持つ 1 つの構造体である場合は、共用体型内のすべてのフィールドに一意の名前を付ける必要があります。</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>指定された型 '{1}' のプロパティ '{0}' で CanRead=false および CanWrite=false とされているため、読み取りも書き込みもできません</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>生成されたプロパティ</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>型の静的 'val' フィールドは、変更可能で、プライベートにし、さらに '[&lt;DefaultValue&gt;]' 属性でマークしてください。フィールドは 'null' 値または 'zero' 値に初期化されます。また、クラス型の 'static let mutable' 束縛も使用してください。</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>このメソッドのこの位置には、CLI 'params' パラメーターが必要です。'params' は、可変個数の引数を C# などの言語のメソッドに渡すときに使用されます。この引数には配列を渡してください。</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>初期化されていない 'val' フィールドは変更可能にし、'[&lt;DefaultValue&gt;]' 属性でマークする必要があります。'val' フィールドの代わりに 'let' 束縛を使用してください。</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>指定された型 '{0}' で 'IsGenericType' が true になっていますが、ジェネリック型はサポートされていません。</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation. All Rights Reserved.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>引用符内には、例外値のフィールドを設定する式を含めることはできません</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>このバイト配列リテラルには、シングル バイトとしてエンコードされない文字が含まれます</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>属性は 'val' の前に配置してください</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>実装では {2} '{3}' を定義していますが、シグネチャでは定義していないため (または定義していても同じ順序ではないため)、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>匿名の単位は、別の単位式の中に入れ子にすることはできません</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>型パラメーター '{0}' の宣言には形式 {1} の制約が必要なため、シグネチャと実装には互換性がありません</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>型またはモジュール</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>指定された型が入れ子の場合、静的引数もジェネリック パラメーターも受け取りません</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>式の中に予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>この宣言はモジュール '{0}' を開きます。'{0}' は 'RequireQualifiedAccess' とマークされています。代わりにモジュールの要素に対する限定参照を使用するようにコードを変更してください (たとえば、'map' の代わりに 'List.map')。この変更によってコードが堅牢になり、新しいコンストラクターがライブラリに追加された場合にも対応できます。</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>拡張にこの宣言の要素は使用できません</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>オブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、指定されているのは {2} 個です。必要なシグネチャは '{3}' です。</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>この新しいメンバーは抽象メンバー '{0}' を隠ぺいしています。メンバーの名前を変更するか、代わりに 'override' を使用してください。</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>この属性によって指定された型の種類は、定義が示す種類と一致しません</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>バイナリ '{0}' の書き込み中に問題が発生しました: {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>プリミティブではない数値リテラル定数は、NumericLiteral モジュールを介して複数の型にマップされる可能性があるため、パターン マッチには使用できません。変数で置き換え、match 句の末尾に 'when &lt;variable&gt; = &lt;constant&gt;' を使用してください。</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>クラス/シグネチャの型パラメーターには、メンバー/実装の型パラメーターとは異なるコンパイル時の要件があるため、シグネチャと実装には互換性がありません</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>冗長な引数は、関数 '{0}' で無視されます。{1} 個の引数が必要ですが、{2} 個の引数があります。</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>カスタム属性はオブジェクト コンストラクターを呼び出す必要があります</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>構文 'expr.id' を使用できるのは、レコードのラベル、プロパティ、およびフィールドのみです</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>この位置より後に型を置く必要があります</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>構造体で 'ReferenceEquality' 属性は使用できません。代わりに 'StructuralEquality' 属性を使用するか、'System.Object.Equals(obj)' のオーバーライドを実装してください。</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>オーバーライド '{0}' は複数の抽象スロットを実装しています (たとえば、'{1}' と '{2}')</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>メンバー '{0}' の引数の数が正しくありません。1 つのオーバーロードには {1} 個の引数を指定できますが、{2} 個が指定されました。必要な署名は '{3}' です。{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>モジュール名はパスではなく簡易名にする必要があります</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>このプロパティを設定できることを示すには、'member val PropertyName = expr with get,set' を使用します。</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>コンパイラのディレクトリ内に FSharp.Core.dll が見つかりませんでした</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>型の基本型が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>メソッド '{0}' に一致するオーバーロードはありません。</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>これはコンストラクターまたはリテラルではありません。またはコンストラクターの使用方法に誤りがあります。</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>'Measure' 属性を指定できるのは、単位を表す型のみです</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>インスタンス メンバーに対して引数を指定してください</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>明示的な型変数 '{0}' をジェネリック化できないため、このコードは、注釈に必要な総称性よりも低くなります。このコードは '{1}' に制限されました。</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>通常、'{0}' 演算子は再定義できません。型の等値セマンティクスを定義するには、その型の定義で 'Object.Equals' メンバーをオーバーライドしてください。</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>'ReferenceEquality' 属性を持つ型には、'Object.Equals(obj)'、'System.IEquatable&lt;_&gt;'、または 'System.Collections.IStructuralEquatable' を明示的に実装することはできません</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>'UseNullAsTrueValue' 属性フラグを使用できるのは、引数がないケース 1 つと、引数があるケース 1 つ以上を持つ共用体型のみです</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>'begin' または 'struct' が対応しません</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>変数に値を割り当てます。</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>この位置以前に始まった #if セクションの途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>F# では文字範囲の一致が削除されました。代わりに 'when' パターン ガードを使用してください。</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! は、ファイル先頭の最初の行にのみ指定できます。</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>例外の拡張にコンストラクターは指定できません</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>指定された型 '{0}' で 'IsArray' が true になっていますが、配列型はサポートされていません。</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>重複したプロパティ。プロパティ '{0}' は、タプル、関数、測定単位、指定された型が消去されると、名前とシグネチャが型 '{1}' の別のプロパティと同じになります。</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、モジュール/名前空間 '{2}' が含まれません</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>非再帰的な束縛の宣言の形式 'let ... and ...' は、F# コードでは使用されません。'let' 束縛のシーケンスを使用してください。</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' には 'Object.GetHashCode' または 'Object.Equals' の明示的な実装があります。この型には 'CustomEquality' 属性を適用してください。</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>デリゲート コンストラクターの使用方法に誤りがあります。'new Type(args)' か、単に 'Type(args)' という構文を使用してください</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>型パラメーター '{0}' には形式 {1} の制約がありますが、実装にはないため、シグネチャと実装には互換性がありません。シグネチャからこの制約を削除するか、実装に制約を追加してください。</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>参照アセンブリ '{0}' にアセンブリ レベル属性 '{1}' が含まれていますが、パブリックな型プロバイダー クラスが見つかりません</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>すべての警告をエラーとして報告する</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>F# コードにタブを使用するには、#indent \"off\" オプションを使用する必要があります</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>指定された型に対して無効な静的引数が渡されました。'{0}' という種類の引数を渡す必要があります。</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>変更可能な値を 'inline' とマークすることはできません</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>複数のオーバーライドが '{0}' を実装しています</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>abstract とマークされているか、一部のメソッドが実装されていないため、この型のインスタンスを作成できません。代わりにオブジェクト式 '{{ new ... with ... }}' を使用してください。</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>再帰的な宣言グループでは、モジュールの省略形は、すべての 'open' 宣言の後、その他の宣言の前になければなりません</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>単一の引数でパターン マッチングを持つラムダ式で fun キーワードと match 式の代わりに省略形として使用します。</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれていますが、シグネチャには\n    {2}    \nが指定されています。コンパイル名が異なります。</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャでは\n    {2}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>これは有効なオブジェクト構築式ではありません。明示的なオブジェクト コンストラクターでは、代わりのコンストラクターを呼び出すかまたはオブジェクトのすべてのフィールドを初期化し、スーパークラス コンストラクターの呼び出しを指定する必要があります。</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>認識されないプラットフォーム '{0}'。有効な値は 'x86'、'x64'、'Itanium'、'anycpu32bitpreferred'、および 'anycpu' です。</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>インターフェイス型では 'new' を使用できません。代わりにオブジェクト式 '{{ new ... with ... }}' を使用してください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>省略形がシグネチャによって隠ぺいされているため、シグネチャおよび実装の型 '{1}' の {0} 定義に互換性がありません。省略形は他の CLI 言語から参照できるようにする必要があります。シグネチャ内の省略形を参照できるようにしてください。</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>プロパティの set アクセス操作子の形式が無効です。少なくとも 1 つの引数が必要です。</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>クエリで 'let!'、'use!'、および 'do!' 式を使用することはできません</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>この位置以前に始まった verbatim 文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>このフィールドは読み取り専用です</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>StructLayout 属性をデコードできませんでした</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>型 '{0}' は CLI のデリゲート型ではありません</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>この式は関数ではないため、適用できません。そうではなく、expr.[index] によってインデクサーにアクセスしようとしましたか?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>'{0}' で置換</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>構造体またはクラスのフィールド '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>コンピュテーション式で、コンピュテーション式を含む結果のコレクションにそのコンピュテーション式の結果を追加します。</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>式 '{0}' は無効です</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>の型パラメーターは 'Nullable' にインスタンス化できません。別の CLI 言語などでも 'Nullable' の値との関係で、'null' の意味があいまいにならないように、この制限があります。</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>ファイルまたはモジュール '{0}' の実装は指定済みです</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>型プロバイダー '{0}' で指定されたコンストラクターは、宣言型 '{1}' のコンストラクターの中で報告されていません</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>他のインターフェイスによって継承されたインターフェイスは、'interface ...' ではなく 'inherit ...' を使用して宣言する必要があります</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>'EntryPointAttribute' 属性のラベルを付けた関数は、コンパイル シーケンスの最後のファイルの最後の宣言にする必要があります。</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>レコードの種類 '{0}' にラベル '{1}' が含まれていません。</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>ブロックが閉じられていません</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>このカスタム属性型に、このプロパティまたはフィールドが見つかりませんでした</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>'{0}' という名前空間とモジュールの両方がこのアセンブリの 2 か所で発生しています</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>このアセンブリのターゲット フレームワーク プロファイルを指定します。有効な値は、mscorlib、netcore、netstandard のいずれかです。既定 - mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>F# 4.1 まででは、型略称のアクセシビリティはコンパイル時に確認されます。型略称のアクセシビリティを変更することを検討してください。この警告を無視すると、ランタイム エラーが発生する可能性があります。</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>#endif ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>RSAParameters 構造が正しくありません - '{{0}}' が必要です</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>型パラメーター {1} が 'equality' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造の等値性をサポートしません。型 '{2}' に 'NoEquality' 属性を追加して、型が構造の等値性をサポートしないことを明確にしてください。</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>型 {1} が 'equality' 制約を満たしていないため、構造体型、レコード型、または共用体型 '{0}' は構造の等値性をサポートしません。型 '{2}' に 'NoEquality' 属性を追加して、型が構造の等値性をサポートしないことを明確にしてください。</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>この言語要素では、この属性を使用できません。アセンブリの属性は (必要に応じて F# モジュール内で) 'do ()' 宣言にアタッチする必要があります。</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>thread-static 変数および context-static 変数は静的にし、[&lt;DefaultValue&gt;] 属性を指定して、新しいスレッドごとに値が既定値に初期化されることを示してください</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>この時点で配列要素のアドレスは使用できません</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>構文エラー: 予期しない型パラメーターが指定されました</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DefaultAugmentation 属性をデコードできませんでした</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>'DefaultValue' 属性を使用するフィールドの型は、既定の初期化を許可する必要があります。つまり、'null' が正規の値として含まれるか、すべてのフィールドが既定の初期化を許可する構造体型です。このチェックを無効にするには、'DefaultValue(false)' を使用します。</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>基本バージョンと異なる抽象メソッドまたは仮想メソッドのバージョンの実装に使用します。</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>指定された型 '{0}' のメンバー '{1}' で予期しない例外が発生しました: {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>型変数が複数の異なるクラス型によって制約されています。型変数が持つことのできるクラス制約は 1 つだけです。</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>指定されたこのメソッドには静的パラメーターが必要です</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>コンストラクター、モジュール、または名前空間 '{0}' が定義されていません。</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>このコードの場所からこの型にアクセスすることはできません</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>この型の属性は、その型に対して複数の種類を指定しています</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>この操作は、別のアセンブリに定義されている変更可能な最上位の値にアクセスしていますが、サポートされないアクセス方法です。アドレスでは値にアクセスできません。変更可能なローカル変数に式をコピーし (たとえば、'let mutable x = ...')、必要に応じて、操作の完了後に値を割り当て直してください。</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>'try' 式に予期しない入力の終わりが見つかりました。'try &lt;expr&gt; with &lt;rules&gt;' または 'try &lt;expr&gt; finally &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>'for' 式の中に予期しない入力の終わりが見つかりました。'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>シグネチャおよび実装内の型 '{1}' の {0} 定義は、表現が異なるため、互換性がありません</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>引用符内には、この種類のパターン マッチを含めることはできません</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>予期しない型の末尾です。この位置より後に名前を置く必要があります。</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>型プロバイダー '{0}' がエラーを報告しました: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>MDB を生成できませんでした。互換性のあるメンバー {0} が見つかりませんでした</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>型略称にインターフェイスの宣言を含めることはできません</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>'StructuralEquality' 属性は、'NoComparison' 属性または 'StructuralComparison' 属性と組み合わせて使用する必要があります</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>式スプライス演算子は引用符で囲む必要があります</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif に対応する #if がありません</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>この言語要素では、この属性を使用できません</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>オーバーフロー チェックの生成</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Apache 2.0 のオープン ソース ライセンスで無料配布</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' は {1} 個の引数ではありません。{2} 個の引数を使用するオーバーロードが見つかりました。</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>アセンブリ属性 '{0}' はデザイナー アセンブリ '{1}' を参照していますが、このアセンブリは読み込めないか、存在していません。{2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>指定された型 '{1}' のメンバー '{2}' のメンバー '{0}' で予期しない例外が発生しました: {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>型プロバイダーが GetStaticParametersForMethod を実装しましたが、ApplyStaticArgumentsForMethod は実装されなかったか、無効でした</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- リソース -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>このアセンブリ内のコードでは引用符リテラルが使用されています。静的リンクでは、F# 4.0 以上ですべてのアセンブリがコンパイルされる場合を除き、引用符リテラルを使用するコンポーネントがインクルードされない可能性があります。</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' は 'for' 選択句の後に配置し、その後に残りのクエリを配置する必要があります。構文: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyDelaySignAttribute' 属性は、'--delaysign' オプションでオーバーライドされます</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>リテラル フィールドのアドレスは使用できません</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>この数値は、32 ビット符号付き整数に使用できる範囲から外れています</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>'[|' が対応しません</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' は {1} ではありません。プライベート メンバーには、宣言する型の中からのみアクセスできます。プロテクト メンバーには、拡張する型からのみアクセスでき、内部ラムダ式からアクセスすることはできません。</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>メソッドまたはオブジェクト コンストラクター '{0}' が静的ではありません</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>アセンブリ '{0}' 内のコードで引用符リテラルが使用されています。静的リンクでは、F# 4.0 以上ですべてのアセンブリがコンパイルされる場合を除き、引用符リテラルを使用するコンポーネントがインクルードされない可能性があります。</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' は有効なファイル名ではありません</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>厳密な名前のキーの公開部分のみを使ってアセンブリを公開署名し、アセンブリを署名済みとしてマークします</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>この数値は、16 ビット符号なし整数に使用できる範囲から外れています</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>型プロバイダー '{0}' が 'ApplyStaticArguments' から無効な型を返しました。'{1}' という名前の型が返される必要がありましたが、返されたのは '{2}' という名前の型でした。</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>変更可能なローカル '{0}' がクロージャでキャプチャされているため、参照セルとして暗黙的に割り当てられています。この警告は、情報提供のみの目的で、暗黙的な割り当てを実行する場所を示しています。</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>F# コードでは、'expr.[expr]' を使用できます。最初の式が配列であることを示すには、型の注釈が必要です。</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>インターフェイスにオブジェクト コンストラクターの定義を含めることはできません</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>'--subsystemversion' のバージョン '{0}' が無効です。バージョンは 4.00 以上でなければなりません。</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>名前付き引数は、その他の引数の後ろに指定してください</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>変数 '{0}' は引用符内でバインドされていますが、スプライスされた式の一部として使用されています。スコープが回避される可能性があるため、この操作は許可されていません。</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>この位置、またはこの位置付近にある 'enum' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>シグネチャのディレクトリがありません</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>単位式に予期しない挿入演算子が見つかりました。正しい演算子は '*'、'/'、および '^' です。</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>プロパティ</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>sealed 型を継承できません</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>このコンストラクトはシーケンス式の一部としてあいまいです。入れ子の式を記述するには 'let _ = (...)' を使用し、入れ子のシーケンスには 'yield! seq {{... }}' を使用します。</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IStructuralEquatable' を明示的に実装しています。この型には 'CustomEquality' 属性を適用してください。</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>オブジェクトの実装では、このメンバーは使用できません</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>インポートされたアセンブリでは型 '{0}' を使用していますが、その型はパブリックではありません</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- その他 -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>コンパイル ユニット '{1}' のモジュール/名前空間 '{0}' には、名前空間、モジュール、または型の '{2}' が含まれません</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>サーバーとの通信で問題が発生したため、常駐コンパイル サービスが使用されませんでした。</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>ここでは field/val の宣言を使用できません</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>'new' 制約は型 'unit' の引数を 1 つ指定し、構築された型を返す必要があります</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>バックグラウンドに常駐するコンパイル サービスを使用して、コンパイラの起動時間を改善します。</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>制約が無効です</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>実装では表現としてこの型に null を使用できると指定していますが、シグネチャは指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>静的な引数を指定されたメソッドに適用する際エラーが発生しました</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>指定したマネージ リソースを埋め込みます</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>'fixed' 式のビルド時に、参照内でメソッド System.Runtime.CompilerServices.OffsetToStringData が見つかりませんでした。</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>メンバーとローカル クラスの束縛はどちらも '{0}' という名前を使用しています</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' の後には変数名が必要です。使い方: {1}。</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>指定された型 '{0}' は実行時に '{1}' に消去されるため、この型を使用して型テストを実行することはできません。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>実装は抽象クラスですが、シグネチャは抽象クラスではないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。シグネチャに [&lt;AbstractClass&gt;] 属性を追加してください。</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>引数の長さが一致しません</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>この値は関数ではないため、適用できません。宣言を終結しましたか?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>'{1}' を実装するためにメンバー '{0}' は使用できません。必要なシグネチャは '{2}' です。</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>この型は、異なるジェネリックのインスタンス化 '{0}' と '{1}' で同じインターフェイスを実装しています。これは、このバージョンの F# で許可されていません。</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>ソース ファイルまたは追加されたモジュールに指定された 'System.Reflection.AssemblyNameAttribute' 属性は、'--keycontainer' オプションでオーバーライドされます</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>システム型 '{0}' が必要でしたが、この型を含む参照されたシステム DLL はありません</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>コンピュテーション式を示し、評価されたときはそのコンピュテーション式の結果を示すために使用します。</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>挿入演算子メンバー '{0}' に余分なカリー化された引数があります。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>インターフェイスの実装では、このメンバーは使用できません</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>挿入演算子メンバー '{0}' に {1} 個の初期引数があります。3 つの引数を持つタプルを指定してください</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>FieldOffset 属性は、StructLayout(LayoutKind.Explicit) でマークされた型のメンバーでのみ使用できます</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>コンストラクターには明示的な型パラメーターを使用できません。代わりに静的構築のメソッドを使用してください。</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>指定された型 '{1}' のプロパティ '{0}' で CanRead=false となっていますが、GetGetMethod() がメソッドを返しました</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>クエリ内では、'{0}' は単純なパターンを使用する必要があります</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>予期しない Const_bytearray です:</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>予期しない Expr.TyChoose です:</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>オブジェクト メンバーに予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>メソッド '{0}' にはカリー化された引数が使用されていますが、型 '{1}' の別のメソッドと名前が同じです。カリー化された引数を使用したメソッドはオーバーロードできません。メソッドにはタプル化された引数を使用することをご検討ください。</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>{0} がバージョン '{1}' を指定しましたが、この値は無効なため無視されました</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>型パラメーターは型コンストラクターとして使用できません</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>変更可能な変数ではメソッドをエスケープできません</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>単位の宣言に使用できるのは静的なメンバーのみです</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>通常、'{0}' 演算子は再定義できません。別の演算子名を使用してください。</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>この時点で byref 型の値 '{0}' は使用できません</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>検索ディレクトリ '{0}' が見つかりませんでした</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>このコンストラクトはコンピュテーション式の一部としてあいまいです。入れ子の式を記述するには 'let _ = (...)' を使用し、入れ子の計算には 'let! res = builder {{ ... }}' を使用します。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>シグネチャでは {2} '{3}' を定義していますが、実装では定義していないため (または定義していても同じ順序ではないため)、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>完全名</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>完全修飾パスを含むメッセージを出力します</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>フィールド {2} が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>生成したバイナリと共に FSharp.Core.dll をコピーしないでください</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>ジェネリック コンストラクターの型 '{0}' はアンマネージ型にする必要があります</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' には 'Object.Equals' の明示的な実装があります。'Object.GetHashCode()' に対応するオーバーライドを実装してください。</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>コンストラクターの明示的な型宣言は、'ty1 * ... * tyN -&gt; resTy' という形式にする必要があります。必要に応じて、'resTy' をかっこで囲んでください。</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>関数が再帰的であることを示すために使用します。</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>限定された状態において、シグネチャで値を示したり、型でメンバーを宣言したりするために使用されます。</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Dispose を呼び出してリソースを解放する必要のある値に対して、let の代わりに使用します。</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>例外を生成する可能性があるコード ブロックを開始するために使用します。with または finally と一緒に使用します。</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>オブジェクトを作成または作成可能なコンストラクターの宣言、定義、起動に使用します。ジェネリック パラメーターの制約でも、型が特定のコンストラクターを持つ必要があることを示すために使用します。</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>実際にはキーワードではありませんが、not struct という組み合わせでジェネリック パラメーターの制約として使用します。</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>値または関数への名前の関連付けまたはバインドに使用します。</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>ラムダ式で使用し、匿名関数とも呼ばれます。</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>ループ コンストラクトで使用します。</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>型定義や型拡張で、メンバー定義セクションの末尾を示します。冗語構文では、begin キーワードで始まるコード ブロックの末尾を示すために使用します。</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>プロパティのゲッターとセッターは同じ型でなければなりません。プロパティ '{0}' は、ゲッターの型が '{1}' でセッターの型が '{2}' です。</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>型引数の数が一致しません: 指定されているのは '{0}' 個ですが、'{1}' 個にする必要があります。このエラーは、前に報告されたエラーに関係する場合があります。</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>このフィールドには名前が必要です</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>生成された型</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>バージョン文字列 '{0}' が無効です</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>ここで型引数は指定できません</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>この数値は、符号付きネイティブ整数に使用できる範囲から外れています</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>この型テストまたはダウンキャストによって、指定された型 '{0}' が型 '{1}' に消去されます</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>'inherit' 宣言に 'as' 束縛は指定できません。メソッドをオーバーライドするときに基底クラスのメンバーにアクセスするには、'base.SomeMember' という構文を使用できます。'base' はキーワードです。この 'as' 束縛は削除してください。</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>デリゲートの宣言に使用します。</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>メソッドまたはオブジェクト コンストラクター '{0}' が見つかりません</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>書式指定子の幅に誤りがあります</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>'AllowNullLiteral' 属性を持つ型が継承または実装できるのは、null のリテラルも使用できる型のみです</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>静的初期化子には引数が必要です</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>構文エラー - 予期しない '?' 記号です</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>インターフェイス型の使用方法に誤りがあります</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>複数のパターンが連続する場合、スペースで区切るかタプル化します</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>必要なシグネチャは {0} です</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit が終了しませんでした</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>静的最適化の条件は、F# ライブラリ内でのみ使用できます</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>配列コンストラクター式の要素はすべて同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>宣言された型パラメーター '{0}' はコンパイル時に解決できないため、使用できません</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' は有効なアセンブリ名ではありません</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>アクティブ パターンの有効な名前ではありません</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>'if' 式に 'else' ブランチがありません。'then' ブランチは型 '{0}' です。'if' はステートメントではなく式であるため、同じ型の値を返す 'else' ブランチを追加してください。</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>型シグネチャに予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>重複したメソッド。メソッド '{0}' は、名前とシグネチャが型 '{1}' の別のメソッドと同じです。</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>型パラメーターのこのメソッドは、制約過多です</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>変数 '{0}' が見つかりません</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>アクセシビリティ修飾子はインライン アセンブラー コード型では許可されていません</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>リフレクションされた定義には、プレフィックスのスプライス演算子 '%' を使用できません</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>型に対するプレフィックス引数として単位を使用することはできません。山かっこで囲んだ後置引数として書き換えてください。</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>'struct' および 'not struct' という制約は矛盾しています</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>このリテラル パターンは引数を使用しません</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>宣言の構文が無効です</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>型 '{0}' はいずれも演算子 '{1}' をサポートしていません</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>デリゲート型は常にシールされます</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>この位置より後に式を置く必要があります</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>型 '{0}' は、使用されている値、メンバー、型 '{1}' よりもアクセシビリティが低く設定されています。</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>決定論的アセンブリを作成します (モジュール バージョン GUID やタイムスタンプなど)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>指定された型 '{0}' のメンバー '{1}' から予期しない 'null' 戻り値が返されました</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>IDisposable に Dispose が見つからないか、Dispose がオーバーロードされました</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>マネージ リソースの認識されないプライバシー設定 '{0}'。有効なオプションは 'public' および 'private' です。</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>'inline' とマークされた値をインライン展開できませんでした</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>ジェネリック コンストラクトの型 '{0}' には、パブリック既定コンストラクターが必要です</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} はインスタンス メンバーではありません</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>引用符内には、この種類の定数を含めることはできません</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>型プロバイダー '{0}' の ParameterExpression 内で無効なパラメーターが使用されました: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>このプログラム ポイントよりも前の同型でないインスタンス化で、汎用メンバー '{0}' が使用されています。このメンバーが最初に出現するようにメンバーの順序を変えることを検討してください。または、引数の型、戻り値の型、および追加のジェネリック パラメーターと制約を含む、メンバーの完全な型を明示的に指定してください。</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>型に byref 型の値が保存されています。この操作は Common IL では許可されていません。</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>実装ファイルが指定されていません</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。インライン フラグが異なります。</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>名前空間、モジュール、型、または共用体ケースの名前が無効です</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>型略称にメンバーを含めることはできません</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>このモジュールの 'rec' は外側の 'rec' 宣言で暗黙的に示されており、無視されます</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>この型はレコード型ではありません。クラス型および構造体型の値は、オブジェクト コンストラクターの呼び出しを使用して作成してください。</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>演算子 '{0}' をサポートし、特定の関数型である型が必要です。関数に対する引数が足りない可能性があります。</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>名前空間に値を含めることはできません。値の宣言を保持するモジュールを使用してください。</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>デリゲート型に Invoke メソッドが見つかりませんでした</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>条件が不完全です。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式にしてください。</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>このコンピュテーション式に 'use'、'try/with'、'try/finally'、'if/then/else'、または 'match' 演算子が含まれている場合、カスタム操作を使用することができません</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>'StructuralComparison' 属性は、'StructuralEquality' 属性と組み合わせて使用する必要があります</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>'rec' キーワードの使用法が無効です</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>列挙型にメンバーを含めることはできません</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>レコード ラベルまたは名前空間 '{0}' が定義されていません。</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>引用符内にはジェネリック式の使用を含めることはできません</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>コマンド ライン オプション '{0}' は使用されなくなりました</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>非同期コンピュテーションの結果に名前をバインドする非同期ワークフローで使用します。また別のコンピュテーション式では、そのコンピュテーション型を示す名前を結果にバインドします。</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>呼び出し</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else に対応する #if がありません</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>コンパイラーが mscorlib.dll およびフレームワーク コンポーネントを検索する場所をオーバーライドするために使用します</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の型引数が必要ですが、存在するのは {2} 個です。必要なシグネチャは '{3}' です。</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} '{1}' がアセンブリ '{2}' に見つかりません。バージョンの互換性がないことが原因の可能性があります。すべての参照コンポーネントが正しいバージョンを使用できるように、このアセンブリの正しいバージョンを明示的に参照しなければならない可能性があります。</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>型式の構文が正しくありません</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>この数値は、この整数型に使用できる範囲から外れています</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>アクティブ パターン '{0}' が関数ではありません</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>型 '{1}' のプロパティ '{0}' には一致しないゲッターとセッターがあります。一方が抽象の場合、もう一方も抽象にします。</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>クエリで整数の範囲を扱う場合は、'for x in n .. m do ...' という形式を使用してください</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>この位置以前に始まった三重引用符文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>値、関数、またはメンバーの定義内で予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>オブジェクト コンストラクター '{0}' には {1} 個の引数が必要ですが、指定されているのは {2} 個です。必要なシグネチャは '{3}' です。いくつかの引数がプロパティに値を割り当てる引数である場合は、それらの引数をコンマ (',') で区切ることを検討してください。</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}' は、型が '{1}' の引数に適用する必要がありますが、型が '{2}' の引数に適用されています</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>sealed 型の拡張は作成できません</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>この 'let' に対応する 'in' が見つかりません</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>モジュールの省略形には '{0}' 可視属性を使用できません。モジュールの省略形は常にプライベートです。</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>通常、'NoComparison' 属性を持つ型には、'System.IComparable'、'System.IComparable&lt;_&gt;'、または 'System.Collections.IStructuralComparable' を明示的に実装しません。相互運用性のために意図的に実装した場合、この警告は無効にしてください。</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>このコンストラクトはコンピュテーション式内でのみ使用できます。通常の関数から値を返すには、'return' を使用せずに式を記述してください。</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>プロパティの定義は変更可能として宣言することはできません。このプロパティが設定できることを示すには、'member val PropertyName = expr with get,set' を使用します。</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- 詳細 -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'static' 修飾子が異なります。</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>共用体ケースのコンパイル済みの形式</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>この場所またはこの場所付近でアセンブリ解決エラーが発生しました</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>フィールドの順序がシグネチャと実装とで異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>拡張に抽象メンバーは使用できません。型の一部として定義する必要があります。</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>条件式の 'then' 分岐に予期しない入力の終わりが見つかりました。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>'match' 式または 'try' 式に予期しない入力の終わりが見つかりました</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>条件式の 'else' 分岐で予期しない入力の終わりが見つかりました。'if &lt;expr&gt; then &lt;expr&gt;' または 'if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>レコード値を構築するときに指定できる引数はありません</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>'@' を含む識別子は、F# コードの生成で使用するために予約されています</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>ここでこの参照は使用できません</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>インターフェイス型、デリゲート型、または enum 型を拡張するメンバーは、型の定義とは別のモジュールに配置する必要があります。このモジュールに AutoOpen 属性を指定するか、クライアント コードで明示的にモジュールを開いて、拡張メンバーをスコープに含める必要があります。</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>構築式ではインターフェイスの実装を指定できません</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>このコードの総称性が十分ではありません。スコープが回避されるため、型変数 {0} をジェネリック化することはできません。</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>この位置以前に始まった IF-OCAML セクションの途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>'AbstractClass' 属性を指定できるのはクラスのみです</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>F# では、'System.Void' は 'typeof&lt;System.Void&gt;' としてのみ使用できます</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>F# コードでは、構文 '(typ,...,typ) ident' は使用されません。'ident&lt;typ,...,typ&gt;' を使用してください。</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>構造体型に抽象メンバーを含むことはできません</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>タプル、関数、測定単位、または指定された型が消去されると、この新しいメンバーは抽象メンバー '{0}' を隠ぺいします。メンバーの名前を変更するか、代わりに 'override' を使用してください。</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>InterfaceDataVersionAttribute の予期しないデコードです:</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>ある列で、このパターン マッチの規則を区切る '|' トークンが正しく配置されていません。コードの配置を変更するか、インデントを増やしてください。</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。この値の項数は推論されませんでした。</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>構文ツリーに予期しないソースレベルのプロパティの指定があります:</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>不適切なフィールドに値を指定しました</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>継承チェーン内の下位の型に変換するために使用します。</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\n1 つ以上の引数についてタプル型を指定する必要があります。指定した引数を追加のかっこ内にラップすることを検討するか、インターフェイスの定義を確認してください。</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>有理定数が大きすぎます:</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>イメージ形式が正しくありません</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>型プロバイダー '{0}' に空の名前空間が見つかりました。グローバル名前空間を表す 'null' を使用してください。</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。名前が異なります。</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey)。'{2}' の後ろにはかっこが必要です。</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' または '=' が必要です</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>InternalsVisibleToAttribute の予期しないデコードです:</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>不完全なプリプロセッサの式です</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: 遅延しました</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>生成された型 '{0}' への直接参照は許可されていません。型定義を使用してください (たとえば、'type TypeAlias = &lt;path&gt;')。この例では、生成された型が型プロバイダーによってアセンブリに追加されます。</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>構文エラー。#endif の入れ子が不適切です。#endif の前に予期しないトークンがあります。</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>既定でオフにすることができる特定の警告を有効にします</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} はアクティブ パターンで、名前付きフィールドのある判別された共用体ケースとしては扱えません。</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>レコード型は常にシールされます</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>set メンバーのシグネチャが無効です</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>'while' 式は、クエリ内で使用できません</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>これは有効な文字リテラルではありません</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>戻り値には名前を指定できません</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>指定された型が消去されている場合、継承することはできません</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>プロバイダー '{0}' は、一連の生成された型のコンテキスト内で、生成されていない型 '{1}' を返しました。型プロバイダーが生成された型のみを返すように調整することを検討してください。</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>'enum' 制約は 'enum&lt;type&gt;' という形式で指定する必要があります</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は抽象ですが、もう一方は違います。</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>名前 '({0})' はメンバー名として使用しないでください。型の等値セマンティクスを定義するには、'Object.Equals' メンバーをオーバーライドしてください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>この数値は、10 進リテラルに使用できる範囲から外れています</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>静的パラメーターが多すぎます。静的パラメーターの最大数は {0} 個ですが、名前のないパラメーターが {1} 個、名前付きパラメーターが {2} 個あります。</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>'namespace' 宣言の後に '=' 記号は指定できません</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>型 System.ValueType、System.Enum、System.Delegate、System.MulticastDelegate、および System.Array は、オブジェクト式またはクラスのスーパー型として使用できません</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>このファイルには、'module SomeNamespace.SomeModule' という形式の宣言が複数含まれます。1 ファイル内で指定できるこの形式の宣言は 1 つのみです。最初の名前空間宣言を使用するようにファイルを変更するか、'module ModuleName = ...' を使用してモジュールを定義してください。</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>インターフェイスの型から継承できません。代わりに interface ... with を使用してください。</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>モジュール間の最適化を有効または無効にします</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>クエリ式でどのフィールドまたは列を抽出するかを指定するために使用します。これはコンテキスト キーワードであり、実際には予約語ではなく、適切なコンテキストでキーワードとしてのみ動作します。</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>この時点でフィールド '{0}' のアドレスは使用できません</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>この位置、またはこの位置付近にある 'unmanaged' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>この型定義には 'CLIMutable' 属性を含めることができません。この属性を含めることができるのはレコード型のみです。</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>この数値は、64 ビット符号付き整数に使用できる範囲から外れています</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>列挙型フィールドにアクセシビリティ修飾子は使用できません</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>{2} の数が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>型の拡張が無効です</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>ファイル名 '{0}' に問題があります: {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#else には #endif が必要です</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>構造体型の宣言に使用します。ジェネリック パラメーターの制約にも使用します。モジュール定義の OCaml の互換性を保つために使用します。</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>型のインスタンスなしで呼び出すことのできるメソッドまたはプロパティ、または型のすべてのインスタンスで共有される値メンバーを示すために使用します。</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>'EntryPointAttribute' 属性を使用できるのは、モジュールの関数定義のみです</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>既定値が引数と同じ型ではありません。DefaultParameterValue 属性とすべての Optional 属性は無視されます。注: 'null' には適切な型の注釈を付ける必要があります。例: 'DefaultParameterValue(null:obj)'。</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>ジェネリックのインスタンス化が正しくありません。{2} のジェネリック引数を使用する '{1}' という {0} メンバーはありません。</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>型を定義したファイルおよび名前空間宣言グループの場合を除き、名前空間に拡張メンバーを含めることはできません。拡張メンバーの宣言を保持するモジュールを使用してください。</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>コンピュテーション式の結果として提供される値を示すために使用します。</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>値 '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>この 'in' トークンのインデントは、対応する 'let' に対して正しくありません</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>ここでは型 '{0}' が必要ですが使用できません。アセンブリ '{1}' に参照を追加する必要があります。</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>演算子 '{0}' では、'into' を使用することはできません</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} は静的メンバーではありません</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>この宣言で匿名型の変数は使用できません</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>このレコードには、相反する型からのフィールドが含まれます</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>型定義内のメンバーとインターフェイスの定義の前に、'let' および 'do' 束縛を含める必要があります</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>モジュール内のディレクティブは無視されます</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>この数値は、16 ビット符号付き整数に使用できる範囲から外れています</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>コードページ '{0}' に問題があります: {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>属性式は、オブジェクト コンストラクターに対する呼び出しにしてください</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>デリゲート コンストラクターには単一の関数値を渡す必要があります</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>このインデクサーには {0} 個の引数が必要ですが、存在するのは {1} 個です</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>コンテキストの型要件を満たすためには、'if' 式の型は '{0}' である必要があります。現在の型は '{1}' です。</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>省略された型に 'Sealed' 属性を指定することはできません</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>最適化を有効にします (短い形式: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>この無視では、対応する抽象メンバーに対して異なる数の引数を使用しています。次の抽象メンバーが見つかりました: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>'[' が対応しません</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>リテラル値に 'inline' とマークすることはできません</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>'NoEquality' 属性は、'NoComparison' 属性と組み合わせて使用する必要があります</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>引用符内には、byref ポインターを必要とする式を含めることはできません</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>型に予期しない / があります:</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>アセンブリ コード型は常にシールされます</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>入力が指定されていません</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>0 でない定数にジェネリック ユニットは使用できません。ジェネリックな 0 の場合、0.0&lt;_&gt; と記述してください。</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>プロパティのゲッターまたはセッターが無効です</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>シグネチャは {2} を宣言していますが、実装では {3} を宣言しているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>指定された名前空間名 '{1}' には、文字 '{0}' を使用することはできません</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>ディレクティブが無効です。'#I \"&lt;path&gt;\"' という形式で指定する必要があります。</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>この数値は、32 ビット符号なし整数に使用できる範囲から外れています</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>プロパティ '{0}' は、型 '{1}' のメソッドと名前が同じです。</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>イベント</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>フィールド</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>再帰的に定義された値は、再帰的な束縛内にあるタプル値の構造の一部として直接使用することはできません。</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>コマンド ライン オプション '{0}' は使用されなくなりました。HTML ドキュメントの生成は、F# Power Pack のツール FsHtmlDoc.exe で実行できるようになりました。</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>式内の 'let' 束縛では、属性を使用できません</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。それぞれの型パラメーター数が異なります。</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>このメンバーの総称性が十分ではありません</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>ブール型のリテラルとして使用します。</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>引用符内に降順の for loop を含めることはできません</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>ビルドするライブラリのベース アドレス</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>アセンブリ '{0}' を読み取る際に問題が発生しました: {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>指定された型 '{0}' が null のメンバーを返しました</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>アセンブリ '{1}' 内の型 '{0}' に対する参照が見つかりましたが、型はそのアセンブリ内に見つかりませんでした</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>常に '{0}' であるという制約があるジェネリック型パラメーターが使用されました</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方はオーバーライドとマークされていますが、もう一方は違います。</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>{0} 式を指定する必要がありますが、{1} が指定されました</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>この型の拡張の 1 つ以上の宣言された型パラメーターについて、型の制約が見つからないか、型の制約が '{0}' の元の型の制約に一致しないため正しくありません。</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>少なくとも 1 つのオーバーライドが対応する抽象メンバーを正しく実装していません</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>'AssemblyVersionAttribute' は、バージョンがコマンド ライン オプションを使用して指定されたため無視されました</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>'DefaultValue' 属性は 'val' 宣言でのみ使用できます</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>構造体型は常にシールされます</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>型は複数の具象型から継承できません</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>予期しない型引数です:</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>シグネチャでは型がインターフェイス {2} をサポートする必要がありますが、インターフェイスが実装されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- コード生成 -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>予期しない Const_uint16array です:</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>メンバー '{0}' の使用方法に誤りがあります。'{2}' の定義の前に '{1}' の使用が推論されました。これは無効な前方参照です。</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>は</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>このバージョンの F# では、この属性を使用できません</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>パターン内では属性を使用できません</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>継承されたメンバー '{0}' はシールされているため、オーバーライドできません</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>この型に入れ子の型はありません</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>ファイル名 '{0}' に無効な文字 '{1}' が含まれています</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>フィールド、コンストラクター、またはメンバー '{0}' が定義されていません。</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>[&lt;ReflectedDefinition&gt;] 用語には、プレフィックスのスプライス演算子 '%' を使用できません</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>型のインスタンス化の長さが一致しません</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Set アクセス操作子のプロパティに指定できる引数グループの数は 2 以下です</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>指定の警告メッセージを無効にする</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>コンパイラーの著作権メッセージを表示しません</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>型 '{0}' は明示的なレイアウトがあるとしてマークされていますが、フィールド '{1}' は 'FieldOffset' 属性でマークされていません</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。型が異なります。</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>式スプライス演算子のファーストクラスの使用は許可されていません</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>このダウンキャストによって、指定された型 '{0}' が型 '{1}' に消去されます。</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>型 {0} にメンバー '{1}' が含まれていますが、このメンバーは無視または実装に使用できる仮想メソッドでも抽象メソッドでもありません。</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>属性 '{0}' が実装とシグネチャの双方に出現していますが、属性の引数が異なります。コンパイル済みコードには、シグネチャの属性のみが含まれます。</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>演算子 '{0}' を解決できません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>認識されないオプション:'{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>拡張子</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>実装にはフィールド '{0}' がありますが、シグネチャにはないため、例外の定義に互換性がありません。モジュールには例外の定義\n    {1}    \nが含まれますが、シグネチャでは\n\t{2}\nを指定しています。</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>型 '{0}' にメソッド '{1}' (フル ネームは '{2}') がありますが、メソッドは静的ではありません</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>'reraise' への呼び出しを直接実行できるのは、try-with ハンドラーの中のみです。</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>enum 型は常にシールされます</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>引数の型が一致しません</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>この書式指定子に 'l' または 'L' は不要です。F# のコードでは、%d、%x、%o、または %u を使用できます。これらは、すべての基本的な整数型を扱うためにオーバーロードされます。</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>型の外部からのメンバーに対して、アクセスを許可します。</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>型 '{0}' に 'null' は使用できません。Null 許容型に対して null 値を作成するには、'System.Nullable()' を使用します。</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>再帰的な ValValue {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>byref&lt;T&gt; では T に byref 型を含めることができないため、型 '{0}' は正しくありません。</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>条件付きコンパイル シンボルを定義します (短い形式: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>'inherit' 宣言に属性は使用できません</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>指定された型 '{1}' のプロパティ '{0}' で CanWrite=true となっていますが、GetSetMethod() からの値が存在しません</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>例外の宣言が異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core と同じ場所に FSharp.Core.sigdata が見つかりません。ファイルは {0} にある必要があります。このファイルを必要としない、より新しいバージョンの FSharp.Core にアップグレードすることをご検討ください。</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>単一行のコメントまたは行の終わりが必要です</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>型プロバイダーが 'null' を返しましたが、これは '{0}' からの戻り値としては無効です</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>#if ディレクティブの直後に識別子を指定する必要があります</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>'{0}' に指定された実装がありませんでした。すべてのインターフェイス メンバーを実装し、適切な 'interface' 宣言で列挙してください (たとえば、'interface ... with member ...')。</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>この '{0}' に続くブロックが完了していません。すべてのコード ブロックは式であり、結果を持つ必要があります。'{1}' をブロック内の最後のコード要素にすることはできません。このブロックに明示的な結果を指定することを検討してください。</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>'while' 式に予期しない入力の終わり見つかりました。'while &lt;expr&gt; do &lt;expr&gt;' という形式を使用する必要があります。</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>単位の定義に型パラメーターは使用できません</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>F# でコンパイルされたこの DLL '{0}' は、このバージョンの F# で使用するために再コンパイルする必要があります</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>'match' 式に予期しない入力の終わりが見つかりました。'match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...' という形式を使用する必要があります。</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>インターフェイス型またはデリゲート型にフィールドを含めることはできません</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>ファイル拡張子 '.ml' および '.mli' は ML 互換用です</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>名前空間</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要です。必要なシグネチャは '{2}' です。</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>単位の宣言に使用できるのは静的なメンバーのみです。コンストラクターは使用できません。</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>インターフェイスに静的初期化子の定義を含めることはできません</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>内部ジェネリック関数は引用符付きの式には使用できません。関数の型を特定できるまで、何らかの型の制約を追加してください。</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>不明 -- テスト引数:'{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>複雑すぎるため、型推論ができません (最大反復回数に達しました)。さらに詳細な型の注釈を増やしてください。</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>値、名前空間、型、またはモジュール '{0}' が定義されていません。</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。データ フィールドの数が異なります。</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>構造体の既定のコンストラクターは束縛を実行しないため、構造体には 'do' 束縛を含むことができません</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>継承チェーン内の上位の型に変換するために使用します。</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{0} var in collection {1} (outerKey = innerKey) into group。'{2}' の後ろにかっこが必要です</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>構造体型のすべてのフィールドが既定の初期化を許可している場合のみ、既定である、ゼロで初期化した構造型のコンストラクターを使用できます。</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>ジェネリック型に 'StructLayout' 属性を指定することはできません</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>明示的なオブジェクト コンストラクターには 'new(args) = expr' という構文を使用してください</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>型指定のないコード引用符を区切ります。</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>構造体の既定のコンストラクターは束縛を実行しないため、構造体には値の定義を含むことができません。型のプライマリ コンストラクターに引数を追加してください。</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>この数値は、8 ビット符号付き整数に使用できる範囲から外れています</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>指定された型 '{1}' のメンバー '{0}' が無効です。許容されるのは、プロパティ、メソッド、およびコンストラクターのみです</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>型 '{1}' のフィールド '{0}' に割り当てが指定されていません</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>型 '{0}' は演算子 '{1}' をサポートしていません</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>この時点で静的フィールド '{0}' のアドレスは使用できません</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>この宣言は部分的な修飾パスを介して名前空間またはモジュール '{0}' を開きます。名前空間の完全パスを使用するようにコードを変更してください。この変更によってコードが堅牢になり、新しいコンストラクターが F# ライブラリや CLI ライブラリに追加された場合にも対応できます。</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>シーケンス式内には 'do!' を使用できません</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>ファイルまたはモジュール '{0}' の実装は指定済みです。型推論があるため、F# ではコンパイルの順序が重要です。必要に応じて、実装の前にシグネチャ ファイルを配置するよう、ファイルの順序を調整します。Visual Studio では、プロジェクト ファイル内の出現順にファイルが型チェックされます。プロジェクト ファイルは、手動で編集するか、ソリューション エクスプローラーを使用して調整することができます。</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>指定された型の名前空間が無効です</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>この型定義では、構造体フィールドまたは継承の関係による直接的な循環参照が発生します</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>この値はリテラルではないため、パターンに使用できません</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>構造体のプライマリ コンストラクターの各引数には型を指定してください (たとえば、'type S(x1:int, x2: int) = ...')。これらの引数で構造体のフィールドが決定されます。</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>変更可能な値にジェネリック パラメーターを指定することはできません</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>この位置、またはこの位置付近にある 'delegate' 制約を含むジェネリック コンストラクトの使用に関して、あいまいさを解決できませんでした</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>デリゲートは 'typ -&gt; typ' という形式で指定する必要があります</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>ReflectedDefinitionAttribute は、構造体型でインスタンス メンバーに適用することはできません。これは、このインスタンス メンバーが暗黙的な 'this' byref パラメーターを受け取るためです。</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get'、'set'、またはその両方が必要です</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}' はプレフィックスの '{1}' フラグをサポートしていません</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>常に '{0}' であるという制約がある型パラメーターが使用されました</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>名前付き引数をメンバーの特徴 (trait) の呼び出しに指定することはできません</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>指定した .NET Framework のバージョン '{0}' はサポートされていません。列挙型 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion からの値を指定してください。</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>定数値も指定する場合、宣言は [&lt;Literal&gt;] 属性にしてください (たとえば、'val x : int = 1')</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>'{0}' のファイル拡張子は認識されません。ソース ファイルの拡張子は .fs、.fsi、.fsx、.fsscript、.ml、または .mli にする必要があります。</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>この 'inherit' 宣言は継承された型を指定していますが、引数がありません。引数を指定してください (たとえば、'inherit BaseType(args)')。</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>出力デバッグ ファイルの名前を指定します</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>ソース ファイルおよびアセンブリの解決に使用する include パスのディレクトリを指定します (短い形式: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>アセンブリの推論されたインターフェイスをファイルに出力します</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>別のアセンブリに追加できるモジュールをビルドします</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>文字 ' |' は、アクティブなパターンのケース識別子では許可されていません</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>アクセシビリティ修飾子はこのメンバーでは許可されていません。抽象スロットには、それを囲む型と常に同じ可視性があります。</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>';' は、レコード内でフィールド値を区切るために使われます。',' を ';' で置き換えることを検討してください。</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>このプログラム ポイント、またはその付近にある演算子 '{0}' の使用に関して、あいまいな継承を解決できませんでした。あいまいさを解決するために、型の注釈を使用してください。</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>型 '{0}' が定義されていません。</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>呼び出し元のコードに直接統合する必要のある関数を示すために使用します。</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>列挙型のケースの有効な名前ではありません</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>このインスタンス メンバーには、呼び出されるオブジェクトを表すパラメーターが必要です。メンバーを静的にするか、'member x.Member(args) = ...' という表記を使用してください。</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>'{0}' という名前の静的パラメーターがありません</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>通常、'NoEquality' 属性を持つ型には、'Object.Equals(obj)' を明示的に実装しません。相互運用性のために意図的に実装した場合、この警告は無効にしてください。</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>この操作で元の値が変更されないように、値はコピーされました</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>この束縛に関する 1 つまたは複数の明示的クラスまたは関数型の変数は、他の型に制限されているため、ジェネリック化できませんでした。</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>候補: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>with' が対応しないか、'with' ブロックの形式に誤りがあります</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>リスト コンストラクター式のすべての要素は同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>明示的な型の指定は、例外のコンストラクターには使用できません</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>レコード フィールド '{0}' のレコード型が RequireQualifiedAccessAttribute によって定義されました。使用中の名前にレコード型 ('{1}') の名前を含めてください。</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>対応する正式な引数はオプションではありません</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>無効な値です</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>値 '{0}' は使用されていません</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>オプションにパラメーターが必要です: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>宣言が無効です</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>この数値は、符号なしネイティブ整数に使用できる範囲から外れています</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>パターン識別子 '{0}' が定義されていません。</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>予期しない入力の終わりです:</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>'{0}' という 2 つのモジュールがこのアセンブリの 2 か所で使用されています</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>デリゲート型に複数の Invoke メソッドが見つかりました</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>この値は関数ではないため、適用できません。そうではなく、{0}.[index] によってインデクサーにアクセスしようとしましたか?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>パラメーター '{0}' は byref 型であると推論されました。byref 型のパラメーターには、明示的な型の注釈を付ける必要があります ('x1: byref&lt;int&gt;' など)。byref パラメーターは、使用時に暗黙的に逆参照されます。</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>この静的メンバーに 'this' パラメーターを指定することはできません。'member Member(args) = ...' という表記を使用してください。</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>ジェネリック コンストラクトの型 '{0}' は、非抽象にする必要があります</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>インライン コンストラクトの実装に必要な最適化情報のみを含めてください。モジュール間のインライン処理を禁止し、バイナリの互換性を改善してください。</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>この型の表現はシグネチャによって隠ぺいされています。型の特性を示すために、[&lt;Sealed&gt;]、[&lt;Class&gt;]、[&lt;Interface&gt;] などの属性を指定する必要があります。</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>'{0}' 形式は '0' フラグをサポートしていません</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>型推論により型変数 {0} はスコープを回避しました。明示的な型パラメーター宣言を追加するか、コードの総称性が低くなるよう調整してください。</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>デバッグの種類 full、portable、pdbonly を指定します (デバッグの種類が指定されない場合には '{0}' が既定で、実行中のプログラムにデバッガーを付加することができます。'portable' はクロスプラットフォーム形式、'embedded' は出力ファイルに埋め込まれたクロスプラットフォーム形式です)。</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>最初の 'namespace' 宣言の前に指定できるのは、'#' コンパイラ ディレクティブのみです</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>最適化中にローカルの値 {0} が見つかりませんでした</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>型プロバイダー '{0}' で、'{1}' という名前のメソッドとメタデータ トークン '{2}' が指定されましたが、これは宣言型 '{3}' のメソッドの中で報告されていません</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>'{0}' の構文が正しくありません。使い方: {1}。</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>浮動小数点数が無効です</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>コンストラクターは拡張メンバーとして許可されていません - その型の元の定義の一部として定義する必要があります</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>オブジェクト コンストラクター '{0}' には、引数または設定可能な戻り値のプロパティ '{1}' がありません。{2}。</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>'anycpu32bitpreferred' プラットフォームは、EXE ターゲットでのみ使用できます。代わりに、'anycpu' を使用してください。</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。名前が異なります。</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は静的ですが、もう一方は違います。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>実装の型はシールされていませんが、シグネチャはシールされていると考えられるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。実装に [&lt;Sealed&gt;] 属性を追加してください。</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>シーケンス式内には 'try'/'with' を使用できません</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>抽象メンバー '{2}' が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' には 'Object.GetHashCode' の明示的な実装があります。'Object.Equals(obj)' に対応するオーバーライドを実装してください。</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>オブジェクトの種類のプロパティまたはメソッドの宣言に使用します。</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>関連する型、値、関数のグループに名前を関連付け、その他のコードと論理的に分離するために使用します。</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。型が異なります。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>型パラメーターの数が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>デリゲートにはカリー化された型を指定しないでください。複数引数のデリゲートには 'typ * ... * typ -&gt; typ' を使用し、関数値を返すデリゲートには 'typ -&gt; (typ -&gt; typ)' を使用します。</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>値 '{0}' は 'inline' とマークされましたが、実装ではアクセシビリティが低い内部関数またはプライベート関数を使用しています</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>プロパティ '{0}' は静的ではありません</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>オブジェクト式、シーケンス式、またはレコード式が無効です</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>この値で推論された型パラメーターは、型略称がなくなると安定しません。これは、型パラメーターの脱落や順序の変更を行う型略称を使用しているためです。次に例を示します。\n\ttype taggedInt&lt;'a&gt; = int または\n\ttype swap&lt;'a,'b&gt; = 'b * 'a\nこの値の型パラメーターを明示的に宣言してください。次に例を示します。\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x)</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IStructuralComparable' を明示的に実装しています。この型には 'CustomComparison' 属性を適用してください。</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>構文エラー</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>'{0}' に無効な結合関係が含まれています。'expr &lt;op&gt; expr' という形式を使用する必要があります (&lt;op&gt; は =、=?、?=、または ?=? です)。</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>フィールドの束縛は 'id = expr;' という形式にする必要があります</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>イベント '{0}' は静的ではありません</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>{0} var in collection</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>シーケンス式でシーケンスの値を生成します。</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>'try/finally' 式は、クエリ内で使用できません</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>IDisposable インターフェイスをサポートするオブジェクトは、コンストラクターを表す関数値として 'Type(args)' や 'Type' ではなく 'new Type(args)' の構文を使用して作成することをお勧めします。これは、リソースが生成された値に所有される可能性があることを示すためです</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>リテラル値に 'mutable' とマークすることはできません</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>ループ コンストラクトを導入します。</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} は静的メソッドではありません</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>インターフェイスの実装に属性は使用できません</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>この式の形式を使用できるのは、シーケンス式またはコンピュテーション式のみです</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>引用符内には、共用体ケースのインデックスをフェッチする式を含めることはできません</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>冗語構文で、クラス定義の始まりを示します。</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>冗語構文で、コード ブロックの先頭を示します。</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>型パラメーター上のオブジェクト コンストラクターの呼び出しに引数を指定することはできません</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>値をパターンと比較して分岐するために使用します。</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>インポートされたアセンブリに予期しない条件があります。AttributeUsage 属性のデコードに失敗しました:</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>この共用体ケースに引数は指定できません</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>最上位の .NET 名前空間を参照するために使用します。</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>この制御コンストラクトを使用できるのは、コンピュテーション式ビルダーが '{0}' メソッドを定義する場合のみです</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>/ に続く暗黙的な単位の積</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>指定されたフィールドが無効です。指定された型が消去されている場合、指定されたフィールドはリテラルである必要があります。</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>これは既知のクエリ演算子ではありません。クエリ演算子は、'select'、'where'、'sortBy'、'thenBy'、'groupBy'、'groupValBy'、'join'、'groupJoin'、'sumBy'、および 'averageBy' などの識別子であり、'QueryBuilder' 型で対応するメソッドを使用して定義されます。</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>float 型、float32 型、decimal 型、および符号付き整数型でのみサポートされる単位です</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>フィールド '{0}' は静的ではありません</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>ファイルは名前空間またはモジュールの宣言から開始する必要があります。たとえば、'namespace SomeNamespace.SubNamespace'、'module SomeNamespace.SomeModule' などです。ただし、両方は指定しません。名前空間内でモジュールを定義するには、'module SomeModule = ...' を使用してください。</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>この外部関数のシグネチャには型パラメーターが含まれます。引数を制限し、対応する C 関数の型を示す型を戻してください。</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>パターン マッチ式のすべてのブランチは同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>メソッド '{0}' はシールされているため、オーバーライドできません</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>'{0}' が対応しません</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>これは変数、定数、アクティブ レコグナイザー、またはリテラルではありません</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>フィールド '{0}' に値が指定されましたが、このフィールドは型 '{1}' に存在しません</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>引用符内には、静的フィールドをフェッチする式を含めることはできません</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>静的な値の定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください ( たとえば、'type X(args) = ...')。</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>この属性を対象にしたコードが見つかりません。属性の後のコードが完全ではない可能性があります。</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>モジュール名または名前空間名が無効です</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>カスタム操作</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>デバッグ中のコードの検証に使用します。</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>このファイルの宣言は、ファイル名 '{1}' に基づいて、暗黙的なモジュール '{0}' に配置されます。ただし、これは有効な F# 識別子ではないため、その内容には他のファイルからアクセスできません。ファイル名を変更するか、ファイルの一番上に 'module' または 'namespace' の宣言を追加してください。</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>キー ファイル '{0}' を開けませんでした</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>引用符内には、配列のパターン マッチを含めることはできません</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>片方のタプル型は構造体タプルで、もう一方は参照タプルです</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には追加で {1} 個の引数が必要です。必要なシグネチャは '{2}' です。足りない引数の名前は {3} です。</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には {1} 個の引数が必要です。必要なシグネチャは '{2}' です。足りない引数の名前は {3} です。</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>メンバーまたはオブジェクト コンストラクター '{0}' には追加で {1} 個の引数が必要です。必要なシグネチャは '{2}' です。</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>値の定義が不完全です。これが式の中にある場合、式の本体を 'let!' キーワードと同じ列にインデントする必要があります。</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>型引数または静的引数が必要です</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>競合するオプションが指定されました: 'win32manifest' および 'win32res'。これらのうち、1 つのみを使用できます。</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>重複したプロパティ。プロパティ '{0}' は、名前とシグネチャが型 '{1}' の別のプロパティと同じです。</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value> 優先する出力用言語のカルチャ名を指定します (例: es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>シーケンス式の結果は、'yield' を使用して生成されます</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>厳密名キー ファイルを指定します</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>予期しない識別子: '{0}':</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>行番号: '{0}' は無効です</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>オプションの引数は使用できません</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>このコンストラクトは試験段階です</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>デリゲート型 moduleDefns では拡張が許可されていません</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' は有効な整数引数ではありません</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>mscorlib.dll または FSharp.Core.dll が明示的に参照される場合は、{0} オプションも渡す必要があります</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>プロパティのゲッターおよびセッターでは、'get()' または 'set(v)' の後に型の注釈を指定する必要があります。たとえば、'with get() : string = ...' などです。</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Windows 実行可能ファイルをビルドします</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>出力ファイルの名前 (短い形式: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>--sourcelink スイッチは、ポータブル PDB の生成時にのみサポートされます (--debug:portable または --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>パラメーター '{0}' に適用される CallerMemberNameAttribute は無効になります。CallerFilePathAttribute に上書きされます。</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>名前付きの静的引数は、名前のない静的引数の後に置く必要があります</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>コンソール実行可能ファイルをビルドします</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>実装したすべてのインターフェイスは、型の最初の宣言で宣言する必要があります</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>予期しないソースレベルのプロパティの指定があります:</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>抽象基本メンバーを呼び出すことはできません:'{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>'ConditionalAttribute' 属性はメンバーでのみ使用できます</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>'CustomComparison' 属性を持つ型には、'System.IComparable' または 'System.Collections.IStructuralComparable' の少なくとも 1 つの明示的な実装が必要です</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。CLI メンバー名が異なります。</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>この既定で実装されたメソッドはあいまいです</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# は、1 から 32 の配列ランクをサポートしています。値 {0} は使用できません。</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>引用符内には、この種類の型を含めることはできません</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>オブジェクト式に指定できるのは、抽象メンバーおよび仮想メンバーのオーバーライドのみです。</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>指定したファイルにアセンブリの xmldoc を書き込みます</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>フィールド '{2}' が実装にはありますがシグネチャにはないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません。この型のシグネチャでは、構造体型のフィールドを公開する必要があります。ただし、フィールドのラベルは 'private' または 'internal' のままにすることもできます。</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>共用体ケース '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>'ReferenceEquality' 属性、'StructuralEquality' 属性、および 'StructuralComparison' 属性を使用して拡張できるのは、レコード型、共用体型、例外型、および構造体型のみです</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>シグネチャのサイズが正しくありません</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Win32 マニフェスト ファイルを指定します</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>インデクサー式が無効です</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>型名を入力してください。</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>ソース ファイル '{0}' が見つかりませんでした</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>モジュールまたは名前空間の親 {0} を指定してください</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>構築式に使用できるのは、'id = expr' という形式の単純な束縛のみです</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>宣言されたプログラム要素が別のバイナリまたはアセンブリで定義されていることを示します。</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>ポータブル PDB ファイルに埋め込むソース リンク情報ファイル</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' を使用できるのは、オブジェクト コンストラクターのみです</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>このコードは注釈よりも総称性が低く設定されています。'_' を使用して指定された単位は、'1' (無次元) と判断されます。コードをジェネリックにするか、'_' を使用しないでください。</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>これは有効な定数式ではありません。[&lt;Literal&gt;] 属性は無視されます。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>シグネチャでは特別な値としてこの型に null を使用できると指定していますが、実装は指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>'try/with' 式はクエリ内で使用できません</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>F# ライブラリと、ライブラリに依存するすべての参照 DLL を、生成されるアセンブリへ静的にリンクします</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>アセンブリ '{1}' の属性 'AutoOpen(\"{0}\")' は、このアセンブリ内の有効なモジュールまたは名前空間を参照していないため、無視されました</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>このフィールドは変更可能ではありません</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>型の種類が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>列挙型にインターフェイスの宣言を含めることはできません</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>ライブラリをビルドします (短い形式: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>アセンブリ '{0}' を解決できませんでした</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>{1} 個の引数を使用するメンバーまたはオブジェクト コンストラクター '{0}' は、このコードの場所からはアクセスできません。メソッド '{2}' のすべてのアクセス可能なバージョンは {3} 個の引数を使用します。</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>'{0}' の短い形式</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>インターフェイスの明示的な実装が型の定義時に指定されなかったため、このインターフェイスの既定の実装が追加されました。</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>名前付きフィールド '{0}' が複数回使用されています。</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>決定論的ビルドはポータブル PDB のみをサポートします (--debug:portable または --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>オブジェクト式が無効です。オーバーライドまたはインターフェイスがないオブジェクトには、かっこなしで 'new Type(args)' という形式の式を使用してください。</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>{0} から</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>for 式で、逆方向にカウントするときに使用します。</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>この型はレコード型ではありません</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>引用符内には、フィールドのアドレスを使用した式を含めることはできません</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型の '{0}' はインターフェイス 'System.IComparable' を明示的に実装しています。この型には 'CustomComparison' 属性を適用する必要があります。</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>if/then/else 式はクエリ内で使用できません。if/then 式を使用するか、シーケンス式を使用してください。</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>静的パラメーター '{0}' には既に値が指定されています</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>ポータブル PDB ファイル内に特定のソース ファイルを埋め込む</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>byref 型の変数 '{0}' の使用方法に誤りがあります。byref をクロージャでキャプチャすること、または内部関数に渡すことはできません。</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>プロパティ '{0}' は設定できません</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>このプロパティは設定できません</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>アドレス演算子のファーストクラスの使用は許可されていません</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方はコンストラクター/プロパティですが、もう一方は違います。</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>オブジェクト構築式は、クラス型のコンストラクターを実装する場合にのみ使用できます</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>シグネチャにはフィールド '{0}' が必要ですが、実装では指定されなかったため、例外の定義に互換性がありません。モジュールには例外の定義\n    {1}    \nが含まれますが、シグネチャでは\n\t{2}\nを指定しています。</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>数値リテラルの場合、関数 FromZero、FromOne、FromInt32、FromInt64、および FromString を定義するモジュール '{0}' がスコープに含まれている必要があります</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>この型にコンストラクターは定義できません</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>シグネチャにはフィールド {2} が必要ですが、実装では指定されていないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>型メンバーにはオプションの引数のみを使用できます</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>指定された型に対する参照に、静的パラメーター '{0}' に対応する値がありません。1 つ以上の参照アセンブリを再コンパイルする必要がある場合があります。</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>'if' 式のすべてのブランチは同じ型である必要があります。この式に必要な型は '{0}' ですが、ここでは型 '{1}' になっています。</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>消去先</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>この値、型、またはメソッドには {0} 型パラメーターを使用しますが、{1} が指定されました</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>フィールドの順序がシグネチャと実装とで異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>このコンピュテーション式の別の部分に値のない束縛または再帰的な 'let' 束縛が含まれている場合、カスタム操作を使用することができません</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>メンバー '{0}' には正しい数のメソッド型パラメーターがありません。必要なシグネチャは '{1}' です。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>CLI の型表現がシグネチャによって隠ぺいされているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' に 'StructuralComparison' 属性がありますが、型パラメーター '{1}' は 'comparison' 制約を満たしていません。型パラメーターに 'comparison' 制約を追加してください。</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>構造体型、レコード型、または共用体型 '{0}' に 'StructuralComparison' 属性がありますが、コンポーネント型 '{1}' は 'comparison' 制約を満たしていません。</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>この時点で変数 '{0}' のアドレスは使用できません</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>共用体ケース</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>グローバル アセンブリ キャッシュ</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>インターフェイスが重複するか、冗長です</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>正しくない応答ファイル '{0}' ( '{1}' )</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>'use!' 束縛は 'use! &lt;var&gt; = &lt;expr&gt;' という形式にする必要があります</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>型表現がシグネチャによって隠ぺいされているため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>無効なレコード、シーケンス式、またはコンピュテーション式です。シーケンス式は 'seq {{ ... }}' という形式にしてください。</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>指定された型 '{1}' におけるイベント '{0}' に、GetAddMethod() の値が含まれていません</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>インターフェイスの宣言と実装に使用します。</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は拡張メンバーですが、もう一方は違います。</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>プロパティ Set アクセス操作子を定義するには、'set value = '、'set idx value = '、または 'set (idx1,...,idxN) value = ... ' を使用する必要があります</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>パラメーター化されたパターン ラベルに無効な引数が指定されました</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>ビット長が正しくありません</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>#if ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>'{0}' という名前の静的パラメーターが複数存在しています</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>volatile フィールドは 'mutable' とマークしてください。また、thread-static にすることはできません。</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>共用体ケースの戻り値の型は、省略形に従い、定義されている型と同じにする必要があります</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>オーバーライドまたはインターフェイスの実装にはアクセシビリティ修飾子を使用できません</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>代わりに、ファイル拡張子に '.ml' または '.mli' を使用してください</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>このプロパティは、抽象プロパティをオーバーライドまたは実装しますが、抽象プロパティには対応する {0} がありません</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>コンパイラー エラー: 予期しない認識されない値</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>指定された型に対する参照に、静的パラメーターでは無効な値 '{0}' が含まれていました。1 つ以上の参照アセンブリを再コンパイルする必要がある場合があります。</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>例外の省略形がシグネチャと実装とで異なるため、例外の定義に互換性がありません。モジュールには例外の定義\n    {0}    \nが含まれますが、シグネチャでは\n\t{1}\nを指定しています。</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>カスタム属性値が無効です (定数またはリテラルではありません)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>例外の省略形に引数リストを含めることはできません</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>このプロパティの型は無効です。複数のインデクサー引数を使用するプロパティには、'ty1 * ty2 -&gt; ty3' という形式の型を使用してください。関数を返すプロパティには、'(ty1 -&gt; ty2)' という形式の型を使用してください。</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>byref 型の値がここに保存されます。トップレベルの let-bound byref 値は許可されていません。</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>この識別子に複数の可視属性が指定されました。式内のすべての 'let' 束縛と同様に、クラス内の 'let' 束縛は常にプライベートです。</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>引用符内には、ジェネリック型に推論または宣言する関数定義を含めることはできません。有効な引用符付きの式にするには、何らかの型の制約を追加してください。</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>書式指定子の精度に誤りがあります</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>この型にアクセスできるオブジェクト コンストラクターはありません</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>型プロバイダー '{1}' からの型 '{0}' に空の名前空間が含まれています。グローバル名前空間を表す 'null' を使用してください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>実装では特別な値としてこの型に null を使用できると指定していますが、シグネチャは指定していないため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>このオブジェクト コンストラクターには引数が必要です</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>'inherits' 宣言にアクセシビリティ修飾子は使用できません</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>この型には定義が必要です</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>リテラル フィールドを設定できません</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>for ループで範囲を示します。</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>ブール値の or 演算子としてブール条件で使用します。|| に相当します。メンバー制約でも使用します。</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>判別共同体で値のカテゴリの種類を示し、デリゲート宣言と例外宣言でも使用します。</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>条件分岐のコンストラクトで使用します。</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>冗語構文で、式のバインディングを分離するためにシーケンス式に使用します。</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>現在のクラス オブジェクトにオブジェクト名を指定するために使用します。パターン マッチ内のパターン全体に名前を指定するためにも使用します。</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>ループ コンストラクト、または命令型コードの実行に使用します。</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。変更可能属性が異なります。</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Common IL の例外型の場合、省略形には対応するオブジェクト コンストラクターが必要です</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>これは有効な数値リテラルではありません。有効な数値リテラルの例には、1、0x1、0b0001 (int)、1u (uint32)、1L (int64)、1UL (uint64)、1s (int16)、1y (sbyte)、1uy (byte)、1.0 (float)、1.0f (float32)、1.0m (decimal)、1I (BigInteger) などがあります。</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>'CustomEquality' 属性は、'NoComparison' 属性または 'CustomComparison' 属性と組み合わせて使用する必要があります</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>ゲッターのプロパティに指定できる引数グループの数は 1 以下です</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>このメンバー、関数、または値の宣言を 'inline' で宣言することはできません</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>無効なプレフィックス演算子です</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>この位置にセミコロンは使用できません</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' の使用方法が正しくありません。使い方: {1}。これは、このクエリまたはコンピュテーション式のカスタム操作です。</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>'{0}' のオーバーライドがあいまいでした</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>厳密名キー コンテナーを指定します</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>このプログラムのポイントよりも前の情報に基づいた不確定の型のオブジェクトに、演算子 'expr.[idx]' が使用されました。型の制約を増やしてください。</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- エラーと警告 -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>MSBuild の解決ではなく、ディレクトリベースの規則を使用してアセンブリの参照を解決します</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>重複したメソッド。抽象メソッド '{0}' は、タプル、関数、測定単位、または指定された型が消去されると、名前とシグネチャが継承型の抽象メソッドと同じになります。</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>型コンストラクター応用には単位を使用できません</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>オブジェクト構築式 (つまり、継承の指定があるレコード式) は、オブジェクト モデル型のコンストラクターを実装する場合にのみ使用できます。コンストラクターの外側でオブジェクト モデル型のインスタンスを構築するには、'new ObjectType(args)' を使用してください。</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>'{0}' は演算子名の文字として使用できません。将来利用するために予約されています</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>'use' 式はクエリ内で使用できません</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>型 '{0}' は、この構文で列挙できる値を持つ型ではありません。つまり、seq&lt;_&gt;、IEnumerable&lt;_&gt;、または IEnumerable のいずれとも互換性がなく、GetEnumerator メソッドを含みません。</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>予期しない空の長識別子:</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>ディレクティブが無効です。'#r \"&lt;file-or-assembly&gt;\"' という形式で指定する必要があります。</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>型推論により型変数はスコープを回避しました。型の注釈を追加して総称性が低くなるようにしてください。</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>型 '{0}' は型 '{1}' への変換をサポートしていません</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>コマンド ライン オプション '--cliroot' は使用されなくなりました。代わりに mscorlib.dll の特定のコピーに対する明示的な参照を使用してください。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>シグネチャおよび実装内の {0} 定義は、名前が異なるため、互換性がありません。この型はシグネチャ ファイルでは '{1}' という名前ですが、実装では '{2}' という名前です。</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>codegen で 'methodhandleof' に無効な引数が渡されました</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>式の予期しない記号 '='。代わりに 'for x in y .. z do' を使用するつもりでしたか?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>型 '{0}' に使用できるコンストラクターがありません</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>インターフェイスの指定に重複があります</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>アセンブリ '{0}' は、対象のバイナリの依存関係セットから見つかりませんでした。静的にリンクされたルートは、DLL または EXE 拡張子なしでアセンブリ名を使用して指定する必要があります。このアセンブリが明示的に参照された場合、アセンブリは生成されたバイナリで実際に要求されていない可能性があり、この場合には静的にリンクしないでください。</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>型 '{0}' は 'System.IComparable' を実装しています。'Object.Equals' の明示的なオーバーライドも追加してください。</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>相互に再帰的なバインディング、プロパティの宣言、およびジェネリック パラメーターの複数の制約に使用します。</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>これは有効な定数式ではありません</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>応答ファイル '{0}' が '{1}' にありません</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>名前空間 '{0}' が定義されていません。</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>型 '{0}' はいずれも演算子 '{1}' をサポートしていません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>'do' バインドにはアクセシビリティ修飾子を使用できませんが、'{0}' が指定されました。</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>プリプロセッサの式に予期しない文字 '{0}' があります</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>使用できる 'with' の拡張の数は 1 以下です</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>属性を持つパラメーターには名前を指定してください (たとえば、'[&lt;Attribute&gt;] Name : Type')</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>フィールド ラベルとこのレコード式またはパターンの型だけでは、対応するレコード型を一意に決定できません</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>結果を 1 つだけ返すアクティブ パターンのみが、引数を使用できます</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>挿入演算子メンバー '{0}' に {1} 個の初期引数があります。静的メンバー (+) (x,y) = ... など、2 つの引数を持つタプルを指定してください。</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>引数</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>このコンストラクターは ML 互換用です。{0}。'--mlcompatibility' または '--nowarn:62' を使用して、この警告を無効にできます。</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value># 書式修飾子は F# では無効です</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>厳密名キーのパブリックな部分のみを使ってアセンブリを遅延署名します</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>例外の種類の宣言に使用します。</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>このメソッドのオーバーロードの 1 つまたは複数にカリー化された引数があります。タプル化された形式で引数を使用するようにこれらのメンバーを再設計してください。</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' は、修飾パスの最初の名前としてのみ使用できます</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>リテラル列挙値の型は、int、uint、int16、uint16、int64、uint64、byte、sbyte、または char にする必要があります</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>F# メタデータ ノードをアセンブリ '{2}' のテーブル '{1}' の位置 {0} で読み取るときにエラーが発生しました。このノードには、一致する宣言がありませんでした。この警告を報告してください。使用している F# アセンブリの再コンパイルが必要になる場合があります。</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>バイナリ ファイル '{0}' を開くときにエラーが発生しました: {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>メンバー名が無効です。メンバーに '.ctor' または '.cctor' という名前を付けることはできません</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>書式指定子に誤りがあります:'{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>このフィールドはリテラルではないため、パターンに使用できません</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>'mutable' とマークできるのはレコード フィールドと単純で非再帰的な 'let' バインディングのみです</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>ディレクティブが無効です。'#load \"&lt;file&gt;\" ... \"&lt;file&gt;\"' という形式で指定する必要があります。</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>型 '{0}' にメソッド '{1}' (フル ネームは '{2}') がありますが、メソッドは静的です</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>このオーバーライドに対応する抽象メンバーまたはインターフェイス メンバーが見つかりませんでした</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>これは有効なパターンではありません</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'for' 式の中に 'do' がありません。'for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;' という形式にしてください。</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>ジェネリック抽象メソッドをオーバーライドする場合、明示的にすべての型パラメーターを宣言するか、まったく宣言しないでください</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>型プロバイダーから、サポートされない式 '{0}' が指定されました。この型プロバイダーの作成者である場合は、別の指定された式を指定するように調整することを検討してください。</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>このアセンブリのサブシステム バージョンを指定してください</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>byref 型変数の予期しない使用方法です:</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>'inline' とマークされた値 '{0}' をインライン化できませんでした。再帰的な値が 'inline' とマークされた可能性があります。</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>関数型で、引数と戻り値を区切ります。式 (シーケンス式) が得られ、yield キーワードに相当します。match 式に使用されます</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>構造体には、引数なしのオブジェクト コンストラクターを使用できません。構造体は既定のコンストラクターを自動的にサポートするため、これはすべての CLI 言語に課せられた制限です。</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>algId が正しくありません - '指数' が必要です</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>'return' の代わりに 'return!' を使うことを検討してください。</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>'!' 演算子は ref セルの逆参照に使用されます。ここに 'not expr' を使用することをご検討ください。</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>F# 固有のメタデータを含む生成済みアセンブリにリソースを追加しないでください</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>型式に予期しない挿入演算子が見つかりました:</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>--embed スイッチは、ポータブル PDB の生成時にのみサポートされます (--debug:portable または --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>無効な演算子の定義です。プレフィックス演算子の定義には、有効なプレフィックス演算子名を使用する必要があります。</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>名前なしの引数は、呼び出されるメソッドの引数のプレフィックスを形成できません</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>指定された型の完全名が無効です</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>#else ディレクティブは、スペース以外の最初の文字として行頭に指定する必要があります</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>共用体ケース/例外フィールド '{0}' を 2 回以上使用することはできません。</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>アクセシビリティ修飾子は共用体ケースに使用できません。表現全体にアクセシビリティを付与するには、'type U = internal ...' または 'type U = private ...' を使用してください。</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>型のインスタンス化に byref 型が使用されています。この操作は Common IL の規則では許可されていません。</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>不明な共用体ケースです</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>名前 '({0})' はメンバー名として使用しないでください。型の比較セマンティクスを定義するには、'System.IComparable' インターフェイスを実装してください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>型略称に拡張を含めることはできません</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>モジュールにはコンストラクター\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。シグネチャに指定されたアクセシビリティの方が、実装よりも高い設定です。</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャでは\n    {2}    \nを指定しています。シグネチャと実装の項数が異なります。シグネチャは、'{3}' が {4} 個以上の引数を受け入れる関数定義またはラムダ式であると指定していますが、実装は計算された関数値です。計算された関数値が許可された実装であることを宣言するには、シグネチャの型をかっこで囲んでください。たとえば、\n\tval {6}: int -&gt; int -&gt; int\nではなく、次のように指定します。\n\tval {5}: int -&gt; (int -&gt; int)</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>およびその他の {0} 個のオーバーロード</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>型 '{0}' は CLI の列挙型ではありません</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>モジュールの省略形はパスではなく簡易名にする必要があります</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>再帰的な値は、再帰的な束縛内の型 '{0}' の構造として直接使用することはできません。この機能は F# 言語から削除されました。代わりにレコードを使用してください。</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>F# {0} の F# コンパイラ</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>名前付き引数に複数の値が割り当てられました</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>静的リンク中に混合マネージ/アンマネージ アセンブリ '{0}' を無視しています</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>'StructLayout' 属性を指定できるのは、プライマリ コンストラクターなしの構造体およびクラスのみです</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>単位パラメーターではなく型パラメーターを指定してください</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>抽象メソッドの実装を示します。抽象メソッドの宣言と同時に使用して仮想メソッドを作成します。</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>この位置以前に始まったコメントに埋め込まれた三重引用符文字列の途中でファイルの終わりが見つかりました</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>高エントロピ ASLR の有効化</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>秘密キーが必要です</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>アクティブ パターンの結果</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>この宣言は、再帰的な宣言グループではサポートされていません</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>プリプロセッサの式にトークン '{0}' がありません</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>終了しています - エラーが多すぎます</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>メンバー '{0}' には引数の正しいメンバーがありません。必要なシグネチャは '{1}' です。</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>この型には、'NoEquality' 属性、'ReferenceEquality' 属性、'StructuralEquality' 属性、'NoComparison' 属性、および 'StructuralComparison' 属性の無効な組み合わせが使用されています</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>この定義は、プライマリ コンストラクターを含む型でのみ使用できます。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>属性の型 '{0}' に 'AllowMultiple=false' があります。この属性を持つ複数のインスタンスは、単一の言語要素にアタッチできません。</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>シーケンス式で、複数の結果は 'yield!' を使用して生成されます</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>型 '{0}' は演算子 '{1}' をサポートしていません。'Microsoft.FSharp.Linq.NullableOperators' モジュールを開いてください。</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>構造体、インターフェイス、列挙体、およびデリゲートは、他の型から継承できません</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>指定された型で、型 '{0}' に対して渡された汎用引数の数が無効です。適正な引数の数は '{1}' 個ですが、渡されたのは '{2}' 個でした。</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>メソッド '{0}' はこのコードの場所からアクセスできません</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>CLR ヘッダーのマジック値が正しくありません</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>プロパティまたはフィールドに対するオプションの割り当てが無効です</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません。名前付き引数 '{3}' に対応する、オーバーロードに合致した任意の引数、または設定可能な戻り値のプロパティはありません。</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>{2} 個の引数を使用する {0} メンバーまたはオブジェクト コンストラクター '{1}' がありません。このメンバーの呼び出しには、{3} 個の名前付き引数も必要です。</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>フィールド ラベルが無効です</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>MarshalAs 属性をデコードできませんでした</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>IL 表現が異なるため、シグネチャおよび実装内の型 '{1}' の {0} 定義は互換性がありません</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>非ジェネリック型 '{0}' に型引数は使用できませんが、{1} 個の型引数があります</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>値、コンストラクター、名前空間、または型 '{0}' が定義されていません。</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>名前空間/モジュール</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>型 '{0}' の再帰的クラス階層</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>再帰的オブジェクト参照 '{0}' は使用されていません。再帰的オブジェクト参照が存在すると、この型および派生型のメンバーに対するランタイムの初期化チェックが追加されます。この再帰的オブジェクト参照を削除してください。</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>1 つの型に 'ReferenceEquality' 属性および 'StructuralEquality' 属性、または 'ReferenceEquality' 属性および 'StructuralComparison' 属性を同時に使用することはできません</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>このコンストラクトはコンピュテーション式内でのみ使用できます</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>値の型の内容を変更するか、値の型のアドレスを使用するために、値は変更可能にする必要があります (たとえば、'let mutable x = ...')</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>例外の省略形は、既存の例外、または System.Exception から派生した F# 型を参照する必要があります</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>ポータブル PDB ファイル内にすべてのソース ファイルを埋め込む</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>'let rec' コンストラクトでバインドできるのは、単純な変数パターンのみです</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>複数の引数が連続する場合、スペースで区切るかタプル化します。関数またはメソッド アプリケーションに関する引数の場合、かっこで囲む必要があります。</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>例外ではありません</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>内部エラー。アクティブ パターン配列への無効なインデックスです。</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>アセンブリ '{0}' は推移的に参照され、このアセンブリを自動的に解決できませんでした。静的リンクでは、この DLL に F# ライブラリ上またはその他の静的にリンクされた DLL 上の依存関係がないと見なされます。この DLL に明示的な参照を追加することを検討してください。</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>'System.Reflection.AssemblyCultureAttribute' 属性の生成中にエラーが発生しました -- '実行可能ファイルをサテライト アセンブリにすることはできません。カルチャは常に空である必要があります'</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>インターフェイスは、それを囲む型と常に同じ可視性を持ちます</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。一方は型関数ですが、もう一方は違います。型パラメーターが実装にある場合、シグネチャには明示的な型パラメーターが必要です。</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>F# コードでは 'module ... = struct .. end' という構文は使用されません。'module ... = begin .. end' を使用してください。</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>'VolatileField' 属性を使用できるのは、クラス内の 'let' 束縛上のみです</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>モジュールにはフィールド\n    {0}    \nが含まれますが、シグネチャでは\n    {1}    \nを指定しています。'literal' 修飾子が異なります。</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>シグネチャおよび実装内の型 '{1}' の {0} 定義は、省略形が異なるため ({2} と {3})、互換性がありません</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>明示的な静的初期化子には 'static new(args) = expr' という構文を使用してください</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>'inline' とマークできるのは関数のみです</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>この型はインターフェイス型ではありません</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>型 '{0}' はインターフェイス型ではありません</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>オブジェクト コンストラクターでは、オブジェクトの初期化前に try/with および try/finally を直接使用できません。'for x in ...' などのコストラクトを呼び出す可能性があるようなコンストラクトがこれに含まれます。これは Common IL での制限事項です。</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' および 'return!' は、クエリ内で使用できません</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>アクセシビリティ修飾子はレコード フィールドに使用できません。表現全体にアクセシビリティを付与するには、'type R = internal ...' または 'type R = private ...' を使用してください</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>非同期ワークフロー、および Dispose を呼び出してリソースを解放する必要のある値のその他のコンピュテーション式で let! の代わりに使用します。</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>ここでは継承の宣言を使用できません</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>指定された型 '{0}' のメンバー情報 '{1}' に null を宣言する型が含まれています</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>型プロバイダー '{0}' が、'ApplyStaticArgumentsForMethod' から無効なメソッドを返しました。名前が '{1}' のメソッドが必要ですが、名前が '{2}' のメソッドが返されました。</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} は、無効な Unicode 文字のエスケープ シーケンスです</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>異なる数のジェネリック パラメーターを使用する '{0}' という複数の型が存在します。厳密に型を解決できるように、型のインスタンス化を指定してください (たとえば、'{1}')。</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>名前空間属性またはモジュール属性が、シグネチャと実装とで異なります</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>複数の明示的に実装されたインターフェイス型に、インターフェイス '{0}' が含まれています。このインターフェイスの明示的な実装を追加してください。</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>イベント '{0}' が標準以外の型です。このイベントが別の CLI 言語で宣言された場合、イベントにアクセスするには、このイベントに明示的な {1} メソッドや {2} メソッドを使用する必要があります。このイベントが F# で宣言された場合、イベントの型を IDelegateEvent&lt;_&gt;' または 'IEvent&lt;_,_&gt;' のインスタンス化にします。</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>構文 'type X with ...' は拡張のために予約されています。表現が隠ぺいされていてメンバーがある型が、'type X = ...' を使用するシグネチャで宣言されています。必要に応じて、シグネチャ内の型定義に '[&lt;Sealed&gt;]' 属性も追加してください。</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>次のいずれかの可能性はありませんか:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>レコード ラベル '{0}' が定義されていません。</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>この型テストまたはダウンキャストでは、測定単位 '{0}' が無視されます</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>公開キー BLOB が正しくありません</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>静的リンクは、System.Runtime (.NET Core またはポータブル アセンブリなど) を参照するアセンブリを生成する場合、mscorlib (.NET Framework アセンブリなど) を参照するアセンブリには使用できません。</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。シグネチャと実装のジェネリック パラメーター数が異なります (シグネチャは {3} 個を宣言しましたが、実装は {4} 個です)。</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>メンバー '{0}' には正しい種類のジェネリック パラメーターがありません。必要なシグネチャは '{1}' です。</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>それぞれの型パラメーターの数が異なるため、シグネチャおよび実装は互換性がありません</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>型、例外、またはモジュール</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>このリスト式または配列式には、'if ... then ... else' という形式の要素が含まれます。この式をかっこで囲んでリストまたは配列の個別の要素であることを示し、シーケンス式を使用して生成されたリストとこのリストを区別してください。</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>型 '{0}' に 'null' は使用できません</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>アクセシビリティ修飾子は、コンストラクトを示す識別子の直前に指定する必要があります</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>値の定義が不完全です。これが式の中にある場合、式の本体を 'use' キーワードと同じ列にインデントする必要があります。</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>値または関数定義が不完全です。これが式の中にある場合、式の本体を 'let' キーワードと同じ列にインデントする必要があります。</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>共用体ケース/例外 '{0}' には、'{1}' という名前のフィールドがありません。</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>名前 '({0})' はメンバー名として使用しないでください。他の CLI 言語から使用するために静的メンバーを定義する場合、代わりに '{1}' という名前を使用してください。</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>型プロバイダーに有効なコンストラクターが含まれていません。引数を受け取らないコンストラクター、または 'TypeProviderConfig' 型の引数を 1 つ受け取るコンストラクターが必要です。</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>レコード型、共用体型、省略形型、および構造体型に 'AllowNullLiteral' 属性を指定することはできません</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>{{ expr with ... }} という形式の式を使用できるのはレコード型のみです。オブジェクトの型を構築するには、{{ new Type(...) with ... }} を使用してください。</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>'{0}' に指定された実装がありませんでした</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>この共用体ケースにはタプル形式の引数を {0} 個指定してください</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>'{0}' という 2 つの型の定義が、このアセンブリの 2 か所の名前空間 '{1}' で発生しています</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>モジュール名が無効です</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>{0} から {1} への変換は、コンパイル時のダウンキャストではなく、セーフ アップキャストです。:?&gt; (ダウンキャスト) 演算子の代わりに :&gt; (アップキャスト) 演算子を使うことを検討してください。</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>位置指定子は書式指定文字列で許可されていません</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>カスタム操作 '{0}' が、オーバーロードされたメソッドを参照しています。カスタム操作の実装をオーバーロードすることはできません。</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>モジュールに 'use' 束縛は使用できません。この束縛は 'let' 束縛として扱われます。</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>ソース ファイルの読み取りに使用するコードページを指定します</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>この演算子は F# コンパイラーが直接処理するようになったため、演算子の意味を再定義することはできません</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>型を階層の下位にある型に変換します。</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>mscorlib.dll からバージョンを読み取ることができませんでした</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>型プロバイダー '{0}' が、指定された型 '{1}'、メンバー '{2}' のコンテキストでエラーを報告しました。エラー: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>指定された型に静的引数を適用する際にエラーが発生しました</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- 入力ファイル -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>ループの整数には単純な識別子を使用する必要があります</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>この数値は、16 進 8 ビット符号付き整数に使用できる範囲から外れています</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>パターン マッチ ガードは型 'bool' である必要がありますが、この 'when' 式は型 '{0}' です。</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>型定義には、1 つまたは複数のメンバーまたは他の宣言が必要です。空のクラス、構造体、またはインターフェイスを定義する場合、'type ... = class end'、'interface end'、または 'struct end' を使用してください。</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>ジェネリック コンストラクトの型 '{0}' には参照のセマンティクスが必要ですが、存在しません (つまり構造体です)</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。名前が異なります。</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>型略称に byref が含まれます。この操作は F# で許可されていません。</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>MDB デバッグ情報を生成できません。'Mono.CompilerServices.SymbolWriter.dll' アセンブリから 'MonoSymbolWriter' 型を読み込むことができませんでした。</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>デバッグ情報ファイル '{0}' の作成中に予期しないエラーが発生しました:</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>型パラメーターではなく単位パラメーターを指定してください。明示的な単位パラメーターは [&lt;Measure&gt;] 属性でマークする必要があります。</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>書式指定文字列 '{0}' を解析できません</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>AutoOpenAttribute の予期しないデコードです:</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>引用符内にメンバーの制約を呼び出す式を含めること、または暗黙的にメンバーの制約の呼び出しに解決される演算子を使用することはできません</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>ライブラリ内のファイル、または複数ファイル アプリケーション内のファイルでは、先頭に名前空間宣言またはモジュール宣言を置く必要があります。ファイルの先頭にモジュール宣言を置く場合、'=' 記号は指定できません。これが最上位レベルのモジュールである場合は、このエラーを解決するために = を削除することを検討してください。</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>のレコード式またはパターンに、フィールド '{0}' が 2 回出現します</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>指定された型の名前が '{0}' である必要がありましたが、指定された型の名前は 'Name'、値は '{1}' でした</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>指定された型のパスが '{0}' である必要がありましたが、指定された型のパスは '{1}' でした</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>カスタム属性の引数の数は、属性コンストラクターの引数に必要な数と一致しません</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>メンバー '{0}' の使用方法に誤りがあります。'{2}' または '{2}' 付近の定義の前に '{1}' の使用が推論されました。これは無効な前方参照です。</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>指定された型 '{1}' におけるイベント '{0}' に、GetRemoveMethod() の値が含まれていません</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>RSA キーが必要です</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>FSharp.Core.dll のすべてのレコード型、共用体型、および構造体型は、'StructuralComparison' または 'NoComparison' で明示的にラベル指定する必要があります</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>共用体ケース '{0}' の共用体型が RequireQualifiedAccessAttribute によって定義されました。使用中の名前に共用体型 ('{1}') の名前を含めてください。</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>アクティブ パターンが返すことができる結果は 7 個以下です</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>値またはコンストラクター '{0}' が定義されていません。</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>この 'inherit' 宣言には引数が含まれていますが、これはプライマリ コンストラクターを含む型ではありません。型定義に引数を追加してください (たとえば、'type X(args) = ...')。</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>判別された共用体型は常にシールされます</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>プロパティに予期しない GetSet 注釈がありました:</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>列挙型リテラルの有効な値ではありません</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>モジュール/式/型が無効です</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} オーバーロード</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 オーバーロード</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>演算子 '{0}' をサポートする型が必要ですが、タプル型が指定されました</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>アセンブリ '{0}' はコマンド ラインに一覧表示されます。アセンブリは '-r' などのコマンド ライン フラグを使用して参照する必要があります。</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>指定された型の '{0}' が null または空でした。</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>重複したメソッド。抽象メソッド '{0}' は、名前とシグネチャが継承型の抽象メソッドと同じです。</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>また、{0} から</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>配列メソッド '{0}' はランタイムによって提供されるため、コードで直接使用することはできません。配列要素を操作する場合は、LanguagePrimitives.IntrinsicFunctions モジュールにある GetArray/SetArray 関数のファミリを使用することを検討してください。</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>モジュールの省略形には '{0}' アクセシビリティ属性を使用できません。モジュールの省略形は常にプライベートです。</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>ここで型プロバイダーを使用して生成した指定された型は、他の F# アセンブリからは使用できないため、内部またはプライベートとしてマークする必要があります。'type internal TypeName = ...' または 'type private TypeName = ...' を使用することを検討してください。</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>インデクサーにアクセスするには . を追加します。</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>DLLImport 束縛はモジュール内のクラスまたは関数定義の静的メンバーであることが必要です</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>現在使用されている関数またはメンバー '{0}' では、推論された型の一貫性を確保するために、さらに型の注釈が必要です。推論されたシグネチャは '{1}' です。</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>このメソッドには既に既定の実装があります</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。このメソッドのコンパイル済み表現はインスタンス メンバーとして指定されていますが、シグネチャが示すコンパイル済み表現は静的メンバーです。</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>これは有効なバイト リテラルではありません</value>
  </data>
</root>