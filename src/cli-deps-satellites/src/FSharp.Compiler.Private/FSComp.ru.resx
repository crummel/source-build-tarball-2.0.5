<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в этой позиции для сокращенных форм типов не допускается</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Статическое связывание может не включать EXE-файл</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>Свойство "{0}" недоступно для чтения</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>привязки "use" должны иметь форму "use &lt;var&gt; = &lt;expr&gt;"</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Compiler, версия {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Поле записи, структуры или класса "{0}" недоступно из этой точки кода</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>Недопустимый элемент "{0}" предоставленного типа "{1}". Элементы предоставленного типа должны быть открытыми, а не универсальными, виртуальными или абстрактными.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>Недопустимое выражение: "{{ }}" Записи должны включать по меньшей мере одно поле. Пустые последовательности задаются с использованием Seq.empty или пустого списка "[]".</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Динамический вызов {0} не поддерживается</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralEquality", но параметр типа "{1}" не удовлетворяет ограничению "equality". Рекомендуется добавить к параметру типа ограничение "equality"</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralEquality", но тип компонента "{1}" не удовлетворяет ограничению "equality"</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Вместо этого рекомендуется использовать отдельный тип записи</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>Адрес переменной "{0}" сейчас невозможно использовать. Метод или функция могут не возвратить адрес этого локального значения.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>Не удается прочитать сборку "{0}"</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>В универсальной конструкции требуется использовать тип "{0}", являющийся типом структуры CLI или F#</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>Поставщик типов "{0}" вернул значение NULL в результате вызова метода GetInvokerExpression.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Множественные ссылки на файлы "{0}.dll" не допускаются</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>Несоответствующее имя оператора кавычки, начиная с "{0}"</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>Обозначает метод, который не имеет реализации в типе, в котором он объявлен, или является виртуальным и имеет реализацию по умолчанию.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Статическое связывание может не включать DLL-файл смешанного (управляемого и неуправляемого) типа</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Ограничивает доступ к члену для кода в том же типе или модуле.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>Тип "{0}" несовместим с любыми типами {1}, возникающими при использовании строки формата printf-style</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Элементы расширения не могут предоставлять перегрузку операторов.  Вместо этого рекомендуется определить оператор как часть определения типа.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>Недопустимый способ использования переменной "{0}"</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>""{0}" может использоваться только для формирования типов объектов</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Ожидался токен "{0}" или неполное выражение</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>Символ "_" нельзя использовать как имя поля</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Задано несколько модификаторов доступности для метода получения или задания свойства</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Конструкторы должны применяться к аргументам и не должны использоваться как значения первого класса. При необходимости используйте анонимную функцию "(fun arg1 ... argN -&gt; new Type(arg1,...,argN))".</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Недопустимый файл версии "{0}"</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Рекурсивные привязки, включающие спецификации элементов, могут встречаться только как прямое приращение типа</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Недопустимая рекурсивная ссылка на абстрактный слот</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Цитаты не могут содержать встроенный код сборки или сопоставление по шаблону для массивов</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Объекты должны инициализироваться выражением конструкции объекта, вызывающим конструктор унаследованного объекта и назначающим значение для каждого поля</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Аргументы операторов запросов могут требовать использования скобок, напр. "where (x &gt; y)" или "groupBy (x.Length / 10)"</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Задать уровень предупреждений (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Вывод данного сообщения об использовании (краткая форма: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>Для использования классов UnknownWrapper\DispatchWrapper требуется сборка System.Runtime.InteropServices.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>модуль</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Недопустимое выражение в левой части оператора присваивания</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Недопустимая встроенная спецификация</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Отделяет типизированную цитату кода.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet требуется только в деревьях синтаксического анализа</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>Проблема с именем файла "{0}": недопустимые символы в пути.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(идет загрузка описания...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "comparison", поскольку он является записью, объединением или структурой с одним или несколькими типами структурных элементов, которые не поддерживают ограничение "comparison". Исключите ограничение "comparison" из типа или добавьте в него атрибут "StructuralComparison", определяющий типы полей, которые не поддерживают ограничение "comparison"</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "comparison". Например, он не поддерживает интерфейс "System.IComparable"</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "comparison", поскольку содержит атрибут "NoComparison"</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>Атрибут System.Diagnostics.ConditionalAttribute допустим только в методах или классах атрибутов</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>Определения исключений несовместимы из-за различий в представлениях CLI. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Ошибка синтаксиса в аргументе типа с меткой</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Свойство не может иметь явных параметров типа. Вместо этого рекомендуется использовать метод.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>Выводит сообщения в кодировке UTF-8</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>Определение модуля и типа с именем "{0}" встречаются в пространстве имен "{1}" в двух разных частях этой сборки</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>Имя "{0}" не привязано в контексте шаблона</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Конструктор поставщика типов создал исключение: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Неизвестный вид статического аргумента "{0}" при разрешении ссылки на предоставленный тип или метод "{1}"</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>В определении пользовательского оператора "{0}" используется недопустимое сочетание флагов атрибутов</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} представлен как статический метод, однако не является допустимым лямбда-выражением</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 8-битных целых чисел без знака</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Атрибуты в этой конструкции пропущены</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>За "{0}" должно следовать in. Использование: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" явно реализует интерфейс "'System.IEquatable&lt;_&gt;". К типу необходимо применить атрибут "CustomEquality", а также предоставить постоянную реализацию небазового переопределения "System.Object.Equals(obj)".</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Исходный файл слишком велик для внедрения в переносимый PDB-файл.</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Конструктор объекта требует аргумент</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>Ошибка при чтении или записи метаданных для скомпилированной на языке F# библиотеки DLL "{0}". Была ли библиотека DLL скомпилирована с использованием более ранней версии компилятора F#? (ошибка: "{1}").</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Интерфейсы не могут содержать определения переопределений элементов</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Для данного идентификатора были указаны множественные атрибуты видимости</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура является абстрактным классом, а реализация — нет. Попробуйте добавить атрибут [&lt;AbstractClass&gt;] в реализацию.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>Предоставленный тип "{0}" имеет элемент "{1}" с объявляющим типом "{2}". Ожидается, что объявляющий тип будет совпадать с предоставленным типом.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Несогласованный "class", "interface" или "struct"</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Используется для связывания имени с группой соответствующих типов и модулей для логического отделения их от других частей кода.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>Пространство имен или модуль "{0}" не определены.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Данный случай объединения принимает один аргумент</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Недопустимый пустой список типа moduleDefn</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Используется для логических условий (условий when) для сопоставлений шаблонов и для введения предложения ограничения для параметра универсального типа.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Используется с ключевым словом match в выражениях сопоставления шаблонов. Также используется в выражениях объектов, выражениях копирования записей и расширениях типов для введения определений членов и обработчиков исключений.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>Обозначает тип void .NET. Используется при взаимодействии с другими языками .NET.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Используется в условных выражениях. Также используется для выполнения побочных эффектов после создания объекта.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Используется для объявления класса, записи, структуры, размеченного объединения, типа перечисления, единицы измерения или аббревиатуры типа.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Используется для предоставления доступа к содержимому пространства имен или модуля без квалификации.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Указывает на отсутствие объекта. Также используется в ограничениях универсальных параметров.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Преобразует тип в тип, находящийся выше в иерархии.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Используется в качестве имени объекта базового класса.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Используется для указания вычисления, которое должно быть выполнено, только когда требуется результат.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Используется в условном ветвлении.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Используется в условном ветвлении. Краткая форма else if.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>В подробном синтаксисе обозначает окончание блока кода в циклическом выражении.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>Ссылка на библиотеку DLL {0} требуется для сборки {1}. Импортированный тип {2} расположен в первой сборке и не может быть разрешен.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 32-битных чисел с плавающей точкой</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Определения типа могут иметь только одну спецификацию inherit, и она должна являться первым объявлением</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Значения литералов не могут иметь базовых параметров</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Непредвиденный оператор цитирования "&lt;@" в определении типа. Если планируется передать строку verbatim в качестве статического аргумента поставщику типов, вставьте пробел между символами "&lt;" и "@".</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>Оператор "{0}" обычно не должен быть переопределен. Чтобы определить для типа семантику сравнения, реализуйте интерфейс "System.IComparable" в определении этого типа.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>В методах с каррированными аргументами не допускается объявление аргументов "out", "ParamArray", "optional", "ReflectedDefinition", "byref", "CallerLineNumber", "CallerMemberName" или "CallerFilePath"</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>Для параметра "--pdb" требуется использовать параметр "--debug"</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>Значение "{0}" отмечено как "inline", однако не было привязано в среде оптимизации</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>Свойство "{0}" является статическим</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" не сравним структурно, так как параметр типа {1} не удовлетворяет ограничению "comparison". Рекомендуется добавить к типу "{2}" атрибут "NoComparison", чтобы пояснить, что тип не является сравнимым</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" не сравним структурно, так как тип {1} не удовлетворяет ограничению "comparison". Рекомендуется добавить к типу "{2}" атрибут "NoComparison", чтобы пояснить, что тип не является сравнимым</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация определяет структуру, а сигнатура определяет тип со скрытым представлением.</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Примечание. Оптимизации замыкания лямбда-выражения не были применены, так как данная локальная ограниченная универсальная функция была использована в качестве первого значения класса. Устранить эту проблему можно путем добавления ограничений типов.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>Использование "let! x = coll" в выражениях последовательности не разрешается. Вместо этого используется "for x in coll".</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "mutable" различаются</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>MDB-файл должен иметь имя &lt;имя_файла_сборки&gt;.mdb. Параметр --pdb будет проигнорирован.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОткомпилированное представление этого метода является статическим элементом, однако его сигнатура указывает, что его откомпилированное представление является экземплярным элементом</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Не удается декодировать атрибут DllImport</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>Недопустимый способ использования ключевого слова "base". Вызовы базового (base) класса не могут использоваться в замкнутых выражениях. Для вызовов базового класса рекомендуется использовать закрытый элемент.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>"new" необходимо использовать с именованным типом</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Сокращение данного типа имеет один или несколько объявленных параметров типа, не находящихся в сокращаемом типе. Сокращения типов должны использовать все объявленные параметры в сокращаемом типе. Рекомендуется удалить один или несколько параметров типа либо использовать определение конкретного типа, переносящего основной тип, такое как "type C&lt;'a&gt; = C of ...".</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Имя файла ответа "{0}" пустое, содержит недопустимые символы, имеет имя диска без абсолютного пути или слишком длинное.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как доступность, заданная в сигнатуре, шире указанной в реализации.</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Не было найдено ни одного абстрактного свойства, соответствующего данному переопределению</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Ошибка при синтаксическом анализе встроенного IL</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>Заглушки DLLImport не могут быть подставлены</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Недопустимый шаблон</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Здесь требуется простое имя метода</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Определения "member val" разрешены только в типах с первичным конструктором. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>флаг "{0}" установлен дважды</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Цитаты не могут содержать выражения объектов</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>Недопустимое значение для значения, отмеченного как "inline"</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>В запросах нельзя использовать выражения match</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>Имена свойства "{0}" и другого свойства в типе "{1}" совпадают, но только одно из этих свойств принимает аргументы индексатора. Возможно, в одном из свойств отсутствует аргумент индексатора.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Идентификаторы, после которых следует "{0}", зарезервированы для будущего использования</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Явные параметры типа могут быть использованы только в модуле или привязках элемента</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>У свойства "{0}" предоставленного типа "{1}" CanWrite=false, но метод GetSetMethod() вернул метод</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Вывод отладочной информации в кавычках</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Не включать манифест Win32 по умолчанию</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>активный распознаватель</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>Атрибут "CompiledName" нельзя использовать с данным элементом языка.</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Используется для объявления переменной, то есть значения, которое может быть изменено.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>Сигнатура файла или модуля "{0}" уже указана</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, задающие поля вариантов объединения</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Определение данного типа включает прямую циклическую ссылку через сокращение</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>Недопустимое значение "{0}" параметра --targetprofile; допустимые значения: mscorlib, netcore и netstandard.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>Использование привязок use в первичных конструкторах не допускается</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Структуры могут выполнять привязку параметра "this" только в объявлениях элементов</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Всем перечисляемым полям необходимо присвоить значения</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>В выражениях объектов не разрешены определения "member val" и "override val".</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку сокращенная форма исключения скрыта сигнатурой. Сокращение должно быть видимым для других языков CLI. Попробуйте сделать сокращение видимым в сигнатуре. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Используется вместе с ключевым словом try для введения блока кода, который выполняется независимо от того, возникает ли исключение.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>Не допускается указание пользовательского маршаллера в коде F#. Рекомендуется использовать вспомогательную функцию C#.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Ни одна реализация "{0}" не имеет нужного числа аргументов и параметров типа. Необходимая сигнатура: "{1}".</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Переопределения методов и реализации интерфейсов здесь не разрешаются</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Не удается декодировать атрибут FieldOffset</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>Отсутствует соответствующий файл реализации для файла сигнатур "{0}". Если файл реализации существует, убедитесь, что объявления "module" и "namespace" в файлах сигнатур и реализации совпадают.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>Оператор "{0}" не может быть переопределен. Рекомендуется использовать другое имя оператора</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура имеет сокращение, а реализация — нет.</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>Параметр типа {0} не определен.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Используется для указания базового класса или базового интерфейса.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Возможно, неправильные отступы: этот токен находится вне контекста, начиная с позиции {0}. Попробуйте увеличить отступ токена или использовать стандартные соглашения о форматировании.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако в его сигнатуре указано\n    {2}    \nОтображаемые имена различаются</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Это строковое выражение или аргумент атрибута вызывает арифметическое переполнение.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>Необязательные аргументы не могут использоваться в пользовательских атрибутах</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Статическая компоновка заданной сборки и всех зависимых от нее библиотек DLL, на которые существуют ссылки. Используйте имя сборки, например, mylib, вместо имени библиотеки DLL.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Конец файла во встроенной в комментарий строке verbatim начался в этой позиции или до нее</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nЗначения литеральных констант и (или) атрибутов различаются</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Эта кодировка Юникод может использоваться только в строковых литералах</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>"{0}" можно применять только к дополнительным аргументам</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>В этой операции осуществляется получение адреса значения "{0}", представленного с помощью локальной переменной или другого специального представления. Это не допускается.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Не обращаться к сборкам CLI по умолчанию</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>Файл "{0}" не найден вместе с FSharp.Core. Файл ожидался в {1}. Рекомендуется обновление до более новой версии FSharp.Core, где этот файл не требуется.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура (в отличие от реализации) определяет, что этот тип может использовать значение NULL в качестве представления.</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Конец файла в комментарии начался в этой позиции или до нее</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Конструктор элемента или объекта "{0}" не содержит аргумент или задаваемое возвращаемое свойство "{1}". {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Неподдерживаемый тип константы "{0}". Цитирования, предоставляемые поставщиками типов, могут содержать только простые константы. Может потребоваться изменить реализацию поставщика типов, переместив значение, объявленное вне предоставленного литерала цитирования, в литерал цитирования с привязкой let.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Частично активные шаблоны могут возвращать только один результат</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Тип "{0}" недоступен из данного расположения в коде</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Данное выражение списка превышает максимальный размер литералов списка. Для больших литералов используется массив и вызывается Array.ToList.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как тип реализации запечатан, а сигнатура неявно не предполагает этого. Попробуйте добавить атрибут [&lt;Sealed&gt;] в сигнатуру.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>Именованный аргумент "{0}" не совпал ни с одним аргументом или изменяемым свойством</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Недопустимое ограничение: тип, использованный для ограничения, запечатан, это означает, что ограничение может быть удовлетворено максимум одним решением.</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Недопустимый символ "{0}".</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку сопоставление исключений CLI скрыто сигнатурой. Сопоставление исключений должно быть видимо в других модулях. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Пропуск атрибутов в сокращенной форме модуля</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Требуется тип, а не единица измерения</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>Тип "{0}" явно реализует "System.IComparable", но не предоставляет соответствующего переопределения для "Object.Equals". Была автоматически предоставлена реализация "Object.Equals"; реализация выполнена через "System.IComparable". Рекомендуется явно реализовывать переопределение "Object.Equals"</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>Не удалось разрешить сборку "{0}", необходимую для "{1}"</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Недопустимое изменение константного выражения. Рекомендуется скопировать выражение в изменяемую локальную переменную, например, "let mutable x = ...".</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Обрабатывать указанные предупреждения как ошибки</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>Преобразование {0} в {1} является безопасным повышением времени компиляции, а не понижением. Рекомендуется использовать "upcast" вместо "downcast".</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>Идентификатор "{0}" зарезервирован для будущего использования в языке F#</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Файлы в библиотеках или многофайловых приложениях должны начинаться с объявления пространства имен или модуля, например, "namespace SomeNamespace.SubNamespace" или "module SomeNamespace.SomeModule". Такое объявление может отсутствовать только в последнем файле исходного кода приложения.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Привязка не может быть одновременно отмечена как "use" и "rec"</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Непредвиденный конец входных данных в аргументах типа</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является виртуальным, другой - нет</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Эта нотация индексатора удалена из языка F#</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>Тип "{0}" используется недопустимо. Значение перед "{1}" имеет логически выведенный тип, включающий "{2}", что является недопустимой короткой ссылкой.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Повторяющийся метод. Имя и сигнатура метода "{0}" аналогичны другому методу в типе "{1}" после удаления кортежей, функций, единиц измерения и предоставляемых типов.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>Внутренняя ошибка или поврежденные метаданные: недостаточно параметров типа в области видимости в процессе импорта</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Недопустимое число аргументов типа для локального вызова</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>Синтаксис "module ... : sig .. end" не используется в коде F#. Рекомендуется использовать синтаксис "module ... = begin .. end"</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Требуется интерфейсный тип</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>Имя "({0})" не должно использоваться в качестве имени элемента, так как оно получает стандартное определение в библиотеке F# поверх исправленных типов</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Непредвиденный конец входных данных в определении типа</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Недопустимое значение параметра единицы измерения "{0}"</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Недопустимое значение "{0}" параметра единицы измерения "{1}"</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Недопустимая форма метода получения свойства. При использовании явного синтаксиса требуется как минимум один аргумент "()".</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>При настройке предоставленного типа были обнаружены одна или более ошибок</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Выражения конструктора для интерфейсов не принимают аргументы</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Недопустимый уровень предупреждения "{0}".</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>Ветвь объединения с именем "{0}" вступает в конфликт с созданным типом "{1}"</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>Элемент "{0}" не соответствует какому-либо абстрактному или виртуальному методу, доступному для переопределения или реализации.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Недопустимая конструкция записи</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nТипы полей различаются</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>Метка {0} не найдена</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>Активный шаблон "{0}" имеет тип результата, содержащий переменные типа, которые не определены входными данными. Обычно эта ошибка возникает, когда не упоминается тестовый случай результата, например "let (|A|B|) (x:int) = A x". Для ее устранения можно ввести ограничение типа, например "let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x"</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}, однако здесь задано следующее число аргументов: неименованные ({2}) и именованные ({3}). Необходимая сигнатура: "{4}".</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>Тип или модуль "{0}" не является конкретным модулем или типом</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- ВЫХОДНЫЕ ФАЙЛЫ -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Доступные перегрузки показаны ниже (или в окне списка ошибок).</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>"{0}" используется с неверным числом аргументов. Это пользовательская операция в данном запросе или выражении с вычислениями. Ожидалось аргументов: {1}; задано аргументов: {2}.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} не является экземплярным методом</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Эта форма выражения объекта не используется в F#. Используйте "member this.MemberName ... = ...' для определения реализации элемента в выражениях объекта.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Недопустимое выражение в точке рекурсивного выведения</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как абстрактный элемент "{2}" задан в сигнатуре, но не указан в реализации.</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>метод или функция "{0}" не должна получать явные аргументы типа, так как она не объявляет свои параметры типа явно</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>Тип "{0}" имеет представление встроенного кода сборки</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Не допускается непосредственное присваивание рекурсивных значений неизменяемому полю "{0}" типа "{1}" внутри рекурсивной привязки. Вместо этого рекомендуется использовать изменяемое поле.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>Игнорировать предупреждения многоязыковой совместимости</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>Элемент инфиксного оператора "{0}" не имеет аргументов. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Интерфейсы не могут содержать определений конкретных элементов. Чтобы указать, что тип является классом, возможно, потребуется определить конструктор для типа.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>Отсутствует квалификация после "."</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>Создание экземпляра универсального типа "{0}" отсутствует и не может быть выведено из типа аргументов или возвращаемого значения этого элемента. Рекомендуется предоставить создание экземпляра типа при доступе к типу, например, "{1}".</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Активные идентификаторы вариантов шаблона должны начинаться с прописной буквы</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>Использовать "h" или "H" в этом описателе формата необязательно. Вместо них можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>Форма выражения ''expr then expr'' может использоваться только как часть конструктора явного объекта</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>Значения "base" можно использовать только для выполнения прямых вызовов реализаций класса base для переопределенных элементов</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Это выражение не является допустимым константным выражением или значением пользовательского атрибута</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Данная рекурсивная привязка использует недопустимое совмещение рекурсивных форм</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IComparable&lt;_&gt;". К типу необходимо применить атрибут "CustomComparison", а также предоставить постоянную реализацию небазового интерфейса System.IComparable.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Недопустимое присваивание</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Конец файла в строке начался в этой позиции или до нее</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Тип функции первого класса не может содержать параметры типа byref</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "equality", поскольку он является типом функции</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "equality", поскольку он является записью, объединением или структурой с одним или несколькими типами структурных элементов, которые не поддерживают ограничение "equality". Исключите ограничение "equality" из типа или добавьте в него атрибут "StructuralEquality", определяющий типы полей, которые не поддерживают ограничение "equality"</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>Тип "{0}" не поддерживает ограничение "equality", поскольку содержит атрибут "NoEquality"</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово "use!".</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>Использование синтаксиса "int C" и "C  &lt;int&gt;" не допускается. Рекомендуется изменить форму типа на "C&lt;int&gt;"</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Флаг префикса (" " или "+") установлен дважды</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>Найдено по разделу реестра AssemblyFolders</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Данный конструктор может быть использован только в вычислительных выражениях или выражениях последовательностей</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Ошибка при синтаксическом анализе встроенного типа IL</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Значение литерала не может получить атрибуты [&lt;ThreadStatic&gt;] или [&lt;ContextStatic&gt;]</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>У сборки "{0}" имеется атрибут TypeProviderAssembly с недопустимым значением "{1}". Значение должно представлять собой допустимое имя сборки</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Данное значение функции используется для конструирования типа делегата, подпись которого включает аргумент byref. Необходимо использовать явное лямбда выражение, принимающее {0} аргументов.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Сокращенные формы исключений общего промежуточного языка не поддерживают получение аргументов</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>Тип "{0}" не является допустимым типом перечислителя, т. е. у него нет метода MoveNext(), возвращающего логическое значение, и свойства Current</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Конец файла в директиве начался в этой позиции или до нее</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>формат "{0}" не поддерживает точность</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>Конструкторы для типа "{0}" должны напрямую или косвенно вызывать свой неявный конструктор объекта. Вместо выражения записи используйте вызов неявного конструктора объекта.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>"{0}" используется неверно. Это пользовательская операция в данном запросе или выражении с вычислениями.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Непарные скобки "[&lt;". Ожидались закрывающие скобки "&gt;]"</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Недопустимое использование выражения "fixed". Выражение "fixed" можно использовать только в объявлении формы "use x = fixed expr", где выражение является массивом, адресом поля, адресом элемента массива или строки.</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>Не допускается использовать символ "{0}" в указанном имени типа "{1}"</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>Для статического параметра "{0}" предоставленного типа или метода "{1}" требуется значение. Статические параметры поставщиков типов могут задаваться с помощью именованных аргументов, например: "{2}&lt;{3}=...&gt;".</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Непредвиденное значение SynMeasure.Anon</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>assert нельзя использовать в качестве значения первого класса. Вместо этого используйте "assert &lt;expr&gt;".</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Не удается реализовать наследование от типа переменной</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>Случаи объединения или поля типа "{0}" недоступны из данного расположения в коде</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Изменяемые значения функции должны записываться, как "let mutable f = (fun args -&gt; ...)"</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Только типы класса могут принимать аргументы "значение"</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Недопустимый номер предупреждения "{0}".</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>Тип "{0}" имеет нестандартный тип делегата</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>Члену "{0}" передано неправильное число аргументов. Ожидалось аргументов: {1}, предоставлено аргументов: {2}. Требуемая сигнатура — "{3}".{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является финальным, другой - нет</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>В делегатах не поддерживаются переданные сигнатуры</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Выберите платформы, на которых может выполняться этот код: x86, Itanium, x64, anycpu32bitpreferred или anycpu. По умолчанию используется любой процессор (anycpu).</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Требуется единица измерения, а не тип</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Укажите файл ресурсов Win32 (.res)</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Привязки локального класса нельзя пометить как "inline" Рекомендуется удалить определение из класса, или не помечать его как "inline".</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(описание недоступно...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>Тип "{0}" не определен в "{1}".</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Требуется идентификатор.</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Неожиданный токен "{0}" в выражении препроцессора</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>Отсутствует точность после "."</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Цитата может не включать присваивание полученной локальной переменной или получение ее адреса</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>Параметр командной строки "{0}" предназначен только для тестирования</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>Рекомендуется использовать "yield!" вместо "yield".</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Унаследованный тип не является типом модели объекта</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Основной модуль программы пуст: при запуске программы не будет выполнено никаких действий</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Пользователь {0} указал версию "{1}", но это значение является подстановочным знаком, а вы запросили детерминированную сборку: возник конфликт.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>Не рекомендуется передавать RESX-файл ({0}) компилятору в качестве исходного файла. С помощью программы resgen.exe преобразуйте RESX-файл в RESOURCES-файл для передачи с параметром --resource. При использовании MSBuild это можно сделать с помощью элемента &lt;EmbeddedResource&gt; в FSPROJ-файле проекта.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>Путь {0} указывает на пространство имен. Сокращение модуля не может уменьшать длину пространства имен.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Объявлению может назначаться значение в сигнатуре только в том случае, если объявление имеет атрибут [&lt;Literal&gt;]</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>Исключение при обращении к "{0}" предоставленного типа: {1}</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Используется для указания того, что член доступен внутри сборки, но не за ее пределами.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>Отсутствует директива #endif для директивы #if или #else</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Обнаружена недопустимая сигнатура элемента, связанная с предшествующей ошибкой</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Конфликт именованного поля "{0}" с автоматически созданным именем для анонимного поля.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Недопустимая директива. Требуется ''#time'', ''#time \"on\"'' или ''#time \"off\"''.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в этой позиции для перечисляемых типов не допускается</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Использование атрибутов не допускается</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- ЯЗЫК -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Нераспознанный тип отладки "{0}"; требуется "pdbonly" или "full"</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>После использования into должна располагаться оставшаяся часть вычислений</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>Использование функции "reraise" в первом классе не допускается</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Непарная скобка "&lt;". Ожидалась закрывающая скобка "&gt;"</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит значение "{2}"</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>Базовой функции "{0}" должны быть даны явные аргументы типа.</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>У свойства "{0}" предоставленного типа "{1}" CanRead=true, однако значение GetGetMethod() не получено</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Тип возвращаемого значения метода будет содержать параметры типа byref, что не допускается</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>Событие "{0}" является статическим</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Этот токен зарезервирован для будущего использования</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>В группе рекурсивных объявлений объявления "open" должны стоять первыми в каждом модуле</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>Предоставленный тип "{0}" вернул элемент с именем NULL или пустым именем</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Недопустимый спецификатор формата (после l или L): требуется ld,li,lo,lu,lx или lX. В коде F# можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Недопустимое предоставленное значение литерала "{0}"</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Типы интерфейсов не могут быть запечатаны</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Литерал в нижнем регистре "{0}" скрыт новым шаблоном с тем же именем. Только литералы в верхнем регистре и литералы с модулем в качестве префикса можно использовать в качестве именованного шаблона.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Неопределенное значение "{0}"</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Данный конструктор может использоваться только в выражениях списка, массива и последовательности, т.е. выражениях формы "seq {{ ... }}", "[ ... ]" или "[| ... |]". Они используют синтаксис "for ... in ... do ... yield..." для создания элементов.</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Пользовательский атрибут должен являться ссылочным типом</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Там, где требовалось поле экземпляра, было использовано статическое поле</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Несогласованный "("</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Невозможно определить уникальную перегрузку метода "{0}" на основе сведений о типе, заданных до данной точки программы. Возможно, требуется аннотация типа.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Конструктор элемента или объекта "{0}" не является {1}</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Вывод отладочной информации (краткая форма: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>Параметр --keyfile переопределяет атрибут System.Reflection.AssemblyKeyFileAttribute, заданный в файле с исходным кодом или в добавленном модуле</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Считывать файл ответа с дополнительными параметрами</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Несогласованный "{{"</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Несогласованный "begin"</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Определение let нельзя использовать в запросе. В запросах можно использовать только простые определения значений.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Вызывается защищенный элемент, или используется класс "base". Это допускается только в прямых реализациях элементов, поскольку при этом возможен выход за пределы области видимости объекта.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Аргументы типа необходимо указывать непосредственно после имени типа, например \"C&lt;'T&gt;\", но не \"C  &lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Параметры типа необходимо указывать непосредственно после имени типа, например, \"type C&lt;'T&gt;\", но не     type \"C   &lt;'T&gt;\"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>Не удалось разрешить неоднозначность, унаследованную в использовании строки формата вида "printf"</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Ошибка в выражении return для этого выражения "let". Возможно, неправильные отступы.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Неявное создание экземпляров базовой конструкции в данной точке или рядом с ней не может быть разрешено, так как тогда возможно разрешение в несколько несвязанных типов, напр. "{0}" и "{1}". Рекомендуется использовать аннотации типа для решения неоднозначности</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>Необязательные аргументы должны следовать в конце списка аргументов, после обязательных</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Предпринята попытка синтаксического анализа этого имени оператора, однако она завершилась неудачно</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Ссылка на сборку (краткая форма: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>Найдено по разделу реестра AssemblyFoldersEx</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>Требуется "get", "set" и (или) "get,set"</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>"{0}" не является действительным аргументом с плавающей запятой</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Параметр командной строки "{0}" не рекомендуется к использованию. Вместо этого используйте объект "{1}".</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>Тип с атрибутом "CustomEquality" должен как минимум содержать явную реализацию метода "Object.Equals(obj)", интерфейса "System.IEquatable&lt;_&gt;" или "System.Collections.IStructuralEquatable"</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Недопустимый {0} в выражении типа</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Нераспознанная цель атрибута. Допустимыми целями атрибута являются "assembly", "module", "type", "method", "property", "return", "param", "field", "event", "constructor".</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Отсутствует тело функции</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Использование модификаторов доступности не допускается, но указан "{0}".</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Типы не могут содержать вложенные определения типов</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Цветные выходные предупреждения и сообщения об ошибках</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Недопустимое использование имени типа</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Это значение имеет недопустимый тип метода присваивания значения свойства</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Недопустимый каталог поиска "{0}".</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Скомпоновать указанный ресурс вместе с этой сборкой, где формат resinfo: &lt;файл&gt;[,&lt;имя_строки&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Делитель в экспоненте единицы измерения не должен равняться 0.</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>"inherit" не может использоваться в типах интерфейса. Рекомендуется реализовать интерфейс, используя "interface ... with ... end"</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Недопустимый целочисленный литерал в выражении единицы измерения</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>"{0}" может использоваться только с именованными типами</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}, однако здесь задано следующее число аргументов: {2}. Необходимая сигнатура: "{3}".</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>приращение по умолчанию для ветви объединения</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Это значение не является функцией, и применить его невозможно.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Отсутствует указатель формата</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Свойству индексатора необходимо присвоить как минимум один аргумент</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Нераспознанный целевой формат "{0}"; требуется "exe", "winexe", "library" или "module"</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>В выражении while отсутствует do. Ожидалось "while &lt;выражение&gt; do &lt;выражение&gt;".</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Непредвиденный конец входных данных в теле лямбда-выражения. Ожидалось "fun &lt;шаблон&gt; ... &lt;шаблон&gt; -&gt; &lt;выражение&gt;".</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>У файла документации нет суффикса .xml</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>Использование "-&gt;" в выражениях последовательности и вычисления ограничивается формой "for pat in expr -&gt; expr". Использование синтаксиса "for ... in ... do ... yield..." для создания элементов в более сложных выражениях последовательности.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Свойство метода получения должно быть функцией, например, "get() = ..." или "get(index) = ..."</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>Несоответствующие кавычки, начиная с "{0}"</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 64-битных целых чисел без знака</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" не найден в типе "{2}" из сборки "{3}". Это может быть вызвано несовместимостью версий. Вам может потребоваться явно сослаться на правильную версию этой сборки, чтобы ее могли использовать все указанные в ссылке компоненты.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nУниверсальные параметры в сигнатуре и реализации имеют разные разновидности. Возможно, отсутствует атрибут [&lt;Measure&gt;].</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Этот тип не может использоваться для поля литерала</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Включение или отключение концевых вызовов</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Выражения записей копирования и обновления должны включать хотя бы одно поле.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Конец файла во встроенной в комментарий строке начался в этой позиции или до нее</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>Пользовательская операция запроса для "{0}" является обязательной, но не указана</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Недопустимый литерал в типе</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>Элемент "{0}" соответствует нескольким перегрузкам одного метода.\nНеобходимо ограничить его одним из следующих: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Если тип объединения имеет более одного варианта и является структурой, всем полям в типе объединения необходимо присвоить уникальные имена.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>Свойство "{0}" предоставленного типа "{1}" не доступно ни для чтения, ни для записи, поскольку у него CanRead=false и CanWrite=false</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>созданное свойство</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Статические поля ''val'' в типах должны быть изменяемыми, закрытыми и помечены атрибутом ''[&lt;DefaultValue&gt;]'' Они инициализируются до значения "null" или "zero" для своего типа. Рекомендуется также использовать в типе класса привязку "static let mutable".</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>В этой позиции метода требуется параметр CLI "params". В таких языках, как C#, параметр "params" используется для передачи переменного числа аргументов в метод. Рекомендуется передавать в качестве аргумента массив</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Неинициализированные поля val должны быть изменяемыми и помечены атрибутом [&lt;DefaultValue&gt;]. Рекомендуется использовать вместо поля val привязку let.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>Предоставленный тип "{0}" имеет свойство IsGenericType, равное true, однако универсальные типы не поддерживаются.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>(c) Корпорация Майкрософт (Microsoft Corp.). Все права защищены.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, задающие поля в значениях исключений</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Этот литерал массива байтов содержит знаки, не поддерживающие однобайтовую кодировку</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Атрибуты не должны располагаться перед выражением "val"</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация определяет {2} "{3}", а сигнатура — нет (или определяет, но не в том же порядке).</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Не допускается вложение анонимной единицы измерения в другое выражение единицы измерения</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>Сигнатура и реализация несовместимы, так как объявление параметра типа "{0}" требует ограничения формы {1}</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>тип или модуль</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>Вложенные предоставленные типы не принимают статических аргументов или универсальных параметров</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Данное объявление открывает модуль "{0}", помеченный как "RequireQualifiedAccess". Измените код так, чтобы вместо этого использовались квалифицированные ссылки на элементы модуля, напр. 'List.map' вместо 'map'. Данное изменение обеспечит надежность кода при добавлении конструкций в библиотеки.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Данный элемент объявления не допускается в приращении</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>Конструктор объектов "{0}" принимает определенное число аргументов (а именно: {1}), но здесь ему предоставлено {2}. Требуется сигнатура "{3}".</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Этот новый элемент скрывает абстрактный элемент "{0}". Переименуйте элемент или используйте "override".</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Вид типа, указанный его атрибутами, не совпадает с видом, подразумеваемым его определением</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>Проблема при записи двоичного файла "{0}": {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Непримитивные числовые константы-литералы не могут использоваться в сопоставлении шаблонов, так как они могут сопоставляться с несколькими различными типами через использование модуля NumericLiteral. Рекомендуется произвести замену переменной, а в конце конструкции сопоставления использовать "when &lt;variable&gt; = &lt;constant&gt;"</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>Сигнатура и реализация несовместимы, так как параметр типа в классе/сигнатуре имеет требования по времени компилирования, отличные от требований в элементе/реализации</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>Избыточные аргументы игнорируются в функции "{0}". Ожидался аргумент {1}, но получен аргумент {2}.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Пользовательский атрибут должен вызывать конструктор объекта</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>Синтаксис "expr.id" может использоваться только с метками записей, свойствами и полями</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>После этой точки ожидался тип</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>Атрибут "ReferenceEquality" не может использоваться в структурах. Вместо этого рекомендуется использовать атрибут "StructuralEquality" или реализовать переопределение метода "System.Object.Equals(obj)".</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>Переопределение "{0}" реализует более одного абстрактного слота, напр. "{1}" и "{2}"</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>Члену "{0}" передано неправильное число аргументов. Одна перегрузка принимает следующее число аргументов: {1}, предоставлено аргументов: {2}. Требуемая сигнатура — "{3}".{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Имя модуля может быть простым именем, но не путем</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Чтобы показать, что свойство можно задавать, используйте конструкцию "member val PropertyName = expr with get,set".</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Не удается найти FSharp.Core.dll в каталоге компилятора.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как типы имеют разные базовые типы.</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Отсутствуют перегрузки метода "{0}".</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Объект не является конструктором или литералом, либо конструктор используется неправильно</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Атрибут "Measure" может присваиваться только типам, представляющим единицы измерения</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Требуются аргументы элемента экземпляра</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Данный код является менее базовым, чем требуется его аннотациями, так как переменная явного типа "{0}" не может быть обобщена. Она была ограничена до "{1}".</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>Оператор "{0}" обычно не должен быть переопределен. Чтобы определить для типа семантику равенства, переопределите элемент "Object.Equals" в определении этого типа.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>Тип с атрибутом "ReferenceEquality" не может содержать явную реализацию метода "Object.Equals(obj)" либо интерфейса "System.IEquatable&lt;_&gt;" или "System.Collections.IStructuralEquatable"</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>Флаг атрибута "UseNullAsTrueValue" может использоваться только с типами объединений, имеющими один нулевой случай и по меньшей мере один ненулевой случай.</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Несогласованный "begin" или "struct"</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Назначает значение переменной.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>Конец файла в директиве #if начался в этой позиции или после нее</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Совпадения диапазона символов были убраны из F#. Вместо этого рекомендуется использовать шаблон условия "when".</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! может отображаться только в качестве первой строки в начале файла.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Конструкторы нельзя указывать в приращениях исключений</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>Предоставленный тип "{0}" имеет свойство IsArray, равное true, однако типы массивов не поддерживаются.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Повторяющееся свойство. Имя и сигнатура свойства "{0}" аналогичны другому свойству в типе "{1}" после удаления кортежей, функций, единиц измерения и предоставляемых типов.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит модуль или пространство имен "{2}"</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Форма объявления "let ... and ..." для нерекурсивных привязок не используется в коде F#. Рекомендуется использовать последовательность привязок "let"</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.GetHashCode" или "Object.Equals". Необходимо применить к типу атрибут "CustomEquality"</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Недопустимое использование конструктора делегата. Допустимый синтаксис: "new Type(args)" или "Type(args)".</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>Сигнатура и реализация несовместимы, поскольку параметр типа "{0}" имеет ограничение формы {1}, а реализация не имеет. Удалите это ограничение из сигнатуры либо добавьте его к реализации.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Сборка "{0}", на которую указывает ссылка, содержит атрибут уровня сборки "{1}", однако классы поставщика открытых типов не обнаружены</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Обрабатывать все предупреждения как ошибки</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>В коде F# табуляция может использоваться только при использовании параметра #indent \"off\"</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Недопустимый статический аргумент предоставленного типа. Ожидался аргумент вида "{0}".</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Изменяемые значения не могут помечаться как "inline"</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>"{0}" реализуется более чем одним переопределением</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Создание экземпляров этого типа невозможно, поскольку он помечен как abstract, и реализации представлены не для всех методов. Вместо этого рекомендуется использовать выражение объекта "{{ new ... with ... }}"</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>В группе рекурсивных объявлений сокращенные формы модулей должны следовать после всех объявлений "open" и до других объявлений</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Используется в качестве краткого варианта ключевого слова fun и выражения сопоставления в лямбда-выражении с сопоставлением шаблонов по одному аргументу.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако в его сигнатуре указано\n    {2}    \nСкомпилированные имена различаются</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nДоступность, заданная в сигнатуре, шире указанной в реализации</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Это недопустимое выражение конструкции объекта. Конструкторы явных объектов должны либо вызывать альтернативный конструктор, либо инициализировать все поля объекта и указывать вызов конструктора суперкласса.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Нераспознанная платформа "{0}"; допустимые значения: x86, x64, Itanium, anycpu32bitpreferred и anycpu</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>"new" не может использоваться в типах интерфейса. Вместо этого рекомендуется использовать выражение объекта "{{ new ... with ... }}"</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сокращение скрывается сигнатурой. Сокращение должно быть видимым для других языков CLI. Попробуйте сделать сокращение видимым в сигнатуре.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Недопустимая форма метода присваивания значения свойства. Требуется как минимум один аргумент.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>В запросах нельзя использовать выражения "let!", "'use!" и "do!"</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Конец файла в строке verbatim начался в этой позиции или до нее</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Это поле доступно только для чтения</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Не удается декодировать атрибут StructLayout</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>Тип "{0}" не является делегатным типом CLI</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Это выражение не является функцией, и применить его невозможно. Вы хотели обратиться к индексатору с помощью конструкции выражение.[индекс]?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>Заменить на "{0}"</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>Поле структуры или класса "{0}" недоступно из этой точки кода</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Используется в вычислительном выражении для добавления результата данного вычислительного выражения в набор результатов для содержащего его вычислительного выражения.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Недопустимое выражение "{0}"</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Не удается создать экземпляр "Nullable" для этого параметра типа. Это ограничение позволяет отличить значение "null" в некоторых языках CLI от используемых совместно с ним значений "Nullable".</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>Реализация файла или модуля "{0}" уже задана</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Поставщик типов "{0}" предоставил конструктор, который не указан среди конструкторов его объявляющего типа "{1}"</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Для объявления интерфейсов, наследуемых другими интерфейсами, следует использовать "inherit ...", а не "interface ..."</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>Функция, помеченная атрибутом "EntryPointAttribute", должна быть последним объявлением в последнем файле последовательности компиляции.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>Тип записи "{0}" не содержит метку "{1}".</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Незакрытый блок</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Данное свойство или поле не было найдено в этом пользовательском типе атрибута</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Пространство имен и модуль с именем "{0}" одновременно встречаются в двух частях этой сборки</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Укажите профиль целевой платформы этой сборки. Допустимые значения: mscorlib, netcore и netstandard. Значение по умолчанию — mscorlib.</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>В версии F# 4.1 доступность сокращений типов проверяется во время компиляции. Рекомендуется изменить доступность сокращений типов. Если проигнорировать это предупреждение, возможны ошибки во время выполнения.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>Перед директивами #endif могут находиться только знаки пробела</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Недопустимая структура RSAParameters — ожидалось "{{0}}"</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" не поддерживает структурное равенство, так как параметр типа {1} не удовлетворяет ограничению "equality". Рекомендуется добавить к типу "{2}" атрибут "NoEquality", чтобы пояснить, что тип не поддерживает структурное равенство</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" поддерживает структурное равенство, так как параметр типа {1} не удовлетворяет ограничению "equality". Рекомендуется добавить к типу "{2}" атрибут "NoEquality", чтобы пояснить, что тип не поддерживает структурное равенство</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Не допускается использование этого атрибута для этого элемента языка. Атрибуты сборки необходимо присоединять к объявлению "do ()" (при необходимости внутри модуля F#).</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Переменные статического потока и статического контекста должны являться статическими и должны получить атрибут [&lt;DefaultValue&gt;], чтобы указать, что значение инициализировано до значения по умолчанию в каждом новом потоке</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>В этой точке нельзя использовать адрес элемента массива</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Синтаксическая ошибка: недопустимая спецификация параметра типа</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>Не удается декодировать атрибут DefaultAugmentation</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>Тип поля, использующего атрибут "DefaultValue", должен поддерживать инициализацию по умолчанию, т. е. должен содержать собственное значение "null" или являться типом структуры, все поля которого поддерживают инициализацию по умолчанию. Чтобы отключить эту проверку, используйте "DefaultValue(false)"</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Используется для реализации версии абстрактного или виртуального метода, который отличается от базовой версии.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>Непредвиденное исключение, полученное из элемента "{1}" предоставленного типа "{0}": {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Переменная типа ограничена несколькими различными типами классов. Переменная типа может иметь только одно ограничение класса.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Этому предоставленному методу требуются статические параметры</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>Конструктор, модуль или пространство имен "{0}" не определены.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Этот тип недоступен из данного расположения в коде</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Атрибуты этого типа задают несколько видов типа</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Эта операция обращается к изменяемому значению верхнего уровня, определенному в другой сборке неподдерживаемым способом. Не удается получить доступ к значению по его адресу. Рекомендуется скопировать выражение в локальную изменяемую переменную, например, "let mutable x = ...", и, при необходимости, снова присвоить это значение по завершении операции</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении try. Ожидалось "try &lt;выражение&gt; with &lt;правила&gt;" или "try &lt;выражение&gt; finally &lt;выражение&gt;".</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении for. Ожидалось "for &lt;шаблон&gt; in &lt;выражение&gt; do &lt;выражение&gt;".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представления различаются.</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Цитаты не могут содержать эту разновидность сопоставления шаблону</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Непредвиденный конец файла. После этой точки ожидалось имя.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Поставщик типов "{0}" сообщил об ошибке: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>Сбой при создании MDB-файла. Не удалось найти совместимый элемент {0}</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Сокращения типов не могут иметь объявлений интерфейса</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>Атрибут "StructuralEquality" необходимо использовать в сочетании с атрибутами "NoComparison" или "StructuralComparison"</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>Операторы expression-splicing можно использовать только в кавычках</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>Отсутствует директива #if, соответствующая директиве #endif</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Не допускается использование этого атрибута для этого элемента языка</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Сформировать проверки переполнений</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>Распространяется бесплатно по лицензии Apache 2.0 Open Source License</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Конструктор элемента или объекта "{0}" не принимает следующее число аргументов: {1}. Обнаружена перегрузка, принимающая следующее число аргументов: {2}.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Атрибут сборки "{0}" ссылается на сборку конструктора "{1}", которая не может быть загружена или не существует. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>Непредвиденное исключение, полученное из элемента "{0}" предоставленного типа "{1}", элемент "{2}": {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Поставщик типов реализовал GetStaticParametersForMethod, но поддержка аргумента ApplyStaticArgumentsForMethod не была реализована или была реализована неправильно</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- РЕСУРСЫ -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>В коде этой сборки используются литералы кавычек. При статическом связывании компоненты, использующие литералы кавычек, могут быть не включены, если все сборки не скомпилированы в версии F# не ниже 4.0.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>Перед "{0}" должно располагаться предложение выбора for, а после - оставшаяся часть запроса. Синтаксис: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>Параметр --delaysign переопределяет атрибут System.Reflection.AssemblyDelaySignAttribute, заданный в файле с исходным кодом или в добавленном модуле</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Недопустимое получение адреса поля литерала</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 32-битных целых чисел со знаком</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Несогласованный "[|"</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Конструктор элемента или объекта "{0}" не является {1}. Закрытые элементы доступны только внутри типа, в котором они объявляются. Защищенные типы доступны только из расширяющего типа и недоступны из внутренних лямбда-выражений.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>Метод или конструктор объекта "{0}" не является статическим</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>В коде сборки "{0}" используются литералы кавычек. При статическом связывании компоненты, использующие литералы кавычек, могут быть не включены, если все сборки не скомпилированы в версии F# не ниже 4.0.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>"{0}" не является допустимым именем файла</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Выполнить общедоступную подпись сборки, используя только открытую часть ключа строгого имени, и пометить сборку как подписанную</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 16-битных целых чисел без знака</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>Поставщик типов "{0}" вернул недопустимый тип из метода ApplyStaticArguments. Ожидался тип с именем "{1}", но был возвращен тип с именем "{2}".</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Локальная изменяемая переменная "{0}" была неявно выделена в качестве ссылочной ячейки, поскольку она попала в замыкание. Это предупреждение отображается только в ознакомительных целях, чтобы указать на неявно определенные выделения.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>В коде F# можно использовать выражения вида "expr.[expr]". Может потребоваться аннотация типа для указания на то, что первое выражение является массивом</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Интерфейсы не могут содержать определения конструкторов объектов</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>Недопустимая версия "{0}" для "--subsystemversion". Должна быть версия 4.00 или больше.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Именованные аргументы должны появиться после всех остальных аргументов</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>Переменная "{0}" заключена в кавычки, однако используется в составе соединенного выражения. Это не допускается, поскольку может привести к выходу за пределы области видимости.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "enum" в этой позиции или рядом с ней</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>Нет каталога сигнатуры</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Недопустимый инфиксный оператор в выражении единицы измерения. Допустимые операторы: "*", "/" и "^".</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>свойство</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Не удается реализовать наследование от запечатанного типа</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Этот конструктор является неоднозначным как часть выражения последовательности. Вложенные выражения могут записываться с использованием "let _ = (...)", а вложенные последовательности - с использованием "yield! seq {{... }}".</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IStructuralEquatable". Необходимо применить к типу атрибут "CustomEquality".</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Использование этого элемента в реализации объекта не допускается</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>В импортированной сборке используется тип "{0}", который не является открытым</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- ПРОЧЕЕ -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>Модуль или пространство имен "{0}" из блока компиляции "{1}" не содержит пространство имен, модуль или тип "{2}"</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Служба резидентной компиляции не использовалась, поскольку возникла проблема при взаимодействии с сервером.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Объявление field/val здесь не разрешено</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>Ограничения "new" должны принять один аргумент типа "unit" и возвратить сформированный тип.</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Используйте службу фоновой резидентной компиляции, чтобы сократить время запуска компилятора.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Недопустимое ограничение</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация (в отличие от сигнатуры) определяет, что этот тип может использовать значение NULL в качестве представления.</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Произошла ошибка при применении статических аргументов к предоставленному методу</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Внедрить указанный управляемый ресурс</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>Не удалось найти в ссылках метод System.Runtime.CompilerServices.OffsetToStringData при создании выражения "fixed".</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Элемент и привязка локального класса имеют одно имя "{0}"</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>За "{0}" должно следовать имя переменной. Использование: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>Такая проверка предоставленного типа "{0}" запрещена, поскольку при этом предоставленный тип будет во время выполнения стерт до типа "{1}".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация является абстрактным классом, а сигнатура — нет. Попробуйте добавить атрибут [&lt;AbstractClass&gt;] в сигнатуру.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Несоответствие длин аргументов</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Данное значение не является функцией и не может быть применено. Забыли завершить объявление?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Использование элемента "{0}" для реализации "{1}" невозможно. Необходимая сигнатура: {2}.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>В этом типе реализуется один и тот же интерфейс в различных универсальных установках "{0}" и "{1}". В данной версии F# это не допускается.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>Параметр --keycontainer переопределяет атрибут System.Reflection.AssemblyNameAttribute, заданный в файле с исходным кодом или добавленном модуле</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>Требуется системный тип "{0}", а в этом типе нет упоминаемой системой библиотеки DLL.</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Используется для обозначения вычислительного выражения, при вычислении которого выдается результат содержащего его вычислительного выражения.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Элемент инфиксного оператора "{0}" имеет лишние переданные аргументы. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Этот элемент не разрешается в реализации интерфейса</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Элемент инфиксного оператора "{0}" имеет {1} начальных аргументов. Ожидался кортеж из 3 аргументов</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>Атрибут FieldOffset может назначаться только членам типов, для которых используется StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Конструктор не может иметь явных параметров типа. Возможно, требуется использовать статический метод.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>У свойства "{0}" предоставленного типа "{1}" CanRead=false, но метод GetGetMethod() вернул метод</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>В запросах для "{0}" следует использовать простой шаблон</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Недопустимый Const_bytearray</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Непредвиденное значение Expr.TyChoose</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Непредвиденный конец входных данных в элементах объекта</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>Метод "{0}" содержит каррированные аргументы, но его имя и сигнатура аналогичны другому методу в типе "{1}". Перегрузка методов с каррированными аргументами не допускается. Рекомендуется использовать метод, принимающий аргументы в форме кортежа.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>В {0} была указана версия "{1}", однако это значение является недопустимым и было проигнорировано</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Тип параметра нельзя использовать в качестве конструктора типа</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Изменяемые переменные не могут обходить собственные методы</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Определения измерений могут иметь только статические элементы</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>Оператор "{0}" обычно не должен быть переопределен. Рекомендуется использовать другое имя оператора</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>В этой точке нельзя использовать значение типа byref "{0}"</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Не удалось найти каталог поиска "{0}".</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Этот конструктор является неоднозначным как часть вычислительного выражения. Вложенные выражения могут записываться с использованием "let _ = (...)", а вложенные вычисления - с использованием "let! res = builder {{ ... }}".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура определяет {2} "{3}", а реализация — нет (или определяет, но не в том же порядке).</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Полное имя</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Вывод сообщений с полными путями</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле {2} присутствует в реализации, но отсутствует в сигнатуре.</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>Не копировать FSharp.Core.dll вместе с созданными двоичными файлами</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>В универсальной конструкции тип "{0}" должен быть неуправляемым</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.Equals". Попробуйте реализовать соответствующее переопределение для "Object.GetHashCode()"</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Явные объявления типа для конструкторов должны иметь форму "ty1 * ... * tyN -&gt; resTy". Вокруг "resTy" могут потребоваться круглые скобки.</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Используется для обозначения того, что функция является рекурсивной.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Используется в сигнатуре для обозначения значения или в типе для объявления члена (в ограниченных ситуациях).</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Используется вместо let для значений, требующих вызова Dispose для освобождения ресурсов.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Используется для введения блока кода, который может создать исключение. Используется вместе с with или finally.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Используется для объявления, определения или вызова конструктора, который создает или может создать объект. Также используется в ограничениях универсальных параметров, чтобы указать, что тип должен иметь определенный конструктор.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Не является ключевым словом. Тем не менее структура not в сочетаниях используется как ограничение универсальных параметров.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Используется для связывания (или привязки) имени со значением или функцией.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Используется в лямбда-выражениях, также известных как анонимные функции.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Используется в циклических конструкциях.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>В определениях и расширениях типов обозначает окончание раздела определений членов. В подробном синтаксисе используется для указания окончания блока кода, который начинается с ключевого слова begin.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Метод получения и метод задания свойства должны относиться к одному типу. Свойство "{0}" имеет метод получения типа "{1}" и метод задания типа "{2}".</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Число аргументов типа не совпадает. Задано: {0}, ожидалось: {1}. Это может быть связано с ошибкой, о которой сообщалось ранее.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Для этого поля требуется имя</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>созданный тип</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Недопустимая строка версии "{0}"</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Аргументы типа не могут быть здесь указаны</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для собственных целых чисел со знаком</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Это нисходящее приведение или проверка типа сотрет предоставленный тип "{0}" до типа "{1}".</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>Объявления "inherit" не могут содержать привязки "as". Для доступа к элементам базового класса при переопределении метода можно использовать синтаксис "base.SomeMember", где "base" -- это ключевое слово. Удалить эту привязку "as".</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Используется для объявления делегата.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Не найден конструктор метода или объекта "{0}"</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Недопустимая ширина спецификатора формата</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>Типы с атрибутом "AllowNullLiteral" могут наследоваться только от типов, поддерживающих пустые литералы, и реализовать только такие типы</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Для статического инициализатора требуется аргумент</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Ошибка синтаксиса - недопустимый символ "?"</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Недопустимое использование интерфейсного типа</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Последовательные шаблоны следует разделять пробелами или включать в кортежи</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>Необходимая сигнатура: "{0}"</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit не был выполнен</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Условия статической оптимизации используются только в библиотеке F#</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Все элементы выражения конструктора массива должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Не удается использовать объявленный параметр типа "{0}", поскольку не удается разрешить его во время выполнения</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>"{0}" не является допустимым именем сборки</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Недопустимое имя для активного шаблона</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>Выражение "if" не содержит ветвь "else". Ветвь "then" включает тип "{0}". Так как "if" является выражением, а не оператором, добавьте ветвь "else", которая возвращает значение того же типа.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Непредвиденный конец входных данных в сигнатуре типа</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Повторяющийся метод. Имя и сигнатура метода "{0}" аналогичны другому методу в типе "{1}".</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Данный метод чрезмерно ограничен в параметрах типа</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Отсутствует переменная "{0}"</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в типах встроенного кода сборки не допускается</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Отраженные определения не могут включать использование оператора соединения префикса "%"</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Единицы измерения нельзя использовать как аргументы-префиксы для типа. Перепишите аргументы-постфиксы в угловых скобках.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>Противоречивые ограничения "struct" и "not struct"</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Этот шаблон литерала не включает аргументы.</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Недопустимый синтаксис объявления</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>Ни один из типов "{0}" не поддерживает оператор "{1}"</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Делегатные типы всегда являются запечатанными</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>После этой точки ожидалось выражение</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>Тип "{0}" является менее доступным, чем значение, элемент или тип "{1}", в которых он используется.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Создать детерминированную сборку (включая GUID версии модуля и метку времени)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>Непредвиденное возвращаемое значение NULL, полученное из элемента "{1}" предоставленного типа "{0}"</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>Не удалось найти Dispose на IDisposable, возможно, оно перегружено.</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Нераспознанный параметр конфиденциальности "{0}" для управляемого ресурса. Допускается использование параметров "public" и "private"</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>Не удалось встроить значение, отмеченное как "inline"</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>В универсальной конструкции требуется использовать тип "{0}", содержащий открытый конструктор по умолчанию</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} не является экземплярным элементом</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Цитаты не могут содержать эту разновидность константы</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Поставщик типов "{0}" использовал недопустимый параметр в выражении ParameterExpression: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>Базовый элемент "{0}" использовался при неоднородном создании экземпляров ранее этой точки программы. Рассмотрите возможность изменения порядка элементов таким образом, чтобы данный элемент следовал первым. Альтернативное решение - задать полный тип элемента в явном виде, включая типы аргументов, тип возвращаемого значения и все дополнительные универсальные параметры и ограничения.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Тип обычно используется для хранения значения типа byref. В общем промежуточном языке это не допускается.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Файлы реализации не указаны</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nВстроенные флаги различаются</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Недопустимое имя пространства имен, типа или ветви объединения</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Сокращения типов не могут иметь элементов</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>Ключевое слово "rec" в этом модуле подразумевается согласно внешнему объявлению "rec" и будет пропущено</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Этот тип не является типом записи. Значения типов класса и структуры должны создаваться, используя вызовы конструкторов объекта.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>Требуется тип, поддерживающий оператор "{0}", однако задан тип функции. Возможно, отсутствует аргумент функции.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Пространство имен не может содержать значений. Рекомендуется использовать модуль для удержания объявлений значений.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Отсутствуют методы Invoke для типа делегата</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Незавершенное условное выражение. Ожидалось "if &lt;выражение&gt; then &lt;выражение&gt;" или "if &lt;выражение&gt; then &lt;выражение&gt; else &lt;выражение&gt;".</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Пользовательскую операцию нельзя использовать в сочетании с операторами use, try/with, try/finally, if/then/else и match в этом выражении с вычислениями</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>Атрибут "StructuralComparison" необходимо использовать в сочетании с атрибутом "StructuralEquality"</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>Недопустимое использование ключевого слова "rec"</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Перечисления не могут содержать элементы</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>Метка записи или пространство имен "{0}" не определены.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>В кавычки нельзя заключать универсальные выражения</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Параметр командной строки "{0}" не рекомендуется к использованию</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Используется в асинхронных рабочих процессах для привязки к результату асинхронного вычисления или (в других вычислительных выражениях) для привязки имени к результату, который имеет тип вычисления.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Вызовы</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>Отсутствует директива #if, соответствующая директиве #else</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Используйте этот параметр, чтобы переопределить место для поиска компилятором библиотеки mscorlib.dll и компонентов инфраструктуры</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число аргументов типа: {1}, однако здесь задано следующее число аргументов: {2}. Необходимая сигнатура: "{3}".</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>{0} "{1}" не найден в сборке "{2}". Это может быть вызвано несовместимостью версий. Вам может потребоваться явно сослаться на правильную версию этой сборки, чтобы ее могли использовать все указанные в ссылке компоненты.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Недопустимый синтаксис в выражении типа</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для целого типа</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>Активный шаблон "{0}" не является функцией</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>Свойство "{0}" типа "{1}" содержит несовпадающие методы получения и задания. Если один из этих методов является абстрактным, второй также должен быть абстрактным.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>В запросах используйте для перебора интервала целых чисел форму "for x in n .. m do ..."</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Конец файла в строке с тройными кавычками, начавшейся здесь или ранее</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Непредвиденный конец входных данных в определении значения, функции или элемента</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>Конструктор объектов "{0}" принимает определенное число аргументов (а именно: {1}), но здесь ему предоставлено {2}. Требуется сигнатура "{3}". Если некоторые аргументы предполагают назначение значений свойствам, рекомендуется отделить их запятой (",").</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>"{0}" следует применять только к аргументу типа "{1}", но он был применен к аргументу типа "{2}"</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Не удается создать расширение запечатанного типа</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Отсутствует маркер "in", соответствующий этому маркеру "let"</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Атрибут видимости "{0}" запрещен в сокращенной форме модуля. В сокращенных формах модуля всегда используются закрытые атрибуты.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>Тип с атрибутом "NoComparison" обычно не должен содержать явную реализацию интерфейсов "System.IComparable", "System.IComparable&lt;_&gt;" или "System.Collections.IStructuralComparable". Если эта операция выполняется в целях обеспечения совместимости, отключите это предупреждение</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Данный конструктор может быть использован только в вычислительных выражениях Для возврата значения из обычной функции просто напишите выражение без "return".</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Определения свойств не могут объявляться как изменяемые. Чтобы показать, что свойство можно задавать, используйте конструкцию "member val PropertyName = expr with get,set".</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- ДОПОЛНИТЕЛЬНО -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "static" различаются</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>откомпилированная форма ветви объединения</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Сбой при разрешении сборки в этой или близлежащих строках</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как порядок полей в сигнатуре и реализации различается.</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Использование абстрактных элементов в приращении не допускается; такие элементы должны быть определены непосредственно в самом типе</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Непредвиденный конец входных данных в ветви then условного выражения. Ожидалось "if &lt;выражение&gt; then &lt;выражение&gt;" или "if &lt;выражение&gt; then &lt;выражение&gt; else &lt;выражение&gt;".</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении "match" или "try"</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Непредвиденный конец входных данных в ветви else условного выражения. Ожидалось "if &lt;выражение&gt; then &lt;выражение&gt;" или "if &lt;выражение&gt; then &lt;выражение&gt; else &lt;выражение&gt;".</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Невозможно предоставить аргументы при формировании значения записи.</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>Идентификаторы, содержащие "@", зарезервированы для будущего использования при создании кода на языке F#</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Данный поиск не может быть использован здесь.</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Элементы, расширяющие типы интерфейса, делегатов или перечисления, должны помещаться в отдельном от определения типа модуле. Данный модуль должен либо иметь атрибут AutoOpen, либо открываться явно клиентским кодом для запуска элементов расширения в области.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Реализации интерфейса не могут быть даны в выражениях конструкций</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Этот код является недостаточно базовым Переменная типа {0} не может быть обобщена, так как тогда она выйдет за пределы области.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>Конец файла в разделе IF-OCAML начался в этой позиции или до нее</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>Атрибут "AbstractClass" может присваиваться только классам</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>В языке F# System.Void можно использовать только в виде typeof&lt;System.Void&gt;</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>Синтаксис "(typ,...,typ) ident" не используется в коде F#. Вместо этого рекомендуется использовать синтаксис "ident&lt;typ,...,typ&gt;"</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Типы структуры не могут содержать абстрактных элементов</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Этот новый элемент скрывает абстрактный элемент "{0}" после удаления кортежей, функций, единиц измерения и предоставляемых типов. Переименуйте элемент или используйте override.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Недопустимое декодирование атрибута InterfaceDataVersionAttribute</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Токены "|", разделяющие правила этого сопоставления шаблону, неправильно выровнены по одному столбцу. Рекомендуется выровнять код или увеличить отступ.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nАрность не была выведена для этого значения</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Недопустимая спецификация свойства уровня источника в синтаксическом дереве</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Посторонние поля получили значения</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Используется для преобразования в тип, который находится ниже в цепочке наследования.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nНеобходимо указать тип кортежа для одного аргумента (или нескольких). Рекомендуется заключить эти аргументы в дополнительные скобки или проверить определение интерфейса.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Недопустимая большая рациональная константа</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Неправильный формат изображения</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>У поставщика типов "{0}" обнаружено пустое пространство имен. Используйте null для глобального пространства имен.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nИмена различаются</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>Переменная {0} в коллекции {1} (outerKey = innerKey). Обратите внимание, что после "{2}" нужны круглые скобки</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>Ожидалось "in" или "="</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Недопустимое декодирование атрибута InternalsVisibleToAttribute</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Неполное выражение препроцессора</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: инерционность</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>Прямые ссылки на создаваемый тип "{0}" запрещены. Вместо этого следует использовать определение типа, напр. "type TypeAlias = &lt;path&gt;". Оно показывает, что поставщик типов добавляет создаваемые типы в сборку.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Синтаксическая ошибка. Неправильный вложенный #endif; недопустимые лексемы перед ним.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Включить конкретные предупреждения, которые по умолчанию могут быть отключенными</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} является активным шаблоном и не может обрабатываться как различаемая ветвь объединения с именованными полями.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Типы записей всегда являются запечатанными</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Недопустимая сигнатура для элемента множества</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>В запросах нельзя использовать выражения while</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Не является допустимым символьным литералом.</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Значения возврата не могут иметь имен</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Невозможно наследование от удаленного предоставленного типа</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>Поставщик "{0}" вернул несоздаваемый тип "{1}" в контексте набора создаваемых типов. Попробуйте изменить поставщик типов, чтобы он возвращал только создаваемые типы.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>Ограничение "enum" должно иметь форму "enum&lt;type&gt;"</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является абстрактным, другой - нет</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>Имя "({0})" не может использоваться в качестве имени элемента. Чтобы определить для типа семантику равенства, переопределите элемент "Object.Equals". При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для десятичных литералов</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Слишком много статических параметров. Ожидалось не более {0} параметров, однако было получено {1} неименованных и {2} именованных параметров.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>После объявления "namespace" отсутствует символ "="</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>Типы System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate и System.Array не могут использоваться в качестве супертипа в выражении объекта или классе объекта</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Этот файл содержит несколько объявлений вида "module SomeNamespace.SomeModule". В одном файле может присутствовать только одно объявление такого вида. Измените файл, объявив в нем исходное пространство имен или определив модули с помощью объявления "module ModuleName = ...".</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Не удается реализовать наследование от типа интерфейса. Вместо этого используйте выражение "interface ... with".</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Включение или отключение межмодульной оптимизации</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nдоступность, заданная в сигнатуре, шире указанной в реализации</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Используется в выражениях запроса для указания полей или столбцов для извлечения. Обратите внимание, что это контекстно-зависимое ключевое слово, то есть фактически оно не является зарезервированным словом и функционирует как ключевое слово только в соответствующем контексте.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>В этой точке нельзя использовать адрес поля "{0}"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "unmanaged" в этой позиции или рядом с ней</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Определение этого типа не может содержать атрибута CLIMutable. Этот атрибут можно использовать только в типах записей.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 64-битных целых чисел со знаком</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в полях перечисления не допускается</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как количества {2} различаются.</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Недопустимое расширение типа</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Ошибка в имени файла "{0}": {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>Для директивы #else требуется директива #endif</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Используется для объявления типа структуры. Также используется в ограничениях универсальных параметров. Используется для обеспечения совместимости с OCaml в определениях модулей.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Используется для обозначения метода или свойства, которые могут вызываться без экземпляра типа, или члена значения, общего для всех экземпляров типа.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>Атрибут "EntryPointAttribute" может использоваться только в определениях функций в модулях</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Значение по умолчанию и аргумент имеют разные типы. Атрибут DefaultParameterValue и любые атрибуты Optional будут игнорироваться. Примечание: null необходимо аннотировать правильным типом, например DefaultParameterValue(null:obj).</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Недопустимое создание универсального экземпляра. Отсутствует элемент "{0}" с именем "{1}", принимающий универсальные аргументы {2}.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Пространства имен не могут содержать элементы расширения, кроме элементов в том же файле и группе объявлений пространства имен, где определен тип. Рекомендуется использовать модуль для объявлений элементов расширения.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Используется для указания значения, предоставляемого как результат вычислительного выражения.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>Значение "{0}" недоступно из данного расположения в коде</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Недопустимый отступ токена "in" по отношению к соответствующему токену "let"</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Требуемый здесь тип "{0}" недоступен. Следует добавить ссылку на сборку "{1}".</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>Оператор "{0}" не принимает использование into</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} не является статическим элементом</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Использование анонимных переменных типа в этом объявлении не допускается</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Данная запись содержит поля из несогласованных типов</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>Привязки let и do должны располагаться до определений элементов и интерфейсов в определениях типов</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Директивы внутри модулей пропущены</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 16-битных целых чисел со знаком</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>Неполадка с кодовой страницей "{0}": {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Выражения атрибутов должны вызывать конструкторы объектов</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Конструктору делегата необходимо передать отдельное значение функции</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Для индексатора требуется аргумент {0}, однако задан аргумент {1}</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>Для соблюдения требований к типу контекста в выражении "if" должен использоваться тип "{0}". Сейчас используется тип "{1}".</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Не допускается присваивание атрибута "Sealed" сокращенным типам</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>Включить оптимизацию (краткая форма: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Это переопределение передает другое число аргументов соответствующему абстрактному элементу. Найдены следующие абстрактные элементы: {0}.</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Несогласованный "["</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Значение литерала нельзя пометить как "inline"</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>Атрибут "NoEquality" необходимо использовать в сочетании с атрибутом "NoComparison"</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, требующие использования указателей byref</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Недопустимый / в типе</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Типы кодов сборок всегда являются запечатанными</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Не указаны входные данные</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Ненулевые константы не могут иметь базовых единиц. Для базового нуля введите 0.0&lt;_&gt;.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Недопустимый метод получения или задания свойства</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура объявляет {2}, а реализация — {3}.</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>Не допускается использовать символ "{0}" в указанном имени пространства имен "{1}"</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Недопустимая директива. Требуется ''#I \"&lt;путь&gt;\"''.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 32-битных целых чисел без знака</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>Имя свойства "{0}" аналогично имени метода в типе "{1}".</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>событие</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>поле</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Рекурсивно определяемые значения не могут использоваться непосредственно в составе конструкции или значения кортежа внутри рекурсивной привязки</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Параметр командной строки "{0}" не рекомендуется к использованию. Функции создания документа HTML теперь реализуются с помощью средства из состава пакета F# Power Pack.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>Использование атрибутов для привязок "let" в выражениях не допускается</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nСоответствующие количества параметров типов различаются</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Данный элемент является недостаточно базовым</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Используется в качестве логического литерала.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>В кавычки нельзя заключать нисходящие циклы for</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Базовый адрес библиотеки, для которой будет выполнена сборка</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Проблема при чтении сборки "{0}": {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>Предоставленный тип "{0}" вернул элемент с NULL</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>Обнаружена ссылка на тип "{0}" в сборке "{1}", который отсутствует в этой сборке</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Был использован базовый параметр типа таким образом, что он всегда ограничен до "{0}"</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин помечен как "override", другой - нет</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>Требуется {0} выражений, получено {1}</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>В одном объявленном параметре типа или нескольких для этого расширения типа отсутствует ограничение типа или содержится неверное ограничение типа, не совпадающее с исходными ограничениями типа для "{0}"</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>Как минимум в одном переопределении неправильно реализован соответствующий абстрактный элемент</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Атрибут AssemblyVersionAttribute был проигнорирован, поскольку версия задана с помощью параметра командной строки</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>Атрибут "DefaultValue" может использоваться только в объявлениях "val"</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Типы структур всегда являются запечатанными</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Типы не могут наследовать от множественных конкретных типов</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Недопустимые аргументы типа</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как в сигнатуре указано, что тип поддерживает интерфейс {2}, который не реализован.</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- ФОРМИРОВАНИЕ КОДА -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Недопустимый Const_uint16array</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>Элемент "{0}" используется недопустимо. Использование "{1}" было логически выведено перед определением "{2}", что является недопустимой короткой ссылкой.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>является</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Данный атрибут не может быть использован в этой версии F#</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Использование атрибутов внутри шаблонов не допускается</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Невозможно переопределить унаследованный элемент "{0}", поскольку он является запечатанным</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Этот тип не имеет вложенных типов</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Имя файла "{0}" содержит недопустимый символ "{1}"</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>Поле, конструктор или элемент "{0}" не определены.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>Условия [&lt;ReflectedDefinition&gt;] не могут включать использование оператора соединения префикса "%"</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Несоответствие длины создаваемого экземпляра типа</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Свойство метода присваивания значения может иметь не более двух групп аргументов</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Отключить указанные предупреждения</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Запрещает отображение сообщения компилятора об авторских правах</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>Тип "{0}" был помечен как имеющий явно заданный макет, но поле "{1}" не было помечено атрибутом FieldOffset</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nТипы различаются</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>Использование операторов expression-splicing в первом классе не допускается</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Это нисходящее приведение типа сотрет предоставленный тип "{0}" до типа "{1}".</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>Тип {0} содержит элемент "{1}", но не является виртуальным или абстрактным методом, доступным для переопределения или реализации.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>Атрибут "{0}" присутствует как в реализации, так и в сигнатуре, но с разными аргументами. В скомпилированный код будет включен только атрибут из сигнатуры.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>Не удается разрешить оператор "{0}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Нераспознанный параметр: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>расширение</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку поле "{0}" присутствует в реализации, но не в сигнатуре. Модуль содержит определение исключения\n    {1}    \nоднако его сигнатура задает\n\t{2}.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>Тип "{0}" содержит метод "{1}" (полное имя "{2}"), не являющийся статическим</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>Вызовы "reraise" могут выполняться только непосредственно из обработчика блока try-with</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Перечисляемые типы всегда являются запечатанными</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Типы аргументов не совпадают</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Использовать "l" или "L" в этом спецификаторе формата необязательно. В коде F# можно использовать %d, %x, %o или %u, которые перегружаются и поддерживают работу со всеми базовыми целочисленными типами.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Разрешает доступ к члену из-за пределов типа.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>NULL не является собственным значением типа "{0}". Чтобы создать значение NULL для типа, допускающего это значение, используйте структуру System.Nullable().</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Рекурсивное значение ValValue {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>Тип "{0}" является недопустимым, поскольку в byref&lt;T&gt; T не может содержать типы byref.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Определить символы условной компиляции (краткая форма: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>Использование атрибутов в объявлениях "inherit" не допускается</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>У свойства "{0}" предоставленного типа "{1}" CanWrite=true, однако значение GetSetMethod() не получено</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Определения исключений несовместимы из-за различий в объявлениях исключений. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>Ресурс FSharp.Core.sigdata не найден вместе с FSharp.Core. Файл ожидался в {0}. Рекомендуется обновление до более новой версии FSharp.Core, где этот файл не требуется.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Ожидается однострочный комментарий или конец строки</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Поставщик типов вернул значение NULL, которое не является допустимым возвращаемым значением для "{0}"</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>Сразу после директивы #if необходимо указать идентификатор</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>Для "{0}" не было дано реализации. Обратите внимание на то, что все элементы интерфейса должны быть реализованы и перечислены в соответствующем объявлении "interface", например "interface ... with member ...".</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Блок, следующий за блоком "{0}", не закончен. Каждый блок кода является выражением и должен иметь результат. "{1}" не может быть заключительным элементом кода в блоке. Рекомендуется предоставить для этого блока явный результат.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении while. Ожидалось "while &lt;выражение&gt; do &lt;выражение&gt;".</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Определения измерений не могут иметь параметры типа</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>Чтобы использовать библиотеку DLL "{0}", скомпилированную на языке F#, в этой версии F#, необходимо перекомпилировать ее</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>Непредвиденный конец входных данных в выражении match. Ожидалось "match &lt;выражение&gt; with | &lt;шаблон&gt; -&gt; &lt;выражение&gt; | &lt;шаблон&gt; -&gt; &lt;выражение&gt; ...".</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Типы интерфейсов и типы делегатов не могут содержать поля</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>Расширения файлов ".ml" и ".mli" предназначены для многоязыковой совместимости</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>пространство имен</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}. Необходимая сигнатура: "{2}".</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Определения измерений могут иметь только статические элементы: конструкторы недоступны</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Интерфейсы не могут содержать определения статических инициализаторов</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Использование внутренних универсальных функций в выражениях в кавычках не допускается. Рекомендуется добавить ограничения типа, чтобы функция более не являлась универсальной.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Неизвестный аргумент --test: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Слишком сложная проблема определения типа (достигнута максимальная глубина итераций). Рекомендуется добавить дополнительные аннотации типов.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>Значение, пространство имен, тип или модуль "{0}" не определены.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nСоответствующие количества полей данных различаются</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Структуры не могут содержать привязок "do", так как конструктор по умолчанию для структур не будет выполнять эти привязки</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Используется для преобразования в тип, который находится выше в цепочке наследования.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>Переменная {0} из коллекции {1} (outerKey = innerKey) в группе. Обратите внимание, что после "{2}" нужны круглые скобки</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Конструктор нулевой инициализации типа структуры по умолчанию может использоваться только в случае, если все поля типа структуры допускают инициализацию по умолчанию.</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Базовые типы не могут получать атрибут "StructLayout"</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Конструктор явного объекта должен использовать синтаксис "new(args) = expr"</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Отделяет нетипизированную цитату кода.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Структуры не могут содержать определений значений, так как конструктор по умолчанию для структур не будет выполнять эти привязки. Попробуйте добавить к первичному конструктору для типа дополнительные аргументы.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 8-битных целых чисел со знаком</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>Недопустимый элемент "{0}" предоставленного типа "{1}". Разрешены только свойства, методы и конструкторы</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>Нет назначения для поля "{0}" типа "{1}"</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>Тип "{0}" не поддерживает оператор "{1}"</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>В этой точке нельзя использовать адрес статического поля "{0}"</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Это объявление открывает пространство имен или модуль "{0}" через частичный путь. Измените этот код для использования полного пути пространства имен. Данное изменение обеспечит надежность кода при добавлении новых конструкций в библиотеки F# и CLI.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>"do!" нельзя использовать в выражениях последовательности</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>Реализация файла или модуля "{0}" уже задана. В связи с использованием определения типа в F# имеет значение порядок компиляции. Перед выполнением реализации может потребоваться изменение порядка для размещения файла сигнатур. В среде Visual Studio файлы проверяются на типы в том порядке, в котором они отображаются в файле проекта, который можно изменить вручную или с помощью обозревателя решений.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>недопустимое пространство имен для предоставленного типа</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Определение данного типа включает циклическую ссылку верхнего уровня через поле структуры или отношение наследования</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Данное значение не является литералом и не может использоваться в шаблоне</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Каждый аргумент первичного конструктора для структуры должен получить тип, например "type S(x1:int, x2: int) = ...". Эти аргументы определяют поля структуры.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Изменяемые значения не могут иметь базовых параметров</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Не удалось разрешить неоднозначность в использовании базовой конструкции с ограничением "delegate" в этой позиции или рядом с ней</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Спецификации делегатов должны иметь форму "typ -&gt; typ"</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>Атрибут ReflectedDefinitionAttribute не может применяться к элементам экземпляров типа struct, поскольку элемент экземпляра принимает неявный параметр this byref</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>Требуется "get" и (или) "set"</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>"{0}" не поддерживает флаг префикса "{1}"</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Данный параметр типа был использован так, что был ограничен до постоянного значения "{0}"</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Именованные аргументы не могут применяться к вызовам свойств элемента</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Указанная версия платформы .NET Framework ("{0}") не поддерживается. Укажите значение из перечисления Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Определение может являться только атрибутом [&lt;Literal&gt;], если также указано постоянное значение, напр. "val x : int = 1"</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Нераспознанное расширение файла "{0}". Исходные файлы должны иметь расширения .fs, .fsi, .fsx, .fsscript, .ml или .mli..</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Данное объявление "inherit" указывает унаследованный тип, и не указывает аргументов. Рекомендуется предоставить аргументы, напр. "inherit BaseType(args)".</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Имя выходного файла отладки</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Укажите каталог для поиска включаемых файлов, который будет использоваться для разрешения исходных файлов и сборок (краткая форма: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Печатать выведенный интерфейс сборки в файл</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Сборка модуля, который может быть добавлен в другую сборку</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>Символ "|" запрещено использовать в идентификаторах вариантов активного шаблона</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Использование модификаторов доступности для этого элемента не допускается. Видимость абстрактных слотов всегда соответствует видимости включающего их типа.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Символ ";" используется для разделения значений поля в записях. Рекомендуется заменить "," на ";".</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>Не удалось разрешить неоднозначность, унаследованную в использовании оператора "{0}" в данной точке программы или рядом с ней. Рекомендуется использовать аннотации типа для решения неоднозначности.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>Тип "{0}" не определен.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Используется для обозначения функции, которая должна быть интегрирована непосредственно в код вызывающего объекта.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Недопустимое имя для случая перечисления</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Для данного элемента экземпляра требуется параметр для представления вызываемого объекта. Сделайте элемент статическим, или же используйте нотацию "member x.Member(args) = ...".</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>Имя "{0}" не имеет статических параметров</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>Тип с атрибутом "NoEquality" обычно не должен содержать явную реализацию метода "Object.Equals(obj)". Если эта операция выполняется в целях обеспечения совместимости, отключите это предупреждение</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Значение было скопировано, чтобы не допустить изменения исходного значения этой операцией, или так как копирование выполняется неявно при возвращении структуры из члена и последующего получения доступа к другому члену</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Один или несколько явных классов или переменных типов функций для данной привязки не могут быть обобщены, так как они были ограничены на другие типы.</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Кандидаты: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Несоответствующий или неправильно отформатированный блок "with"</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Все элементы выражения конструктора списка должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Явные спецификации типа не могут быть использованы для конструкторов исключений</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Тип записи для поля записи "{0}" определен с RequireQualifiedAccessAttribute. Включите имя типа записи ("{1}") в используемое имя.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>Соответствующий формат аргумента не является необязательным.</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Недопустимое значение</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>Значение "{0}" не используется</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Требуется параметр: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Недопустимое объявление</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для собственных целых чисел без знака</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>Дискриминатор шаблона "{0}" не определен.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Непредвиденный конец входных данных</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>Два модуля с именем "{0}" встречаются в двух частях этой сборки</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Обнаружено более одного метода Invoke для типа делегата</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Это значение не является функцией, и применить его невозможно. Вы хотели обратиться к индексатору с помощью конструкции {0}.[индекс]?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>Предполагается, что параметр "{0}" имеет тип byref. Параметры типа byref должны сопровождаться явной аннотацией типа, например "x1: byref&lt;int&gt;". При использовании параметра byref происходит неявное разыменование ссылки.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Данный статический элемент не должен иметь параметр "this". Рекомендуется использовать нотацию "member Member(args) = ...".</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>В универсальной конструкции требуется использовать неабстрактный тип "{0}"</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Включать только данные оптимизации, необходимые для реализации встроенных конструкций. Отключение межмодульного встраивания и повышение совместимости на уровне двоичного кода.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>Представление этого типа скрыто сигнатурой. Для него должен быть получен атрибут, такой, как [&lt;Sealed&gt;], [&lt;Class&gt;] или [&lt;Interface&gt;], для указания характеристики типа.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>"{0}" не поддерживает флаг "0"</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Определение типа привело к выходу за пределы области переменной типа {0}. Попробуйте добавить явное объявление параметра типа или скорректировать код таким образом, чтобы он был менее универсальным.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Укажите тип отладки: full, portable, embedded, pdbonly (если тип отладки не указан, по умолчанию используется тип "{0}", позволяющий подключить отладчик к выполняющейся программе; тип portable представляет собой кроссплатформенный формат; тип embedded — кроссплатформенный формат, встроенный в выходной файл).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>Перед первым объявлением "namespace" можно указывать только директивы компилятора "#"</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>В процессе оптимизации не найдено локальное значение {0}</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Поставщик типов "{0}" предоставил метод с именем "{1}" и токеном метаданных "{2}", который отсутствует в списке методов соответствующего объявляющего типа "{3}"</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>Неверный синтаксис для "{0}". Использование: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Недопустимое число с плавающей точкой</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Не допускается использование конструкторов в качестве элементов расширений — они должны быть определены в рамках исходного определения типа.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Конструктор объектов "{0}" не содержит аргумент или задаваемое возвращаемое свойство "{1}". {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>Платформу anycpu32bitpreferred можно использовать только с целевыми файлами EXE. Вместо этого необходимо использовать платформу anycpu.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nИмена различаются</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является статическим, другой - нет</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как тип реализации не запечатан, а сигнатура неявно предполагает это. Попробуйте добавить атрибут [&lt;Sealed&gt;] в реализацию.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>''try''/''with'' не могут использоваться внутри (within) выражений последовательностей</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как абстрактный элемент "{2}" присутствует в реализации, но отсутствует в сигнатуре.</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" содержит явную реализацию "Object.GetHashCode". Попробуйте реализовать соответствующее переопределение для "Object.Equals(obj)"</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Используется для объявления свойства или метода в типе объекта.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Используется для связывания имени с группой соответствующих типов, значений и функций для логического отделения их от других частей кода.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nТипы различаются</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как соответствующие количества параметров типов различаются.</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Спецификации делегатов не должны являться переданными типами. Используйте "typ * ... * typ -&gt; typ" для мульти-аргументных делегатов, и "typ -&gt; (typ -&gt; typ)" для делегатов, возвращающих значения функций.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>Значение "{0}" отмечено как "inline", однако в его реализации используется недостаточно доступная внутренняя или закрытая функция</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>Свойство "{0}" не является статическим</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Недопустимое выражение объекта, последовательности или записи</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Параметры типа, логически выведенные для данного значения, нестабильны при удалении сокращений типов. Это происходит из-за использования сокращений типов, которые удаляют или реорганизуют параметры типа, напр. \n\ttype taggedInt&lt;'a&gt; = int or\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nРекомендуется явно объявить параметры типа для данного значения, напр.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IStructuralComparable". Необходимо применить к типу атрибут "CustomComparison".</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Синтаксическая ошибка</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>Недопустимое отношение соединения в "{0}". Ожидалось "expr &lt;оператор&gt; expr", где в качестве &lt;оператор&gt; может использоваться =, =?, ?= или ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Привязка поля должна иметь вид "id = expr;"</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>Событие "{0}" не является статическим</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>Переменная {0} в коллекции</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Используется в выражении последовательности для получения значения для последовательности.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>В запросах нельзя использовать выражения try/finally</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Рекомендуется создавать объекты, поддерживающие интерфейс IDisposable с помощью "new Type(args)", а не "Type(args)" или "Type" в качестве значения функции, представляющего конструктор; это делается для того, чтобы указать, что ресурсы могут принадлежать созданному значению.</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Значение литерала нельзя пометить как "mutable"</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Вводит циклическую конструкцию.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} не является статическим методом</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Использование атрибутов в реализациях интерфейса не допускается</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Данная форма выражения может использоваться только в выражениях последовательности и вычислений.</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, извлекающие индексы вариантов объединения</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>В подробном синтаксисе обозначает начало определения класса.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>В подробном синтаксисе обозначает начало блока кода.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Вызовам конструкторов объектов на параметрах типа нельзя присваивать аргументы</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Используется для ветвления путем сравнения значения с шаблоном.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>Недопустимое условие в импортированной сборке: не удалось декодировать атрибут AttributeUsage</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Данный случай объединения не принимает аргументов</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>Используется для ссылки на пространство имен .NET верхнего уровня.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Конструкция данного элемента управления может использоваться только в том случае, если построитель вычислительного выражения определяет метод "{0}"</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>Далее неявный результат измерений /</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Недопустимое предоставляемое поле. Предоставляемые поля удаленных предоставляемых типов должны быть литералами.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Это неизвестный оператора запроса. Операторы запросов представляют собой идентификаторы, такие как select, where, sortBy, thenBy, groupBy, groupValBy, join, groupJoin,sumBy и averageBy, определяемые с помощью соответствующих методов типа QueryBuilder.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Единицы измерения поддерживаются только с типами float, float32, decimal и signed integer</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>Поле "{0}" не является статическим</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>В начале файла необходимо указывать либо пространство имен либо объявление модуля, например "namespace SomeNamespace.SubNamespace" или "module SomeNamespace.SomeModule". Чтобы определить модуль внутри пространства имен, используйте синтаксис "module SomeModule = ..."</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>Сигнатура этой внешней функции содержит параметры типа. Ограничьте типы аргументов и возвращаемых значений, чтобы обозначить типы соответствующих функций C.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Все ветви выражения сопоставления шаблона должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>Метод "{0}" запечатан и не может быть переопределен</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Несогласованный "{0}".</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Это не переменная, константа, активный распознаватель или литерал</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>Значение для поля "{0}" было задано, но не представлено в типе "{1}"</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Цитаты не могут содержать выражения, извлекающие статические поля</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Статические определения значений можно использовать только в типах с первичными конструкторами. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Не удается найти целевой код для этого атрибута; возможно, это вызвано тем, что код после атрибута незавершен.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Недопустимое имя модуля или пространства имен</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>пользовательская операция</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Используется для проверки кода во время отладки.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Объявления, содержащиеся в этом файле, будут помещены в неявный модуль "{0}" на основе имени файла "{1}". Тем не менее, поскольку этот идентификатор не является допустимым идентификатором F#, содержимое будет недоступно из других файлов. Рекомендуется переименовать файл либо добавить объявление "module" или "namespace" в начало файла.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Не удалось открыть файл ключей "{0}"</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>В кавычки нельзя заключать сопоставления шаблонов массивов</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Один тип кортежа является кортежем структуры, другой — эталонным кортежем</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число дополнительных аргументов: {1}. Необходимая сигнатура: "{2}". Некоторые имена отсутствующих аргументов: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число аргументов: {1}. Необходимая сигнатура: "{2}". Некоторые имена отсутствующих аргументов: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Для конструктора элемента или объекта "{0}" требуется следующее число дополнительных аргументов: {1}. Необходимая сигнатура: "{2}".</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово "let!".</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Ожидался аргумент типа или статический аргумент</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Указаны противоречащие друг другу параметры: win32manifest и win32res. Можно использовать только один из них.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Повторяющееся свойство. Имя и сигнатура свойства "{0}" аналогичны другому свойству в типе "{1}".</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Укажите предпочитаемое имя языка и региональных параметров (например, es-ES, ja-JP)</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>В выражениях последовательности результаты создаются с помощью "yield"</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Укажите файл ключей строгого имени</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Недопустимый идентификатор: '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Недопустимый номер строки: '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>Использование дополнительных аргументов не допускается</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Экспериментальная конструкция</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>Использование приращений для типа делегата moduleDefns не допускается</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>"{0}" не является действительным целочисленным аргументом</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>При явной ссылке на mscorlib.dll или FSharp.Core.dll также должен передаваться параметр {0}</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Аннотации типов для методов получения или задания свойства необходимо указывать после выражений "get()" или "set(v)", например, "with get() : string = ..."</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Выполнить сборку исполняемого файла Windows</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Имя выходного файла (краткая форма: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>Параметр --sourcelink поддерживается только при создании переносимого PDB-файла (--debug:portable или --debug:embedded).</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>Атрибут CallerMemberNameAttribute, примененный для параметра "{0}", не будет действовать. Он будет переопределен атрибутом CallerFilePathAttribute.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Именованные статические аргументы должны располагаться после неименованных статических аргументов</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Собрать консольный исполняемый файл</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>В исходном объявлении типа должны быть объявлены все реализованные интерфейсы</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Недопустимая спецификация свойства уровня источника</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Не удается вызвать абстрактный член базового класса: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>Атрибут "ConditionalAttribute" может использоваться только с элементами</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>Тип с атрибутом "CustomComparison" должен как минимум содержать явную реализацию интерфейса "System.IComparable" или "System.Collections.IStructuralComparable"</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИмена элементов CLI различаются</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Метод, реализованный этим вариантом по умолчанию, является неоднозначным</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F# поддерживает массивы рангом от 1 до 32. Значение {0} не допускается.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Цитаты не могут содержать эту разновидность типа</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>В выражениях объектов могут указываться только переопределения абстрактных и виртуальных элементов</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Запись xmldoc сборки в заданный файл</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле "{2}" присутствует в реализации, но отсутствует в сигнатуре. Типы-структуры теперь должны показывать свои поля в сигнатуре для типа, несмотря на то что поля по-прежнему могут помечаться как private или internal.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>Случай объединения "{0}" недоступен из данного расположения в коде</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Атрибуты "ReferenceEquality", "StructuralEquality" и "StructuralComparison" можно использовать только для приращения типов записи, объединения, исключения и структуры</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Недопустимый размер сигнатуры</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Задать файл манифеста Win32</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Недопустимое выражение индексатора</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Имя типа не может быть пустым.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Исходный файл "{0}" не найден</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Требуется модуль или родительский элемент пространства имен {0}</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Только простые привязки вида "id = expr" могут использоваться в выражениях конструкции</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Указывает, что объявленный элемент программы определяется в другом двоичном файле или сборке.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Файл со сведениями о компоновке источников, внедряемый в переносимый PDB-файл</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>"new" может использоваться только с конструкторами объектов</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Этот код является менее универсальным, чем указано в соответствующих аннотациях. Значение единицы измерения, заданной с помощью знака "_", определено как "1" (безразмерная). Рекомендуется сделать код универсальным или удалить знак "_".</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Недопустимое выражение литерала. Атрибут [&lt;Literal&gt;] будет пропущен.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сигнатура (в отличие от реализации) определяет, что этот тип может использовать значение NULL в качестве дополнительного значения.</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>В запросах нельзя использовать выражения try/with</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>Статическая компоновка библиотеки F# и всех зависимых от нее библиотек DLL, на которые существуют ссылки, в создаваемую сборку</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>Атрибут "AutoOpen(\"{0}\")" в сборке "{1}" пропущен, поскольку он не ссылается на допустимые модуль или пространство имен в этой сборке</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Это поле не является изменяемым</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как типы принадлежат разным разновидностям.</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Перечисления не могут содержать объявления элементов</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Собрать библиотеку (краткая форма: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>Не удалось разрешить сборку "{0}".</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>Конструктор элементов или объектов "{0}", принимающий следующее число аргументов: {1}, недоступен из этой точки кода. Все доступные версии метода "{2}" принимают следующее число аргументов: {3}.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>Краткая форма "{0}"</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Реализация по умолчанию для данного интерфейса уже была добавлена, так как в определении типа не была указана явная реализация интерфейса</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Именованное поле "{0}" используется более одного раза.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Детерминированные сборки поддерживают только переносимые PDB-файлы (--debug:portable или --debug:embedded)</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Недопустимое выражение объекта. Объекты без переопределений или интерфейсов должны использовать форму выражения "new Type(args)" без фигурных скобок.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>из {0}</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>В выражении for используется для счета в обратном порядке.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Этот тип не является типом записи</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, используемые для получения адреса поля</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" явно реализует интерфейс "System.IComparable". Необходимо применить к типу атрибут "CustomComparison".</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>В запросах нельзя использовать выражения if/then/else. Попробуйте использовать выражение if/then или используйте вместо этого выражение последовательности.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>Для статического параметра "{0}" уже было задано значение</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Внедрить конкретные исходные файлы в переносимый PDB-файл</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>Недопустимый способ использования переменной "{0}" типа byref. Переменные типа byref нельзя зафиксировать с помощью замкнутых выражений или передать во внутренние функции.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>Нельзя задать свойство "{0}".</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Это свойство задать нельзя</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Использование операторов address-of в первом классе не допускается</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является конструктором или свойством, другой - нет</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Выражения конструкции объекта могут использоваться только для реализации конструкторов в типах классов</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку поле "{0}" требуется в сигнатуре, но не задано в реализации. Модуль содержит определение исключения\n    {1}    \nоднако его сигнатура задает\n\t{2}.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Данный числовой литерал требует наличия в области модуля "{0}" определяющих функций FromZero, FromOne, FromInt32, FromInt64 и FromString</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Для данного типа не удается определить конструкторы</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как поле {2} является обязательным в сигнатуре, но не указано в реализации.</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>Необязательные аргументы разрешены только в элементах типов</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>В ссылке на предоставленный тип отсутствовало значение статического параметра "{0}". Может потребоваться перекомпилировать одну или более сборок, на которые указывают ссылки.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Все ветви выражения "if" должны иметь один и тот же тип. В этом выражении ожидалось использование типа "{0}", но используется тип "{1}".</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Стерт до</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Для данного значения, типа или метода требуется {0} параметров типа, но получено {1}</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку отличается порядок полей в сигнатуре и реализации. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Пользовательскую операцию нельзя использовать в сочетании c не содержащей значения или рекурсивной привязкой let в другой части этого выражения с вычислениями</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Элемент "{0}" не имеет нужного числа параметров типа метода. Необходимая сигнатура: "{1}".</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представление типа CLI скрывается сигнатурой.</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralComparison", но параметр типа "{1}" не удовлетворяет ограничению "comparison". Рекомендуется добавить к параметру типа ограничение "comparison"</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Тип структуры, записи или объединения "{0}" имеет атрибут "StructuralComparison", но тип компонента "{1}" не удовлетворяет ограничению "comparison"</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>В этой точке нельзя использовать адрес переменной "{0}"</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>ветвь объединения</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Глобальный кэш сборок</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Повторяющийся или избыточный интерфейс</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Недопустимый файл ответов "{0}" ("{1}")</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>Привязки "use!" должны иметь форму "use! &lt;переменная&gt; = &lt;выражение&gt;"</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представление типа скрывается сигнатурой.</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Недопустимая запись, выражение последовательности или вычислительное выражение. Выражения последовательностей должны иметь форму "seq {{ ... }}'</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>Событие "{0}" предоставленного типа "{1}" не имеет значения, полученного от метода GetAddMethod()</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Используется для объявления и реализации интерфейсов.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является элементом расширения, другой - нет</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Для определения методов присваивания свойств необходимо использовать синтаксис "set value = ", "set idx value = " или "set (idx1,...,idxN) value = ... '</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Недопустимый аргумент в параметризованной метке шаблона</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Недопустимая длина в битах</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>Перед директивами #if могут находиться только знаки пробела</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>Имя "{0}" имеет несколько статических параметров</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Временные поля должны быть помечены как "mutable"; они также не могут быть потокостатическими</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Типы возвращаемых значений случаев объединений должны быть идентичны определяемому типу, вплоть до сокращений</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Модификаторы специальных возможностей не разрешаются на переопределениях или реализациях интерфейса</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Рассмотрите возможность использования файла с расширением ".ml" или ".mli"</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Это свойство переопределяет или реализует абстрактное свойство, однако абстрактное свойство не имеет соответствующего {0}</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Ошибка компилятора: недопустимое нереализованное значение</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Ссылка на предоставленный тип имеет недопустимое значение "{0}" статического параметра. Может потребоваться перекомпилировать одну или более сборок, на которые указывают ссылки.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Определения исключений несовместимы, поскольку их сокращенные формы в сигнатуре и реализации различаются. Модуль содержит определение исключения\n    {0}    \nоднако его сигнатура задает\n\t{1}.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Недопустимое значение пользовательского атрибута (не является константой или литералом)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Сокращения исключений не должны иметь списков аргументов</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Это свойство имеет недопустимый тип. Свойства, принимающие множественные аргументы индексатора, должны иметь типы формы "ty1 * ty2 -&gt; ty3". Свойства, принимающие множественные аргументы индексатора, должны иметь типы формы "(ty1 -&gt; ty2)".</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Здесь будет храниться значение типа byref. Использование значений верхнего уровня типа byref с привязкой let не допускается.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Для данного идентификатора были указаны множественные атрибуты видимости. привязки "let" в классах всегда являются закрытыми, так же, как и привязки "let" внутри выражений.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>В кавычки нельзя заключать определения выведенных функций или функций, объявленных как универсальные. Рекомендуется добавить ограничения типа, преобразующие это выражение в допустимое выражение с кавычками.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Недопустимая точность спецификатора формата</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Этот тип не имеет доступных конструкторов объекта</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>Тип "{0}" поставщика типов "{1}" имеет пустое пространство имен. Используйте null для глобального пространства имен.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как реализация (в отличие от сигнатуры) определяет, что этот тип может использовать значение NULL в качестве дополнительного значения.</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Данный конструктор объекта требует аргументов.</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>Использование модификаторов доступности в объявлении "inherits" не допускается</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Для этого типа требуется определение</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Поля литералов нельзя задавать</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>Используется в циклах for для обозначения диапазона.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Используется с логическими условиями в качестве логического значения или оператора. Эквивалентно ||. Также используется в ограничениях членов.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Используется в размеченных объединениях для обозначения типа категорий значений, а также в объявлениях делегатов и исключений.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Используется в конструкциях условного ветвления.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Используется для выражений последовательностей и (в подробном синтаксисе) для отделения выражений от привязок.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Используется для присвоения текущему объекту класса имени объекта. Также используется для присвоения имени всему шаблону в пределах сопоставления шаблонов.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Используется в циклических конструкциях или для выполнения императивного кода.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИзменяемость атрибутов различается</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Сокращенные формы исключений общего промежуточного языка должны иметь соответствующий конструктор объекта</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Не является допустимым числовым литералом. Допустимые числовые литералы: 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>Атрибут "CustomEquality" необходимо использовать в сочетании с атрибутами "NoComparison" или "CustomComparison"</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Свойство метода получения может иметь не более одной группы аргументов</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Этот элемент, функция или значение не могут быть объявлены как inline</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Недопустимый префиксный оператор</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>В этой точке кода не требуется точка с запятой</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>"{0}" используется неверно. Использование: {1}. Это пользовательская операция в данном запросе или выражении с вычислениями.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>Переопределение для "{0}" было неоднозначным</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Укажите контейнер ключей строгого имени</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Оператор expr.[idx] применялся к объекту неопределенного типа на основе информации до данной точки программы. Попробуйте добавить дополнительные ограничения типов</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Разрешать ссылки на сборку с помощью основанных на каталоге правил вместо разрешения MSBuild</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Повторяющийся метод. Имя и сигнатура абстрактного метода "{0}" аналогичны абстрактному методу унаследованного типа после удаления кортежей, функций, единиц измерения и предоставляемых типов.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Единица измерения не может быть использована в приложении конструктора типов</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Выражения конструкции объекта (напр. выражений записи со спецификациями наследования) могут использоваться только для реализации конструкторов в типах моделей объектов. Для формирования экземпляров типов моделей объектов вне конструкторов используется "new ObjectType(args)"</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>"{0}" не может использоваться в качестве знака в именах операторов и зарезервирован для будущего использования</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>В запросах нельзя использовать выражения use</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>Тип "{0}" не является типом, элементы которого могут быть перечислены с помощью данного синтаксиса, напр., несовместимы с seq&lt;_&gt;, IEnumerable&lt;_&gt; или с IEnumerable, а также не имеют метода GetEnumerator</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Недопустимый пустой длинный идентификатор</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Недопустимая директива. Требуется ''#r \"&lt;файл_или_сборка&gt;\"''.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Определение типа привело к выходу за пределы области переменной типа определения. Попробуйте добавить аннотации типа, чтобы сделать код менее универсальным.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>Тип "{0}" не поддерживает преобразование в тип "{1}"</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Параметр командной строки "--cliroot" не рекомендуется к использованию. Используйте явную ссылку на конкретную копию библиотеки mscorlib.dll.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Определения {0} в сигнатуре и реализации несовместимы, так как названия различаются. Название типа — "{1}" в файле сигнатуры, но "{2}" в реализации.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Недопустимый аргумент methodhandleof во время создания кода</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>Непредвиденный символ = в выражении. Возможно, предполагалось использовать for x in y .. z do?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>Недоступны конструкторы для типа "{0}"</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Дублированная спецификация интерфейса</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>Сборка "{0}" не найдена в наборе зависимостей целевого двоичного файла. Корневые элементы со статическим связыванием должны указываться с помощью имени сборки без расширения DLL или EXE. Если сборка задана в ссылке явным образом, возможно, сборка на самом деле не требовалась для созданного двоичного файла. Это означает, что для нее не требуется статическое связывание.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>Тип "{0}" реализует "System.IComparable". Рекомендуется также добавить явное переопределение для "Object.Equals"</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Используется во взаимно рекурсивных привязках, объявлениях свойств и с несколькими ограничениями для универсальных параметров.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Это недопустимое постоянное выражение.</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Файл ответа "{0}" не найден в "{1}".</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>Пространство имен "{0}" не определено.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>Ни один из типов "{0}" не поддерживает оператор "{1}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в привязках "do" не допускается, но указан "{0}".</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Неожиданный символ "{0}" в выражении препроцессора</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>Допускается использование не более одного приращения "with"</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Параметру с атрибутами также должно быть дано имя, напр. "[&lt;атрибут&gt;] имя : тип"</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Метки поля и требуемый тип данного выражения записи или шаблона не определяют уникально соответствующий тип записи</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Только активные шаблоны, возвращающие ровно один результат, могут принимать аргументы</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Элемент инфиксного оператора "{0}" имеет {1} начальных аргументов. Требуется кортеж из 2 аргументов, например: static member (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>аргумент</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Эта конструкция предназначена для многоязыковой совместимости. {0}. Это предупреждение можно отключить с помощью параметра "--mlcompatibility" или "--nowarn:62".</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value>Модификатор форматирования # в F# недопустим.</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Использовать отложенную подпись для сборки, используя только открытую часть ключа строгого имени</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Используется для объявления типа исключения.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Одна или несколько перегрузок данного метода имеет переданные аргументы. Рекомендуется изменить эти элементы так, чтобы они принимали аргументы в форме кортежа</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>Параметр "global" может использоваться только в качестве первого имени в полном пути</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Перечисления литералов должны иметь тип int, uint, int16, uint16, int64, uint64, byte, sbyte или char</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>Произошла ошибка при чтении узла метаданных F# в позиции {0} в таблице "{1}" сборки "{2}". В узле отсутствовало соответствующее объявление. Отправьте это предупреждение в отчете. Вам может потребоваться повторно скомпилировать сборку F#, которую вы используете.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>Ошибка при открытии двоичного файла "{0}": {1}</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Недопустимое имя элемента. Элементы не могут иметь имя ".ctor" или ".cctor"</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Неправильный спецификатор формата: '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Данное поле не является литералом и не может использоваться в шаблоне</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Только поля записей и простые нерекурсивные привязки "let" могут быть помечены как изменяемые</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Недопустимая директива. Требуется ''#load \"&lt;файл&gt;\" ... \"&lt;файл&gt;\"''.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>Тип "{0}" содержит метод "{1}" (полное имя "{2}"), являющийся статическим</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Не было найдено ни одного абстрактного элемента либо элемента интерфейса, соответствующего данному переопределению</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Недопустимый шаблон.</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>В выражении for отсутствует do. Ожидалось "for &lt;шаблон&gt; in &lt;выражение&gt; do &lt;выражение&gt;".</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Необходимо явно объявить либо все параметры типа, либо не объявлять их вообще при переопределении базового абстрактного метода</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Неподдерживаемое выражение "{0}" от поставщика типов. Если вы являетесь автором этого поставщика типов, попробуйте изменить его для предоставления другого выражения.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Укажите версию подсистемы этой сборки</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Недопустимое использование переменной типа byref</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Не удалось встроить значение "{0}", отмеченное как "inline", возможно, в связи с отметкой рекурсивного значения как "inline"</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>В типах функций разделяет аргументы и возвращаемые значения. Выдает выражение (в выражениях последовательности); эквивалентно ключевому слову yield. Используется в выражениях сопоставления.</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Структуры не могут иметь конструктор объектов без аргументов. Это ограничение, накладываемое на все языки CLI, так как структуры автоматически поддерживают конструктор по умолчанию.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Недопустимый algId — ожидалось "Exponent"</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>Рекомендуется использовать "return!" вместо "return".</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>Оператор "!" используется для разыменования ссылочной ячейки. Рассмотрите использование здесь "not expr".</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>Не добавлять ресурс к создаваемой сборке, содержащей специальные метаданные F#</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Недопустимый инфиксный оператор в выражении типа</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>Параметр --embed поддерживается только при создании переносимого PDB-файла (--debug:portable или --debug:embedded).</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Недопустимое определение оператора. Определения префиксных операторов должны использовать допустимые имена префиксных операторов.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Аргументы без названий не образуют префикса аргументов вызываемого метода</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>недопустимое полное имя для предоставленного типа</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>Перед директивами #else могут находиться только знаки пробела</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>Поле "{0}" ветви объединения/исключения не может использоваться более одного раза.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в вариантах объединения не допускается. Чтобы обеспечить доступность всего представления, используйте синтаксис "type U = internal ..." или "type U = private ...".</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Создание экземпляра типа с использованием типа byref. В правилах общего промежуточного языка это не допускается.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Неизвестная ветвь объединения</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>Имя "({0})" не может использоваться в качестве имени элемента. Чтобы определить для типа семантику сравнения, реализуйте интерфейс "System.IComparable". При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Сокращения типов не могут иметь приращений</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Модуль содержит конструктор\n    {0}    \nоднако его сигнатура задает\n    {1}    \nдоступность, заданная в сигнатуре, шире указанной в реализации</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nАрности в сигнатуре и реализации различаются. Сигнатура указывает, что "{3}" является определением функции или лямбда-выражением, принимающим по крайней мере {4} аргументов, однако реализация является вычисляемым значением функции. Чтобы объявить, что вычисляемое значение функции является разрешенной реализацией, просто возьмите в круглые скобки его тип в сигнатуре, например:\n\tval {5}: int -&gt; (int -&gt; int)\nвместо\n\tval {6}: int -&gt; int -&gt; int.</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>и {0} других перегрузок</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>Тип "{0}" не является перечисляемым типом CLI</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Сокращенная форма модуля может быть простым именем, но не путем</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Рекурсивные значения не могут использоваться непосредственно в конструкциях вида "{0}" внутри рекурсивной привязки. Эта функция удалена из языка F#. Вместо этого рекомендуется использовать запись.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>Компилятор F# для F# {0}</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Именованному аргументу было назначено более одного значения</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Игнорирование сборки смешанного (управляемого и неуправляемого) типа "{0}" во время статического связывания</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Атрибут StructLayout может присваиваться только структурам и классам без первичных конструкторов</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Требуется параметр типа, а не параметр единицы измерения</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Обозначает реализацию абстрактного метода; используется вместе с объявлением абстрактного метода для создания виртуального метода.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Конец файла в строке с тройными кавычками, вставленной в комментарий, который начался здесь или ранее</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Включить технологию ASLR с высокой энтропией</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Ожидался закрытый ключ</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>активный результат шаблона</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Это объявление не поддерживается в группах рекурсивных объявлений</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Отсутствует токен "{0}" в выражении препроцессора</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Осуществляется выход - слишком много ошибок</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Элемент "{0}" не имеет нужного числа аргументов. Необходимая сигнатура: "{1}".</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>В этом типе используется недопустимое сочетание атрибутов "NoEquality", "ReferenceEquality", "StructuralEquality", "NoComparison" и "StructuralComparison"</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Это определение можно использовать только в типе с первичным конструктором. Попробуйте добавить в определение типа аргумент, напр. "type X(args) = ...".</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>Тип атрибута "{0}" имеет значение "AllowMultiple=false". Нельзя присоединить несколько экземпляров этого атрибута к одному элементу языка.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>В выражениях последовательности множественные результаты создаются с помощью "yield!"</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>Тип "{0}" не поддерживает оператор "{1}". Попробуйте открыть модуль Microsoft.FSharp.Linq.NullableOperators.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Структуры, интерфейсы, перечисления и делегаты не могут наследовать от других типов</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Недопустимое число универсальных аргументов для типа "{0}" в предоставленном типе. Ожидалось аргументов: "{1}", задано аргументов: "{2}".</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>Метод "{0}" недоступен из данного расположения в коде</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>Недопустимое магическое значение в заголовке CLR</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Недопустимое необязательное назначение свойству или полю</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}. Именованный аргумент "{3}" не соответствует какому-либо аргументу или задаваемому возвращаемому свойству для какой-либо перегрузки.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Отсутствуют конструкторы элемента или объекта {0} с именем "{1}", принимающие следующее число аргументов: {2}. Обратите внимание, что при вызове этого члена также предоставляется следующее число именованных аргументов: {3}.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Недопустимая метка поля</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>Не удается декодировать атрибут MarshalAs</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как представления IL различаются.</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Для не являющегося универсальным типа "{0}" не требуются аргументы типа, однако здесь задано следующее число аргументов типа: {1}</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>Значение, конструктор, пространство имен или тип "{0}" не определены.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>пространство имен/модуль</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>Рекурсивная иерархия классов в типе "{0}"</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Рекурсивная ссылка на объект "{0}" не используется. Наличие рекурсивных ссылок на объект увеличивает число проверок инициализации, проводимых во время выполнения для элементов этого типа и его производных типов. Рекомендуется удалить рекурсивную ссылку на объект.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Тип не может содержать одновременно атрибуты "ReferenceEquality" и "StructuralEquality" или "StructuralComparison"</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Данный конструктор может быть использован только в вычислительных выражениях</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>Чтобы изменить содержимое или получить адрес типа значения, значение должно быть изменяемым, например, "let mutable x = ..."</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Сокращения исключений должны ссылаться на существующие исключения или типы F#, производные от System.Exception</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Внедрить все исходные файлы в переносимый PDB-файл</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>Только простые шаблоны переменных могут быть связаны в конструкциях "let rec"</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Последовательные аргументы следует разделять пробелами или включать в кортежи; аргументы, предполагающие применение функции или метода, следует заключать в круглые скобки</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Не является исключением</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>Внутренняя ошибка. Недопустимый индекс в массив активного шаблона</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>Ссылка на сборку "{0}" была задана транзитивно, поэтому автоматически разрешить сборку не удалось. При статическом связывании предполагается, что у этого DLL-файла нет зависимостей от библиотеки F# или других DLL-файлов со статическим связыванием. Попробуйте добавить явную ссылку на этот DLL-файл.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>Ошибка при создании атрибута System.Reflection.AssemblyCultureAttribute - "Исполняемые файлы не могут быть вспомогательными сборками; свойство " Культура" должно обязательно быть пустым"</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Видимость интерфейсов всегда соответствует видимости включающего их типа</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОдин является функциональным типом, другой - нет Сигнатура требует явных параметров типов, если они присутствуют в реализации.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>Синтаксис "module ... = struct .. end" не используется в код F#. Рекомендуется использовать синтаксис "module ... = begin .. end"</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>Атрибут "VolatileField" может использоваться только в привязках "let" в классах</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Модуль содержит поле\n    {0}    \nоднако его сигнатура задает\n    {1}    \nМодификаторы "literal" различаются</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Определения {0} для типа "{1}" в сигнатуре и реализации несовместимы, так как сокращения различаются: {2} в сравнении с {3}.</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Явный статический инициализатор должен использовать синтаксис "new(args) = expr"</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Только функции могут помечаться как "inline"</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Этот тип не является интерфейсным типом</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>Тип "{0}" не является интерфейсным типом</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>В конструкторе объекта нельзя прямо использовать блоки try/with и try/finally до инициализации объекта. К таким вариантам использования также относятся и конструкции вида "for x in ...", применение которых может привести к использованию указанных конструкций. Это ограничение связано с требованиями общего промежуточного языка.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>В запросах нельзя использовать "return" и "return!"</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Использование модификаторов доступности в полях записи не допускается. Чтобы обеспечить доступность всего представления, используйте синтаксис "type R = internal ..." или "type R = private ...".</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Используется вместо let! в асинхронных рабочих процессах и других вычислительных выражениях для значений, требующих вызова Dispose для освобождения ресурсов.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Объявление наследования здесь не разрешено</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>Сведения об элементе "{1}" предоставленного типа "{0}" содержат объявляющий тип NULL</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Поставщик типов "{0}" вернул недействительный метод из ApplyStaticArgumentsForMethod. Предполагалось, что вернется метод "{1}" , но был возвращен метод "{2}".</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} не является допустимой escape-последовательностью символов Юникода</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Существует несколько типов, вызываемых "{0}" и принимающих различное число универсальных параметров. Предоставьте создание экземпляра типа, чтобы однозначно определить разрешение типа, например, "{1}".</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Атрибуты пространства имен или модуля различаются в сигнатуре и реализации</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>Интерфейс "{0}" включен в несколько явно реализованных типов интерфейса. Добавьте явную реализацию данного интерфейса.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>Событие "{0}" имеет нестандартный тип. Если это событие объявлено в другом языке CLI, для доступа к нему может потребоваться использование методов {1} и {2} события. Если это событие объявлено в языке F#, используйте в качестве типа события экземпляр "IDelegateEvent&lt;_&gt;" или "IEvent&lt;_,_&gt;".</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>Синтаксис "type X with ..." зарезервирован для приращений. Типы, представления которых скрыты, но при этом имеющие элементы, теперь объявляются в сигнатурах с использованием "type X = ...". Возможно также потребуется добавить к определению типа в сигнатуре атрибут [&lt;Sealed&gt;]</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Возможно, требуется одно из следующих:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>Метка записи "{0}" не определена.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>При такой проверке типа или нисходящем приведении единица измерения "{0}" будет проигнорирована</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Недопустимый BLOB-объект открытого ключа</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>Статическая компоновка не позволяет использовать сборку, которая ссылается на mscorlib (например, сборку .NET Framework), при создании сборки, которая ссылается на System.Runtime (например, сборки .NET Core или переносимой сборки).</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nЧисло универсальных параметров в сигнатуре и реализации различаются (сигнатура объявляет {3}, однако реализация объявляет {4})</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Элемент "{0}" не имеет нужных базовых параметров. Необходимая сигнатура: "{1}".</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>Сигнатура и реализация несовместимы, поскольку соответствующие количества параметров типов различаются</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>тип, исключение или модуль</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Данный список выражений массива включает элемент формы "if ... then ... else". Заключите данное выражение в скобки, чтобы показать, что это отдельный элемент списка или массива, отличающийся от списка, созданного с использованием выражения последовательности</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>Тип "{0}" не содержит собственное значение "null"</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Модификаторы доступности следует указывать непосредственно перед идентификатором, определяющим имя конструкции</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Неполное определение значения. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово use.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Неполное определение значения или функции. Если оно находится в выражении, тело выражения должно располагаться с таким же отступом, что и ключевое слово let.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>Ветвь объединения/исключение "{0}" не содержит поля с именем "{1}".</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>Имя "({0})" не может использоваться в качестве имени элемента. При определении статического элемента для использования из других языков CLI, используйте имя "{1}".</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>У поставщика типов нет допустимого конструктора. Ожидался конструктор, принимающий один аргумент типа TypeProviderConfig или не принимающий ни одного аргумента этого типа.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Типы записей, объединений, сокращений и структур не могут иметь атрибут "AllowNullLiteral"</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>Форма выражения {{ expr with ... }} может использоваться только с типами записи. Для сборки типов объекта используется {{ new Type(...) with ... }}</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>Для "{0}" не было дано реализации</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Для данного случая объединения требуется {0} аргументов в форме кортежа </value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>Два определения типа с именем "{0}" встречаются в пространстве имен "{1}" в двух разных частях этой сборки</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Недопустимое имя модуля</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>Преобразование {0} в {1} является безопасным повышением времени компиляции, а не понижением. Рекомендуется использовать оператор :&gt; (upcast) вместо оператора :?&gt; (downcast).</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Использование позиционных спецификаторов в строках формата не допускается</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>Пользовательский оператор "{0}" ссылается на перегруженный метод. Нельзя перегружать реализации пользовательских операций.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>привязки "use" недопустимы в модулях и обрабатываются как привязки "let"</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Укажите кодовую страницу, которая будет использоваться для чтения исходных файлов</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Этот оператор обрабатывается непосредственно компилятором F#, в связи с чем его значение не может быть повторно определено</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Преобразует тип в тип, находящийся ниже в иерархии.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Не удалось прочитать версию из библиотеки mscorlib.dll</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Поставщик типов сообщил об ошибке "{0}" в контексте предоставленного типа "{1}", элемент "{2}". Ошибка: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Ошибка при применении статических аргументов к предоставленному типу</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- ВХОДНЫЕ ФАЙЛЫ -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>В целочисленном цикле for необходимо использовать простой идентификатор</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Это число находится вне допустимого диапазона для 8-битных шестнадцатеричных целых чисел со знаком</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Условие соответствия шаблону должно иметь тип "bool", но это выражение "when" имеет тип "{0}".</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>В определении типа требуются один или несколько элементов или других объявлений. Если предполагается определение пустых класса, структуры или объединения, используйте выражения "type ... = class end", "interface end" или "struct end".</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>В универсальной конструкции требуется использовать тип "{0}", содержащий семантику ссылки, однако заданный тип эту семантику не содержит, т. е. является структурой</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nИмена различаются</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>Сокращенная форма типа содержит параметры типа byref. В языке F# это не допускается.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>Невозможно создать сведения об отладке MDB. Не удалось загрузить тип MonoSymbolWriter из сборки Mono.CompilerServices.SymbolWriter.dll.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Непредвиденная ошибка при создании файла отладочной информации "{0}"</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Требуется параметр единицы измерения, а не параметр типа Явные параметры единицы измерения должны быть помечены атрибутом [&lt;Measure&gt;]</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>Не удается выполнить синтаксический анализ строки формата "{0}"</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Недопустимое декодирование атрибута AutoOpenAttribute</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>В кавычки нельзя заключать выражения, выполняющие вызовы ограничения элементов или использующие операторы, которые явным образом разрешаются в вызовы элементов ограничения</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Файлы в библиотеках или многофайловых приложениях должны начинаться с объявления пространства имен или модуля. При использовании объявления модуля в начале файла знак "=" не разрешен. Если это модуль верхнего уровня, рекомендуется удалить "=", чтобы устранить эту ошибку.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>Поле "{0}" появляется дважды в данном выражении записи или шаблоне</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>Ожидался предоставленный тип с именем "{0}", однако у предоставленного типа значение Name равнялось "{1}"</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Ожидался предоставленный тип с путем "{0}", однако предоставленный тип имеет путь "{1}"</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Количество аргументов пользовательского атрибута не совпадает с требуемым числом аргументов для конструктора атрибутов</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>Недопустимый способ использования элемента "{0}". Использование "{1}" выведено до его определения в строке "{2}" или близлежащих строках. Недопустимая опережающая ссылка.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>Событие "{0}" предоставленного типа "{1}" не имеет значения, полученного от метода GetRemoveMethod()</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>Ожидался ключ RSA</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>Все типы записи, объединений и структур в FSharp.Core.dll должны быть явно помечены "StructuralComparison" или "NoComparison"</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>Тип объединения для ветви объединения "{0}" определен с RequireQualifiedAccessAttribute. Включите имя типа объединения ("{1}") в используемое имя.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Активные шаблоны не могут возвращать более 7 возможностей</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>Значение или конструктор "{0}" не определены.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Данное объявление inherit содержит аргументы, но не находится в типе с первичным конструктором. Попробуйте добавить в определение типа аргументы, напр. "type X(args) = ...".</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Типы различаемых объединений всегда являются запечатанными</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Недопустимая аннотация GetSet для свойства</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Это не является допустимым значением для литерала перечисления</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Недопустимый модуль, выражение или тип</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} перегрузок</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 перегрузка</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>Ожидался тип, поддерживающий оператор "{0}", однако указан кортежный тип</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>Сборка "{0}" указана в командной строке. Ссылки на сборки следует задавать с помощью флага командной строки, например флага "-r".</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>Значение "{0}" предоставленного типа равнялось NULL или было пустым.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Повторяющийся метод. Имя и сигнатура абстрактного метода "{0}" аналогичны абстрактному методу унаследованного типа.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>также из {0}</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Метод массива "{0}" предоставляет средой выполнения и не может использовать непосредственно в коде. Для операций с элементами используйте семейство функций GetArray/SetArray из модуля LanguagePrimitives.IntrinsicFunctions.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Атрибут доступности "{0}" запрещен в сокращенной форме модуля. В сокращенных формах модуля всегда используются закрытые атрибуты.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Предоставленные типы, созданные в результате данного использования поставщика типов, не могут использоваться из других сборок F#, и их следует пометить модификатором internal или private. Попробуйте использовать конструкцию "type internal TypeName = ..." или "type private TypeName = ...".</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Добавьте "." для доступа к индексатору.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>Привязки DLLImport должны быть статическими элементами в определениях класса или функции в модуле</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>Функция или элемент "{0}" используются таким образом, что для подтверждения согласованности выводимых типов требуются дополнительные аннотации типов при их определении. Выводимая сигнатура: "{1}".</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Этот метод уже имеет реализацию по умолчанию</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>Модуль "{0}" содержит\n    {1}    \nоднако его сигнатура задает\n    {2}    \nОткомпилированное представление этого метода является экземплярным элементом, однако его сигнатура указывает, что его откомпилированное представление является статическим элементом</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Не является допустимым байтовым литералом.</value>
  </data>
</root>