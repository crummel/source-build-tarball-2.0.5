<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="parsTypeAbbreviationsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine tür kısaltmalarının bu konumunda izin verilmez</value>
  </data>
  <data name="fscStaticLinkingNoEXE" xml:space="preserve">
    <value>Statik bağlama .EXE içeremez</value>
  </data>
  <data name="tcPropertyIsNotReadable" xml:space="preserve">
    <value>'{0}' özelliği okunamıyor</value>
  </data>
  <data name="tcInvalidUseBinding" xml:space="preserve">
    <value>'use!' bağlamaları 'use &lt;var&gt; = &lt;expr&gt;' biçiminde olmalıdır</value>
  </data>
  <data name="buildProductName" xml:space="preserve">
    <value>Microsoft (R) F# Derleyicisi sürümü {0}</value>
  </data>
  <data name="fieldIsNotAccessible" xml:space="preserve">
    <value>Record, struct veya class alanı '{0}' öğesine bu kod konumundan erişilemiyor</value>
  </data>
  <data name="etMethodHasRequirements" xml:space="preserve">
    <value>'{1}' sağlanan türünde geçersiz '{0}' üyesi. Sağlanan tür üyeleri genel, sanal veya soyut değil ortak olmalıdır.</value>
  </data>
  <data name="tcEmptyRecordInvalid" xml:space="preserve">
    <value>'{{ }}' geçerli bir ifade değil. Kayıtlar en az bir alan içermelidir. Boş diziler Seq.empty veya boş liste '[]' kullanılarak belirtilir.</value>
  </data>
  <data name="ilDynamicInvocationNotSupported" xml:space="preserve">
    <value>Dinamik {0} çağırma desteklenmiyor</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied1" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'StructuralEquality' özniteliğine sahip ancak tür parametresi '{1}' 'equality' kısıtlamasını karşılamıyor. Tür parametresine 'equality' kısıtlamasını eklemeyi düşünün</value>
  </data>
  <data name="tcStructuralEqualityNotSatisfied2" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'StructuralEquality' özniteliğine sahip ancak bileşen türü '{1}' 'equality' kısıtlamasını karşılamıyor</value>
  </data>
  <data name="parsConsiderUsingSeparateRecordType" xml:space="preserve">
    <value>Onun yerine ayrı bir kayıt türü kullanmayı deneyin</value>
  </data>
  <data name="chkNoByrefReturnOfLocal" xml:space="preserve">
    <value>'{0}' değişkeninin adresi bu noktada kullanılamaz. Bir metot veya işlev, bu yerel değerin adresini döndüremez.</value>
  </data>
  <data name="buildCannotReadAssembly" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodu okunamıyor</value>
  </data>
  <data name="csGenericConstructRequiresStructType" xml:space="preserve">
    <value>Genel bir yapı, '{0}' türünün bir CLI veya F# struct türü olmasını gerektirir</value>
  </data>
  <data name="etNullProvidedExpression" xml:space="preserve">
    <value>'{0}' tür sağlayıcısı GetInvokerExpression yönteminden null döndürdü.</value>
  </data>
  <data name="buildMultipleReferencesNotAllowed" xml:space="preserve">
    <value>Birden çok '{0}.dll' başvurusuna izin verilmiyor</value>
  </data>
  <data name="parsMismatchedQuotationName" xml:space="preserve">
    <value>'{0}' ile başlayan, eşleşmeyen alıntı işleci adı</value>
  </data>
  <data name="keywordDescriptionAbstract" xml:space="preserve">
    <value>İçinde bildirildiği türde hiç uygulaması olmayan veya sanal olup varsayılan uygulaması olan bir metodu belirtir.</value>
  </data>
  <data name="fscStaticLinkingNoMixedDLL" xml:space="preserve">
    <value>Statik bağlama karışık bir yönetilen/yönetilmeyen DLL içeremez</value>
  </data>
  <data name="keywordDescriptionPrivate" xml:space="preserve">
    <value>Üyeye erişimi aynı türdeki veya modüldeki kodla sınırlandırır.</value>
  </data>
  <data name="csTypeNotCompatibleBecauseOfPrintf" xml:space="preserve">
    <value>'{0}' türü, printf tarzı biçim dizesinin kullanımından kaynaklanan {1} türlerinden herhangi biriyle uyumlu değil</value>
  </data>
  <data name="tcMemberOperatorDefinitionInExtrinsic" xml:space="preserve">
    <value>Uzantı üyeleri işleç aşırı yüklemeleri sağlayamaz. Bunun yerine işleci tür tanımının parçası olarak tanımlamayı düşünün.</value>
  </data>
  <data name="chkVariableUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' değişkeni geçersiz bir biçimde kullanılmış</value>
  </data>
  <data name="tcSyntaxCanOnlyBeUsedToCreateObjectTypes" xml:space="preserve">
    <value>'{0}' yalnızca nesne türlerini oluşturmak için kullanılabilir</value>
  </data>
  <data name="parsUnfinishedExpression" xml:space="preserve">
    <value>Beklenmeyen '{0}' belirteci veya eksik ifade</value>
  </data>
  <data name="parsUnderscoreInvalidFieldName" xml:space="preserve">
    <value>'_' alan adı olarak kullanılamaz</value>
  </data>
  <data name="parsMultipleAccessibilitiesForGetSet" xml:space="preserve">
    <value>Özellik alıcı veya ayarlayıcı için birden çok erişilebilirlik verildi</value>
  </data>
  <data name="tcConstructorsCannotBeFirstClassValues" xml:space="preserve">
    <value>Oluşturucular bağımsız değişkenlere uygulanmalıdır ve birinci sınıf değer olarak kullanılamazlar. Gerekirse anonim bir işlev kullanın: '(fun arg1 ... argN -&gt; new Type(arg1,...,argN))'.</value>
  </data>
  <data name="buildInvalidVersionFile" xml:space="preserve">
    <value>Geçersiz dosya sürümü '{0}'</value>
  </data>
  <data name="tcRecursiveBindingsWithMembersMustBeDirectAugmentation" xml:space="preserve">
    <value>Üye belirtimleri içeren özyinelemeli bağlamalar yalnızca türün doğrudan genişletmesi olarak oluşabilir</value>
  </data>
  <data name="InvalidRecursiveReferenceToAbstractSlot" xml:space="preserve">
    <value>Soyut yuvaya geçersiz özyinelemeli başvuru</value>
  </data>
  <data name="crefQuotationsCantContainInlineIL" xml:space="preserve">
    <value>Alıntılar, satır içi bütünleştirilmiş kod kodu veya dizilerde desen eşleştirme içeremez</value>
  </data>
  <data name="tcObjectsMustBeInitializedWithObjectExpression" xml:space="preserve">
    <value>Nesneler devralınan nesne oluşturucusunu çağıran ve her alana bir değer atayan bir nesne oluşturma ifadesi ile başlatılmalıdır</value>
  </data>
  <data name="tcUnrecognizedQueryBinaryOperator" xml:space="preserve">
    <value>Sorgu işleçlerinin bağımsız değişkenleri ayraç gerektirebilir, örn. 'where (x &gt; y)' veya 'groupBy (x.Length / 10)'</value>
  </data>
  <data name="optsWarn" xml:space="preserve">
    <value>Uyarı düzeyini ayarla (0-5)</value>
  </data>
  <data name="optsHelp" xml:space="preserve">
    <value>Bu kullanım iletisini görüntüle (Kısa biçimi: -?)</value>
  </data>
  <data name="fscSystemRuntimeInteropServicesIsRequired" xml:space="preserve">
    <value>UnknownWrapper\DispatchWrapper sınıflarını kullanmak için System.Runtime.InteropServices bütünleştirilmiş kodu gerekiyor.</value>
  </data>
  <data name="typeInfoModule" xml:space="preserve">
    <value>modül</value>
  </data>
  <data name="astInvalidExprLeftHandOfAssignment" xml:space="preserve">
    <value>Atamanın solunda geçersiz ifade</value>
  </data>
  <data name="tcInvalidInlineSpecification" xml:space="preserve">
    <value>Geçersiz satır içi belirtim</value>
  </data>
  <data name="keywordDescriptionTypedQuotation" xml:space="preserve">
    <value>Türü belirtilmiş kod alıntısını ayırır.</value>
  </data>
  <data name="tcMemberKindPropertyGetSetNotExpected" xml:space="preserve">
    <value>MemberKind.PropertyGetSet yalnızca ayrıştırma ağaçlarında beklenir</value>
  </data>
  <data name="pathIsInvalid" xml:space="preserve">
    <value>'{0}' dosya adında sorun: Yolda geçersiz karakterler var.</value>
  </data>
  <data name="loadingDescription" xml:space="preserve">
    <value>(açıklama yükleniyor...)</value>
  </data>
  <data name="csTypeDoesNotSupportComparison3" xml:space="preserve">
    <value>'{0}' türü, 'comparison' kısıtlamasını desteklemeyen bir veya daha fazla yapısal öğe türünün olduğu bir record, union veya struct olduğu için 'comparison' kısıtlamasını desteklemez. Bu türde karşılaştırma kullanmayın veya hangi alan türünün karşılaştırmayı desteklemediğini belirlemek için 'StructuralComparison' özniteliğini türe ekleyin</value>
  </data>
  <data name="csTypeDoesNotSupportComparison2" xml:space="preserve">
    <value>'{0}' türü 'comparison' kısıtlamasını desteklemez. Örneğin, 'System.IComparable' arabirimini desteklemez</value>
  </data>
  <data name="csTypeDoesNotSupportComparison1" xml:space="preserve">
    <value>'{0}' türünün 'NoComparison' özniteliği olduğu için 'comparison' kısıtlamasını desteklemez</value>
  </data>
  <data name="notAFunctionButMaybeIndexerErrorCode" xml:space="preserve">
    <value>
    </value>
  </data>
  <data name="tcConditionalAttributeUsage" xml:space="preserve">
    <value>'System.Diagnostics.ConditionalAttribute' özniteliği yalnızca metotlarda veya öznitelik sınıflarında geçerlidir</value>
  </data>
  <data name="ExceptionDefsNotCompatibleDotNetRepresentationsDiffer" xml:space="preserve">
    <value>CLI temsilleri farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor</value>
  </data>
  <data name="parsSyntaxErrorInLabeledType" xml:space="preserve">
    <value>Etiketli tür bağımsız değişkeninde sözdizimi hatası</value>
  </data>
  <data name="tcPropertyRequiresExplicitTypeParameters" xml:space="preserve">
    <value>Bir özelliğin açık tür parametreleri olamaz. Onun yerine metot kullanmayı düşünün.</value>
  </data>
  <data name="optsUtf8output" xml:space="preserve">
    <value>UTF-8 kodlamasında çıkış iletileri</value>
  </data>
  <data name="tastConflictingModuleAndTypeDefinitionInAssembly" xml:space="preserve">
    <value>'{0}' adlı bir modül ve tür tanımı bu bütünleştirilmiş kodun iki yerinde '{1}' ad alanında geçiyor</value>
  </data>
  <data name="tcNameNotBoundInPattern" xml:space="preserve">
    <value>'{0}' adı desen bağlamında bağlanmamış</value>
  </data>
  <data name="etTypeProviderConstructorException" xml:space="preserve">
    <value>Tür sağlayıcısı oluşturucu bir özel durum oluşturdu: {0}</value>
  </data>
  <data name="etUnknownStaticArgumentKind" xml:space="preserve">
    <value>Sağlanan '{1}' türüne yapılan bir başvuru çözümlenirken '{0}' türünde bilinmeyen statik bağımsız değişken</value>
  </data>
  <data name="tcCustomOperationInvalid" xml:space="preserve">
    <value>'{0}' özel işlecinin tanımı geçerli bir öznitelik bayrakları bileşimi kullanmıyor</value>
  </data>
  <data name="ilStaticMethodIsNotLambda" xml:space="preserve">
    <value>GenSetStorage: {0} statik metot olarak gösterildi ancak bu uygun bir lambda ifadesi değildi</value>
  </data>
  <data name="lexOutsideEightBitUnsigned" xml:space="preserve">
    <value>Bu sayı, 8 bit işaretsiz tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="parsAttributesIgnored" xml:space="preserve">
    <value>Bu yapıda öznitelikler yok sayıldı</value>
  </data>
  <data name="tcOperatorRequiresIn" xml:space="preserve">
    <value>'{0}' öğesini 'in' izlemelidir. Kullanım: {1}.</value>
  </data>
  <data name="tcImplementsIEquatableExplicitly" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'System.IEquatable&lt;_&gt;' arabirimini açık olarak uyguluyor. Türe 'CustomEquality' özniteliğini uygulayın ve genel olmayan 'System.Object.Equals(obj)' geçersiz kılma işleminin tutarlı bir uygulamasını sağlayın.</value>
  </data>
  <data name="srcFileTooLarge" xml:space="preserve">
    <value>Kaynak dosya, taşınabilir PDB dosyasına eklemek için çok büyük</value>
  </data>
  <data name="tcObjectConstructorRequiresArgument" xml:space="preserve">
    <value>Nesne oluşturucusu bağımsız değişken gerektiriyor</value>
  </data>
  <data name="pickleErrorReadingWritingMetadata" xml:space="preserve">
    <value>F# ile derlenmiş DLL '{0}' meta verilerini hatalı okuma/yazma. DLL, F# derleyicisinin önceki bir sürümüyle mi derlenmişti? (hata: '{1}').</value>
  </data>
  <data name="tcMemberOverridesIllegalInInterface" xml:space="preserve">
    <value>Arabirimler üye geçersiz kılma tanımları içeremez</value>
  </data>
  <data name="tcMultipleVisibilityAttributes" xml:space="preserve">
    <value>Bu tanımlayıcı için birden çok görünürlük özniteliği belirtilmiş</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract" xml:space="preserve">
    <value>İmza bir soyut sınıf olmasına rağmen uygulama soyut sınıf olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Uygulamaya [&lt;AbstractClass&gt;] özniteliğini eklemeyi düşünün.</value>
  </data>
  <data name="etNullMemberDeclaringTypeDifferentFromProvidedType" xml:space="preserve">
    <value>'{0}' sağlanan türünde '{2}' tanımlama türüne sahip '{1}' üyesi var. Tanımlama türünün sağlanan türle aynı olması bekleniyordu.</value>
  </data>
  <data name="parsUnmatchedClassInterfaceOrStruct" xml:space="preserve">
    <value>Eşleşmeyen 'class', 'interface' veya 'struct'</value>
  </data>
  <data name="keywordDescriptionNamespace" xml:space="preserve">
    <value>Bir adı diğer kodlardan mantıksal olarak ayırmak amacıyla, birbiriyle ilişkili bir tür ve modül grubuyla ilişkilendirmek için kullanılır.</value>
  </data>
  <data name="undefinedNameNamespaceOrModule" xml:space="preserve">
    <value>'{0}' ad alanı veya modülü tanımlı değil.</value>
  </data>
  <data name="tcUnionCaseRequiresOneArgument" xml:space="preserve">
    <value>Bu birleşim durumu bir bağımsız değişken alır</value>
  </data>
  <data name="parsUnexpectedEmptyModuleDefn" xml:space="preserve">
    <value>Beklenmeyen boş tür moduleDefn listesi</value>
  </data>
  <data name="keywordDescriptionWhen" xml:space="preserve">
    <value>Desen eşleştirmelerde ve genel türde bir parametreye yönelik olarak bir kısıtlama yan tümcesi eklemek amacıyla Boolean koşulları (when korumaları) için kullanılır.</value>
  </data>
  <data name="keywordDescriptionWith" xml:space="preserve">
    <value>Desen eşleştirme ifadelerinde match anahtar sözcüğü ile birlikte kullanılır. Ayrıca nesne ifadelerinde, kayıt kopyalama ifadelerinde ve tür uzantılarında üye tanımlarını ve özel durum işleyicilerini tanıtmak için kullanılır.</value>
  </data>
  <data name="keywordDescriptionVoid" xml:space="preserve">
    <value>.NET void türünü belirtir. Diğer .NET dilleriyle birlikte çalışırken kullanılır.</value>
  </data>
  <data name="keywordDescriptionThen" xml:space="preserve">
    <value>Koşullu ifadelerde kullanılır. Ayrıca nesne oluşturmadan sonra yan etkileri gerçekleştirmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionType" xml:space="preserve">
    <value>Bir sınıf, kayıt, yapı, ayırt edici birleşim, sabit listesi türü, ölçü birimi veya tür kısaltması bildirmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionOpen" xml:space="preserve">
    <value>Bir ad alanının veya modülün içeriğinin sınırlama olmaksızın kullanılabilmesini sağlamak için kullanılır.</value>
  </data>
  <data name="keywordDescriptionNull" xml:space="preserve">
    <value>Bir nesnenin olmadığını belirtir. Ayrıca genel parametre kısıtlamalarında kullanılır.</value>
  </data>
  <data name="keywordDescriptionCast" xml:space="preserve">
    <value>Bir türü hiyerarşide daha yukarıdaki bir türe dönüştürür.</value>
  </data>
  <data name="keywordDescriptionBase" xml:space="preserve">
    <value>Temel sınıf nesnesinin adı olarak kullanılır.</value>
  </data>
  <data name="keywordDescriptionLazy" xml:space="preserve">
    <value>Yalnızca bir sonuç gerekli olduğunda gerçekleştirilecek bir hesaplamayı belirtmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionElse" xml:space="preserve">
    <value>Koşullu dallanmada kullanılır.</value>
  </data>
  <data name="keywordDescriptionElif" xml:space="preserve">
    <value>Koşullu dallanmada kullanılır. else if'in kısa bir biçimidir.</value>
  </data>
  <data name="keywordDescriptionDone" xml:space="preserve">
    <value>Ayrıntılı söz diziminde, döngü ifadesindeki bir kod bloğunun sonunu gösterir.</value>
  </data>
  <data name="impReferenceToDllRequiredByAssembly" xml:space="preserve">
    <value>{1} bütünleştirilmiş kodu için {0} DLL'sine başvuru gerekli oldu. İçeri aktarılan {2} türü ilk bütünleştirilmiş kodda bulunuyordu ve çözümlenemedi.</value>
  </data>
  <data name="lexOusideThirtyTwoBitFloat" xml:space="preserve">
    <value>Bu sayı, 32 bit kayan noktalı sayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit" xml:space="preserve">
    <value>Tür tanımlarının yalnızca bir 'inherit' belirtimi olabilir ve bu ilk bildirim olmalıdır</value>
  </data>
  <data name="tcLiteralCannotHaveGenericParameters" xml:space="preserve">
    <value>Sabit değerlerin genel parametreleri olamaz</value>
  </data>
  <data name="parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString" xml:space="preserve">
    <value>Tür tanımında beklenmeyen alıntı işleci '&lt;@'. Statik bağımsız değişken olarak bir tam dizeyi tür sağlayıcısına geçirmeyi düşünüyorsanız '&lt;' ve '@' karakterleri arasına boşluk koyun.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionRelational" xml:space="preserve">
    <value>'{0}' işleci normalde yeniden tanımlanmamalıdır. Belirli bir türün aşırı yüklenmiş karşılaştırma semantiğini tanımlamak için o türün tanımında 'System.IComparable' arabirimini uygulayın.</value>
  </data>
  <data name="chkCurriedMethodsCantHaveOutParams" xml:space="preserve">
    <value>Curry bağımsız değişkenlerine sahip metotlar 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName' veya 'CallerFilePath' bağımsız değişkenlerini bildiremez</value>
  </data>
  <data name="buildPdbRequiresDebug" xml:space="preserve">
    <value>'--pdb' seçeneği '--debug' seçeneğinin kullanılmasını gerektirir</value>
  </data>
  <data name="optValueMarkedInlineButWasNotBoundInTheOptEnv" xml:space="preserve">
    <value>'{0}' değeri satır içi olarak işaretlenmiş ancak iyileştirme ortamında bağlanmamış</value>
  </data>
  <data name="tcPropertyIsStatic" xml:space="preserve">
    <value>'{0}' özelliği statik</value>
  </data>
  <data name="tcNoComparisonNeeded1" xml:space="preserve">
    <value>Tür parametresi {1} 'comparison' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal olarak karşılaştırılabilir değil. Türün karşılaştırılabilir olmadığını netleştirmek için '{2}' türüne 'NoComparison' özniteliği eklemeyi düşünün</value>
  </data>
  <data name="tcNoComparisonNeeded2" xml:space="preserve">
    <value>'{1}' türü 'comparison' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal olarak karşılaştırılabilir değil. Türün karşılaştırılabilir olmadığını netleştirmek için '{2}' türüne 'NoComparison' özniteliği eklemeyi düşünün</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesStruct" xml:space="preserve">
    <value>Uygulamada bir struct tanımlanmasına rağmen imzada gizli temsili olan bir tür tanımlandığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tlrLambdaLiftingOptimizationsNotApplied" xml:space="preserve">
    <value>Not: Yerel olarak kısıtlanmış bir genel işlev olan lambda kaldırma iyileştirmelerinin birinci sınıf değer olarak kullanılması nedeniyle bu iyileştirmeler uygulanmamıştır. Tür kısıtlamaları eklemek bu durumu çözebilir.</value>
  </data>
  <data name="tcUseForInSequenceExpression" xml:space="preserve">
    <value>Dizi ifadelerinde 'let! x = coll' kullanımına izin verilmez. Onun yerine 'for x in coll' kullanın.</value>
  </data>
  <data name="FieldNotContainedMutablesDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'mutable' değiştiricileri farklı</value>
  </data>
  <data name="ilwriteMDBFileNameCannotBeChangedWarning" xml:space="preserve">
    <value>MDB dosyasının adı &lt;bütünleştirilmiş kod-dosyası-adı&gt;.mdb olmalıdır. --pdb seçeneği yok sayılacak.</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticButInstance" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu metodun derlenen temsili statik üye olarak gösteriliyor ancak imzada derlenmiş gösterim örnek üye olarak belirtiliyor</value>
  </data>
  <data name="ilDllImportAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DllImport özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="chkBaseUsedInInvalidWay" xml:space="preserve">
    <value>'Base' anahtar sözcüğü geçersiz bir biçimde kullanılmış. Base çağrıları kapanışlarda kullanılamaz. Base çağrıları yapmak için özel üye kullanmayı düşünün.</value>
  </data>
  <data name="tcNewMustBeUsedWithNamedType" xml:space="preserve">
    <value>'new' adlandırılmış türle kullanılmalıdır</value>
  </data>
  <data name="tcTypeAbbreviationHasTypeParametersMissingOnType" xml:space="preserve">
    <value>Bu tür kısaltmasının kısaltılan türde görünmeyen bir veya daha fazla bildirilmiş tür parametresi var. Tür kısaltmaları, bildirilmiş tüm tür parametrelerini kısaltılan türde kullanmalıdır. Bir veya daha fazla tür parametresini kaldırmayı düşünün veya temel türü sarmalayan 'type C&lt;'a&gt; = C of ...' gibi somut bir tür tanımını kullanın.</value>
  </data>
  <data name="optsResponseFileNameInvalid" xml:space="preserve">
    <value>Yanıt dosyası adı '{0}' boş, geçersiz karakter içeriyor, mutlak yolu olmayan bir sürücüyü belirtiyor veya çok uzun</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer" xml:space="preserve">
    <value>İmzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcNoPropertyFoundForOverride" xml:space="preserve">
    <value>Bu geçersiz kılmaya karşılık gelen bir soyut özellik bulunamadı</value>
  </data>
  <data name="astParseEmbeddedILError" xml:space="preserve">
    <value>Gömülü IL ayrıştırılırken hata oluştu</value>
  </data>
  <data name="tcDllImportStubsCannotBeInlined" xml:space="preserve">
    <value>DLLImport saplamaları satır içine alınamaz</value>
  </data>
  <data name="tcIllegalPattern" xml:space="preserve">
    <value>Geçersiz desen</value>
  </data>
  <data name="tcSimpleMethodNameRequired" xml:space="preserve">
    <value>Burada basit metot adı gereklidir</value>
  </data>
  <data name="tcAutoPropertyRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>'member val' tanımlarına yalnızca birincil oluşturucusu olan türlerde izin verilir. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</value>
  </data>
  <data name="forFlagSetTwice" xml:space="preserve">
    <value>'{0}' bayrağı iki kez ayarlandı</value>
  </data>
  <data name="crefQuotationsCantContainObjExprs" xml:space="preserve">
    <value>Alıntılar, nesne ifadeleri içeremez</value>
  </data>
  <data name="optValueMarkedInlineHasUnexpectedValue" xml:space="preserve">
    <value>'inline' olarak işaretlenmiş değerde beklenmeyen bir değer var</value>
  </data>
  <data name="tcMatchMayNotBeUsedWithQuery" xml:space="preserve">
    <value>'match' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="chkPropertySameNameIndexer" xml:space="preserve">
    <value>'{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada sahip ancak bunlardan biri dizin oluşturucu bağımsız değişkenleri alırken diğeri almıyor. Özelliklerinizden birinde dizin oluşturucu bağımsız değişkeni eksik olabilir.</value>
  </data>
  <data name="lexIdentEndInMarkReserved" xml:space="preserve">
    <value>Ardından '{0}' gelen tanımlayıcılar ileride kullanılmak üzere ayrılmıştır</value>
  </data>
  <data name="tcExplicitTypeParameterInvalid" xml:space="preserve">
    <value>Açık tür parametreleri yalnızca modülde veya üye bağlamalarında kullanılabilir</value>
  </data>
  <data name="etPropertyHasSetterButNoCanWrite" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' özelliğinde CanWrite=false var, ancak GetSetMethod() metodu bir metot döndürdü</value>
  </data>
  <data name="optsEmitDebugInfoInQuotations" xml:space="preserve">
    <value>Tırnak içindeki hata ayıklama bilgilerini yay</value>
  </data>
  <data name="optsNowin32manifest" xml:space="preserve">
    <value>Varsayılan Win32 bildirimini eklemeyin</value>
  </data>
  <data name="typeInfoActiveRecognizer" xml:space="preserve">
    <value>etkin tanıyıcı</value>
  </data>
  <data name="tcCompiledNameAttributeMisused" xml:space="preserve">
    <value>'CompiledName' özniteliği bu dil öğesiyle kullanılamaz</value>
  </data>
  <data name="keywordDescriptionMutable" xml:space="preserve">
    <value>Bir değişkeni, başka bir deyişle değiştirilebilir bir değeri bildirmek için kullanılır.</value>
  </data>
  <data name="buildSignatureAlreadySpecified" xml:space="preserve">
    <value>'{0}' dosyasının veya modülünün imzası zaten belirtilmiş</value>
  </data>
  <data name="crefQuotationsCantSetUnionFields" xml:space="preserve">
    <value>Alıntılar, birleşim durumu alanları ayarlayan ifadeler içeremez</value>
  </data>
  <data name="tcTypeDefinitionIsCyclic" xml:space="preserve">
    <value>Bu tür tanımı, kısaltma aracılığıyla anlık döngüsel başvuru içeriyor</value>
  </data>
  <data name="optsInvalidTargetProfile" xml:space="preserve">
    <value>'--targetprofile' için geçersiz değer '{0}'; geçerli değerler: 'mscorlib', 'netcore' veya 'netstandard'.</value>
  </data>
  <data name="parsUseBindingsIllegalInImplicitClassConstructors" xml:space="preserve">
    <value>birincil oluşturucularda 'use' bağlamalarına izin verilmez</value>
  </data>
  <data name="tcStructsCanOnlyBindThisAtMemberDeclaration" xml:space="preserve">
    <value>Yapılar üye bildirimlerinde yalnızca 'this' parametresini bağlayabilirler</value>
  </data>
  <data name="parsAllEnumFieldsRequireValues" xml:space="preserve">
    <value>Tüm enum alanları verilen değerler olmalıdır</value>
  </data>
  <data name="parsIllegalMemberVarInObjectImplementation" xml:space="preserve">
    <value>Nesne ifadelerinde 'member val' ve 'override val' tanımlarına izin verilmez.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleAbbreviationHiddenBySignature" xml:space="preserve">
    <value>Özel durum kısaltması imza tarafından gizlendiği için özel durum tanımları uyumlu değil. Kısaltmanın diğer CLI dillerine görünmesi gerekir. Bu kısaltmayı imzada görünür yapmayı düşünün. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</value>
  </data>
  <data name="keywordDescriptionFinally" xml:space="preserve">
    <value>Özel durumun oluşup oluşmadığına bakılmaksızın yürütülen bir kod bloğunu tanıtmak için try ile birlikte kullanılır.</value>
  </data>
  <data name="ilCustomMarshallersCannotBeUsedInFSharp" xml:space="preserve">
    <value>F# kodunda özel hazırlayıcılar belirtilemez. C# yardım işlevi kullanmayı düşünün.</value>
  </data>
  <data name="typrelOverloadNotFound" xml:space="preserve">
    <value>Hiçbir '{0}' uygulamasında doğru sayıda bağımsız değişken ve tür parametresi yoktu. Gereken imza: '{1}'.</value>
  </data>
  <data name="tcMethodOverridesIllegalHere" xml:space="preserve">
    <value>Burada metot geçersiz kılmalara ve arabirim uygulamalarına izin verilmez</value>
  </data>
  <data name="ilFieldOffsetAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>FieldOffset özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="buildSignatureWithoutImplementation" xml:space="preserve">
    <value>'{0}' imza dosyasında eşleşen bir uygulama dosyası yok. Bir uygulama dosyası varsa imza ve uygulama dosyalarındaki 'module' ve 'namespace' bildirimlerinin eşleştiğini kontrol edin.</value>
  </data>
  <data name="tcInvalidIndexOperatorDefinition" xml:space="preserve">
    <value>'{0}' işleci yeniden tanımlanamaz. Farklı bir işleç adı kullanmayı düşünün</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation" xml:space="preserve">
    <value>İmzanın kısaltması olmasına rağmen uygulamanın olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="undefinedNameTypeParameter" xml:space="preserve">
    <value>'{0}' tür parametresi tanımlı değil.</value>
  </data>
  <data name="keywordDescriptionInherit" xml:space="preserve">
    <value>Temel sınıfı veya temel arabirimi belirtmek için kullanılır.</value>
  </data>
  <data name="lexfltTokenIsOffsideOfContextStartedEarlier" xml:space="preserve">
    <value>Olası hatalı girinti: {0} konumundan başlatılan bu belirteç bağlam dışıdır. Bu belirteci daha fazla girintilemeyi veya standart biçimlendirme kurallarını kullanmayı deneyin.</value>
  </data>
  <data name="ValueNotContainedMutabilityDisplayNamesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Görünen adlar farklı</value>
  </data>
  <data name="tastConstantExpressionOverflow" xml:space="preserve">
    <value>Bu sabit değer ifadesi veya öznitelik bağımsız değişkeni aritmetik taşma ile sonuçlanıyor.</value>
  </data>
  <data name="tcOptionalArgumentsCannotBeUsedInCustomAttribute" xml:space="preserve">
    <value>İsteğe bağlı bağımsız değişkenler özel özniteliklerde kullanılamaz</value>
  </data>
  <data name="optsStaticlink" xml:space="preserve">
    <value>Verilen bütünleştirilmiş kodu ve bu bütünleştirilmiş koda bağlı tüm başvurulan DLL'leri, statik olarak bağlayın. DLL adı değil bütünleştirilmiş kod adı kullanın, örn. mylib.</value>
  </data>
  <data name="parsEofInVerbatimStringInComment" xml:space="preserve">
    <value>Açıklamaya gömülü tam dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="ValueNotContainedMutabilityLiteralConstantValuesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Sabit değerler ve/veya öznitelikler farklı</value>
  </data>
  <data name="lexThisUnicodeOnlyInStringLiterals" xml:space="preserve">
    <value>Bu Unicode kodlaması yalnızca dize sabit değerlerinde geçerlidir</value>
  </data>
  <data name="tcCallerInfoNotOptional" xml:space="preserve">
    <value>'{0}' sadece isteğe bağlı bağımsız değişkenlere uygulanabilir</value>
  </data>
  <data name="ilAddressOfValueHereIsInvalid" xml:space="preserve">
    <value>Bu işlem, yerel değişken kullanılarak veya başka bir özel gösterimle sunulan '{0}' değerinin adresini almayı içeriyor. Bu geçersizdir.</value>
  </data>
  <data name="optsNoframework" xml:space="preserve">
    <value>Varsayılan seçenek olarak varsayılan CLI bütünleştirilmiş kodlarına başvurma</value>
  </data>
  <data name="buildExpectedFileAlongSideFSharpCore" xml:space="preserve">
    <value>'{0}' dosyası FSharp.Core ile birlikte bulunamadı. Dosyanın {1} içinde olması bekleniyordu. Bu dosyayı gerektirmeyen daha yeni bir FSharp.Core sürümüne yükseltmeniz önerilir.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull" xml:space="preserve">
    <value>İmzada bu türün temsil olarak null değerleri kullanabileceği belirtilmesine rağmen uygulamada bu belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="parsEofInComment" xml:space="preserve">
    <value>Açıklamada dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="csMemberHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' bağımsız değişkene veya ayarlanabilen '{1}' dönüş özelliğine sahip değil. {2}.</value>
  </data>
  <data name="etUnsupportedConstantType" xml:space="preserve">
    <value>Desteklenmeyen sabit türü '{0}'. Tür sağlayıcıları tarafından sağlanan alıntılar yalnızca basit sabitler içerebilir. Tür sağlayıcısı uygulamasının; sağlanmış alıntı sabit değerinin dışında bildirilen bir değer, alıntı sabit değerinin içindeki bir 'let' bağlaması olacak şekilde taşınarak ayarlanması gerekebilir.</value>
  </data>
  <data name="patcPartialActivePatternsGenerateOneResult" xml:space="preserve">
    <value>Kısmen etkin desenler yalnızca bir sonuç oluşturabilir</value>
  </data>
  <data name="typeIsNotAccessible" xml:space="preserve">
    <value>Bu '{0}' türüne bu kod konumundan erişilemiyor</value>
  </data>
  <data name="tcListLiteralMaxSize" xml:space="preserve">
    <value>Bu liste ifadesi liste sabit değerlerinin en büyük boyutunu aşıyor. Daha büyük sabit değerler için dizi kullanın ve Array.ToList işlevini çağırın.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSealed" xml:space="preserve">
    <value>Uygulama türü korumalı olmasına rağmen imza korumalı olmamasını gerektirdiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. İmzaya [&lt;Sealed&gt;] özniteliğini eklemeyi düşünün.</value>
  </data>
  <data name="tcNamedArgumentDidNotMatch" xml:space="preserve">
    <value>'{0}' adlandırılmış bağımsız değişkeni herhangi bir bağımsız değişkenle veya değişebilir özelliğiyle eşleşmedi</value>
  </data>
  <data name="tcInvalidConstraintTypeSealed" xml:space="preserve">
    <value>Geçersiz kısıtlama: kısıtlama için kullanılan tür korumalı, yani bu kısıtlama yalnızca en çok tek çözümde karşılanabilir</value>
  </data>
  <data name="lexUnexpectedChar" xml:space="preserve">
    <value>Beklenmeyen karakter: '{0}'</value>
  </data>
  <data name="ExceptionDefsNotCompatibleHiddenBySignature" xml:space="preserve">
    <value>CLI özel durum eşlemesi imza aracılığıyla gizlendiği için özel durum tanımları uyumlu değil. Özel durum eşlemesi diğer modüllere görünmelidir. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviation" xml:space="preserve">
    <value>Modül kısaltmasındaki öznitelikler yoksayılıyor</value>
  </data>
  <data name="tcExpectedTypeNotUnitOfMeasure" xml:space="preserve">
    <value>Ölçü birimi değil tür bekleniyordu</value>
  </data>
  <data name="typrelTypeImplementsIComparableDefaultObjectEqualsProvided" xml:space="preserve">
    <value>'{0}' türü 'System.IComparable' metodunu açık olarak uyguluyor ancak 'Object.Equals' için buna karşılık gelen bir geçersiz kılma sağlamıyor. 'System.IComparable' aracılığıyla uygulanan 'Object.Equals' metodunun uygulaması otomatik olarak sağlandı. 'Object.Equals' geçersiz kılma işlemini açık olarak uygulamayı düşünün</value>
  </data>
  <data name="buildCouldNotResolveAssemblyRequiredByFile" xml:space="preserve">
    <value>'{1}' tarafından istenen '{0}' bütünleştirilmiş kodu çözümlenemedi</value>
  </data>
  <data name="tastInvalidMutationOfConstant" xml:space="preserve">
    <value>Sabit ifadesinin geçersiz olarak değiştirilmesi. İfadeyi değiştirilebilir bir yerel değere kopyalamayı düşünün, örn. 'let mutable x = ...'.</value>
  </data>
  <data name="optsWarnaserror" xml:space="preserve">
    <value>Belirli uyarıları hata olarak bildir</value>
  </data>
  <data name="considerUpcast" xml:space="preserve">
    <value>{0} türünden {1} türüne dönüştürme, bir alt türe çevirme değil, derleme zamanında güvenli bir üst türe çevirmedir. 'downcast' yerine 'upcast' kullanmayı düşünün.</value>
  </data>
  <data name="lexhlpIdentifierReserved" xml:space="preserve">
    <value>'{0}' tanımlayıcısı F# tarafından ileride kullanılmak üzere ayrılmıştır</value>
  </data>
  <data name="buildMultiFileRequiresNamespaceOrModule" xml:space="preserve">
    <value>Kitaplıklardaki veya çok dosyalı uygulamalardaki dosyalar ad alanı veya modül bildirimiyle başlamalıdır, örn. 'namespace SomeNamespace.SubNamespace' veya 'module SomeNamespace.SomeModule'. Bir uygulamanın yalnızca son kaynak dosyasında böyle bir bildirim atlanabilir.</value>
  </data>
  <data name="tcBindingCannotBeUseAndRec" xml:space="preserve">
    <value>Bir bağlama hem 'use' hem de 'rec' olarak işaretlenemez</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeArgs" xml:space="preserve">
    <value>Tür bağımsız değişkenlerinde beklenmeyen giriş sonu</value>
  </data>
  <data name="ValueNotContainedMutabilityVirtualsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri sanal, diğeri değil</value>
  </data>
  <data name="astDeprecatedIndexerNotation" xml:space="preserve">
    <value>Bu dizin erişimcisi gösterimi F# dilinden kaldırıldı</value>
  </data>
  <data name="tcTypeUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' türü geçersiz biçimde kullanılmış. '{1}' öğesinden önceki bir değer '{2}' içeren çıkarılmış türüne sahip, bu geçersiz bir ileriye doğru başvurudur.</value>
  </data>
  <data name="chkDuplicateMethodWithSuffix" xml:space="preserve">
    <value>Yinelenen metot. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra '{0}' metodu, '{1}' türündeki başka bir metotla aynı ada ve imzaya sahip oluyor.</value>
  </data>
  <data name="impNotEnoughTypeParamsInScopeWhileImporting" xml:space="preserve">
    <value>İç hata veya hatalı oluşturulmuş meta veri: içeri aktarma sırasında kapsamda yeterli tür parametresi yoktu</value>
  </data>
  <data name="ilIncorrectNumberOfTypeArguments" xml:space="preserve">
    <value>Yerel çağrı için hatalı sayıda tür bağımsız değişkeni</value>
  </data>
  <data name="parsSyntaxModuleSigEndDeprecated" xml:space="preserve">
    <value>'module ... : sig .. end' sözdizimi F# kodunda kullanılmaz. 'module ... = begin .. end' kullanmayı düşünün</value>
  </data>
  <data name="tcExpectedInterfaceType" xml:space="preserve">
    <value>Arabirim türü bekleniyordu</value>
  </data>
  <data name="tcInvalidMemberNameFixedTypes" xml:space="preserve">
    <value>'({0})' adına F# kitaplığında sabit türler üzerinden standart bir tanım verildiği için üye adı olarak kullanılmamalıdır</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeDefinition" xml:space="preserve">
    <value>Tür tanımında beklenmeyen giriş sonu</value>
  </data>
  <data name="impInvalidMeasureArgument2" xml:space="preserve">
    <value>Geçersiz değerli ölçü birimi parametresi '{0}'</value>
  </data>
  <data name="impInvalidMeasureArgument1" xml:space="preserve">
    <value>Ölçü birimi parametresi '{1}' için geçersiz '{0}' değeri</value>
  </data>
  <data name="tastInvalidFormForPropertyGetter" xml:space="preserve">
    <value>Özellik alıcı için geçersiz biçim. Açık sözdizimini kullanırken en az bir '()' bağımsız değişkeni gereklidir.</value>
  </data>
  <data name="etOneOrMoreErrorsSeenDuringExtensionTypeSetting" xml:space="preserve">
    <value>Sağlanan tür ayarları sırasında bir veya daha fazla hata görüldü</value>
  </data>
  <data name="tcConstructorForInterfacesDoNotTakeArguments" xml:space="preserve">
    <value>Arabirimlerin oluşturucu ifadeleri bağımsız değişken almaz</value>
  </data>
  <data name="optsInvalidWarningLevel" xml:space="preserve">
    <value>Geçersiz uyarı düzeyi '{0}'</value>
  </data>
  <data name="tcUnionCaseNameConflictsWithGeneratedType" xml:space="preserve">
    <value>'{0}' adlı birleşim durumu oluşturulan '{1}' türüyle çakışıyor</value>
  </data>
  <data name="tcNoAbstractOrVirtualMemberFound" xml:space="preserve">
    <value>'{0}' adlı üye, geçersiz kılma veya uygulama için kullanılabilen herhangi bir soyut veya sanal metoda karşılık gelmiyor.</value>
  </data>
  <data name="tcInvalidRecordConstruction" xml:space="preserve">
    <value>Geçersiz kayıt oluşturma</value>
  </data>
  <data name="ModuleContainsConstructorButTypesOfFieldsDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Alanların türleri farklı</value>
  </data>
  <data name="ilLabelNotFound" xml:space="preserve">
    <value>{0} etiketi bulunamadı</value>
  </data>
  <data name="activePatternChoiceHasFreeTypars" xml:space="preserve">
    <value>'{0}' etkin deseninde, giriş tarafından belirlenmeyen tür değişkenleri içeren bir sonuç türü var. Sonuç örneğinin belirtilmemesi bunun yaygın görülen nedenidir, örn. 'let (|A|B|) (x:int) = A x'. Bu durum, tür kısıtlaması ile düzeltilebilir, örn. 'let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x'</value>
  </data>
  <data name="csMemberSignatureMismatchArityNamed" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken alır ancak burada adlandırılmamış {2} ve adlandırılmış {3} bağımsız değişken verilmiş. Gereken imza: '{4}'.</value>
  </data>
  <data name="tastTypeOrModuleNotConcrete" xml:space="preserve">
    <value>'{0}' türü/modülü somut bir modül veya tür değil</value>
  </data>
  <data name="optsHelpBannerOutputFiles" xml:space="preserve">
    <value>- ÇIKIŞ DOSYALARI -</value>
  </data>
  <data name="csSeeAvailableOverloads" xml:space="preserve">
    <value>Kullanılabilen aşırı yüklemeler aşağıda (veya Hata Listesi penceresinde) gösterilmiştir.</value>
  </data>
  <data name="tcCustomOperationHasIncorrectArgCount" xml:space="preserve">
    <value>'{0}' hatalı sayıda bağımsız değişkenle kullanılıyor. Bu, geçerli sorgudaki veya hesaplama ifadesindeki özel bir işlemdir. {1} bağımsız değişken bekleniyordu, ancak {2} verildi.</value>
  </data>
  <data name="csMethodIsNotAnInstanceMethod" xml:space="preserve">
    <value>{0} bir örnek metodu değil</value>
  </data>
  <data name="tcObjectExpressionFormDeprecated" xml:space="preserve">
    <value>Nesne ifadesinin bu biçimi F# dilinde kullanılmaz. Nesne ifadelerinde üye uygulamalarını tanımlamak için 'member this.MemberName ... = ...' kullanın.</value>
  </data>
  <data name="tcUnexpectedExprAtRecInfPoint" xml:space="preserve">
    <value>Özyinelemeli çıkarım noktasında beklenmeyen ifade</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl" xml:space="preserve">
    <value>'{2}' soyut üyesi imza için gerekmesine rağmen uygulama tarafından belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcDoesNotAllowExplicitTypeArguments" xml:space="preserve">
    <value>'{0}' metodu veya işlevi kendi tür parametrelerini açık olarak tanımlamadığı için açık tür bağımsız değişkenleri verilmemelidir</value>
  </data>
  <data name="tastTypeHasAssemblyCodeRepresentation" xml:space="preserve">
    <value>'{0}' türünün satır içi bir bütünleştirilmiş kod kodu temsili var</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeAssignedToNonMutableField" xml:space="preserve">
    <value>Özyinelemeli değerler, özyinelemeli bir bağlama içinde '{1}' türünün değiştirilemeyen '{0}' alanına dorudan atanamaz. Onun yerine değiştirilebilir alan kullanmayı düşünün.</value>
  </data>
  <data name="optsMlcompatibility" xml:space="preserve">
    <value>ML uyumluluk uyarılarını yoksay</value>
  </data>
  <data name="memberOperatorDefinitionWithNoArguments" xml:space="preserve">
    <value>'{0}' Infix işleç üyesinde hiç bağımsız değişken yok. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</value>
  </data>
  <data name="tcConcreteMembersIllegalInInterface" xml:space="preserve">
    <value>Arabirimler somut üyelerin tanımlarını içeremez. Türün sınıf olduğunu belirtmek için türünüzde bir oluşturucu tanımlamanız gerekebilir.</value>
  </data>
  <data name="parsMissingQualificationAfterDot" xml:space="preserve">
    <value>'.' sonrasında eksik nitelik</value>
  </data>
  <data name="nrTypeInstantiationIsMissingAndCouldNotBeInferred" xml:space="preserve">
    <value>'{0}' genel türünün örneklenmesi eksik ve bu üyenin bağımsız değişkenlerinden ya da dönüş türünden çıkartılamıyor. Bu türe erişirken bir tür örneği sağlamayı düşünün, örn. '{1}'.</value>
  </data>
  <data name="parsActivePatternCaseMustBeginWithUpperCase" xml:space="preserve">
    <value>Etkin desen örneği tanımlayıcıları büyük harfle başlamalıdır</value>
  </data>
  <data name="forHIsUnnecessary" xml:space="preserve">
    <value>Bu biçim tanımlayıcıdaki 'h' veya 'H' gereksiz. Bunun yerine, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</value>
  </data>
  <data name="tcExpressionFormRequiresObjectConstructor" xml:space="preserve">
    <value>'expr then expr' ifade biçimi yalnızca açık nesne oluşturucunun parçası olarak kullanılabilir</value>
  </data>
  <data name="chkLimitationsOfBaseKeyword" xml:space="preserve">
    <value>'base' değerleri yalnızca geçersiz kılınmış üyelerin taban uygulamalarına doğrudan çağrı yapmak için kullanılabilir</value>
  </data>
  <data name="tastNotAConstantExpression" xml:space="preserve">
    <value>Bu geçerli bir sabit ifade veya özel öznitelik değeri değil</value>
  </data>
  <data name="tcInvalidMixtureOfRecursiveForms" xml:space="preserve">
    <value>Bu özyinelemeli bağlama özyinelemeli biçimlerin geçersiz bir karışımını kullanıyor</value>
  </data>
  <data name="tcImplementsGenericIComparableExplicitly" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'System.IComparable&lt;_&gt;' arabirimini açık olarak uyguluyor. Türe 'CustomComparison' özniteliğini uygulamanız ve aynı zamanda genel olmayan System.IComparable arabiriminin tutarlı bir uygulamasını sağlamanız gerekir.</value>
  </data>
  <data name="tcInvalidAssignment" xml:space="preserve">
    <value>Geçersiz atama</value>
  </data>
  <data name="parsEofInString" xml:space="preserve">
    <value>Dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="chkFirstClassFuncNoByref" xml:space="preserve">
    <value>Birinci sınıf bir işlevin türü byref'ler içeremez</value>
  </data>
  <data name="csTypeDoesNotSupportEquality2" xml:space="preserve">
    <value>'{0}' türünün bir işlev türü olduğu için 'equality' kısıtlamasını desteklemez</value>
  </data>
  <data name="csTypeDoesNotSupportEquality3" xml:space="preserve">
    <value>'{0}' türü, 'equality' kısıtlamasını desteklemeyen bir veya daha fazla yapısal öğe türünün olduğu bir record, union veya struct olduğu için 'equality' kısıtlamasını desteklemez. Bu türde eşitlik kullanmayın veya hangi alan türünün eşitliği desteklemediğini belirlemek için 'StructuralEquality' özniteliğini türe ekleyin</value>
  </data>
  <data name="csTypeDoesNotSupportEquality1" xml:space="preserve">
    <value>'{0}' türünün 'NoEquality' özniteliği olduğu için 'equality' kısıtlamasını desteklemez</value>
  </data>
  <data name="parsUnmatchedUseBang" xml:space="preserve">
    <value>Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'use!' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</value>
  </data>
  <data name="parsNonAtomicType" xml:space="preserve">
    <value>'int C' ve 'C  &lt;int&gt;' tür sözdizimi kullanımına burada izin verilmez. Bu türü 'C&lt;int&gt;' biçiminde yazılacak şekilde ayarlamayı düşünün</value>
  </data>
  <data name="forPrefixFlagSpacePlusSetTwice" xml:space="preserve">
    <value>Ön ek bayrağı (' ' veya '+') iki kez ayarlandı</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersKey" xml:space="preserve">
    <value>AssemblyFolders kayıt defteri anahtarı ile bulunur</value>
  </data>
  <data name="tcConstructRequiresSequenceOrComputations" xml:space="preserve">
    <value>Bu yapı yalnızca dizi ve hesaplama ifadeleri içinde kullanılabilir</value>
  </data>
  <data name="astParseEmbeddedILTypeError" xml:space="preserve">
    <value>Gömülü IL türü ayrıştırılırken hata oluştu</value>
  </data>
  <data name="tcIllegalAttributesForLiteral" xml:space="preserve">
    <value>Bir sabit değere [&lt;ThreadStatic&gt;] veya [&lt;ContextStatic&gt;] öznitelikleri verilemez</value>
  </data>
  <data name="etInvalidTypeProviderAssemblyName" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodunun geçersiz '{1}' değerli TypeProviderAssembly özniteliği var. Bu değer geçerli bir bütünleştirilmiş kod adı olmalıdır</value>
  </data>
  <data name="tcFunctionRequiresExplicitLambda" xml:space="preserve">
    <value>Bu işlev değeri, imzası byref bağımsız değişkeni içeren bir temsilci türü oluşturmak için kullanılıyor. {0} bağımsız değişken alan açık lambda ifadesi kullanmanız gerekir.</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsCannotTakeArguments" xml:space="preserve">
    <value>Ortak Ara Dil özel durumlarının kısaltmaları bağımsız değişken alamaz</value>
  </data>
  <data name="tcEnumTypeCannotBeEnumerated" xml:space="preserve">
    <value>'{0}' türü geçerli bir numaralandırıcı türü değil, yani bool döndüren bir 'MoveNext()' metodu ve 'Current' özelliği yok</value>
  </data>
  <data name="parsEofInDirective" xml:space="preserve">
    <value>Yönergede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="forFormatDoesntSupportPrecision" xml:space="preserve">
    <value>'{0}' biçimi duyarlığı desteklemiyor</value>
  </data>
  <data name="tcConstructorRequiresCall" xml:space="preserve">
    <value>'{0}' türünün oluşturucuları doğrudan veya dolaylı olarak kendi örtük nesne oluşturucusunu çağırmalıdır. Kayıt ifadesi yerine örtük nesne oluşturucusu çağrısını kullanın.</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly" xml:space="preserve">
    <value>'{0}' doğru kullanılmadı. Bu, geçerli sorguda veya hesaplama ifadesinde özel bir işlemdir.</value>
  </data>
  <data name="parsUnmatchedLBrackLess" xml:space="preserve">
    <value>Eşleşmeyen '[&lt;'. Beklenen kapanış '&gt;]'</value>
  </data>
  <data name="tcFixedNotAllowed" xml:space="preserve">
    <value>Geçersiz 'fixed' kullanımı. 'fixed' yalnızca 'use x = fixed expr' biçimindeki bir bildirimde kullanılabilir. Burada ifade bir dizi, bir alanın adresi, bir dizi öğesinin adresi veya bir dizedir</value>
  </data>
  <data name="etIllegalCharactersInTypeName" xml:space="preserve">
    <value>'{1}' sağlanan tür adında '{0}' karakterine izin verilmez</value>
  </data>
  <data name="etStaticParameterRequiresAValue" xml:space="preserve">
    <value>'{1}' sağlanan tür veya metodunun '{0}' statik parametresi için bir değer gerekiyor. Tür sağlayıcılarının statik parametreleri adlandırılmış bağımsız değişkenler kullanılarak isteğe göre belirtilebilir: Örn. '{2}&lt;{3}=...&gt;'.</value>
  </data>
  <data name="tcUnexpectedMeasureAnon" xml:space="preserve">
    <value>Beklenmeyen SynMeasure.Anon</value>
  </data>
  <data name="parsAssertIsNotFirstClassValue" xml:space="preserve">
    <value>'assert' birinci sınıf değer olarak kullanılamaz. Onun yerine 'assert &lt;ifade&gt;' kullanın.</value>
  </data>
  <data name="tcCannotInheritFromVariableType" xml:space="preserve">
    <value>Değişken türünden devralınamıyor</value>
  </data>
  <data name="unionCasesAreNotAccessible" xml:space="preserve">
    <value>'{0}' türünün birleşim durumlarına veya alanlarına bu kod konumundan erişilemiyor</value>
  </data>
  <data name="tcMutableValuesSyntax" xml:space="preserve">
    <value>Değişebilir işlev değerleri 'let mutable f = (fun args -&gt; ...)' şeklinde yazılmalıdır</value>
  </data>
  <data name="parsOnlyClassCanTakeValueArguments" xml:space="preserve">
    <value>Yalnızca sınıf türleri değer bağımsız değişkenleri alabilir</value>
  </data>
  <data name="buildInvalidWarningNumber" xml:space="preserve">
    <value>Geçersiz uyarı numarası '{0}'</value>
  </data>
  <data name="csTypeHasNonStandardDelegateType" xml:space="preserve">
    <value>'{0}' türünün standart olmayan temsilci türü var</value>
  </data>
  <data name="tcArgumentArityMismatch" xml:space="preserve">
    <value>'{0}' üyesine doğru sayıda bağımsız değişken geçirilmedi. {1} bağımsız değişken bekleniyor ancak geçerli sayı, {2}. Gerekli imza: '{3}'.{4}</value>
  </data>
  <data name="typeInfoPatternVariable" xml:space="preserve">
    <value>patvar</value>
  </data>
  <data name="ValueNotContainedMutabilityFinalsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri nihai, diğeri değil</value>
  </data>
  <data name="delegatesNotAllowedToHaveCurriedSignatures" xml:space="preserve">
    <value>Temsilcilerin eksiltimli imzaları olmasına izin verilmez</value>
  </data>
  <data name="optsPlatform" xml:space="preserve">
    <value>Bu kodun üzerinde çalışabileceği platformları sınırlandırın: x86, Itanium, x64, anycpu32bitpreferred veya anycpu. Varsayılan: anycpu.</value>
  </data>
  <data name="tcExpectedUnitOfMeasureNotType" xml:space="preserve">
    <value>Tür değil ölçü birimi bekleniyordu</value>
  </data>
  <data name="optsWin32res" xml:space="preserve">
    <value>Win32 kaynak dosyası (.res) belirtin</value>
  </data>
  <data name="tcLocalClassBindingsCannotBeInline" xml:space="preserve">
    <value>Yerel sınıf bağlamaları satır içi olarak işaretlenemez. Tanımı sınıftan çıkarmayı düşünün veya satır içi olarak işaretlemeyin.</value>
  </data>
  <data name="descriptionUnavailable" xml:space="preserve">
    <value>(açıklama yok...)</value>
  </data>
  <data name="undefinedNameTypeIn" xml:space="preserve">
    <value>'{0}' türü '{1}' içinde tanımlı değil.</value>
  </data>
  <data name="parsIdentifierExpected" xml:space="preserve">
    <value>Tanımlayıcı bekleniyor</value>
  </data>
  <data name="ppparsUnexpectedToken" xml:space="preserve">
    <value>Önişlemci ifadesinde beklenmeyen belirteç: '{0}'</value>
  </data>
  <data name="forPrecisionMissingAfterDot" xml:space="preserve">
    <value>'.' karakterinden sonra duyarlık eksik</value>
  </data>
  <data name="crefNoSetOfHole" xml:space="preserve">
    <value>Bir alıntı, yakalanan yerel değişkenin adresine atama içeremez veya bu adresi alamaz</value>
  </data>
  <data name="optsInternalNoDescription" xml:space="preserve">
    <value>'{0}' komut satırı seçeneği yalnızca test amaçlıdır</value>
  </data>
  <data name="yieldUsedInsteadOfYieldBang" xml:space="preserve">
    <value>'yield' yerine 'yield!' kullanmayı deneyin.</value>
  </data>
  <data name="tcInheritedTypeIsNotObjectModelType" xml:space="preserve">
    <value>Devralınan tür bir nesne modeli türü değil</value>
  </data>
  <data name="ilMainModuleEmpty" xml:space="preserve">
    <value>Ana program modülü boş: çalıştırıldığında hiçbir şey olmayacak</value>
  </data>
  <data name="fscAssemblyWildcardAndDeterminism" xml:space="preserve">
    <value>Bir {0} tarafından '{1}' sürümü belirtildi. Ancak siz belirleyici bir derleme istediniz, bu ise bir joker karakter ve bunlar çakışıyor.</value>
  </data>
  <data name="fscResxSourceFileDeprecated" xml:space="preserve">
    <value>.resx dosyasını ({0}) kaynak dosya olarak derleyiciye geçirmek kullanım dışı bırakıldı. .resx dosyasını bir --resource seçeneği olarak geçirmek üzere .resources dosyasına dönüştürmek için resgen.exe kullanın. MSBuild kullanıyorsanız, .fsproj proje dosyasındaki &lt;EmbeddedResource&gt; öğesi aracılığıyla bu yapılabilir.</value>
  </data>
  <data name="tcModuleAbbreviationForNamespace" xml:space="preserve">
    <value>'{0}' yolu bir ad alanı. Modül kısaltması bir ad alanını kısaltamaz.</value>
  </data>
  <data name="tcValueInSignatureRequiresLiteralAttribute" xml:space="preserve">
    <value>Bir bildirimin imzasına değer yalnızca o bildirimin [&lt;Literal&gt;] özniteliği varsa verilebilir</value>
  </data>
  <data name="etProvidedTypeWithNameException" xml:space="preserve">
    <value>{1} sağlanan türünün '{0}' öğesine erişirken bir özel durum oluştu</value>
  </data>
  <data name="keywordDescriptionInternal" xml:space="preserve">
    <value>Bir üyenin bütünleştirilmiş kodun içinde görünür olduğunu, dışında ise görünmediğini belirtmek için kullanılır.</value>
  </data>
  <data name="parsNoHashEndIfFound" xml:space="preserve">
    <value>#if veya #else için bir #endif bulunamadı</value>
  </data>
  <data name="tastInvalidMemberSignature" xml:space="preserve">
    <value>Önceki bir hata nedeniyle geçersiz üye imzasıyla karşılaşıldı</value>
  </data>
  <data name="tcFieldNameConflictsWithGeneratedNameForAnonymousField" xml:space="preserve">
    <value>Adlandırılmış alan '{0}', anonim alanın otomatik oluşturulmuş adıyla çakışıyor.</value>
  </data>
  <data name="buildInvalidHashtimeDirective" xml:space="preserve">
    <value>Geçersiz yönerge. Beklenen: '#time', '#time \"on\"' veya '#time \"off\"'.</value>
  </data>
  <data name="parsEnumTypesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine enum türlerinin bu konumunda izin verilmez</value>
  </data>
  <data name="parsAttributesIllegalHere" xml:space="preserve">
    <value>Özniteliklere burada izin verilmez</value>
  </data>
  <data name="optsHelpBannerLanguage" xml:space="preserve">
    <value>- DİL -</value>
  </data>
  <data name="optsUnrecognizedDebugType" xml:space="preserve">
    <value>Tanınmayan hata ayıklama türü: '{0}'; 'pdbonly' veya 'full' bekleniyordu</value>
  </data>
  <data name="tcIntoNeedsRestOfQuery" xml:space="preserve">
    <value>'into' kullanımını hesaplamanın geri kalanı izlemelidir</value>
  </data>
  <data name="chkNoFirstClassRethrow" xml:space="preserve">
    <value>'reraise' işlevinin birinci sınıf kullanımlarına izin verilmiyor</value>
  </data>
  <data name="parsMissingGreaterThan" xml:space="preserve">
    <value>Eşleşmeyen '&lt;'. Kapanış karakteri '&gt;' bekleniyordu</value>
  </data>
  <data name="tastUndefinedItemRefVal" xml:space="preserve">
    <value>'{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' değerini içermiyordu</value>
  </data>
  <data name="tcFunctionRequiresExplicitTypeArguments" xml:space="preserve">
    <value>'{0}' genel işlevine açık tür bağımsız değişkenleri verilmesi gerekiyor</value>
  </data>
  <data name="etPropertyCanReadButHasNoGetter" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' özelliğinde CanRead=true var, ancak GetGetMethod() yönteminden bir değer yok</value>
  </data>
  <data name="chkReturnTypeNoByref" xml:space="preserve">
    <value>Bir metot dönüş türü byref'ler içeriyordu, buna izin verilmez</value>
  </data>
  <data name="tcEventIsStatic" xml:space="preserve">
    <value>'{0}' olayı statik</value>
  </data>
  <data name="lexTokenReserved" xml:space="preserve">
    <value>Bu belirteç ileride kullanılmak üzere ayrılmıştır</value>
  </data>
  <data name="tcOpenFirstInMutRec" xml:space="preserve">
    <value>Özyinelemeli bir bildirim grubunda, 'open' bildirimleri her modülde en başta olmalıdır</value>
  </data>
  <data name="etNullOrEmptyMemberName" xml:space="preserve">
    <value>'{0}' sağlanan türü null veya boş üye adı olan bir üye döndürdü</value>
  </data>
  <data name="forBadFormatSpecifier" xml:space="preserve">
    <value>Hatalı biçim tanımlayıcı (l veya L'den sonra): ld,li,lo,lu,lx veya lX bekleniyordu. Bunun yerine F# kodunda, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</value>
  </data>
  <data name="infosInvalidProvidedLiteralValue" xml:space="preserve">
    <value>Sağlanan sabit değer '{0}' geçersiz</value>
  </data>
  <data name="tcInterfaceTypesCannotBeSealed" xml:space="preserve">
    <value>Arabirim türleri korumalı olamaz</value>
  </data>
  <data name="checkLowercaseLiteralBindingInPattern" xml:space="preserve">
    <value>Küçük harf '{0}' değişmez değeri aynı ada sahip yeni bir desen tarafından engelleniyor. Adlandırılmış desenler olarak yalnızca büyük harf ve module ön eki almış değişmez değerler kullanılabilir.</value>
  </data>
  <data name="ilUndefinedValue" xml:space="preserve">
    <value>Tanımsız değer '{0}'</value>
  </data>
  <data name="tcConstructRequiresListArrayOrSequence" xml:space="preserve">
    <value>Bu yapı, yalnızca liste, dizi ve sıra ifadeleri içinde, örn. 'seq {{ ... }}', '[ ... ]' veya '[| ... |]' biçimindeki ifadelerde kullanılabilir. Bunlarda öğe oluşturmak için 'for ... in ... do ... yield...' sözdizimi kullanılır</value>
  </data>
  <data name="tcCustomAttributeMustBeReferenceType" xml:space="preserve">
    <value>Özel öznitelik başvuru türünde olmalıdır</value>
  </data>
  <data name="tcStaticFieldUsedWhenInstanceFieldExpected" xml:space="preserve">
    <value>Örnek alanı beklenen yerde statik alan kullanılmış</value>
  </data>
  <data name="parsUnmatchedParen" xml:space="preserve">
    <value>Eşleşmeyen '('</value>
  </data>
  <data name="csMethodIsOverloaded" xml:space="preserve">
    <value>Bu program noktasından önce, tür bilgilerine dayalı olarak '{0}' metodu için benzersiz bir aşırı yükleme belirlenemedi. Tür ek açıklaması gerekebilir.</value>
  </data>
  <data name="csMemberIsNotAccessible" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}', {1} değil</value>
  </data>
  <data name="optsDebugPM" xml:space="preserve">
    <value>Hata ayıklama bilgilerini yay (Kısa biçimi: -g)</value>
  </data>
  <data name="fscKeyFileWarning" xml:space="preserve">
    <value>'--keyfile' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyKeyFileAttribute' özniteliğini geçersiz kılar</value>
  </data>
  <data name="optsResponseFile" xml:space="preserve">
    <value>Daha fazla seçenek için yanıt dosyasını okuyun</value>
  </data>
  <data name="parsUnmatchedBrace" xml:space="preserve">
    <value>Eşleşmeyen '{{'</value>
  </data>
  <data name="parsUnmatchedBegin" xml:space="preserve">
    <value>Eşleşmeyen 'begin'</value>
  </data>
  <data name="tcNonSimpleLetBindingInQuery" xml:space="preserve">
    <value>Bu 'let' tanımı sorguda kullanılamaz. Sorgularda yalnızca basit değer tanımları kullanılabilir.</value>
  </data>
  <data name="chkProtectedOrBaseCalled" xml:space="preserve">
    <value>Korunan bir üye çağrıldı veya 'base' kullanılıyor. Üyeler nesne kapsamlarını kaçırabildikleri için buna yalnızca üyeler doğrudan uygulandığında izin verilir.</value>
  </data>
  <data name="parsNonAdjacentTyargs" xml:space="preserve">
    <value>Tür bağımsız değişkenleri doğrudan tür adının bitişiğine yerleştirilmelidir, örn. \"C  &lt;'T&gt;\" değil \"C&lt;'T&gt;\"</value>
  </data>
  <data name="parsNonAdjacentTypars" xml:space="preserve">
    <value>Tür parametreleri doğrudan tür adının bitişiğine yerleştirilmelidir, örn. type \"C   &lt;'T&gt;\" değil \"type C&lt;'T&gt;\"</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInPrintf" xml:space="preserve">
    <value>'printf' stilindeki biçim dizesinin kullanılmasına bulunan belirsizlik çözümlenemedi.</value>
  </data>
  <data name="parsErrorInReturnForLetIncorrectIndentation" xml:space="preserve">
    <value>Bu 'let' için dönüş ifadesinde hata. Muhtemelen hatalı girinti.</value>
  </data>
  <data name="typrelCannotResolveImplicitGenericInstantiation" xml:space="preserve">
    <value>Genel yapının bu konumda veya yakınında örtük olarak örneklenmesi çözümlenemedi, çünkü ilişkisiz birden çok türe çözümlenebiliyordu, örn. '{0}' ve '{1}'. Belirsizliği çözümlemek için tür ek açıklamaları kullanmayı düşünün</value>
  </data>
  <data name="tcOptionalArgsMustComeAfterNonOptionalArgs" xml:space="preserve">
    <value>İsteğe bağlı bağımsız değişkenler bağımsız değişken listesinin sonunda, isteğe bağlı olmayan tüm bağımsız değişkenlerden sonra gelmelidir</value>
  </data>
  <data name="parsErrorParsingAsOperatorName" xml:space="preserve">
    <value>Bu bir işleç adı olarak ayrıştırılmaya çalışıldı, ancak yapılamadı</value>
  </data>
  <data name="optsReference" xml:space="preserve">
    <value>Bütünleştirilmiş koda başvur (Kısa biçimi: -r)</value>
  </data>
  <data name="assemblyResolutionFoundByAssemblyFoldersExKey" xml:space="preserve">
    <value>AssemblyFoldersEx kayıt defteri anahtarı ile bulunur</value>
  </data>
  <data name="parsGetOrSetRequired" xml:space="preserve">
    <value>'get', 'set' veya 'get,set' gerekiyor</value>
  </data>
  <data name="buildArgInvalidFloat" xml:space="preserve">
    <value>'{0}' geçerli bir kayan nokta bağımsız değişkeni değil</value>
  </data>
  <data name="optsDCLODeprecatedSuggestAlternative" xml:space="preserve">
    <value>Komut satırı seçeneği '{0}' kullanım dışı bırakıldı. Onun yerine '{1}' kullanın.</value>
  </data>
  <data name="augCustomEqNeedsObjEquals" xml:space="preserve">
    <value>'CustomEquality' özniteliği olan bir türde, 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' veya 'System.Collections.IStructuralEquatable' metotlarından en az biri açık olarak uygulanmış olmalıdır</value>
  </data>
  <data name="tcUnexpectedSymbolInTypeExpression" xml:space="preserve">
    <value>Tür ifadesinde beklenmeyen {0}</value>
  </data>
  <data name="tcUnrecognizedAttributeTarget" xml:space="preserve">
    <value>Tanınmayan öznitelik hedefi. Geçerli öznitelik hedefleri şunlardır: 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'.</value>
  </data>
  <data name="parsMissingFunctionBody" xml:space="preserve">
    <value>Eksik işlev gövdesi</value>
  </data>
  <data name="parsUnexpectedVisibilityDeclaration" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine burada izin verilmez, ancak '{0}' belirtildi.</value>
  </data>
  <data name="tcTypesCannotContainNestedTypes" xml:space="preserve">
    <value>Türler iç içe tür tanımları içeremez</value>
  </data>
  <data name="optsConsoleColors" xml:space="preserve">
    <value>Renkli çıkış uyarısı ve hata iletileri</value>
  </data>
  <data name="tcInvalidUseOfTypeName" xml:space="preserve">
    <value>Geçersiz tür adı kullanımı</value>
  </data>
  <data name="tastValueDoesNotHaveSetterType" xml:space="preserve">
    <value>Bu değerin geçerli bir özellik ayarlayıcı türü yok</value>
  </data>
  <data name="buildInvalidSearchDirectory" xml:space="preserve">
    <value>Arama dizini '{0}' geçersiz</value>
  </data>
  <data name="optsLinkresource" xml:space="preserve">
    <value>Belirtilen kaynağı bu bütünleştirilmiş koda bağlayın, burada resinfo biçimi: &lt;dosya&gt;[,&lt;dize adı&gt;[,public|private]]</value>
  </data>
  <data name="parsIllegalDenominatorForMeasureExponent" xml:space="preserve">
    <value>Ölçü birimi üssünde payda 0 olmamalıdır</value>
  </data>
  <data name="tcInheritCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>Arabirim türlerinde 'inherit' kullanılamaz. Onun yerine arabirimi 'interface ... with ... end' kullanarak uygulamayı düşünün.</value>
  </data>
  <data name="parsUnexpectedIntegerLiteralForUnitOfMeasure" xml:space="preserve">
    <value>Ölçü birimi ifadesinde beklenmeyen tamsayı sabit değeri</value>
  </data>
  <data name="tcNamedTypeRequired" xml:space="preserve">
    <value>'{0}' yalnızca adlandırılmış türlerle kullanılır</value>
  </data>
  <data name="csMemberSignatureMismatchArity" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken alır ancak burada {2} bağımsız değişken verilmiş. Gereken imza: '{3}'.</value>
  </data>
  <data name="chkUnionCaseDefaultAugmentation" xml:space="preserve">
    <value>birleşim durumunun varsayılan genişletmesi</value>
  </data>
  <data name="notAFunction" xml:space="preserve">
    <value>Bu değer, bir işlev değil ve uygulanamaz.</value>
  </data>
  <data name="forMissingFormatSpecifier" xml:space="preserve">
    <value>Biçim belirticisi eksik</value>
  </data>
  <data name="parsIndexerPropertyRequiresAtLeastOneArgument" xml:space="preserve">
    <value>Dizin erişimcisi özelliğine en az bir bağımsız değişken verilmelidir</value>
  </data>
  <data name="optsUnrecognizedTarget" xml:space="preserve">
    <value>Tanınmayan hedef '{0}'; 'exe', 'winexe', 'library' veya 'module' bekleniyordu</value>
  </data>
  <data name="parsWhileDoExpected" xml:space="preserve">
    <value>'while' ifadesinde eksik 'do'. 'while &lt;ifade&gt; do &lt;&lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFunBody" xml:space="preserve">
    <value>Lambda ifadesi gövdesinde beklenmeyen giriş sonu. 'fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="docfileNoXmlSuffix" xml:space="preserve">
    <value>Belge dosyasında bir .xml son eki yok</value>
  </data>
  <data name="parsArrowUseIsLimited" xml:space="preserve">
    <value>Dizi ve hesaplama ifadelerinde '-&gt;' kullanımı 'for pat in expr -&gt; expr' biçimiyle sınırlıdır. Daha karmaşık dizi ifadelerinde öğeler oluşturmak için 'for ... in ... do ... yield...' sözdizimini kullanın.</value>
  </data>
  <data name="parsGetterMustHaveAtLeastOneArgument" xml:space="preserve">
    <value>Alıcı özelliğinin işlev olması bekleniyor, örn. 'get() = ...' veya 'get(index) = ...'</value>
  </data>
  <data name="parsMismatchedQuote" xml:space="preserve">
    <value>'{0}' ile başlayan, eşleşmeyen alıntı</value>
  </data>
  <data name="lexOutsideSixtyFourBitUnsigned" xml:space="preserve">
    <value>Bu sayı, 64 bit işaretsiz tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="itemNotFoundInTypeDuringDynamicCodeGen" xml:space="preserve">
    <value>'{3}' bütünleştirilmiş kodundaki '{2}' türünde {0} '{1}' bulunamadı. Bunun nedeni sürüm uyumsuzluğu olabilir. Başvurulan tüm bileşenlerin doğru sürümü kullanmasına izin vermek için bu bütünleştirilmiş kodun doğru sürümüne açıkça başvurmanız gerekebilir.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersAreDifferentKinds" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzadaki ve uygulamadaki genel parametrelerin çeşitleri farklı. Belki [&lt;Measure&gt;] özniteliği eksik olabilir.</value>
  </data>
  <data name="ilTypeCannotBeUsedForLiteralField" xml:space="preserve">
    <value>Bu tür, sabit değer alanı için kullanılamaz</value>
  </data>
  <data name="optsTailcalls" xml:space="preserve">
    <value>Tail çağrılarını etkinleştir veya devre dışı bırak</value>
  </data>
  <data name="tcEmptyCopyAndUpdateRecordInvalid" xml:space="preserve">
    <value>Kayıt kopyalama ve güncelleştirme ifadeleri en az bir alan içermelidir.</value>
  </data>
  <data name="parsEofInStringInComment" xml:space="preserve">
    <value>Açıklamaya gömülü dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="tcMissingCustomOperation" xml:space="preserve">
    <value>'{0}' için özel bir sorgu işlemi gerekiyor ancak belirtilmemiş</value>
  </data>
  <data name="parsInvalidLiteralInType" xml:space="preserve">
    <value>Türde geçersiz sabit değer</value>
  </data>
  <data name="typrelMemberHasMultiplePossibleDispatchSlots" xml:space="preserve">
    <value>'{0}' adlı üye, aynı metodun birden fazla aşırı yüklemesiyle eşleşiyor.\nLütfen şunlardan biriyle kısıtlayın: {1}.</value>
  </data>
  <data name="tcStructUnionMultiCaseDistinctFields" xml:space="preserve">
    <value>Bir birleşim türü büyük ve küçük harfler içeriyorsa ve bir yapıysa, birleşim türü içindeki tüm alanlara benzersiz adlar verilmelidir.</value>
  </data>
  <data name="etPropertyNeedsCanWriteOrCanRead" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' özelliğinde CanRead=false ve CanWrite=false olduğu için özellik okunabilir veya yazılabilir değil</value>
  </data>
  <data name="typeInfoGeneratedProperty" xml:space="preserve">
    <value>oluşturulan özellik</value>
  </data>
  <data name="tcStaticValFieldsMustBeMutableAndPrivate" xml:space="preserve">
    <value>Türlerdeki statik 'val' alanları değiştirilebilir, özel ve '[&lt;DefaultValue&gt;]' özniteliğiyle işaretlenmiş olmalıdır. Bunlar, türlerine yönelik olarak 'null' veya 'zero' ile başlatılır. Ayrıca sınıf türünde 'static let mutable' bağlaması kullanmayı düşünün.</value>
  </data>
  <data name="csMethodExpectsParams" xml:space="preserve">
    <value>Bu metot bu konumda CLI 'params' parametresini bekler. 'params', C# gibi dillerde değişken sayıda bağımsız değişkeni bir metoda geçirme yoludur. Bu bağımsız değişken için bir dizi geçirmeyi düşünün</value>
  </data>
  <data name="tcUninitializedValFieldsMustBeMutable" xml:space="preserve">
    <value>Başlatması geri alınmış 'val' alanları değişebilir olmalı ve '[&lt;DefaultValue&gt;]' özniteliğiyle işaretlenmelidir. 'val' alanı yerine 'let' bağlaması kullanmayı düşünün.</value>
  </data>
  <data name="etMustNotBeGeneric" xml:space="preserve">
    <value>'{0}' sağlanan türünde 'IsGenericType' true olarak mevcut, ancak genel türler desteklenmiyor.</value>
  </data>
  <data name="optsCopyright" xml:space="preserve">
    <value>Telif hakkı (c) Microsoft Corporation. Tüm hakları saklıdır.</value>
  </data>
  <data name="crefQuotationsCantSetExceptionFields" xml:space="preserve">
    <value>Alıntılar, özel durum değerleri içinde alanlar ayarlayan ifadeler içeremez</value>
  </data>
  <data name="lexByteArrayCannotEncode" xml:space="preserve">
    <value>Bu bayt dizisi sabit değeri tek bayt olarak kodlanmayan karakterler içeriyor</value>
  </data>
  <data name="parsAttributesMustComeBeforeVal" xml:space="preserve">
    <value>Öznitelikler 'val' öğesinin önüne konulmalıdır</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot" xml:space="preserve">
    <value>Uygulamada '{3}' adlı {2} tanımlanmasına rağmen imzada tanımlanmadığından (veya farklı sırada tanımlandığından), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcAnonymousUnitsOfMeasureCannotBeNested" xml:space="preserve">
    <value>Anonim ölçü birimi başka bir ölçü birimi ifadesinin içine konamaz</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDiffer" xml:space="preserve">
    <value>'{0}' tür parametresinin bildirimi {1} biçiminin kısıtlamasını gerektirdiği için imza ve uygulama uyumlu değil</value>
  </data>
  <data name="tcTypeOrModule" xml:space="preserve">
    <value>tür veya modül</value>
  </data>
  <data name="etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters" xml:space="preserve">
    <value>İç içe sağlanan türler bağımsız değişken veya genel parametre almaz</value>
  </data>
  <data name="parsUnexpectedEndOfFileExpression" xml:space="preserve">
    <value>İfadede beklenmeyen giriş sonu</value>
  </data>
  <data name="tcModuleRequiresQualifiedAccess" xml:space="preserve">
    <value>Bu bildirim, 'RequireQualifiedAccess' olarak işaretlenmiş '{0}' modülünü açar. Bunun yerine, kodunuzu modülün öğelerine yapılan nitelikli başvuruları kullanacak şekilde ayarlayın, örn. 'map' yerine 'List.map'. Bu değişiklik, kitaplıklara yeni yapılar eklendikçe kodunuzun sağlam kalmasını sağlar.</value>
  </data>
  <data name="tcDeclarationElementNotPermittedInAugmentation" xml:space="preserve">
    <value>Bir genişletmede bu tanımlama öğesine izin verilmez</value>
  </data>
  <data name="csCtorSignatureMismatchArity" xml:space="preserve">
    <value>'{0}' nesne oluşturucusunun {1} bağımsız değişken alması gerekiyor, ancak burada {2} bağımsız değişken almış. Gerekli imza: '{3}'.</value>
  </data>
  <data name="tcNewMemberHidesAbstractMember" xml:space="preserve">
    <value>Bu yeni üye, '{0}' soyut üyesini gizliyor. Üyeyi yeniden adlandırın veya bunun yerine 'override' kullanın.</value>
  </data>
  <data name="tcKindOfTypeSpecifiedDoesNotMatchDefinition" xml:space="preserve">
    <value>Öznitelikleriyle belirtilen türün çeşidi tanımıyla kastedilen çeşitle eşleşmiyor</value>
  </data>
  <data name="fscProblemWritingBinary" xml:space="preserve">
    <value>'{0}' ikili dosyası yazılırken bir sorun oluştu: {1}</value>
  </data>
  <data name="tcInvalidNonPrimitiveLiteralInPatternMatch" xml:space="preserve">
    <value>Temel olmayan sayısal sabit değer sabitleri NumericLiteral modülünün kullanılması aracılığıyla birçok farklı türe eşlenebileceği için desen eşlemelerinde kullanılamazlar. Bir değişkenle değiştirmeyi ve eşleştirme yan tümcesinin sonunda 'when &lt;variable&gt; = &lt;constant&gt;' kullanmayı düşünün.</value>
  </data>
  <data name="typrelSigImplNotCompatibleCompileTimeRequirementsDiffer" xml:space="preserve">
    <value>Sınıf/imzadaki tür parametresinin üye/uygulama içindekinden farklı bir derleme zamanı gereksinimi olduğu için imza ve uygulama uyumlu değil</value>
  </data>
  <data name="checkRaiseFamilyFunctionArgumentCount" xml:space="preserve">
    <value>'{0}' işlevindeki gereksiz bağımsız değişkenler yoksayılıyor. {1} bekleniyordu, ancak {2} bağımsız değişken alındı.</value>
  </data>
  <data name="tcCustomAttributeMustInvokeConstructor" xml:space="preserve">
    <value>Özel öznitelik nesne oluşturucusunu çağırmalıdır</value>
  </data>
  <data name="tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields" xml:space="preserve">
    <value>'expr.id' sözdizimi yalnızca kayıt etiketleri, özellikler ve alanlarla kullanılabilir</value>
  </data>
  <data name="parsExpectedTypeAfterToken" xml:space="preserve">
    <value>Bu noktadan sonra bir tür bekleniyordu</value>
  </data>
  <data name="augNoRefEqualsOnStruct" xml:space="preserve">
    <value>'ReferenceEquality' özniteliği struct öğelerinde kullanılamaz. Onun yerine 'StructuralEquality' özniteliğini kullanın veya 'System.Object.Equals(obj)' için geçersiz kılma uygulayın.</value>
  </data>
  <data name="typrelOverrideImplementsMoreThenOneSlot" xml:space="preserve">
    <value>'{0}' geçersiz kılma işlemi birden fazla soyut yuva uyguluyor, örn. '{1}' ve '{2}'</value>
  </data>
  <data name="tcArgumentArityMismatchOneOverload" xml:space="preserve">
    <value>'{0}' üyesine doğru sayıda bağımsız değişken geçirilmedi. Bir aşırı yükleme {1} bağımsız değişken kabul ediyor ancak geçerli sayı {2}. Gerekli imza: '{3}'.{4}</value>
  </data>
  <data name="parsModuleDefnMustBeSimpleName" xml:space="preserve">
    <value>Modül adı yol değil, basit ad olmalıdır</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSetNotJustSet" xml:space="preserve">
    <value>Bu özelliğin ayarlanabileceğini belirtmek için 'member val PropertyName = expr with get,set' kullanın.</value>
  </data>
  <data name="fsharpCoreNotFoundToBeCopied" xml:space="preserve">
    <value>Derleyici dizininde FSharp.Core.dll bulunamıyor</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes" xml:space="preserve">
    <value>Türler farklı temel türlere sahip olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="csNoOverloadsFound" xml:space="preserve">
    <value>Hiçbir aşırı yükleme '{0}' metodu ile eşleşmiyor.</value>
  </data>
  <data name="nrIsNotConstructorOrLiteral" xml:space="preserve">
    <value>Bu bir oluşturucu veya sabit değer değil ya da bir oluşturucu hatalı kullanılıyor</value>
  </data>
  <data name="tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure" xml:space="preserve">
    <value>Yalnızca ölçü birimlerini temsil eden türlere 'Measure' özniteliği verilebilir</value>
  </data>
  <data name="csExpectedArguments" xml:space="preserve">
    <value>Örnek üye için bağımsız değişkenler bekleniyordu</value>
  </data>
  <data name="tcLessGenericBecauseOfAnnotation" xml:space="preserve">
    <value>Açık tür değişkeni '{0}' oluşturulamadığı için bu kod ek açıklamalarının gerektirdiğinden daha az genel. '{1}' olacak şekilde kısıtlanmıştı.</value>
  </data>
  <data name="tcInvalidOperatorDefinitionEquality" xml:space="preserve">
    <value>'{0}' işleci normalde yeniden tanımlanmamalıdır. Bir türün eşitlik semantiğini tanımlamak için o türün tanımında 'Object.Equals' üyesini geçersiz kılın.</value>
  </data>
  <data name="augRefEqCantHaveObjEquals" xml:space="preserve">
    <value>'ReferenceEquality' özniteliği olan bir türde, 'Object.Equals(obj)', 'System.IEquatable&lt;_&gt;' veya 'System.Collections.IStructuralEquatable' metotları açık olarak uygulanmış olamaz</value>
  </data>
  <data name="tcInvalidUseNullAsTrueValue" xml:space="preserve">
    <value>'UseNullAsTrueValue' öznitelik bayrağı yalnızca bir adet işlenensiz durumu ve en az bir adet işlenenli durumu olan birleşim türleriyle kullanılabilir</value>
  </data>
  <data name="parsUnmatchedBeginOrStruct" xml:space="preserve">
    <value>Eşleşmeyen 'begin' veya 'struct'</value>
  </data>
  <data name="keywordDescriptionLeftArrow" xml:space="preserve">
    <value>Değişkene değer atar.</value>
  </data>
  <data name="parsEofInHashIf" xml:space="preserve">
    <value>#if bölümünde dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="tcUseWhenPatternGuard" xml:space="preserve">
    <value>Karakter aralığı eşleştirmeler F# dilinde kaldırılmıştır. Onun yerine 'when' desen koruma kullanmayı düşünün.</value>
  </data>
  <data name="lexHashBangMustBeFirstInFile" xml:space="preserve">
    <value>#! yalnızca bir dosyanın başlangıcında ilk satırda geçebilir.</value>
  </data>
  <data name="tcConstructorsDisallowedInExceptionAugmentation" xml:space="preserve">
    <value>Oluşturucular özel durum genişletmelerinde belirtilemez</value>
  </data>
  <data name="etMustNotBeAnArray" xml:space="preserve">
    <value>'{0}' sağlanan türünde 'IsArray' true olarak mevcut, ancak dizi türleri desteklenmiyor.</value>
  </data>
  <data name="chkDuplicatePropertyWithSuffix" xml:space="preserve">
    <value>Yinelenen özellik. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra '{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada ve imzaya sahip oluyor.</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespace" xml:space="preserve">
    <value>'{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' modülünü/ad alanını içermiyordu</value>
  </data>
  <data name="parsLetAndForNonRecBindings" xml:space="preserve">
    <value>Özyinelemeli olmayan bağlamalar için 'let ... and ...' bildirim biçimi F# kodunda kullanılmaz. 'let' bağlama sırası kullanmayı düşünün</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCodeOrEquals" xml:space="preserve">
    <value>'{0}' yapı, kayıt veya birleşim türünde açık 'Object.GetHashCode' veya 'Object.Equals' uygulaması var. Türe 'CustomEquality' özniteliğini uygulamanız gerekiyor</value>
  </data>
  <data name="tcInvalidUseOfDelegate" xml:space="preserve">
    <value>Geçersiz temsilci oluşturucu kullanımı. 'new Type(args)' sözdizimini kullanın veya yalnızca 'Type(args)' kullanın.</value>
  </data>
  <data name="typrelSigImplNotCompatibleConstraintsDifferRemove" xml:space="preserve">
    <value>'{0}' tür parametresinde {1} biçiminde bir kısıtlama olmasına karşın uygulamada olmadığı için imza ve uygulama uyumlu değil. Bu kısıtlamayı ya imzadan kaldırın ya da uygulamaya ekleyin.</value>
  </data>
  <data name="etHostingAssemblyFoundWithoutHosts" xml:space="preserve">
    <value>Başvurulan '{0}' bütünleştirilmiş kodunda '{1}' bütünleştirilmiş kod düzeyi özniteliği var ancak hiç ortak tür sağlayıcısı sınıfı bulunamadı</value>
  </data>
  <data name="optsWarnaserrorPM" xml:space="preserve">
    <value>Tüm uyarıları hata olarak bildir</value>
  </data>
  <data name="lexTabsNotAllowed" xml:space="preserve">
    <value>#indent \"off\" seçeneği kullanılmadığı sürece F# kodunda SEKMELERE izin verilmez</value>
  </data>
  <data name="etInvalidStaticArgument" xml:space="preserve">
    <value>Sağlanan türe, geçersiz statik bağımsız değişken verildi. '{0}' türünden bir bağımsız değişken bekleniyordu.</value>
  </data>
  <data name="tcMutableValuesCannotBeInline" xml:space="preserve">
    <value>Değişebilir değerler 'inline' olarak işaretlenemez</value>
  </data>
  <data name="typrelMoreThenOneOverride" xml:space="preserve">
    <value>Birden fazla geçersiz kılma '{0}' uyguluyor</value>
  </data>
  <data name="tcAbstractTypeCannotBeInstantiated" xml:space="preserve">
    <value>Bu tür soyut olarak işaretlendiği veya metotlarının tümüne uygulama verilmediği için örnekleri oluşturulamaz. Onun yerine bir nesne ifadesi '{{ new ... with ... }}' kullanmayı düşünün.</value>
  </data>
  <data name="tcModuleAbbrevFirstInMutRec" xml:space="preserve">
    <value>Özyinelemeli bir bildirim grubunda modül kısaltmaları, tüm 'open' bildirimleri ve diğer bildirimlerden sonra gelmelidir</value>
  </data>
  <data name="keywordDescriptionFunction" xml:space="preserve">
    <value>Tek bir bağımsız değişkende desen eşleştirmesine sahip bir lambda ifadesinde fun anahtar sözcüğünün ve match ifadesinin daha kısa bir alternatifi olarak kullanılır.</value>
  </data>
  <data name="ValueNotContainedMutabilityCompiledNamesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Derlenen adlar farklı</value>
  </data>
  <data name="ValueNotContainedMutabilityAccessibilityMore" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</value>
  </data>
  <data name="tcInvalidObjectConstructionExpression" xml:space="preserve">
    <value>Bu geçerli bir nesne oluşturma ifadesi değil. Açık nesne oluşturucular ya alternatif bir oluşturucu çağırmalı ya da nesnenin tüm alanlarını başlatmalı ve üst sınıf oluşturucuya çağrı belirtmelidir.</value>
  </data>
  <data name="optsUnknownPlatform" xml:space="preserve">
    <value>Tanınmayan platform '{0}', geçerli değerler: 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred' ve 'anycpu'</value>
  </data>
  <data name="tcNewCannotBeUsedOnInterfaceType" xml:space="preserve">
    <value>'new' arabirim türlerinde kullanılamaz. Bunun yerine bir nesne ifadesi '{{ new ... with ... }}' kullanmayı düşünün.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig" xml:space="preserve">
    <value>Bir kısaltma imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Kısaltmanın diğer CLI dilleri tarafından görünebilir olması gerekir. Kısaltmayı imzada görünür yapmayı düşünün.</value>
  </data>
  <data name="tastInvalidFormForPropertySetter" xml:space="preserve">
    <value>Özellik ayarlayıcı için geçersiz biçim. En az bir bağımsız değişken gereklidir.</value>
  </data>
  <data name="tcBindMayNotBeUsedInQueries" xml:space="preserve">
    <value>'let!', 'use!' ve 'do!' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="parsEofInVerbatimString" xml:space="preserve">
    <value>Tam dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="tcFieldIsReadonly" xml:space="preserve">
    <value>Bu alan salt okunur</value>
  </data>
  <data name="ilStructLayoutAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>StructLayout özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="csTypeIsNotDelegateType" xml:space="preserve">
    <value>'{0}' türü bir CLI temsilci türü değil</value>
  </data>
  <data name="notAFunctionButMaybeIndexer" xml:space="preserve">
    <value>Bu ifade, bir işlev değil ve uygulanamaz. Dizin oluşturucuya bunun yerine expr.[index] üzerinden erişmeye mi çalışıyordunuz?</value>
  </data>
  <data name="replaceWithSuggestion" xml:space="preserve">
    <value>'{0}' ile değiştir</value>
  </data>
  <data name="structOrClassFieldIsNotAccessible" xml:space="preserve">
    <value>'{0}' yapısına veya sınıf alanına bu kod konumundan erişilemiyor</value>
  </data>
  <data name="keywordDescriptionYieldBang" xml:space="preserve">
    <value>Verilen bir hesaplama ifadesinin sonucunu, bu hesaplama ifadesinin içerdiği sonuç koleksiyonuna eklemek için hesaplama ifadelerinde kullanılır.</value>
  </data>
  <data name="nrInvalidExpression" xml:space="preserve">
    <value>Geçersiz ifade: '{0}'</value>
  </data>
  <data name="csTypeParameterCannotBeNullable" xml:space="preserve">
    <value>Bu tür parametresi 'Nullable' olarak örneklenemez. Bu, bazı CLI dillerinde 'null' ifadesinin anlamının 'Nullable' değerlerle birlikte kullanıldığında karışıklık yaratmamasını sağlamak amacıyla getirilmiş bir kısıtlamadır.</value>
  </data>
  <data name="buildImplementationAlreadyGiven" xml:space="preserve">
    <value>'{0}' dosyasını veya modülünü uygulama örneği zaten verildi</value>
  </data>
  <data name="etIncorrectProvidedConstructor" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}', kendisinin '{1}' tanımlayan türünün oluşturucuları arasında bildirilmeyen bir oluşturucu sağladı</value>
  </data>
  <data name="tcInterfacesShouldUseInheritNotInterface" xml:space="preserve">
    <value>Diğer arabirimlerce devralınan arabirimler 'interface ...' yerine 'inherit ...' kullanılarak tanımlanmalıdır</value>
  </data>
  <data name="chkEntryPointUsage" xml:space="preserve">
    <value>'EntryPointAttribute' özniteliği ile etiketlenmiş bir işlev, derleme dizisinin sonuncu dosyasındaki sonuncu bildirim olmalıdır.</value>
  </data>
  <data name="nrRecordDoesNotContainSuchLabel" xml:space="preserve">
    <value>'{0}' kayıt türü bir '{1}' etiketi içermiyor.</value>
  </data>
  <data name="parsUnClosedBlockInHashLight" xml:space="preserve">
    <value>Kapatılmamış blok</value>
  </data>
  <data name="tcPropertyOrFieldNotFoundInAttribute" xml:space="preserve">
    <value>Bu özellik veya alan bu özel öznitelik türünde bulunamadı</value>
  </data>
  <data name="tastNamespaceAndModuleWithSameNameInAssembly" xml:space="preserve">
    <value>Bir ad alanı ve '{0}' adlı modülün ikisi birden bu bütünleştirilmiş kodun iki yerinde geçiyor</value>
  </data>
  <data name="optsTargetProfile" xml:space="preserve">
    <value>Bu bütünleştirilmiş kodun hedef çerçeve profilini belirtin. Geçerli değerler: mscorlib, netcore veya netstandard. Varsayılan: - mscorlib</value>
  </data>
  <data name="tcTypeAbbreviationsCheckedAtCompileTime" xml:space="preserve">
    <value>F# 4.1 ve sonrasında tür kısaltmalarının erişilebilirliği, derleme zamanında denetlenmektedir. Tür kısaltmasının erişilebilirliğini değiştirmeniz önerilir. Bu uyarıyı yoksaymak, çalışma zamanı hatalarına neden olabilir.</value>
  </data>
  <data name="lexHashEndifMustBeFirst" xml:space="preserve">
    <value>#endif yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</value>
  </data>
  <data name="ilSignInvalidRSAParams" xml:space="preserve">
    <value>Geçersiz RSAParameters yapısı - ' {{0}}' bekleniyordu</value>
  </data>
  <data name="tcNoEqualityNeeded1" xml:space="preserve">
    <value>Tür parametresi {1} 'equality' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal eşitliği desteklemez. Türün yapısal eşitliği desteklemediğini netleştirmek için '{2}' türüne 'NoEquality' özniteliği eklemeyi düşünün</value>
  </data>
  <data name="tcNoEqualityNeeded2" xml:space="preserve">
    <value>'{1}' türü 'equality' kısıtlamasını yerine getirmediği için yapı, kayıt veya birleşim türü '{0}' yapısal eşitliği desteklemez. Türün yapısal eşitliği desteklemediğini netleştirmek için '{2}' türüne 'NoEquality' özniteliği eklemeyi düşünün</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElementUseDo" xml:space="preserve">
    <value>Bu öznitelik, bu dil öğesinde kullanılmak için geçerli değil. Bütünleştirilmiş kod öznitelikleri, bir 'do ()' bildirimine, gerekirse F# modülü içine iliştirilmelidir.</value>
  </data>
  <data name="tcThreadStaticAndContextStaticMustBeStatic" xml:space="preserve">
    <value>Statik iş parçacıklı ve statik bağlamlı değişkenler statik olmalıdır ve her yeni iş parçacığında değerin varsayılan değerle başlatıldığını belirtmek için [&lt;DefaultValue&gt;] özniteliği verilmelidir</value>
  </data>
  <data name="chkNoAddressOfArrayElementAtThisPoint" xml:space="preserve">
    <value>Dizi öğesinin adresi bu noktada kullanılamaz</value>
  </data>
  <data name="parsUnexpectedTypeParameter" xml:space="preserve">
    <value>Sözdizimi hatası: beklenmeyen tür parametresi belirtimi</value>
  </data>
  <data name="ilDefaultAugmentationAttributeCouldNotBeDecoded" xml:space="preserve">
    <value>DefaultAugmentation özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="chkValueWithDefaultValueMustHaveDefaultValue" xml:space="preserve">
    <value>'DefaultValue' özniteliğini kullanan alanın türü varsayılan başlatmayı kabul etmelidir, yani uygun değer olarak 'null' değerli olmalı veya alanlarının tümü varsayılan başlatmayı kabul eden yapı türünde olmalıdır. Bu denetimi devre dışı bırakmak için 'DefaultValue(false)' kullanabilirsiniz</value>
  </data>
  <data name="keywordDescriptionOverride" xml:space="preserve">
    <value>Soyut veya sanal metodun temel sürümden farklı olan bir sürümünü uygulamak için kullanılır.</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedTypeMember" xml:space="preserve">
    <value>'{0}' sağlanan türü '{1}' üyesinden beklenmeyen özel durum: {2}</value>
  </data>
  <data name="chkTyparMultipleClassConstraints" xml:space="preserve">
    <value>Bir tür değişkeni, birden çok farklı sınıf türü tarafından kısıtlanmış. Bir tür değişkeninin yalnızca bir sınıf kısıtlaması olabilir.</value>
  </data>
  <data name="etMissingStaticArgumentsToMethod" xml:space="preserve">
    <value>Sağlanan bu metot statik parametreler gerektirir</value>
  </data>
  <data name="undefinedNameConstructorModuleOrNamespace" xml:space="preserve">
    <value>'{0}' oluşturucusu, modülü veya ad alanı tanımlı değil.</value>
  </data>
  <data name="tcTypeIsInaccessible" xml:space="preserve">
    <value>Bu türe bu kod konumundan erişilemiyor</value>
  </data>
  <data name="tcAttributesOfTypeSpecifyMultipleKindsForType" xml:space="preserve">
    <value>Bu tür öznitelikler türün birden çok çeşidini belirtir</value>
  </data>
  <data name="tastInvalidAddressOfMutableAcrossAssemblyBoundary" xml:space="preserve">
    <value>Bu işlem, başka bir bütünleştirilmiş kodda desteklenmeyen bir şekilde tanımlanmış değiştirilebilen bir üst düzey değere erişiyor. Değere adresi üzerinden erişilemiyor. İfadeyi değiştirilebilen bir yerel değere kopyalamayı, örn. 'let mutable x = ...' ve gerekirse işlem tamamlandıktan sonra değeri geri atamayı düşünün</value>
  </data>
  <data name="parsUnexpectedEndOfFileTry" xml:space="preserve">
    <value>'try' ifadesinde beklenmeyen giriş sonu. 'try &lt;ifade&gt; with &lt;kurallar&gt;' veya 'try &lt;ifade&gt; finally &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileFor" xml:space="preserve">
    <value>'for' ifadesinde beklenmeyen giriş sonu. 'for &lt;pat&gt; in &lt;ifade&gt; do &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer" xml:space="preserve">
    <value>Temsiller farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="crefQuotationsCantContainThisPatternMatch" xml:space="preserve">
    <value>Alıntılar, bu tür bir desen eşleştirme içeremez</value>
  </data>
  <data name="parsExpectedNameAfterToken" xml:space="preserve">
    <value>Beklenmeyen tür sonu. Bu noktadan sonra bir ad bekleniyordu.</value>
  </data>
  <data name="etProviderError" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}' bir hata bildirdi: {1}</value>
  </data>
  <data name="ilwriteMDBMemberMissing" xml:space="preserve">
    <value>MDB oluşturulamadı. Uyumlu üye {0} bulunamadı</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Tür kısaltmalarının arabirim bildirimleri olamaz</value>
  </data>
  <data name="augStructEqNeedsNoCompOrStructComp" xml:space="preserve">
    <value>'StructuralEquality' özniteliği, 'NoComparison' veya 'StructuralComparison' öznitelikleriyle bağlantılı kullanılmalıdır</value>
  </data>
  <data name="chkSplicingOnlyInQuotations" xml:space="preserve">
    <value>İfade ekleme işleçleri yalnızca tırnak içinde kullanılabilir</value>
  </data>
  <data name="lexHashEndingNoMatchingIf" xml:space="preserve">
    <value>#endif ile eşleşen bir #if yok</value>
  </data>
  <data name="tcAttributeIsNotValidForLanguageElement" xml:space="preserve">
    <value>Bu öznitelik, bu dil öğesinde kullanılmak için geçerli değil</value>
  </data>
  <data name="optsChecked" xml:space="preserve">
    <value>Taşma denetimleri oluştur</value>
  </data>
  <data name="optsCopyrightCommunity" xml:space="preserve">
    <value>MIT Açık Kaynak Lisansı altında ücretsiz olarak dağıtılır. https://github.com/Microsoft/visualfsharp/blob/master/License.txt</value>
  </data>
  <data name="csMemberOverloadArityMismatch" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}', {1} bağımsız değişkenlerini almaz. {2} bağımsız değişkenler alınırken aşırı yükleme bulundu.</value>
  </data>
  <data name="etProviderHasWrongDesignerAssembly" xml:space="preserve">
    <value>Bütünleştirilmiş kod özniteliği '{0}', yüklenemeyen veya var olmayan '{1}' tasarımcı bütünleştirilmiş koduna başvuruyor. {2}</value>
  </data>
  <data name="etUnexpectedExceptionFromProvidedMemberMember" xml:space="preserve">
    <value>'{1}' sağlanan türü '{2}' üyesinin '{0}' üyesinden beklenmeyen özel durum: {3}</value>
  </data>
  <data name="estApplyStaticArgumentsForMethodNotImplemented" xml:space="preserve">
    <value>Bir tür sağlayıcısı tarafından GetStaticParametersForMethod uygulandı, ancak ApplyStaticArgumentsForMethod uygulanmadı veya geçersiz</value>
  </data>
  <data name="optsHelpBannerResources" xml:space="preserve">
    <value>- KAYNAKLAR -</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking0" xml:space="preserve">
    <value>Bu bütünleştirilmiş kod tırnak içinde sabit değerler kullanıyor. Tüm bütünleştirilmiş kodlar en az F# 4.0 ile derlenmediği sürece, statik bağlama tırnak içinde sabit değerler kullanan bileşenler içeremez.</value>
  </data>
  <data name="tcBinaryOperatorRequiresBody" xml:space="preserve">
    <value>'{0}' ifadesi bir 'for' seçim yan tümcesinden sonra gelmeli ve onu sorgunun geri kalanı izlemelidir. Sözdizimi: ... {1} ...</value>
  </data>
  <data name="fscDelaySignWarning" xml:space="preserve">
    <value>'--delaysign' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyDelaySignAttribute' özniteliğini geçersiz kılar</value>
  </data>
  <data name="ilAddressOfLiteralFieldIsInvalid" xml:space="preserve">
    <value>Sabit değer alanının adresini almak geçersizdir</value>
  </data>
  <data name="lexOutsideThirtyTwoBitSigned" xml:space="preserve">
    <value>Bu sayı, 32 bit işaretli tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="parsUnmatchedBracketBar" xml:space="preserve">
    <value>Eşleşmeyen '[|'</value>
  </data>
  <data name="csMemberIsNotAccessible2" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}', {1} değil. Özel üyelere yalnızca tanımlayan türün içinden erişilebilir. Korunan üyelere yalnızca genişletilen bir türden erişilebilir, iç lambda ifadelerinden erişilemez.</value>
  </data>
  <data name="methodIsNotStatic" xml:space="preserve">
    <value>'{0}' metodu veya nesne oluşturucusu, statik değil</value>
  </data>
  <data name="fscQuotationLiteralsStaticLinking" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodundaki kod tırnak içinde sabit değerler kullanıyor. Bütün bütünleştirilmiş kodlar en az F# 4.0 ile derlenmediği sürece, statik bağlama tırnak içinde sabit değerler kullanan bileşenler içeremez.</value>
  </data>
  <data name="buildInvalidFilename" xml:space="preserve">
    <value>'{0}' geçerli bir dosya adı değil</value>
  </data>
  <data name="optsPublicSign" xml:space="preserve">
    <value>Tanımlayıcı ad anahtarının yalnızca genel bölümünü kullanarak, bütünleştirilmiş kodu genel olarak imzala ve bütünleştirilmiş kodu imzalanmış olarak işaretle</value>
  </data>
  <data name="lexOutsideSixteenBitUnsigned" xml:space="preserve">
    <value>Bu sayı, 16 bit işaretsiz tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="etProvidedAppliedTypeHadWrongName" xml:space="preserve">
    <value>'{0}' tür sağlayıcısı 'ApplyStaticArguments' yönteminden geçersiz bir tür döndürdü. '{1}' adlı tür bekleniyordu, ancak '{2}' adlı tür döndürüldü.</value>
  </data>
  <data name="abImplicitHeapAllocation" xml:space="preserve">
    <value>Değişebilir yerel '{0}' bir kapanış tarafından yakalandığından, örtülü bir biçimde bir başvuru hücresi olarak ayrıldı. Bu uyarı, yalnızca örtülü ayırma işlemlerinin gerçekleştirildiğine dair bilgilendirme amacı taşır.</value>
  </data>
  <data name="parsParenFormIsForML" xml:space="preserve">
    <value>F# kodunda 'expr.[expr]' kullanabilirsiniz. İlk ifadenin dizi olduğunu belirtmek için tür ek açıklaması gerekebilir</value>
  </data>
  <data name="tcObjectConstructorsIllegalInInterface" xml:space="preserve">
    <value>Arabirimler nesne oluşturucularının tanımlarını içeremez</value>
  </data>
  <data name="optsInvalidSubSystemVersion" xml:space="preserve">
    <value>'--subsystemversion' için geçersiz sürüm '{0}'. Sürümün 4.00 veya üzeri olması gerekir.</value>
  </data>
  <data name="tcNameArgumentsMustAppearLast" xml:space="preserve">
    <value>Adlandırılmış bağımsız değişkenler diğer tüm bağımsız değişkenlerden sonra görünmelidir</value>
  </data>
  <data name="crefBoundVarUsedInSplice" xml:space="preserve">
    <value>'{0}' değişkeni bir alıntı içine bağlanmış ancak eklenmiş ifadenin parçası olarak kullanılmış. Kapsamından kaçabileceği için buna izin verilmez.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInEnum" xml:space="preserve">
    <value>Bu konumda veya yakınında 'enum' kısıtlaması olan bir genel yapının kullanımındaki belirsizlik çözümlenemedi</value>
  </data>
  <data name="ilSignNoSignatureDirectory" xml:space="preserve">
    <value>İmza dizini yok</value>
  </data>
  <data name="parsUnexpectedOperatorForUnitOfMeasure" xml:space="preserve">
    <value>Ölçü birimi ifadesinde beklenmeyen içtakı işleci. Geçerli işleçler: '*', '/' ve '^'.</value>
  </data>
  <data name="typeInfoProperty" xml:space="preserve">
    <value>özellik</value>
  </data>
  <data name="tcCannotInheritFromSealedType" xml:space="preserve">
    <value>Korumalı tür devralınamıyor</value>
  </data>
  <data name="tcConstructIsAmbiguousInSequenceExpression" xml:space="preserve">
    <value>Bu yapı, bir dizi ifadesinin parçası olarak belirsiz. İç içe ifadeler 'let _ = (...)' kullanılarak ve iç içe diziler 'yield! seq {{... }}' kullanılarak yazılabilir.</value>
  </data>
  <data name="tcImplementsIStructuralEquatableExplicitly" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'System.IStructuralEquatable' arabirimini açık olarak uyguluyor. Türe 'CustomEquality' özniteliğini uygulayın.</value>
  </data>
  <data name="parsMemberIllegalInObjectImplementation" xml:space="preserve">
    <value>Nesne uygulamasında bu üyeye izin verilmez</value>
  </data>
  <data name="impImportedAssemblyUsesNotPublicType" xml:space="preserve">
    <value>İçeri aktarılmış bir bütünleştirilmiş kod '{0}' türünü kullanıyor bu tür ortak değil</value>
  </data>
  <data name="optsHelpBannerMisc" xml:space="preserve">
    <value>- ÇEŞİTLİ -</value>
  </data>
  <data name="tastUndefinedItemRefModuleNamespaceType" xml:space="preserve">
    <value>'{1}' derleme birimindeki '{0}' modülü/ad alanı '{2}' ad alanını, modülünü veya türünü içermiyordu</value>
  </data>
  <data name="fscRemotingError" xml:space="preserve">
    <value>Sunucuyla iletişimde bir sorun oluştuğu için yerleşik derleme hizmeti kullanılmadı.</value>
  </data>
  <data name="tcFieldValIllegalHere" xml:space="preserve">
    <value>Alan/değer bildirimine burada izin verilmez</value>
  </data>
  <data name="tcInvalidNewConstraint" xml:space="preserve">
    <value>'new' kısıtlamaları 'unit' türünde bir bağımsız değişken almalı ve oluşturulan türü döndürmelidir</value>
  </data>
  <data name="optsResident" xml:space="preserve">
    <value>Derleyici başlatma sürelerini geliştirmek için yerleşik bir arka planda derleme hizmetini kullanın.</value>
  </data>
  <data name="tcInvalidConstraint" xml:space="preserve">
    <value>Geçersiz kısıtlama</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull" xml:space="preserve">
    <value>Uygulamada bu türün temsil olarak null değerleri kullanabileceği belirtilmesine rağmen imzada bu belirtmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToMethod" xml:space="preserve">
    <value>Sağlanan metoda statik bağımsız değişkenler uygulanırken bir sorun oluştu</value>
  </data>
  <data name="optsResource" xml:space="preserve">
    <value>Belirtilen yönetilen kaynağı katıştır</value>
  </data>
  <data name="tcCouldNotFindOffsetToStringData" xml:space="preserve">
    <value>'fixed' ifadesi derlenirken başvurularda System.Runtime.CompilerServices.OffsetToStringData metodu bulunamadı.</value>
  </data>
  <data name="tcMemberAndLocalClassBindingHaveSameName" xml:space="preserve">
    <value>Hem üyenin hem de yerel sınıf bağlamasının adı '{0}' olabilir</value>
  </data>
  <data name="tcBinaryOperatorRequiresVariable" xml:space="preserve">
    <value>'{0}' ifadesini değişken adı izlemelidir. Kullanım: {1}.</value>
  </data>
  <data name="tcTypeTestErased" xml:space="preserve">
    <value>'{0}' sağlanan türü çalışma zamanında '{1}' olarak silineceği için bu sağlanan türe sahip bu tür testine izin verilmez.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract" xml:space="preserve">
    <value>Uygulama bir soyut sınıf olmasına rağmen imza soyut sınıf olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. İmzaya [&lt;AbstractClass&gt;] özniteliğini eklemeyi düşünün.</value>
  </data>
  <data name="csArgumentLengthMismatch" xml:space="preserve">
    <value>Bağımsız değişken uzunluğu mismatch uyuşmazlığı</value>
  </data>
  <data name="notAFunctionButMaybeDeclaration" xml:space="preserve">
    <value>Bu değer bir işlev değil ve uygulanamaz. Bir bildirimi sonlandırmayı mı unuttunuz?</value>
  </data>
  <data name="typrelMemberCannotImplement" xml:space="preserve">
    <value>Üye '{0}', '{1}' uygulamak için kullanılamaz. Gerekli imza: '{2}'.</value>
  </data>
  <data name="chkMultipleGenericInterfaceInstantiations" xml:space="preserve">
    <value>Bu tür, farklı '{0}' ve '{1}' genel örneklemelerinde aynı arabirimi uyguluyor. F# dilinin bu sürümünde buna izin verilmez.</value>
  </data>
  <data name="fscKeyNameWarning" xml:space="preserve">
    <value>'--keycontainer' seçeneği kaynak dosyasında veya ekli modülde verilen 'System.Reflection.AssemblyNameAttribute' özniteliğini geçersiz kılar</value>
  </data>
  <data name="tcGlobalsSystemTypeNotFound" xml:space="preserve">
    <value>'{0}' sistem türü gerekiyordu, ancak başvurulan hiçbir sistem DLL'si bu türü içermiyordu</value>
  </data>
  <data name="keywordDescriptionReturnBang" xml:space="preserve">
    <value>Değerlendirildiğinde, içerdiği hesaplama ifadesinin sonucu veren bir hesaplama ifadesini belirtmek için kullanılır.</value>
  </data>
  <data name="memberOperatorDefinitionWithCurriedArguments" xml:space="preserve">
    <value>Infix işleç üyesi '{0}', fazladan eksiltimli bağımsız değişkenlere sahip. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</value>
  </data>
  <data name="tcMemberNotPermittedInInterfaceImplementation" xml:space="preserve">
    <value>Arabirim uygulamasında bu üyeye izin verilmez</value>
  </data>
  <data name="memberOperatorDefinitionWithNonTripleArgument" xml:space="preserve">
    <value>Infix işleç üyesi '{0}', {1} başlangıç bağımsız değişkenine sahip. 3 bağımsız değişkenli bir demet bekleniyordu</value>
  </data>
  <data name="ilFieldHasOffsetForSequentialLayout" xml:space="preserve">
    <value>FieldOffset özniteliği yalnızca StructLayout(LayoutKind.Explicit) ile işaretlenmiş türlerdeki üyelere koyulabilir</value>
  </data>
  <data name="tcConstructorCannotHaveTypeParameters" xml:space="preserve">
    <value>Bir oluşturucunun açık tür parametreleri olamaz. Onun yerine statik oluşturma metodu kullanmayı düşünün.</value>
  </data>
  <data name="etPropertyHasGetterButNoCanRead" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' özelliğinde CanRead=false var, ancak GetGetMethod() metodu bir metot döndürdü</value>
  </data>
  <data name="tcJoinMustUseSimplePattern" xml:space="preserve">
    <value>Sorgularda, '{0}' basit desen kullanmalıdır</value>
  </data>
  <data name="tcUnexpectedConstByteArray" xml:space="preserve">
    <value>Beklenmeyen Const_bytearray</value>
  </data>
  <data name="tlrUnexpectedTExpr" xml:space="preserve">
    <value>Beklenmeyen Expr.TyChoose</value>
  </data>
  <data name="parsUnexpectedEndOfFileObjectMembers" xml:space="preserve">
    <value>Nesne üyelerinde beklenmeyen giriş sonu</value>
  </data>
  <data name="chkDuplicateMethodCurried" xml:space="preserve">
    <value>'{0}' metodunda Curry biçimli bağımsız değişkenler var ancak metodun adı, '{1}' türündeki başka bir metodun adıyla aynı. Curry biçimli bağımsız değişkenleri olan metotlar aşırı yüklenemez. Demet olarak tanımlanmış bağımsız değişkenler alan bir metot kullanmanız önerilir.</value>
  </data>
  <data name="fscBadAssemblyVersion" xml:space="preserve">
    <value>{0} ile sürüm '{1}' belirtildi, ancak bu değer geçersiz ve yok sayıldı</value>
  </data>
  <data name="tcTypeParameterInvalidAsTypeConstructor" xml:space="preserve">
    <value>Tür parametresi tür oluşturucusu olarak kullanılamaz</value>
  </data>
  <data name="ilMutableVariablesCannotEscapeMethod" xml:space="preserve">
    <value>Değişebilir değişkenler metotlarından kaçamaz</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembers" xml:space="preserve">
    <value>Ölçü bildirimlerinin yalnızca statik üyeleri olabilir</value>
  </data>
  <data name="tcInvalidOperatorDefinition" xml:space="preserve">
    <value>'{0}' işleci normalde yeniden tanımlanmamalıdır. Farklı bir işleç adı kullanmayı düşünün</value>
  </data>
  <data name="chkNoByrefAtThisPoint" xml:space="preserve">
    <value>Türü byref olarak belirtilmiş '{0}' değeri bu noktada kullanılamaz</value>
  </data>
  <data name="buildSearchDirectoryNotFound" xml:space="preserve">
    <value>Arama dizini '{0}' bulunamadı</value>
  </data>
  <data name="tcConstructIsAmbiguousInComputationExpression" xml:space="preserve">
    <value>Bu yapı, bir hesaplama ifadesinin parçası olarak belirsiz. İç içe ifadeler 'let _ = (...)' kullanılarak ve iç içe hesaplamalar 'let! res = builder {{ ... }}' kullanılarak yazılabilir.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot" xml:space="preserve">
    <value>İmzada '{3}' adlı {2} tanımlanmasına rağmen uygulamada tanımlanmadığından (veya farklı sırayla tanımlandığından), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="typeInfoFullName" xml:space="preserve">
    <value>Tam ad</value>
  </data>
  <data name="optsFullpaths" xml:space="preserve">
    <value>Tam yollu çıkış iletileri</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldWasPresent" xml:space="preserve">
    <value>{2} alanı uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="optsNoCopyFsharpCore" xml:space="preserve">
    <value>FSharp.Core.dll dosyasını üretilen ikili dosyalarla birlikte kopyalama</value>
  </data>
  <data name="csGenericConstructRequiresUnmanagedType" xml:space="preserve">
    <value>Genel bir yapı, '{0}' türünün yönetilmeyen bir tür olmasını gerektirir</value>
  </data>
  <data name="typrelExplicitImplementationOfEquals" xml:space="preserve">
    <value>'{0}' yapı, kayıt veya birleşim türünde açık 'Object.Equals' uygulaması var. 'Object.GetHashCode()' için bununla eşleşen bir geçersiz kılma uygulamayı düşünün</value>
  </data>
  <data name="tcIllegalFormForExplicitTypeDeclaration" xml:space="preserve">
    <value>Oluşturucuların açık tür bildirimleri 'ty1 * ... * tyN -&gt; resTy' biçiminde olmalıdır. 'resTy' etrafında ayraç gerekebilir</value>
  </data>
  <data name="keywordDescriptionRec" xml:space="preserve">
    <value>Bir işlevin özyinelemeli olduğunu belirtmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionVal" xml:space="preserve">
    <value>Değer belirtmek için imzada veya sınırlı durumlarda üye bildirmek için türde kullanılır.</value>
  </data>
  <data name="keywordDescriptionUse" xml:space="preserve">
    <value>Dispose'un boş kaynaklara çağrılmasını gerektiren değerler için let yerine kullanılır.</value>
  </data>
  <data name="keywordDescriptionTry" xml:space="preserve">
    <value>Özel durum oluşturabilen bir kod bloğunu tanıtmak için kullanılır. with veya finally ile birlikte kullanılır.</value>
  </data>
  <data name="keywordDescriptionNew" xml:space="preserve">
    <value>Nesne oluşturan veya oluşturabilen bir oluşturucuyu bildirmek, tanımlamak veya çağırmak için kullanılır. Ayrıca bir türün belirli bir oluşturucusu olması gerektiğini belirtmek için genel parametre kısıtlamalarında kullanılır.</value>
  </data>
  <data name="keywordDescriptionNot" xml:space="preserve">
    <value>Aslında bir anahtar sözcük değildir. Ancak not yapısı, bir genel parametre kısıtlaması olarak kombine şekilde kullanılır.</value>
  </data>
  <data name="keywordDescriptionLet" xml:space="preserve">
    <value>Adı bir değer veya işlevle ilişkilendirmek ya da bağlamak için kullanılır.</value>
  </data>
  <data name="keywordDescriptionFun" xml:space="preserve">
    <value>Anonim işlevler olarak da bilinen lambda ifadelerinde kullanılır.</value>
  </data>
  <data name="keywordDescriptionFor" xml:space="preserve">
    <value>Döngü yapılarında kullanılır.</value>
  </data>
  <data name="keywordDescriptionEnd" xml:space="preserve">
    <value>Tür tanımlarında ve tür uzantılarında, üye tanımları bölümünün sonunu gösterir. Ayrıntılı söz diziminde, begin anahtar sözcüğü ile başlayan bir kod bloğunun sonunu belirtmek için kullanılır.</value>
  </data>
  <data name="chkGetterAndSetterHaveSamePropertyType" xml:space="preserve">
    <value>Bir özelliğin alıcısı ve ayarlayıcısı aynı türde olmalıdır. '{0}' özelliğinin alıcı türü '{1}' ancak ayarlayıcı türü '{2}'.</value>
  </data>
  <data name="tcInvalidTypeArgumentCount" xml:space="preserve">
    <value>Tür bağımsız değişkenlerinin sayısı eşleşmedi: '{0}' verildi, '{1}' bekleniyordu. Bu, önceden bildirilmiş bir hatayla ilişkili olabilir.</value>
  </data>
  <data name="tcFieldRequiresName" xml:space="preserve">
    <value>Bu alan için ad gerekiyor</value>
  </data>
  <data name="typeInfoGeneratedType" xml:space="preserve">
    <value>oluşturulan tür</value>
  </data>
  <data name="buildInvalidVersionString" xml:space="preserve">
    <value>Geçersiz sürüm dizesi '{0}'</value>
  </data>
  <data name="tcInvalidTypeArgumentUsage" xml:space="preserve">
    <value>Tür bağımsız değişkenleri burada belirtilemez</value>
  </data>
  <data name="lexOutsideNativeSigned" xml:space="preserve">
    <value>Bu sayı, işaretli yerel tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="tcTypeTestLossy" xml:space="preserve">
    <value>Bu tür testi veya alt türe çevirme işlemi '{0}' sağlanan türünü '{1}' türüne silecek</value>
  </data>
  <data name="parsInheritDeclarationsCannotHaveAsBindings" xml:space="preserve">
    <value>'inherit' tanımlamalarının 'as' bağlamaları olamaz. Bir metodu geçersiz kılarken temel sınıfın üyelerine erişmek için 'base.SomeMember' sözdizimi kullanılabilir; 'base' bir anahtar sözcüktür. Bu 'as' bağlamasını kaldırın.</value>
  </data>
  <data name="keywordDescriptionDelegate" xml:space="preserve">
    <value>Bir temsilci bildirmek için kullanılır.</value>
  </data>
  <data name="csMethodNotFound" xml:space="preserve">
    <value>Metot veya nesne oluşturucusu '{0}' bulunamadı</value>
  </data>
  <data name="forBadWidth" xml:space="preserve">
    <value>Biçim tanımlayıcıda hatalı genişlik</value>
  </data>
  <data name="tcAllowNullTypesMayOnlyInheritFromAllowNullTypes" xml:space="preserve">
    <value>'AllowNullLiteral' özniteliğine sahip türler yalnızca null sabit değerinin kullanılmasına da izin veren türlerden devralabilir veya böyle türleri uygulayabilir</value>
  </data>
  <data name="tcStaticInitializerRequiresArgument" xml:space="preserve">
    <value>Statik başlatıcı için bağımsız değişken gerekiyor</value>
  </data>
  <data name="tcSyntaxErrorUnexpectedQMark" xml:space="preserve">
    <value>Sözdizimi hatası - beklenmeyen '?' simgesi</value>
  </data>
  <data name="tcInvalidUseOfInterfaceType" xml:space="preserve">
    <value>Geçersiz arabirim türü kullanımı</value>
  </data>
  <data name="parsSuccessivePatternsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Ardışık desenler boşluklarla veya grup olarak tanımlayarak ayrılmalıdır</value>
  </data>
  <data name="csRequiredSignatureIs" xml:space="preserve">
    <value>Gereken imza: {0}</value>
  </data>
  <data name="elSysEnvExitDidntExit" xml:space="preserve">
    <value>System.Environment.Exit yoktu</value>
  </data>
  <data name="tcStaticOptimizationConditionalsOnlyForFSharpLibrary" xml:space="preserve">
    <value>Statik iyileştirme koşulları yalnızca F# kitaplığı içinde kullanım içindir</value>
  </data>
  <data name="arrayElementHasWrongType" xml:space="preserve">
    <value>Bir array constructor ifadesinin tüm öğeleri aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</value>
  </data>
  <data name="csTypeCannotBeResolvedAtCompileTime" xml:space="preserve">
    <value>Tanımlanan tür parametresi '{0}' derleme zamanında çözümlenemediği için burada kullanılamaz</value>
  </data>
  <data name="buildInvalidAssemblyName" xml:space="preserve">
    <value>'{0}' geçerli bir bütünleştirilmiş kod adı değil</value>
  </data>
  <data name="tcInvalidActivePatternName" xml:space="preserve">
    <value>Etkin desen için bu geçerli bir ad değil</value>
  </data>
  <data name="missingElseBranch" xml:space="preserve">
    <value>'if' ifadesinde bir 'else' dalı eksik. 'then' dalı '{0}' türünde. 'if' bir ifade değil deyim olduğundan, aynı türde değer döndüren bir 'else' dalı eklemeniz gerekir.</value>
  </data>
  <data name="parsUnexpectedEndOfFileTypeSignature" xml:space="preserve">
    <value>Tür imzasında beklenmeyen giriş sonu</value>
  </data>
  <data name="chkDuplicateMethod" xml:space="preserve">
    <value>Yinelenen metot. '{0}' metodu, '{1}' türündeki başka bir metotla aynı ada ve imzaya sahip.</value>
  </data>
  <data name="typrelMethodIsOverconstrained" xml:space="preserve">
    <value>Bu metot tür parametrelerinde aşırı kısıtlanmış</value>
  </data>
  <data name="patcMissingVariable" xml:space="preserve">
    <value>Eksik değişken: '{0}'</value>
  </data>
  <data name="parsInlineAssemblyCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine satır içi bütünleştirilmiş kod kodu türlerinde izin verilmez</value>
  </data>
  <data name="ilReflectedDefinitionsCannotUseSliceOperator" xml:space="preserve">
    <value>Yansıtılmış tanımlar ön ek ekleme işleci '%' kullanımlarını içeremez</value>
  </data>
  <data name="tcInvalidUnitsOfMeasurePrefix" xml:space="preserve">
    <value>Ölçü birimleri bir türün ön ek bağımsız değişkenleri olarak kullanılamaz. Açılı ayraç içinde son ek bağımsız değişkeni olarak yeniden yazın.</value>
  </data>
  <data name="csStructConstraintInconsistent" xml:space="preserve">
    <value>'struct' ve 'not struct' kısıtlamaları tutarsız</value>
  </data>
  <data name="tcLiteralDoesNotTakeArguments" xml:space="preserve">
    <value>Bu sabit değer deseninde bağımsız değişken kullanılamaz</value>
  </data>
  <data name="parsInvalidDeclarationSyntax" xml:space="preserve">
    <value>Geçersiz bildirim sözdizimi</value>
  </data>
  <data name="csTypesDoNotSupportOperator" xml:space="preserve">
    <value>'{0}' türlerinin hiçbiri '{1}' işlecini desteklemez</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDelegate" xml:space="preserve">
    <value>Temsilci türleri her zaman korumalıdır</value>
  </data>
  <data name="parsExpectedExpressionAfterToken" xml:space="preserve">
    <value>Bu noktadan sonra bir ifade bekleniyordu</value>
  </data>
  <data name="chkTypeLessAccessibleThanType" xml:space="preserve">
    <value>'{0}' türünün erişilebilirliği, içinde kullanıldığı değer, üye veya '{1}' türünden daha düşük düzeyde.</value>
  </data>
  <data name="optsDeterministic" xml:space="preserve">
    <value>Belirleyici bir bütünleştirilmiş kod oluşturun (modül sürümü GUID'i ve zaman damgası dahil)</value>
  </data>
  <data name="etUnexpectedNullFromProvidedTypeMember" xml:space="preserve">
    <value>'{0}' sağlanan türü '{1}' üyesinden beklenmeyen 'null' dönüş değeri</value>
  </data>
  <data name="tcCouldNotFindIDisposable" xml:space="preserve">
    <value>IDisposable üzerinde Dispose bulunamadı veya aşırı yüklenmişti</value>
  </data>
  <data name="buildInvalidPrivacy" xml:space="preserve">
    <value>Yönetilen kaynak için tanınmayan gizlilik ayarı '{0}'; geçerli seçenekler: 'public' ve 'private'</value>
  </data>
  <data name="optValueMarkedInlineCouldNotBeInlined" xml:space="preserve">
    <value>'inline' olarak işaretlenmiş bir değer satır içine alınamadı</value>
  </data>
  <data name="csGenericConstructRequiresPublicDefaultConstructor" xml:space="preserve">
    <value>Genel bir yapı, '{0}' türünde ortak varsayılan oluşturucu olmasını gerektirir</value>
  </data>
  <data name="csMemberIsNotInstance" xml:space="preserve">
    <value>{0} bir örnek üyesi değil</value>
  </data>
  <data name="crefQuotationsCantContainThisConstant" xml:space="preserve">
    <value>Alıntılar, bu tür bir sabit içeremez</value>
  </data>
  <data name="etIncorrectParameterExpression" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}', ParameterExpression ifadesinde geçersiz parametre kullandı: {1}</value>
  </data>
  <data name="tcNonUniformMemberUse" xml:space="preserve">
    <value>'{0}' genel üyesi, bu program noktasından önce düzenli olmayan bir örneklemede kullanıldı. Bu üye önce olacak şekilde üyeleri yeniden sıralamayı düşünün. Alternatif olarak, bağımsız değişken türleri, dönüş türü ve diğer ek genel parametreler ve kısıtlamalar dahil üyenin tam türünü açık olarak belirtin.</value>
  </data>
  <data name="chkCantStoreByrefValue" xml:space="preserve">
    <value>Bir türde byref olarak belirtilmiş değer depolanmak istendi. Ortak Ara Dilde (CIL) buna izin verilmez.</value>
  </data>
  <data name="fscNoImplementationFiles" xml:space="preserve">
    <value>Bir uygulama dosyası belirtilmedi</value>
  </data>
  <data name="ValueNotContainedMutabilityInlineFlagsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Satır içi bayraklar farklı</value>
  </data>
  <data name="tcInvalidNamespaceModuleTypeUnionName" xml:space="preserve">
    <value>Geçersiz ad alanı, modül, tür veya birleşim durumu adı</value>
  </data>
  <data name="tcTypeAbbreviationsMayNotHaveMembers" xml:space="preserve">
    <value>Tür kısaltmalarının üyeleri olamaz</value>
  </data>
  <data name="tcRecImplied" xml:space="preserve">
    <value>Bu modüldeki 'rec', bir dış 'rec' bildirimi tarafından kapsanıyor ve yoksayılıyor</value>
  </data>
  <data name="tcTypeIsNotARecordTypeNeedConstructor" xml:space="preserve">
    <value>Bu tür bir kayıt türü değil. Nesne oluşturucularına yapılan çağrılar kullanılarak sınıf ve yapı türlerinin değerlerinin oluşturulması gerekiyor.</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenFunction" xml:space="preserve">
    <value>'{0}' işlecini destekleyen bir tür bekleniyor ancak bir işlev türü verildi. Bir işlevde bağımsız değişkeniniz eksik olabilir.</value>
  </data>
  <data name="tcNamespaceCannotContainValues" xml:space="preserve">
    <value>Ad alanları değer içeremez. Değer bildirimlerinizi tutmak için modül kullanmayı düşünün.</value>
  </data>
  <data name="noInvokeMethodsFound" xml:space="preserve">
    <value>Temsilci türü için bir Invoke metodu bulunamadı</value>
  </data>
  <data name="parsIncompleteIf" xml:space="preserve">
    <value>Eksik koşul. 'if &lt;ifade&gt; then &lt;ifade&gt;' veya 'if &lt;ifade&gt; then &lt;ifade&gt; else &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedHere" xml:space="preserve">
    <value>Özel işlem, bu hesaplama ifadesi içinde 'use', 'try/with', 'try/finally', 'if/then/else' veya 'match' işleçleri ile bağlantılı olarak kullanılamaz</value>
  </data>
  <data name="augStructCompNeedsStructEquality" xml:space="preserve">
    <value>'StructuralComparison' özniteliği, 'StructuralEquality' özniteliği ile bağlantılı kullanılmalıdır</value>
  </data>
  <data name="parsInvalidUseOfRec" xml:space="preserve">
    <value>'rec' anahtar sözcüğü geçersiz şekilde kullanıldı</value>
  </data>
  <data name="tcEnumerationsMayNotHaveMembers" xml:space="preserve">
    <value>Sabit listelerinde üyeler olamaz</value>
  </data>
  <data name="undefinedNameRecordLabelOrNamespace" xml:space="preserve">
    <value>'{0}' kayıt etiketi veya ad alanı tanımlı değil.</value>
  </data>
  <data name="crefQuotationsCantContainGenericExprs" xml:space="preserve">
    <value>Alıntılar, genel ifade kullanımları içeremez</value>
  </data>
  <data name="optsDCLONoDescription" xml:space="preserve">
    <value>Komut satırı seçeneği '{0}' kullanım dışı bırakıldı</value>
  </data>
  <data name="keywordDescriptionLetBang" xml:space="preserve">
    <value>Zaman uyumsuz iş akışlarında adı zaman uyumsuz hesaplamanın sonucuna bağlamak için veya diğer hesaplama ifadelerinde adı hesaplama türünden bir sonuca bağlamak için kullanılır.</value>
  </data>
  <data name="typeInfoCallsWord" xml:space="preserve">
    <value>Çağrılar</value>
  </data>
  <data name="lexHashElseNoMatchingIf" xml:space="preserve">
    <value>#else ile eşleşen bir #if yok</value>
  </data>
  <data name="optsClirootDescription" xml:space="preserve">
    <value>Derleyicinin mscorlib.dll ve çerçeve bileşenlerini aradığı yeri geçersiz kılmak için kullanın</value>
  </data>
  <data name="csMemberSignatureMismatchArityType" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} tür bağımsız değişkeni alır ancak burada {2} bağımsız değişken verilmiş. Gereken imza: '{3}'.</value>
  </data>
  <data name="itemNotFoundDuringDynamicCodeGen" xml:space="preserve">
    <value>'{2}' bütünleştirilmiş kodunda {0} '{1}' bulunamadı. Bunun nedeni sürüm uyumsuzluğu olabilir. Başvurulan tüm bileşenlerin doğru sürümü kullanmasına izin vermek için bu bütünleştirilmiş kodun doğru sürümüne açıkça başvurmanız gerekebilir.</value>
  </data>
  <data name="tcIllegalSyntaxInTypeExpression" xml:space="preserve">
    <value>Tür ifadesinde geçersiz sözdizimi</value>
  </data>
  <data name="lexOutsideIntegerRange" xml:space="preserve">
    <value>Bu sayı, bu tamsayı türü için izin verilen aralığın dışında</value>
  </data>
  <data name="activePatternIdentIsNotFunctionTyped" xml:space="preserve">
    <value>'{0}' etkin deseni bir işlev değil</value>
  </data>
  <data name="chkGetterSetterDoNotMatchAbstract" xml:space="preserve">
    <value>'{1}' türündeki '{0}' özelliğinin alıcısı ve ayarlayıcısı eşleşmiyor. Biri soyut ise diğeri de soyut olmalıdır.</value>
  </data>
  <data name="tcNoIntegerForLoopInQuery" xml:space="preserve">
    <value>Sorgularda, tamsayı aralığını belirlemek için 'for x in n .. m do ...' biçimini kullanın</value>
  </data>
  <data name="parsEofInTripleQuoteString" xml:space="preserve">
    <value>Üç tırnak işaretli dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="parsUnexpectedEndOfFileDefinition" xml:space="preserve">
    <value>Değer, işlev veya üye tanımında beklenmeyen giriş sonu</value>
  </data>
  <data name="csCtorSignatureMismatchArityProp" xml:space="preserve">
    <value>'{0}' nesne oluşturucusunun {1} bağımsız değişken alması gerekiyor, ancak burada {2} bağımsız değişken almış. Gerekli imza: '{3}'. Bazı bağımsız değişkenler özelliklere değer atamak için kullanıldıysa, bu bağımsız değişkenleri virgül (',') ile ayırmanız önerilir.</value>
  </data>
  <data name="tcCallerInfoWrongType" xml:space="preserve">
    <value>'{0}', '{1}' türündeki bağımsız değişkene uygulanmalıdır, ancak '{2}' türündeki bağımsız değişkene uygulanmış</value>
  </data>
  <data name="tcCannotCreateExtensionOfSealedType" xml:space="preserve">
    <value>Korumalı türün uzantısı oluşturulamıyor</value>
  </data>
  <data name="parsNoMatchingInForLet" xml:space="preserve">
    <value>Bu 'let' için eşleşen bir 'in' bulunamadı</value>
  </data>
  <data name="parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Modül kısaltmasında '{0}' görünürlük özniteliğine izin verilmez. Modül kısaltmaları her zaman özeldir.</value>
  </data>
  <data name="augNoCompCantImpIComp" xml:space="preserve">
    <value>'NoComparison' özniteliği olan bir türde, genellikle açık olarak uygulanmış 'System.IComparable', 'System.IComparable&lt;_&gt;' veya 'System.Collections.IStructuralComparable' yöntemleri olmamalıdır. Bu birlikte çalışabilme amacıyla bilerek yapılmışsa bu uyarıyı devre dışı bırakın</value>
  </data>
  <data name="tcConstructRequiresComputationExpressions" xml:space="preserve">
    <value>Bu yapı yalnızca hesaplama ifadeleri içinde kullanılabilir. Normal bir işlevden değer döndürmek için sadece ifadeyi 'return' olmadan yazın.</value>
  </data>
  <data name="parsMutableOnAutoPropertyShouldBeGetSet" xml:space="preserve">
    <value>Özellik tanımları değişebilir olarak tanımlanamaz. Bu özelliğin ayarlanabileceğini belirtmek için 'member val PropertyName = expr with get,set' kullanın.</value>
  </data>
  <data name="optsHelpBannerAdvanced" xml:space="preserve">
    <value>- GELİŞMİŞ -</value>
  </data>
  <data name="FieldNotContainedStaticsDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'static' değiştiricileri farklı</value>
  </data>
  <data name="chkUnionCaseCompiledForm" xml:space="preserve">
    <value>birleşim durumunun derlenmiş biçimi</value>
  </data>
  <data name="buildAssemblyResolutionFailed" xml:space="preserve">
    <value>Bu konumda veya yakınında bütünleştirilmiş kod çözme hatası</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer" xml:space="preserve">
    <value>Alanların sırası imzada ve uygulamada farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcAbstractMembersIllegalInAugmentation" xml:space="preserve">
    <value>Genişletmede soyut üyelere izin verilmez; bunlar türün kendi parçası olarak tanımlanmalıdır</value>
  </data>
  <data name="parsUnexpectedEndOfFileThen" xml:space="preserve">
    <value>Koşullu ifadenin 'then' dalında beklenmeyen giriş sonu. 'if &lt;ifade&gt; then &lt;ifade&gt;' veya 'if &lt;ifade&gt; then &lt;ifade&gt; else &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWith" xml:space="preserve">
    <value>'match' veya 'try' ifadesinde beklenmeyen giriş sonu</value>
  </data>
  <data name="parsUnexpectedEndOfFileElse" xml:space="preserve">
    <value>Koşullu ifadenin 'else' dalında beklenmeyen giriş sonu. 'if &lt;ifade&gt; then &lt;ifade&gt;' veya 'if &lt;ifade&gt; then &lt;ifade&gt; else &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="tcNoArgumentsForRecordValue" xml:space="preserve">
    <value>Kayıt değeri oluşturulurken bir bağımsız değişken verilemez</value>
  </data>
  <data name="lexhlpIdentifiersContainingAtSymbolReserved" xml:space="preserve">
    <value>'@' içeren tanımlayıcılar F# kodunu oluşturmada kullanmak için ayrılmıştır</value>
  </data>
  <data name="tcLookupMayNotBeUsedHere" xml:space="preserve">
    <value>Bu arama burada kullanılamaz</value>
  </data>
  <data name="tcMembersThatExtendInterfaceMustBePlacedInSeparateModule" xml:space="preserve">
    <value>Arabirim, temsilci veya sabit listesi türlerini genişleten üyeler türün tanımından ayrı bir modüle yerleştirilmelidir. Bu modülün ya AutoOpen özniteliği olmalıdır ya da uzantı üyelerini kapsama çıkarmak için istemci kodu aracılığıyla açık olarak açılmalıdır.</value>
  </data>
  <data name="tcNoInterfaceImplementationForConstructionExpression" xml:space="preserve">
    <value>Arabirim uygulamaları oluşturma ifadelerinde verilemez</value>
  </data>
  <data name="tcNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Bu kod yeterince genel değil. Tür değişkeni {0}, kapsamını kaçıracağı için genelleştirilemedi.</value>
  </data>
  <data name="parsEofInIfOcaml" xml:space="preserve">
    <value>IF-OCAML bölümünde dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="tcOnlyClassesCanHaveAbstract" xml:space="preserve">
    <value>'AbstractClass' özniteliği yalnızca sınıflara verilebilir</value>
  </data>
  <data name="chkSystemVoidOnlyInTypeof" xml:space="preserve">
    <value>'System.Void', F# dilinde yalnızca 'typeof&lt;System.Void&gt;' olarak kullanılabilir</value>
  </data>
  <data name="parsMultiArgumentGenericTypeFormDeprecated" xml:space="preserve">
    <value>'(typ,...,typ) ident' sözdizimi F# kodunda kullanılmaz. Onun yerine 'ident&lt;typ,...,typ&gt;' kullanmayı düşünün</value>
  </data>
  <data name="tcStructTypesCannotContainAbstractMembers" xml:space="preserve">
    <value>Struct türleri soyut üyeler içeremez</value>
  </data>
  <data name="tcNewMemberHidesAbstractMemberWithSuffix" xml:space="preserve">
    <value>Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra bu yeni üye, '{0}' soyut üyesini gizliyor. Üyeyi yeniden adlandırın veya bunun yerine 'override' kullanın.</value>
  </data>
  <data name="tastUnexpectedDecodeOfInterfaceDataVersionAttribute" xml:space="preserve">
    <value>Beklenmeyen InterfaceDataVersionAttribute kod çözümü</value>
  </data>
  <data name="lexfltSeparatorTokensOfPatternMatchMisaligned" xml:space="preserve">
    <value>Bu desen eşleşmesinin ayırma kurallarındaki '|' belirteçleri bir sütun kadar yanlış hizalı. Kodunuzu yeniden hizalamayı veya daha fazla girinti kullanmayı düşünün.</value>
  </data>
  <data name="ValueNotContainedMutabilityArityNotInferred" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu değer için parametre sayısı çıkarılmadı</value>
  </data>
  <data name="tcUnexpectedPropertyInSyntaxTree" xml:space="preserve">
    <value>Sözdizimi ağacında beklenmeyen kaynak düzeyli özellik belirtimi</value>
  </data>
  <data name="tcExtraneousFieldsGivenValues" xml:space="preserve">
    <value>Dış alanlara değerler verilmiş</value>
  </data>
  <data name="keywordDescriptionDowncast" xml:space="preserve">
    <value>Devralma zincirinde daha aşağıda bulunan bir türe dönüştürmek için kullanılır.</value>
  </data>
  <data name="tupleRequiredInAbstractMethod" xml:space="preserve">
    <value>\nBir veya daha çok bağımsız değişken için demet türü gerekli. Verilen bağımsız değişkenleri ek parantezlerle sarmalamanız veya arabirimin tanımını gözden geçirmeniz önerilir.</value>
  </data>
  <data name="tcUnexpectedBigRationalConstant" xml:space="preserve">
    <value>Beklenmeyen büyüklükte oran sabiti</value>
  </data>
  <data name="ilSignBadImageFormat" xml:space="preserve">
    <value>Bozuk görüntü biçimi</value>
  </data>
  <data name="etEmptyNamespaceNotAllowed" xml:space="preserve">
    <value>'{0}' tür sağlayıcısından boş ad alanı bulundu. Genel ad alanı için 'null' kullanın.</value>
  </data>
  <data name="ModuleContainsConstructorButNamesDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Adlar farklı</value>
  </data>
  <data name="customOperationTextLikeJoin" xml:space="preserve">
    <value>{1} koleksiyonunda (outerKey = innerKey) {0} değişken. '{2}' öğesinden sonra parantezlerin gerekli olduğuna dikkat edin</value>
  </data>
  <data name="parsInOrEqualExpected" xml:space="preserve">
    <value>'in' veya '=' bekleniyor</value>
  </data>
  <data name="tastUnexpectedDecodeOfInternalsVisibleToAttribute" xml:space="preserve">
    <value>Beklenmeyen InternalsVisibleToAttribute kod çözümü</value>
  </data>
  <data name="ppparsIncompleteExpression" xml:space="preserve">
    <value>Eksik önişlemci ifadesi</value>
  </data>
  <data name="tcExprUndelayed" xml:space="preserve">
    <value>TcExprUndelayed: gecikti</value>
  </data>
  <data name="etDirectReferenceToGeneratedTypeNotAllowed" xml:space="preserve">
    <value>'{0}' oluşturulmuş türüne doğrudan başvuruya izin verilmez. Onun yerine tür tanımını kullanın. örn. 'type TypeAlias = &lt;yol&gt;'. Bu, oluşturulmuş türleri bütünleştirilmiş kodunuza bir tür sağlayıcısının eklediğini gösterir.</value>
  </data>
  <data name="lexWrongNestedHashEndif" xml:space="preserve">
    <value>Sözdizimi hatası. Yanlış girintiye yerleştirilmiş #endif, önünde beklenmeyen belirteçler var.</value>
  </data>
  <data name="optsWarnOn" xml:space="preserve">
    <value>Varsayılan seçenek olarak kapalı olabilen özel uyarıları etkinleştir</value>
  </data>
  <data name="tcNamedActivePattern" xml:space="preserve">
    <value>{0} etkin bir desen ve adlandırılmış alanlar içeren bir ayırt edici birleşim durumu olarak değerlendirilemez.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedRecord" xml:space="preserve">
    <value>Kayıt türleri her zaman korumalıdır</value>
  </data>
  <data name="tcInvalidSignatureForSet" xml:space="preserve">
    <value>Küme üyesi için geçersiz imza</value>
  </data>
  <data name="tcNoWhileInQuery" xml:space="preserve">
    <value>'while' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="lexInvalidCharLiteral" xml:space="preserve">
    <value>Bu geçerli bir karakter sabit değeri değil</value>
  </data>
  <data name="tcReturnValuesCannotHaveNames" xml:space="preserve">
    <value>Dönüş değerlerinin adları olamaz</value>
  </data>
  <data name="tcCannotInheritFromErasedType" xml:space="preserve">
    <value>Silinmiş sağlanan türden devralınamıyor</value>
  </data>
  <data name="etErasedTypeUsedInGeneration" xml:space="preserve">
    <value>'{0}' sağlayıcısı, oluşturulmuş türler kümesi bağlamında oluşturulmamış '{1}' türünü döndürdü. Tür sağlayıcısını yalnızca oluşturulmuş türleri döndürecek şekilde ayarlamayı düşünün.</value>
  </data>
  <data name="tcInvalidEnumConstraint" xml:space="preserve">
    <value>'enum' kısıtlaması 'enum&lt;tür&gt;' biçiminde olmalıdır</value>
  </data>
  <data name="ValueNotContainedMutabilityAbstractsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri soyut, diğeri değil</value>
  </data>
  <data name="tcInvalidMethodNameForEquality" xml:space="preserve">
    <value>'({0})' adı üye adı olarak kullanılmamalıdır. Türe yönelik eşitlik semantiğini tanımlamak için 'Object.Equals' üyesini geçersiz kılın. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</value>
  </data>
  <data name="lexOusideDecimal" xml:space="preserve">
    <value>Bu sayı, ondalık sabit değerleri için izin verilen aralığın dışında</value>
  </data>
  <data name="pickleUnexpectedNonZero" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodunun F# meta verileri okunurken bir hata oluştu. Ayrılmış bir yapı kullanıldı. F# derleyicinizi yükseltmeniz veya bütünleştirilmiş kodun, belirli bir yapıdan yararlanmayan daha eski sürümünü kullanmanız gerekebilir.</value>
  </data>
  <data name="etTooManyStaticParameters" xml:space="preserve">
    <value>Çok fazla statik parametre. En çok {0} parametre bekleniyordu, ancak {1} adlandırılmamış ve {2} adlandırılmış parametre alındı.</value>
  </data>
  <data name="parsNoEqualShouldFollowNamespace" xml:space="preserve">
    <value>'namespace' bildirimini bir '=' simgesi izleyemez</value>
  </data>
  <data name="tcPredefinedTypeCannotBeUsedAsSuperType" xml:space="preserve">
    <value>System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate ve System.Array türleri bir nesne ifadesinde veya sınıfta üst tür olarak kullanılamaz</value>
  </data>
  <data name="buildMultipleToplevelModules" xml:space="preserve">
    <value>Bu dosya, 'module SomeNamespace.SomeModule' formunun birden çok bildirimini içeriyor. Bir dosyada, bu formun yalnızca bir bildirimine izin verilir. Dosyanızı başlangıç ad alanı bildirimi kullanacak şekilde değiştirin ve/veya modüllerinizi tanımlamak için 'module ModuleName = ...' kullanın.</value>
  </data>
  <data name="tcCannotInheritFromInterfaceType" xml:space="preserve">
    <value>Arabirim türünden devralınamıyor. Onun yerine interface ... with kullanın.</value>
  </data>
  <data name="optsCrossoptimize" xml:space="preserve">
    <value>Modüller arası iyileştirmeleri etkinleştir veya devre dışı bırak</value>
  </data>
  <data name="FieldNotContainedAccessibilitiesDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor; imzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</value>
  </data>
  <data name="keywordDescriptionSelect" xml:space="preserve">
    <value>Hangi alanların veya sütunların ayıklanacağını belirtmek için sorgu ifadelerinde kullanılır. Bunun bağlamsal bir anahtar sözcük olduğuna dikkat edin, yani aslında bir ayrılmış anahtar sözcük değildir ve yalnızca uygun bağlamda anahtar sözcük gibi davranır.</value>
  </data>
  <data name="chkNoAddressFieldAtThisPoint" xml:space="preserve">
    <value>'{0}' alanının adresi bu noktada kullanılamaz</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInUnmanaged" xml:space="preserve">
    <value>'unmanaged' kısıtlaması olan bir genel yapının bu konumda veya yakınında kullanılmasındaki belirsizlik çözümlenemedi</value>
  </data>
  <data name="tcThisTypeMayNotHaveACLIMutableAttribute" xml:space="preserve">
    <value>Bu tür tanımının 'CLIMutable' özniteliği olamaz. Yalnızca kayıt türleri bu özniteliğe sahip olabilir.</value>
  </data>
  <data name="lexOutsideSixtyFourBitSigned" xml:space="preserve">
    <value>Bu sayı, 64 bit işaretli tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="parsEnumFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine sabit listesi alanlarında izin verilmez</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNumbersDiffer" xml:space="preserve">
    <value>{2} sayıları farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcInvalidTypeExtension" xml:space="preserve">
    <value>Geçersiz tür uzantısı</value>
  </data>
  <data name="buildProblemWithFilename" xml:space="preserve">
    <value>Dosya adında hata: '{0}': {1}</value>
  </data>
  <data name="lexHashEndifRequiredForElse" xml:space="preserve">
    <value>#else için #endif gerekli</value>
  </data>
  <data name="keywordDescriptionStruct" xml:space="preserve">
    <value>Yapı türü bildirmek için kullanılır. Ayrıca genel parametre kısıtlamaları içinde kullanılır. Modül tanımlarında OCaml uyumluluğu için kullanılır.</value>
  </data>
  <data name="keywordDescriptionStatic" xml:space="preserve">
    <value>Bir türün örneği olmadan veya türün tüm örnekleri arasında paylaşılan bir değer üyesi olmadan çağrılabilecek bir metodu veya özelliği belirtmek için kullanılır.</value>
  </data>
  <data name="tcEntryPointAttributeRequiresFunctionInModule" xml:space="preserve">
    <value>'EntryPointAttribute' özniteliği yalnızca modüllerdeki işlev tanımlarında kullanılabilir</value>
  </data>
  <data name="DefaultParameterValueNotAppropriateForArgument" xml:space="preserve">
    <value>Varsayılan değer, bağımsız değişkenle aynı türde değil. DefaultParameterValue özniteliği ve tüm İsteğe Bağlı öznitelikler yoksayılacak. Not: 'null'un doğru tür ile eklenmesi gerekir, örneğin 'DefaultParameterValue(null:obj)'.</value>
  </data>
  <data name="csIncorrectGenericInstantiation" xml:space="preserve">
    <value>Yanlış genel örnekleme. '{1}' adlı hiçbir {0} üyesi {2} genel bağımsız değişkenlerini almıyor.</value>
  </data>
  <data name="tcNamespaceCannotContainExtensionMembers" xml:space="preserve">
    <value>Ad alanları, türün tanımlandığı dosya ve ad alanı bildirim grubundakiler dışında uzantı üyeleri içeremez. Uzantı üyesi bildirimlerini tutmak için bir modül kullanmayı düşünün.</value>
  </data>
  <data name="keywordDescriptionReturn" xml:space="preserve">
    <value>Bir hesaplama ifadesinin sonucu olarak sağlanacak değeri belirtmek için kullanılır.</value>
  </data>
  <data name="valueIsNotAccessible" xml:space="preserve">
    <value>'{0}' değerine bu kod konumundan erişilemiyor</value>
  </data>
  <data name="lexfltIncorrentIndentationOfIn" xml:space="preserve">
    <value>Bu 'in' belirtecinin girintisi kendisine karşılık gelen 'let''e göre hatalı</value>
  </data>
  <data name="impTypeRequiredUnavailable" xml:space="preserve">
    <value>Burada '{0}' türü gerekiyor ancak tür bulunamıyor. '{1}' bütünleştirilmiş koduna başvuru eklemeniz gerekiyor.</value>
  </data>
  <data name="tcOperatorDoesntAcceptInto" xml:space="preserve">
    <value>'{0}' işleci 'into' kullanımını kabul etmez</value>
  </data>
  <data name="csMemberIsNotStatic" xml:space="preserve">
    <value>{0} bir statik üye değil</value>
  </data>
  <data name="tcAnonymousTypeInvalidInDeclaration" xml:space="preserve">
    <value>Bu bildirimde anonim tür değişkenlerine izin verilmez</value>
  </data>
  <data name="tcRecordFieldInconsistentTypes" xml:space="preserve">
    <value>Bu kayıt tutarsız türlere ait alanlar içeriyor</value>
  </data>
  <data name="tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers" xml:space="preserve">
    <value>'let' ve 'do' bağlamaları tür tanımlarında üye ve arabirim tanımlarından önce gelmelidir</value>
  </data>
  <data name="buildDirectivesInModulesAreIgnored" xml:space="preserve">
    <value>Modül içi yönergeler yoksayılır</value>
  </data>
  <data name="lexOutsideSixteenBitSigned" xml:space="preserve">
    <value>Bu sayı, 16 bit işaretli tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="optsProblemWithCodepage" xml:space="preserve">
    <value>'{0}' kod sayfasında sorun: {1}</value>
  </data>
  <data name="tcAttributeExpressionsMustBeConstructorCalls" xml:space="preserve">
    <value>Öznitelik ifadeleri nesne oluşturucu çağrısı olmalıdır</value>
  </data>
  <data name="tcDelegateConstructorMustBePassed" xml:space="preserve">
    <value>Temsilci oluşturucuya tek bir işlev değeri geçirilmesi gerekiyor</value>
  </data>
  <data name="csIndexArgumentMismatch" xml:space="preserve">
    <value>Bu dizin erişimcisi {0} bağımsız değişkenlerini bekliyor ancak burada {1} verilmiş</value>
  </data>
  <data name="ifExpression" xml:space="preserve">
    <value>'if' ifadesinin bağlam türü gereksinimlerini karşılayabilmesi için '{0}' türüne sahip olması gerekir. Şu anda '{1}' türüne sahip.</value>
  </data>
  <data name="tcAbbreviatedTypesCannotBeSealed" xml:space="preserve">
    <value>Kısaltılmış türlere 'Sealed' özniteliği verilemez</value>
  </data>
  <data name="optsOptimize" xml:space="preserve">
    <value>İyileştirmeleri etkinleştir (Kısa biçimi: -O)</value>
  </data>
  <data name="tcOverrideArityMismatch" xml:space="preserve">
    <value>Bu geçersiz kılma, karşılık gelen soyut üyeden farklı sayıda bağımsız değişken alıyor. Şu soyut üyeler bulundu: {0}</value>
  </data>
  <data name="parsUnmatchedBracket" xml:space="preserve">
    <value>Eşleşmeyen '['</value>
  </data>
  <data name="tcLiteralCannotBeInline" xml:space="preserve">
    <value>Sabit değer 'inline' olarak işaretlenemez</value>
  </data>
  <data name="augNoEqualityNeedsNoComparison" xml:space="preserve">
    <value>'NoEquality' özniteliği, 'NoComparison' özniteliği ile bağlantılı kullanılmalıdır</value>
  </data>
  <data name="crefQuotationsCantRequireByref" xml:space="preserve">
    <value>Alıntılar, byref işaretçileri gerektiren ifadeler içeremez</value>
  </data>
  <data name="tcUnexpectedSlashInType" xml:space="preserve">
    <value>Türde beklenmeyen /</value>
  </data>
  <data name="tcTypesAreAlwaysSealedAssemblyCode" xml:space="preserve">
    <value>Bütünleştirilmiş kod türleri her zaman korumalıdır</value>
  </data>
  <data name="buildNoInputsSpecified" xml:space="preserve">
    <value>Bir giriş belirtilmedi</value>
  </data>
  <data name="tcNonZeroConstantCannotHaveGenericUnit" xml:space="preserve">
    <value>Sıfır olmayan sabitlerin genel birimleri olamaz. Genel sıfır için 0.0&lt;_&gt; yazın.</value>
  </data>
  <data name="parsInvalidProperty" xml:space="preserve">
    <value>Geçersiz özellik alıcı veya ayarlayıcı</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer" xml:space="preserve">
    <value>İmzada {2} bildirilirken uygulamada {3} bildirildiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="etIllegalCharactersInNamespaceName" xml:space="preserve">
    <value>'{1}' sağlanan ad alanı adında '{0}' karakterine izin verilmez</value>
  </data>
  <data name="buildInvalidHashIDirective" xml:space="preserve">
    <value>Geçersiz yönerge. Beklenen: '#I \"&lt;yol&gt;\"'.</value>
  </data>
  <data name="lexOutsideThirtyTwoBitUnsigned" xml:space="preserve">
    <value>Bu sayı, 32 bit işaretsiz tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="chkPropertySameNameMethod" xml:space="preserve">
    <value>'{0}' özelliği, '{1}' türündeki bir metotla aynı ada sahip.</value>
  </data>
  <data name="typeInfoEvent" xml:space="preserve">
    <value>olay</value>
  </data>
  <data name="typeInfoField" xml:space="preserve">
    <value>alan</value>
  </data>
  <data name="tastRecursiveValuesMayNotBeInConstructionOfTuple" xml:space="preserve">
    <value>Özyinelemeli tanımlanmış değerler özyinelemeli bir bağlama içinde demet değer oluşumunun parçası olarak doğrudan görünemez</value>
  </data>
  <data name="optsDCLOHtmlDoc" xml:space="preserve">
    <value>Komut satırı seçeneği '{0}' kullanım dışı bırakıldı. HTML belgesi oluşturma şimdi FsHtmlDoc.exe aracı yoluyla F# Power Pack'in bir parçası.</value>
  </data>
  <data name="tcAttributesAreNotPermittedOnLetBindings" xml:space="preserve">
    <value>İfadelerdeki 'let' bağlamalarında özniteliğe izin verilmez</value>
  </data>
  <data name="ValueNotContainedMutabilityParameterCountsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İlgili tür parametresi sayıları farklı</value>
  </data>
  <data name="tcMemberIsNotSufficientlyGeneric" xml:space="preserve">
    <value>Bu üye yeterince genel değil</value>
  </data>
  <data name="keywordDescriptionTrueFalse" xml:space="preserve">
    <value>Boolean sabit değeri olarak kullanılır.</value>
  </data>
  <data name="crefQuotationsCantContainDescendingForLoops" xml:space="preserve">
    <value>Alıntılar, döngülere yönelik azalan sıra içeremez</value>
  </data>
  <data name="optsBaseaddress" xml:space="preserve">
    <value>Oluşturulacak kitaplığın temel adresi</value>
  </data>
  <data name="buildProblemReadingAssembly" xml:space="preserve">
    <value>Bütünleştirilmiş kod okuma hatası: '{0}': {1}</value>
  </data>
  <data name="etNullMember" xml:space="preserve">
    <value>'{0}' sağlanan türü bir null üye döndürdü</value>
  </data>
  <data name="impReferencedTypeCouldNotBeFoundInAssembly" xml:space="preserve">
    <value>'{1}' bütünleştirilmiş kodunda '{0}' türüne başvuru bulundu, ancak bu tür o bütünleştirilmiş kodda bulunamadı</value>
  </data>
  <data name="tcGenericParameterHasBeenConstrained" xml:space="preserve">
    <value>Genel bir tür parametresi, her zaman '{0}' olarak kısıtlanacak şekilde kullanılmış</value>
  </data>
  <data name="ValueNotContainedMutabilityOverridesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri geçersiz kılma olarak işaretlenmiş, diğeri işaretlenmemiş</value>
  </data>
  <data name="tcExpressionCountMisMatch" xml:space="preserve">
    <value>{0} ifadeleri bekleniyordu, {1} alındı</value>
  </data>
  <data name="tcDeclaredTypeParametersForExtensionDoNotMatchOriginal" xml:space="preserve">
    <value>Bu tür uzantısı için bildirilen tür parametrelerinden bir veya daha fazlası, '{0}' üzerindeki özgün tür tür kısıtlamaları ile eşleşmeyen eksik veya yanlış bir tür kısıtlaması içeriyor</value>
  </data>
  <data name="tcAtLeastOneOverrideIsInvalid" xml:space="preserve">
    <value>En az bir geçersiz kılma işlemi kendisine karşılık gelen soyut üyeyi doğru uygulamadı</value>
  </data>
  <data name="fscAssemblyVersionAttributeIgnored" xml:space="preserve">
    <value>Komut satırı seçeneği kullanılarak sürüm verildiği için 'AssemblyVersionAttribute' yok sayıldı</value>
  </data>
  <data name="tcDefaultValueAttributeRequiresVal" xml:space="preserve">
    <value>'DefaultValue' özniteliği yalnızca 'val' bildirimlerinde kullanılabilir</value>
  </data>
  <data name="tcTypesAreAlwaysSealedStruct" xml:space="preserve">
    <value>Yapı türleri her zaman korumalıdır</value>
  </data>
  <data name="tcTypesCannotInheritFromMultipleConcreteTypes" xml:space="preserve">
    <value>Türler birden çok somut türden devralamaz</value>
  </data>
  <data name="tcUnexpectedTypeArguments" xml:space="preserve">
    <value>Beklenmeyen tür bağımsız değişkenleri</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleMissingInterface" xml:space="preserve">
    <value>İmzanın, türün {2} arabirimini desteklemesini gerektirmesine rağmen arabirim uygulanmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="optsHelpBannerCodeGen" xml:space="preserve">
    <value>- KOD ÜRETİMİ -</value>
  </data>
  <data name="tcUnexpectedConstUint16Array" xml:space="preserve">
    <value>Beklenmeyen Const_uint16array</value>
  </data>
  <data name="tcMemberUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' üyesi geçersiz bir biçimde kullanılmış. '{1}' kullanımı, '{2}' tanımından önce çıkarılmış, bu geçersiz bir ileriye doğru başvurudur.</value>
  </data>
  <data name="descriptionWordIs" xml:space="preserve">
    <value>:</value>
  </data>
  <data name="tcUnsupportedAttribute" xml:space="preserve">
    <value>Bu öznitelik F# dilinin bu sürümünde kullanılamaz</value>
  </data>
  <data name="tcAttributesInvalidInPatterns" xml:space="preserve">
    <value>Desen içinde özniteliğe izin verilmez</value>
  </data>
  <data name="tcCannotOverrideSealedMethod" xml:space="preserve">
    <value>Devralınan üye '{0}' korumalı olduğu için geçersiz kılınamıyor</value>
  </data>
  <data name="tcTypeHasNoNestedTypes" xml:space="preserve">
    <value>Bu türde hiç iç içe tür yok</value>
  </data>
  <data name="buildUnexpectedFileNameCharacter" xml:space="preserve">
    <value>Dosya adı '{0}', geçersiz '{1}' karakterini içeriyor</value>
  </data>
  <data name="undefinedNameFieldConstructorOrMember" xml:space="preserve">
    <value>'{0}' alanı, oluşturucusu veya üyesi tanımlı değil.</value>
  </data>
  <data name="chkReflectedDefCantSplice" xml:space="preserve">
    <value>[&lt;ReflectedDefinition&gt;] terimleri ön ek ekleme işleci '%' kullanımını içeremez</value>
  </data>
  <data name="csTypeInstantiationLengthMismatch" xml:space="preserve">
    <value>Tür örnekleme uzunluğu uyuşmazlığı</value>
  </data>
  <data name="parsSetterAtMostTwoArguments" xml:space="preserve">
    <value>Ayarlayıcı özelliğinin en çok iki bağımsız değişken grubu olabilir</value>
  </data>
  <data name="optsNowarn" xml:space="preserve">
    <value>Belirli uyarı iletilerini devre dışı bırak</value>
  </data>
  <data name="optsNologo" xml:space="preserve">
    <value>Derleyici telif hakkı iletisini gösterme</value>
  </data>
  <data name="ilFieldDoesNotHaveValidOffsetForStructureLayout" xml:space="preserve">
    <value>'{0}' türünün Açık düzeni olduğu işaretlenmiş, ancak '{1}' alanı 'FieldOffset' özniteliğiyle işaretlenmemiş</value>
  </data>
  <data name="FieldNotContainedTypesDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Türler farklı</value>
  </data>
  <data name="chkNoFirstClassSplicing" xml:space="preserve">
    <value>İfade ekleme işlecinin birinci sınıf kullanımlarına izin verilmiyor</value>
  </data>
  <data name="tcTypeCastErased" xml:space="preserve">
    <value>Bu alt türe çevirme işlemi '{0}' sağlanan türünü '{1}' türüne siler.</value>
  </data>
  <data name="tcMemberFoundIsNotAbstractOrVirtual" xml:space="preserve">
    <value>{0} türü, '{1}' üyesini içeriyor ancak bu, geçersiz kılma veya uygulama için kullanılabilen bir sanal veya soyut metot değil.</value>
  </data>
  <data name="tcAttribArgsDiffer" xml:space="preserve">
    <value>'{0}' özniteliği hem uygulamada hem de imzada görünüyor ancak özniteliğin bağımsız değişkenleri farklı. Derlenmiş koda yalnızca imzadaki öznitelik eklenecek.</value>
  </data>
  <data name="cannotResolveNullableOperators" xml:space="preserve">
    <value>'{0}' işleci çözümlenemiyor. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</value>
  </data>
  <data name="buildUnrecognizedOption" xml:space="preserve">
    <value>Tanınmayan seçenek: '{0}'</value>
  </data>
  <data name="typeInfoExtension" xml:space="preserve">
    <value>uzantı</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInImplButNotSig" xml:space="preserve">
    <value>'{0}' alanı uygulamada olup imzada olmadığı için özel durum tanımları uyumlu değil. Modül,\n    {1}    \nözel durum tanımını içeriyor ancak imzasında\n\t{2} belirtiliyor.</value>
  </data>
  <data name="csMethodFoundButIsNotStatic" xml:space="preserve">
    <value>'{0}' türünün '{1}' metodu var (tam adı '{2}'), ancak bu metot statik değil</value>
  </data>
  <data name="chkErrorContainsCallToRethrow" xml:space="preserve">
    <value>'Reraise' çağrıları yalnızca doğrudan try-with ifadesinin işleyicisinde oluşabilir</value>
  </data>
  <data name="tcTypesAreAlwaysSealedEnum" xml:space="preserve">
    <value>Sabit listesi türleri her zaman korumalıdır</value>
  </data>
  <data name="csArgumentTypesDoNotMatch" xml:space="preserve">
    <value>Bağımsız değişken türleri eşleşmiyor</value>
  </data>
  <data name="forLIsUnnecessary" xml:space="preserve">
    <value>Bu biçim tanımlayıcıdaki 'l' veya 'L' gereksiz. Bunun yerine F# kodunda, tüm temel tamsayı türleriyle çalışmak üzere aşırı yüklenmiş olan %d, %x, %o veya %u kullanabilirsiniz.</value>
  </data>
  <data name="keywordDescriptionPublic" xml:space="preserve">
    <value>Türün dışından üyeye erişim sağlar.</value>
  </data>
  <data name="csNullableTypeDoesNotHaveNull" xml:space="preserve">
    <value>'{0}' türünün uygun değer olarak bir 'null' değeri yok. Boş değer atanabilir türe bir boş değer atamak için 'System.Nullable()' kullanın.</value>
  </data>
  <data name="optRecursiveValValue" xml:space="preserve">
    <value>Özyinelemeli ValValue {0}</value>
  </data>
  <data name="chkNoByrefsOfByrefs" xml:space="preserve">
    <value>'{0}' türü byref&lt;T&gt; içinde olduğu için geçersiz, T byref türlerini içeremez.</value>
  </data>
  <data name="optsDefine" xml:space="preserve">
    <value>Koşullu derleme simgelerini tanımla (Kısa biçimi: -d)</value>
  </data>
  <data name="parsAttributesIllegalOnInherit" xml:space="preserve">
    <value>'inherit' tanımlamalarında özniteliklere izin verilmez</value>
  </data>
  <data name="etPropertyCanWriteButHasNoSetter" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' özelliğinde CanWrite=true var, ancak GetSetMethod() yönteminden bir değer yok</value>
  </data>
  <data name="ExceptionDefsNotCompatibleExceptionDeclarationsDiffer" xml:space="preserve">
    <value>Özel durum bildirimleri farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</value>
  </data>
  <data name="buildExpectedSigdataFile" xml:space="preserve">
    <value>FSharp.Core.sigdata, FSharp.Core ile birlikte bulunamadı. Dosyanın {0} içinde olması bekleniyordu. Bu dosyayı gerektirmeyen daha yeni bir FSharp.Core sürümüne yükseltmeniz önerilir.</value>
  </data>
  <data name="pplexExpectedSingleLineComment" xml:space="preserve">
    <value>Tek satırlık açıklama veya satır sonu bekleniyordu</value>
  </data>
  <data name="etProviderReturnedNull" xml:space="preserve">
    <value>Tür sağlayıcısı 'null' döndürdü; bu '{0}' öğesinden gelen geçerli bir dönüş değeri değil</value>
  </data>
  <data name="lexHashIfMustHaveIdent" xml:space="preserve">
    <value>#if yönergesinin hemen ardından tanımlayıcı gelmelidir</value>
  </data>
  <data name="typrelNoImplementationGivenWithSuggestion" xml:space="preserve">
    <value>'{0}' için bir uygulama verilmedi. Tüm arabirim üyelerinin uygulanması ve uygun bir 'interface' bildirimi, örn. 'interface ... with member ...' altında listelenmesi gerektiğine dikkat edin.</value>
  </data>
  <data name="parsExpectedExpressionAfterLet" xml:space="preserve">
    <value>Bu '{0}' öğesini izleyen blok tamamlanmadı. Her kod bloğu bir ifadedir ve bir sonucu olmalıdır. '{1}' bir bloktaki son kod öğesi olamaz. Bu bloğa açık bir sonuç vermeyi düşünün.</value>
  </data>
  <data name="parsUnexpectedEndOfFileWhile" xml:space="preserve">
    <value>'while' ifadesinde beklenmeyen giriş sonu. 'while &lt;expr&gt; do &lt;expr&gt;' bekleniyordu.</value>
  </data>
  <data name="tcMeasureDefinitionsCannotHaveTypeParameters" xml:space="preserve">
    <value>Ölçü tanımlarının tür parametreleri olamaz</value>
  </data>
  <data name="buildDifferentVersionMustRecompile" xml:space="preserve">
    <value>F# ile derlenen '{0}' DLL dosyasının, F# dilinin bu sürümünde kullanılabilmesi için yeniden derlenmesi gerekiyor</value>
  </data>
  <data name="parsUnexpectedEndOfFileMatch" xml:space="preserve">
    <value>'match' ifadesinde beklenmeyen giriş sonu. 'match &lt;ifade&gt; with | &lt;pat&gt; -&gt; &lt;ifade&gt; | &lt;pat&gt; -&gt; &lt;ifade&gt; ...' bekleniyordu.</value>
  </data>
  <data name="tcInterfaceTypesAndDelegatesCannotContainFields" xml:space="preserve">
    <value>Arabirim türleri ve temsilci türleri alan içeremez</value>
  </data>
  <data name="buildCompilingExtensionIsForML" xml:space="preserve">
    <value>'.ml' ve '.mli' dosya uzantıları ML uyumluluğu içindir</value>
  </data>
  <data name="typeInfoNamespace" xml:space="preserve">
    <value>ad alanı</value>
  </data>
  <data name="csMemberSignatureMismatch" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken gerektirir. Gereken imza: '{2}'.</value>
  </data>
  <data name="tcMeasureDeclarationsRequireStaticMembersNotConstructors" xml:space="preserve">
    <value>Ölçü bildirimlerinin yalnızca statik üyeleri olabilir: oluşturucular kullanılmaz</value>
  </data>
  <data name="tcStaticInitializersIllegalInInterface" xml:space="preserve">
    <value>Arabirimler statik başlatıcı tanımları içeremez</value>
  </data>
  <data name="crefNoInnerGenericsInQuotations" xml:space="preserve">
    <value>Tırnak içindeki ifadelerde iç genel işlevlere izin verilmez. Bu işlev artık genel olmayacak şekilde bazı tür kısıtlamaları eklemeyi düşünün.</value>
  </data>
  <data name="optsUnknownArgumentToTheTestSwitch" xml:space="preserve">
    <value>Bilinmeyen --test bağımsız değişkeni: '{0}'</value>
  </data>
  <data name="csTypeInferenceMaxDepth" xml:space="preserve">
    <value>Tür çıkarma sorunu çok karmaşık (en fazla yinelenme derinliğine ulaşıldı). İlave tür ek açıklamaları eklemeyi düşünün.</value>
  </data>
  <data name="undefinedNameValueNamespaceTypeOrModule" xml:space="preserve">
    <value>'{0}' değeri, ad alanı, türü veya modülü tanımlı değil.</value>
  </data>
  <data name="ModuleContainsConstructorButDataFieldsDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. İlgili veri alanı sayısı farklı</value>
  </data>
  <data name="tcStructsMayNotContainDoBindings" xml:space="preserve">
    <value>Yapıların varsayılan oluşturucusu 'do' bağlamalarını yürütmeyeceği için yapılar bu bağlamaları içeremez</value>
  </data>
  <data name="keywordDescriptionUpcast" xml:space="preserve">
    <value>Devralma zincirinde daha yukarıda bulunan bir türe dönüştürmek için kullanılır.</value>
  </data>
  <data name="customOperationTextLikeGroupJoin" xml:space="preserve">
    <value>{1} koleksiyonunda (outerKey = innerKey) gruba yönelik {0} değişken. '{2}' öğesinden sonra parantezlerin gerekli olduğuna dikkat edin</value>
  </data>
  <data name="tcDefaultStructConstructorCall" xml:space="preserve">
    <value>Varsayılan seçenek olan yapı türünün sıfır ile başlayan oluşturucusu yalnızca yapı türünün tüm alanları varsayılan başlatmayı kabul ediyorsa kullanılabilir</value>
  </data>
  <data name="tcGenericTypesCannotHaveStructLayout" xml:space="preserve">
    <value>Genel türlere 'StructLayout' özniteliği verilemez</value>
  </data>
  <data name="tcExplicitObjectConstructorSyntax" xml:space="preserve">
    <value>Açık nesne oluşturucusu 'new(args) = expr' sözdizimini kullanmalıdır</value>
  </data>
  <data name="keywordDescriptionUntypedQuotation" xml:space="preserve">
    <value>Türü belirtilmemiş kod alıntısını ayırır.</value>
  </data>
  <data name="tcStructsMayNotContainLetBindings" xml:space="preserve">
    <value>Yapıların varsayılan oluşturucusu bu bağlamaları yürütmeyeceği için yapılar değer tanımlarını içeremez. Türün birincil oluşturucusuna ek bağımsız değişkenler eklemeyi düşünün.</value>
  </data>
  <data name="lexOutsideEightBitSigned" xml:space="preserve">
    <value>Bu sayı, 8 bit işaretli tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="etUnsupportedMemberKind" xml:space="preserve">
    <value>'{1}' sağlanan türünde geçersiz '{0}' üyesi. Yalnızca özelliklere, metotlara ve oluşturuculara izin verilir</value>
  </data>
  <data name="tcFieldRequiresAssignment" xml:space="preserve">
    <value>'{1}' türündeki '{0}' alanı için bir atama verilmedi</value>
  </data>
  <data name="csTypeDoesNotSupportOperator" xml:space="preserve">
    <value>'{0}' türü '{1}' işlecini desteklemez</value>
  </data>
  <data name="chkNoAddressStaticFieldAtThisPoint" xml:space="preserve">
    <value>'{0}' statik alanının adresi bu noktada kullanılamaz</value>
  </data>
  <data name="tcOpenUsedWithPartiallyQualifiedPath" xml:space="preserve">
    <value>Bu bildirim, ad alanını veya '{0}' modülünü kısmen nitelenmiş yol aracılığıyla açıyor. Bu kodu, ad alanının tam yolunu kullanacak şekilde ayarlayın. Bu değişiklik, F# ve CLI kitaplıklarına yeni yapılar eklendikçe kodunuzun daha sağlam kılar.</value>
  </data>
  <data name="tcDoBangIllegalInSequenceExpression" xml:space="preserve">
    <value>'do!' dizi ifadeleri içinde kullanılamaz</value>
  </data>
  <data name="buildImplementationAlreadyGivenDetail" xml:space="preserve">
    <value>'{0}' dosyasını veya modülünü uygulama örneği zaten verildi. Tür çıkarımı nedeniyle F# dilinde derleme sırası önemlidir. Uygulamadan önce imza dosyasını yerleştirmek için dosyalarınızın sırasını ayarlamanız gerekebilir. Visual Studio'da dosyalar, el ile düzenlenebilen veya çözüm gezgini kullanılarak ayarlanabilen proje dosyasında göründükleri sırada türlerine göre denetlenir.</value>
  </data>
  <data name="invalidNamespaceForProvidedType" xml:space="preserve">
    <value>sağlanan tür için geçersiz ad alanı</value>
  </data>
  <data name="tcTypeDefinitionIsCyclicThroughInheritance" xml:space="preserve">
    <value>Bu tür tanımı, yapı alanı veya devralma ilişkisi aracılığıyla anlık döngüsel başvuru içeriyor</value>
  </data>
  <data name="tcNonLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Bu değer bir sabit değer olmadığından desende kullanılamaz</value>
  </data>
  <data name="tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly" xml:space="preserve">
    <value>Bir struct türünün birincil oluşturucusunun her bağımsız değişkenine bir tür verilmelidir, örneğin 'type S(x1:int, x2: int) = ...'. Bu bağımsız değişkenler yapının alanlarını belirler.</value>
  </data>
  <data name="tcMutableValuesMayNotHaveGenericParameters" xml:space="preserve">
    <value>Değişebilir değerlerin genel parametreleri olamaz</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInDelegate" xml:space="preserve">
    <value>Bu konumda veya yakınında 'delegate' kısıtlaması olan bir genel yapının kullanımındaki belirsizlik çözümlenemedi</value>
  </data>
  <data name="tcInvalidDelegateSpecification" xml:space="preserve">
    <value>Temsilci belirtimleri 'typ -&gt; typ' biçiminde olmalıdır</value>
  </data>
  <data name="chkNoReflectedDefinitionOnStructMember" xml:space="preserve">
    <value>Örnek üyesi örtük 'this' byref parametresini aldığı için ReflectedDefinitionAttribute, yapı türündeki bir örnek üyesine uygulanamaz</value>
  </data>
  <data name="parsGetAndOrSetRequired" xml:space="preserve">
    <value>'get' ve/veya 'set' gerekiyor</value>
  </data>
  <data name="forDoesNotSupportPrefixFlag" xml:space="preserve">
    <value>'{0}', ön ek '{1}' bayrağını desteklemiyor</value>
  </data>
  <data name="tcTypeParameterHasBeenConstrained" xml:space="preserve">
    <value>Bu tür parametresi, her zaman '{0}' olarak kısıtlanacak şekilde kullanılmış</value>
  </data>
  <data name="tcNamedArgumentsCannotBeUsedInMemberTraits" xml:space="preserve">
    <value>Adlandırılmış bağımsız değişkenler üye nitelik çağrılarına verilemez</value>
  </data>
  <data name="toolLocationHelperUnsupportedFrameworkVersion" xml:space="preserve">
    <value>Belirtilen '{0}' .NET Framework sürümü desteklenmiyor. Lütfen Microsoft.Build.Utilities.TargetDotNetFrameworkVersion sabit listesinden bir değer belirtin.</value>
  </data>
  <data name="tcLiteralAttributeRequiresConstantValue" xml:space="preserve">
    <value>Sabit değer de verilmişse bir bildirim yalnızca [&lt;Literal&gt;] özniteliği olabilir, örn. 'val x : int = 1'</value>
  </data>
  <data name="buildInvalidSourceFileExtension" xml:space="preserve">
    <value>Dosya uzantısı '{0}' tanınmadı. Kaynak dosyaların uzantısı .fs, .fsi, .fsx, .fsscript, .ml veya .mli olmalıdır.</value>
  </data>
  <data name="tcInheritDeclarationMissingArguments" xml:space="preserve">
    <value>Bu 'inherit' bildirimi devralınan türü belirtiyor ancak hiç bağımsız değişken yok. Bağımsız değişkenleri sağlamayı düşünün, örn. 'inherit BaseType(args)'.</value>
  </data>
  <data name="optsPdb" xml:space="preserve">
    <value>Çıkış hata ayıklama dosyasını adlandır</value>
  </data>
  <data name="optsLib" xml:space="preserve">
    <value>Kaynak dosyalarını ve bütünleştirilmiş kodları çözümlemek için kullanılan ekleme yolu için bir dizin belirtin (Kısa biçimi: -I)</value>
  </data>
  <data name="optsSig" xml:space="preserve">
    <value>Bütünleştirilmiş kodun çıkartılan arabirimini dosyaya yazdır</value>
  </data>
  <data name="optsBuildModule" xml:space="preserve">
    <value>Başka bir bütünleştirilmiş koda eklenebilir bir modül oluştur</value>
  </data>
  <data name="parsActivePatternCaseContainsPipe" xml:space="preserve">
    <value>'|' karakterine ektin desen örneği tanımlayıcılarında izin verilmez</value>
  </data>
  <data name="parsAccessibilityModsIllegalForAbstract" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine bu üyede izin verilmiyor. Soyut yuvalar, kapsayan tür ile her zaman aynı görünürlüğe sahiptir.</value>
  </data>
  <data name="commaInsteadOfSemicolonInRecord" xml:space="preserve">
    <value>Kayıtlarda alan değerlerini ayırmak için ';' kullanılır. ',' karakterini ';' ile değiştirmeyi düşünün.</value>
  </data>
  <data name="typrelCannotResolveAmbiguityInOverloadedOperator" xml:space="preserve">
    <value>'{0}' işlecinin bu program noktasında veya yakınında kullanılmasında bulunan belirsizlik çözümlenemedi. Bu belirsizliği çözmek için tür ek açıklamaları kullanmayı düşünün.</value>
  </data>
  <data name="undefinedNameType" xml:space="preserve">
    <value>'{0}' türü tanımlı değil.</value>
  </data>
  <data name="keywordDescriptionInline" xml:space="preserve">
    <value>Doğrudan çağıranın koduyla tümleştirilmesi gereken bir işlevi belirtmek için kullanılır.</value>
  </data>
  <data name="tcNotValidEnumCaseName" xml:space="preserve">
    <value>Bu, sabit listesi durumu olarak geçerli bir ad değil</value>
  </data>
  <data name="tcInstanceMemberRequiresTarget" xml:space="preserve">
    <value>Bu örnek üyesinin çağrılan nesneyi temsil etmek için parametreye ihtiyacı var. Üyeyi statik yapın veya 'member x.Member(args) = ...' gösterimini kullanın.</value>
  </data>
  <data name="etNoStaticParameterWithName" xml:space="preserve">
    <value>'{0}' adında hiç statik parametre yok</value>
  </data>
  <data name="augNoEqNeedsNoObjEquals" xml:space="preserve">
    <value>'NoEquality' özniteliği olan bir türde, genellikle açık olarak uygulanmış 'Object.Equals(obj)' metodu olmamalıdır. Bu birlikte çalışabilme amacıyla bilerek yapılmışsa bu uyarıyı devre dışı bırakın</value>
  </data>
  <data name="tastValueHasBeenCopied" xml:space="preserve">
    <value>Bu işlemin özgün değeri değiştirmemesi veya bir üyeden yapı döndürülürken başka bir üyeye erişildiğinde kopyalanmış değer örtük olduğu için, değer kopyalandı</value>
  </data>
  <data name="tcConstrainedTypeVariableCannotBeGeneralized" xml:space="preserve">
    <value>Bu bağlamanın bir veya daha fazla açık sınıf veya işlev türü değişkeni diğer türlerle kısıtlandığı için oluşturulamadı</value>
  </data>
  <data name="csCandidates" xml:space="preserve">
    <value>Adaylar: {0}</value>
  </data>
  <data name="parsUnmatchedWith" xml:space="preserve">
    <value>Eşleşmeyen 'with' veya hatalı biçimlendirilmiş 'with' bloğu</value>
  </data>
  <data name="listElementHasWrongType" xml:space="preserve">
    <value>Bir list constructor ifadesinin tüm öğeleri aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</value>
  </data>
  <data name="tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors" xml:space="preserve">
    <value>Açık tür belirtimleri özel durum oluşturucuları için kullanılamaz</value>
  </data>
  <data name="nrRecordTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>'{0}' kayıt alanının kayıt türü RequireQualifiedAccessAttribute ile tanımlanmış. Kullandığınız ada kayıt türünün adını ('{1}') dahil edin.</value>
  </data>
  <data name="tcFormalArgumentIsNotOptional" xml:space="preserve">
    <value>Karşılık gelen biçimsel bağımsız değişken isteğe bağlı değil</value>
  </data>
  <data name="typrelInvalidValue" xml:space="preserve">
    <value>Geçersiz değer</value>
  </data>
  <data name="ArgumentsInSigAndImplMismatch" xml:space="preserve">
    <value>'{0}' imzasındaki ve '{1}' uygulamasındaki bağımsız değişken adları eşleşmiyor. İmza dosyasındaki bağımsız değişken adı kullanılacak. Bu, hata ayıklama veya profil oluşturma sırasında sorunlara neden olabilir.</value>
  </data>
  <data name="chkUnusedValue" xml:space="preserve">
    <value>'{0}' değeri kullanılmıyor</value>
  </data>
  <data name="buildOptionRequiresParameter" xml:space="preserve">
    <value>Seçenek şu parametreyi gerektiriyor: {0}</value>
  </data>
  <data name="tcInvalidDeclaration" xml:space="preserve">
    <value>Geçersiz bildirim</value>
  </data>
  <data name="lexOutsideNativeUnsigned" xml:space="preserve">
    <value>Bu sayı, işaretsiz yerel tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="undefinedNamePatternDiscriminator" xml:space="preserve">
    <value>'{0}' desen ayrıştırıcısı tanımlı değil.</value>
  </data>
  <data name="parsUnexpectedEndOfFile" xml:space="preserve">
    <value>Beklenmeyen giriş sonu</value>
  </data>
  <data name="tastTwoModulesWithSameNameInAssembly" xml:space="preserve">
    <value>'{0}' adlı iki modül bu bütünleştirilmiş kodun iki yerinde geçiyor</value>
  </data>
  <data name="moreThanOneInvokeMethodFound" xml:space="preserve">
    <value>Temsilci türü için birden fazla Invoke metodu bulundu</value>
  </data>
  <data name="notAFunctionButMaybeIndexerWithName" xml:space="preserve">
    <value>Bu değer, bir işlev değil ve uygulanamaz. Dizin oluşturucuya bunun yerine {0}.[index] üzerinden erişmeye mi çalışıyordunuz?</value>
  </data>
  <data name="tcParameterInferredByref" xml:space="preserve">
    <value>'{0}' parametresinin byref türüne sahip olduğu çıkartıldı. byref türündeki parametrelerin açık bir türün ek açıklamasında verilmesi gerekir, örn. 'x1: byref&lt;int&gt;'. Kullanıldığında, örtük olarak byref parametresinin başvurusu kaldırılır.</value>
  </data>
  <data name="tcStaticMemberShouldNotHaveThis" xml:space="preserve">
    <value>Bu statik üyenin 'this' parametresi olmamalıdır. 'member Member(args) = ...' gösterimini kullanmayı düşünün.</value>
  </data>
  <data name="csGenericConstructRequiresNonAbstract" xml:space="preserve">
    <value>Genel bir yapı, '{0}' türünün soyut olmamasını gerektirir</value>
  </data>
  <data name="optsNoOpt" xml:space="preserve">
    <value>Yalnızca satır içindeki yapıları uygulamak için gerekli iyileştirme bilgilerini ekleyin. Modüller arasında satır içine yerleştirmeyi kısıtlar ancak ikili uyumluluğunu geliştirir.</value>
  </data>
  <data name="tcRepresentationOfTypeHiddenBySignature" xml:space="preserve">
    <value>Bu türün gösterimi imza ile gizlenir. Türün özelliğini belirtmek için [&lt;Sealed&gt;], [&lt;Class&gt;] veya [&lt;Interface&gt;] gibi bir öznitelik verilmelidir.</value>
  </data>
  <data name="forDoesNotSupportZeroFlag" xml:space="preserve">
    <value>'{0}' biçimi '0' bayrağını desteklemiyor</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScope" xml:space="preserve">
    <value>Tür çıkarımı, {0} tür değişkeninin kapsamından çıkmasına neden oldu. Açık bir tür parametresi bildirimi ekleyebilir ya da kodunuzu ayarlayarak daha az genel hale getirebilirsiniz.</value>
  </data>
  <data name="optsDebug" xml:space="preserve">
    <value>Hata ayıklama türünü belirtin: full, portable, embedded, pdbonly. (Hata ayıklama türü belirtilmemişse '{0}' varsayılandır ve çalışan bir programa hata ayıklayıcı iliştirmeyi etkinleştirir. 'portable' bir çoklu platform biçimidir, 'embedded' çıkış dosyasına gömülü bir çoklu platform biçimidir).</value>
  </data>
  <data name="parsOnlyHashDirectivesAllowed" xml:space="preserve">
    <value>İlk 'namespace' bildiriminden önce yalnızca '#' derleyici yönergeleri gerçekleşebilir</value>
  </data>
  <data name="optLocalValueNotFoundDuringOptimization" xml:space="preserve">
    <value>İyileştirme sırasında {0} yerel değeri bulunamadı</value>
  </data>
  <data name="etIncorrectProvidedMethod" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}', kendisinin '{3}' tanımlayan türünün metotları arasında bildirilmeyen '{1}' adlı ve meta veri belirteci '{2}' olan bir metot sağladı</value>
  </data>
  <data name="tcOperatorIncorrectSyntax" xml:space="preserve">
    <value>'{0}' için hatalı sözdizimi. Kullanım: {1}.</value>
  </data>
  <data name="lexInvalidFloat" xml:space="preserve">
    <value>Geçersiz kayan noktalı sayı</value>
  </data>
  <data name="tcConstructorsIllegalInAugmentation" xml:space="preserve">
    <value>Oluşturucuların, uzantı üyesi olarak kullanılmalarına izin verilmez. Türün özgün tanımının bir parçası olarak tanımlanmaları gerekir.</value>
  </data>
  <data name="csCtorHasNoArgumentOrReturnProperty" xml:space="preserve">
    <value>'{0}' nesne oluşturucusu, bağımsız değişkene veya ayarlanabilen '{1}' dönüş özelliğine sahip değil. {2}.</value>
  </data>
  <data name="invalidPlatformTarget" xml:space="preserve">
    <value>'anycpu32bitpreferred' platformu yalnızca EXE hedefleriyle kullanılabilir. Onun yerine 'anycpu' kullanmalısınız.</value>
  </data>
  <data name="FieldNotContainedNamesDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. Adlar farklı</value>
  </data>
  <data name="ValueNotContainedMutabilityStaticsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri statik, diğeri değil</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed" xml:space="preserve">
    <value>Uygulama türü korumalı olmamasına rağmen imza korumalı olmasını gerektirdiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Uygulamaya [&lt;Sealed&gt;] özniteliğini eklemeyi düşünün.</value>
  </data>
  <data name="tcTryIllegalInSequenceExpression" xml:space="preserve">
    <value>Dizi ifadeleri içinde 'try'/'with' kullanılamaz</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig" xml:space="preserve">
    <value>'{2}' soyut üyesi uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="typrelExplicitImplementationOfGetHashCode" xml:space="preserve">
    <value>'{0}' yapı, kayıt veya birleşim türünde açık 'Object.GetHashCode' uygulaması var. 'Object.Equals(obj)' için bununla eşleşen bir geçersiz kılma uygulamayı düşünün</value>
  </data>
  <data name="keywordDescriptionMember" xml:space="preserve">
    <value>Bir nesne türü içinde özellik veya metot bildirmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionModule" xml:space="preserve">
    <value>Bir adı diğer kodlardan mantıksal olarak ayırmak amacıyla, birbiriyle ilişkili bir tür, değer ve işlev grubuyla ilişkilendirmek için kullanılır.</value>
  </data>
  <data name="ValueNotContainedMutabilityTypesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Türler farklı</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer" xml:space="preserve">
    <value>İlgili tür parametresi sayıları farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcDelegatesCannotBeCurried" xml:space="preserve">
    <value>Temsilci belirtimleri eksiltimli türler olmamalıdır. Çok bağımsız değişkenli temsilciler için 'typ * ... * typ -&gt; typ' ve işlev değerleri döndüren temsilciler için 'typ -&gt; (typ -&gt; typ)' kullanın.</value>
  </data>
  <data name="optValueMarkedInlineButIncomplete" xml:space="preserve">
    <value>'{0}' değeri satır içi olarak işaretlenmiş ancak uygulamasında yeterince erişilemeyen bir iç veya özel işlev kullanılıyor</value>
  </data>
  <data name="tcPropertyIsNotStatic" xml:space="preserve">
    <value>'{0}' özelliği statik değil</value>
  </data>
  <data name="tcInvalidObjectSequenceOrRecordExpression" xml:space="preserve">
    <value>Geçersiz nesne, dizi veya kayıt ifadesi</value>
  </data>
  <data name="tcTypeParametersInferredAreNotStable" xml:space="preserve">
    <value>Bu değer için çıkartılan tür parametreleri tür kısaltmalarının silinmesi altında kararlı değil. Bunun nedeni, tür parametrelerini bırakan veya yeniden sıralayan tür kısaltmalarının kullanılmasıdır, örn. \n\ttype taggedInt&lt;'a&gt; = int veya\n\ttype swap&lt;'a,'b&gt; = 'b * 'a.\nBu değerin parametrelerini açık olarak tanımlamayı düşünün, örn.\n\tlet f&lt;'a,'b&gt; ((x,y) : swap&lt;'b,'a&gt;) : swap&lt;'a,'b&gt; = (y,x).</value>
  </data>
  <data name="tcImplementsIStructuralComparableExplicitly" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'System.IStructuralComparable' arabirimini açık olarak uyguluyor. Türe 'CustomComparison' özniteliğini uygulayın.</value>
  </data>
  <data name="parsSyntaxError" xml:space="preserve">
    <value>Sözdizimi hatası</value>
  </data>
  <data name="tcInvalidRelationInJoin" xml:space="preserve">
    <value>'{0}' öğesinde geçersiz join ilişkisi. 'expr &lt;op&gt; expr' bekleniyordu, burada &lt;op&gt; ifadesi: =, =?, ?= veya ?=?.</value>
  </data>
  <data name="parsFieldBinding" xml:space="preserve">
    <value>Alan bağlamaları 'id = expr;' biçiminde olmalıdır</value>
  </data>
  <data name="tcEventIsNotStatic" xml:space="preserve">
    <value>'{0}' olayı statik değil</value>
  </data>
  <data name="customOperationTextLikeZip" xml:space="preserve">
    <value>Koleksiyonda {0} değişken</value>
  </data>
  <data name="keywordDescriptionYield" xml:space="preserve">
    <value>Diziye ait bir değer üretmek için dizi ifadesinde kullanılır.</value>
  </data>
  <data name="tcNoTryFinallyInQuery" xml:space="preserve">
    <value>'try/finally' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="tcIDisposableTypeShouldUseNew" xml:space="preserve">
    <value>Kaynakların oluşturulan değer tarafından sahiplenilebileceğini belirtmek için, IDisposable arabirimini destekleyen nesnelerin, oluşturucuyu temsil eden bir işlev değeri olarak 'Type(args)' veya 'Type' yerine 'new Type(args)' söz dizimi kullanılarak oluşturulması önerilir</value>
  </data>
  <data name="tcLiteralCannotBeMutable" xml:space="preserve">
    <value>Sabit değer 'mutable' olarak işaretlenemez</value>
  </data>
  <data name="keywordDescriptionWhile" xml:space="preserve">
    <value>Döngü yapısını tanıtır.</value>
  </data>
  <data name="csMethodIsNotAStaticMethod" xml:space="preserve">
    <value>{0} bir statik metot değil</value>
  </data>
  <data name="parsAttributesAreNotPermittedOnInterfaceImplementations" xml:space="preserve">
    <value>Arabirim uygulamalarında özniteliklere izin verilmez</value>
  </data>
  <data name="tcExpressionRequiresSequence" xml:space="preserve">
    <value>Bu ifade biçimi yalnızca dizi ve hesaplama ifadelerinde kullanılabilir</value>
  </data>
  <data name="crefQuotationsCantFetchUnionIndexes" xml:space="preserve">
    <value>Alıntılar, birleşim durumu dizinleri getiren ifadeler içeremez</value>
  </data>
  <data name="keywordDescriptionClass" xml:space="preserve">
    <value>Ayrıntılı söz diziminde, sınıf tanımının başlangıcını belirtir.</value>
  </data>
  <data name="keywordDescriptionBegin" xml:space="preserve">
    <value>Ayrıntılı söz diziminde kod bloğunun başlangıcını gösterir.</value>
  </data>
  <data name="tcObjectConstructorsOnTypeParametersCannotTakeArguments" xml:space="preserve">
    <value>Tür parametrelerindeki nesne oluşturucu çağrılarına bağımsız değişken verilemez</value>
  </data>
  <data name="keywordDescriptionMatch" xml:space="preserve">
    <value>Değeri bir desenle karşılaştırarak dal oluşturmak için kullanılır.</value>
  </data>
  <data name="tcUnexpectedConditionInImportedAssembly" xml:space="preserve">
    <value>İçeri aktarılan bütünleştirilmiş kodda beklenmeyen koşul: AttributeUsage özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="tcUnionCaseDoesNotTakeArguments" xml:space="preserve">
    <value>Bu birleşim durumu bağımsız değişken almaz</value>
  </data>
  <data name="keywordDescriptionGlobal" xml:space="preserve">
    <value>En üst düzey .NET ad alanına başvurmak için kullanılır.</value>
  </data>
  <data name="tcRequireBuilderMethod" xml:space="preserve">
    <value>Bu denetim yapısı, yalnızca hesaplama ifadesi oluşturucu '{0}' metodunu tanımlıyorsa kullanılabilir</value>
  </data>
  <data name="tcImplicitMeasureFollowingSlash" xml:space="preserve">
    <value>/ sonrasındaki ölçülerin örtük çarpımı</value>
  </data>
  <data name="tcTPFieldMustBeLiteral" xml:space="preserve">
    <value>Geçersiz sağlanan alan. Silinmiş sağlanan türlerin sağlanan alanları sabit değerler olmalıdır.</value>
  </data>
  <data name="tcUnrecognizedQueryOperator" xml:space="preserve">
    <value>Bu bilinen bir sorgu işleci değil. Sorgu işleçleri, 'QueryBuilder' türündeki ilgili metotlar kullanılarak tanımlanan 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' ve 'averageBy' gibi tanımlayıcılardır.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments" xml:space="preserve">
    <value>Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz</value>
  </data>
  <data name="tcInvalidTypeForUnitsOfMeasure" xml:space="preserve">
    <value>Ölçü birimleri yalnızca kayan, float32, ondalık ve işaretli tamsayı türlerinde desteklenir</value>
  </data>
  <data name="tcFieldIsNotStatic" xml:space="preserve">
    <value>'{0}' alanı statik değil</value>
  </data>
  <data name="parsNamespaceOrModuleNotBoth" xml:space="preserve">
    <value>Dosyalar ad alanıyla veya modül bildirimiyle başlamalıdır, örn. 'namespace SomeNamespace.SubNamespace' veya 'module SomeNamespace.SomeModule', ikisiyle birden değil. Ad alanı içinde bir modül tanımlamak için 'module SomeModule = ...' kullanın</value>
  </data>
  <data name="ilSignatureForExternalFunctionContainsTypeParameters" xml:space="preserve">
    <value>Bu dış işlevin imzası tür parametreleri içeriyor. Karşılık gelen C işlevi türlerini belirtmek için bağımsız değişkeni ve dönüş türlerini kısıtlayın.</value>
  </data>
  <data name="followingPatternMatchClauseHasWrongType" xml:space="preserve">
    <value>Bir pattern match ifadesinin tüm dalları aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</value>
  </data>
  <data name="typrelMethodIsSealed" xml:space="preserve">
    <value>'{0}' metodu korumalı olduğundan geçersiz kılınamaz</value>
  </data>
  <data name="parsUnmatched" xml:space="preserve">
    <value>Eşleşmeyen '{0}'</value>
  </data>
  <data name="tcRequireVarConstRecogOrLiteral" xml:space="preserve">
    <value>Bu bir değişkeni sabit, etkin tanıyıcı veya sabit değer değil</value>
  </data>
  <data name="tcUndefinedField" xml:space="preserve">
    <value>'{0}' alanına bir değer verilmiş ancak '{1}' türünde bu yok</value>
  </data>
  <data name="crefQuotationsCantContainStaticFieldRef" xml:space="preserve">
    <value>Alıntılar, statik alanlar getiren ifadeler içeremez</value>
  </data>
  <data name="tcStaticLetBindingsRequireClassesWithImplicitConstructors" xml:space="preserve">
    <value>Statik değer tanımları yalnızca birincil oluşturucusu olan türlerde kullanılabilir. Tür tanımına bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</value>
  </data>
  <data name="parsAttributeOnIncompleteCode" xml:space="preserve">
    <value>Bu özniteliğin kod hedefi, muhtemelen öznitelikten sonraki kod eksik olduğu için bulunamıyor.</value>
  </data>
  <data name="buildInvalidModuleOrNamespaceName" xml:space="preserve">
    <value>Geçersiz modül veya ad alanı adı</value>
  </data>
  <data name="typeInfoCustomOperation" xml:space="preserve">
    <value>özel işlem</value>
  </data>
  <data name="keywordDescriptionAssert" xml:space="preserve">
    <value>Hata ayıklama sırasında kodu doğrulamak için kullanılır.</value>
  </data>
  <data name="buildImplicitModuleIsNotLegalIdentifier" xml:space="preserve">
    <value>Bu dosyadaki bildirimler, '{1}' dosya adı temelinde örtük '{0}' modülüne yerleştirilecek. Ancak bu geçerli bir F# tanımlayıcısı olmadığından, içeriğine diğer dosyalardan erişilemeyecek. Dosyayı yeniden adlandırmayı veya dosyanın başına 'modül' ya da 'ad alanı' bildirimi eklemeyi düşünün.</value>
  </data>
  <data name="fscKeyFileCouldNotBeOpened" xml:space="preserve">
    <value>Anahtar dosyası '{0}' açılamadı</value>
  </data>
  <data name="crefQuotationsCantContainArrayPatternMatching" xml:space="preserve">
    <value>Alıntılar, dizi deseni eşleştirmesi içeremez</value>
  </data>
  <data name="tcTupleStructMismatch" xml:space="preserve">
    <value>Demetlerden biri yapı demeti, diğeri ise başvuru demeti</value>
  </data>
  <data name="csMemberSignatureMismatch4" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken daha gerektirir. Gereken imza: '{2}'. Eksik bağımsız değişkenlerden bazılarının adları: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch3" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken gerektirir. Gereken imza: '{2}'. Eksik bağımsız değişkenlerden bazılarının adları: {3}.</value>
  </data>
  <data name="csMemberSignatureMismatch2" xml:space="preserve">
    <value>Üye veya nesne oluşturucu '{0}' {1} bağımsız değişken daha gerektiriyor. Gereken imza: '{2}'.</value>
  </data>
  <data name="parsUnmatchedLetBang" xml:space="preserve">
    <value>Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'let!' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</value>
  </data>
  <data name="parsMissingTypeArgs" xml:space="preserve">
    <value>Tür bağımsız değişkeni veya statik bağımsız değişken bekleniyor</value>
  </data>
  <data name="fscTwoResourceManifests" xml:space="preserve">
    <value>Çakışan seçenekler belirtildi: 'win32manifest' ve 'win32res'. Bunlardan yalnızca biri kullanılabilir.</value>
  </data>
  <data name="chkDuplicateProperty" xml:space="preserve">
    <value>Yinelenen özellik. '{0}' özelliği, '{1}' türündeki başka bir özellikle aynı ada ve imzaya sahip.</value>
  </data>
  <data name="optsPreferredUiLang" xml:space="preserve">
    <value>Tercih edilen çıkış dili kültür adını (örn. es-ES, ja-JP) belirtin</value>
  </data>
  <data name="tcSeqResultsUseYield" xml:space="preserve">
    <value>Dizi ifadelerinde, sonuçlar 'yield' kullanılarak oluşturulur</value>
  </data>
  <data name="optsStrongKeyFile" xml:space="preserve">
    <value>Tanımlayıcı ad anahtarı dosyası belirtin</value>
  </data>
  <data name="parsUnexpectedIdentifier" xml:space="preserve">
    <value>Beklenmeyen tanımlayıcı: '{0}'</value>
  </data>
  <data name="lexInvalidLineNumber" xml:space="preserve">
    <value>Geçersiz satır numarası '{0}'</value>
  </data>
  <data name="csOptionalArgumentNotPermittedHere" xml:space="preserve">
    <value>İsteğe bağlı bağımsız değişkenler burada kullanılamaz</value>
  </data>
  <data name="experimentalConstruct" xml:space="preserve">
    <value>Bu yapı deneyseldir</value>
  </data>
  <data name="parsAugmentationsIllegalOnDelegateType" xml:space="preserve">
    <value>moduleDefns temsilci türünde genişletmelere izin verilmiyor</value>
  </data>
  <data name="buildArgInvalidInt" xml:space="preserve">
    <value>'{0}' geçerli bir tamsayı bağımsız değişkeni değil</value>
  </data>
  <data name="buildExplicitCoreLibRequiresNoFramework" xml:space="preserve">
    <value>mscorlib.dll veya FSharp.Core.dll dosyalarına açık olarak başvurulduğunda {0} seçeneği de geçirilmelidir</value>
  </data>
  <data name="parsTypeAnnotationsOnGetSet" xml:space="preserve">
    <value>Özellik alıcılar ve ayarlayıcılardaki tür ek açıklamaları 'get()' veya 'set(v)' ifadesinden sonra verilmelidir, örn. 'with get() : string = ...'</value>
  </data>
  <data name="optsBuildWindows" xml:space="preserve">
    <value>Windows yürütülebilir dosyası oluştur</value>
  </data>
  <data name="optsNameOfOutputFile" xml:space="preserve">
    <value>Çıkış dosyasının adı (Kısa biçimi: -o)</value>
  </data>
  <data name="optsSourceLinkRequirePortablePDBs" xml:space="preserve">
    <value>--sourcelink anahtarı yalnızca Taşınabilir PDB gösterilirken desteklenir (--debug:portable veya --debug:embedded)</value>
  </data>
  <data name="CallerMemberNameIsOverriden" xml:space="preserve">
    <value>'{0}' parametresine uygulanan CallerMemberNameAttribute etkisiz olacak. Bu işlem CallerFilePathAttribute tarafından geçersiz kılınmış.</value>
  </data>
  <data name="etBadUnnamedStaticArgs" xml:space="preserve">
    <value>Adlandırılmış statik bağımsız değişkenler, adlandırılmamış statik bağımsız değişkenlerin tümünden sonra gelmelidir</value>
  </data>
  <data name="optsBuildConsole" xml:space="preserve">
    <value>Çalıştırılabilir konsol dosyası oluştur</value>
  </data>
  <data name="tcAllImplementedInterfacesShouldBeDeclared" xml:space="preserve">
    <value>Türün ilk bildiriminde tüm uygulanan arabirimler tanımlanmalıdır</value>
  </data>
  <data name="tcUnexpectedPropertySpec" xml:space="preserve">
    <value>Beklenmeyen kaynak düzeyli özellik belirtimi</value>
  </data>
  <data name="tcCannotCallAbstractBaseMember" xml:space="preserve">
    <value>Soyut bir temel üye çağrılamaz: '{0}'</value>
  </data>
  <data name="tcConditionalAttributeRequiresMembers" xml:space="preserve">
    <value>'ConditionalAttribute' özniteliği yalnızca üyelerde kullanılabilir</value>
  </data>
  <data name="augCustomCompareNeedsIComp" xml:space="preserve">
    <value>'CustomComparison' özniteliği olan bir türde, 'System.IComparable' veya 'System.Collections.IStructuralComparable' yöntemlerinden en az biri açık olarak uygulanmış olmalıdır</value>
  </data>
  <data name="ValueNotContainedMutabilityDotNetNamesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. CLI üye adları farklı</value>
  </data>
  <data name="tcDefaultAmbiguous" xml:space="preserve">
    <value>Bu varsayılan tarafından uygulanan metot belirsiz</value>
  </data>
  <data name="tastopsMaxArrayThirtyTwo" xml:space="preserve">
    <value>F#, 1 ile 32 arasındaki dizi derecelerini destekler. {0} değeri kullanılamaz.</value>
  </data>
  <data name="crefQuotationsCantContainThisType" xml:space="preserve">
    <value>Alıntılar, böyle bir tür içeremez</value>
  </data>
  <data name="assemblyResolutionNetFramework" xml:space="preserve">
    <value>.NET Framework</value>
  </data>
  <data name="tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual" xml:space="preserve">
    <value>Nesne ifadelerinde yalnızca soyut ve sanal üyelerin geçersiz kılmaları belirtilebilir</value>
  </data>
  <data name="optsWriteXml" xml:space="preserve">
    <value>Bütünleştirilmiş kodun xmldoc dosyasını verilen dosyaya yaz</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig" xml:space="preserve">
    <value>'{2}' alanı uygulamada mevcut olmasına rağmen imzada mevcut olmadığından, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil. Struct türleri artık tür imzasında alanlarını göstermelidir, ancak bu alanlar yine de 'private' veya 'internal' olarak etiketlenebilir.</value>
  </data>
  <data name="unionCaseIsNotAccessible" xml:space="preserve">
    <value>'{0}' birleşim durumuna bu kod konumundan erişilemiyor</value>
  </data>
  <data name="augOnlyCertainTypesCanHaveAttrs" xml:space="preserve">
    <value>Yalnızca kayıt, birleşim, özel durum ve yapı türleri 'ReferenceEquality', 'StructuralEquality' ve 'StructuralComparison' öznitelikleriyle büyütülebilir</value>
  </data>
  <data name="ilSignInvalidSignatureSize" xml:space="preserve">
    <value>Geçersiz imza boyutu</value>
  </data>
  <data name="optsWin32manifest" xml:space="preserve">
    <value>Win32 bildirim dosyası belirt</value>
  </data>
  <data name="tcInvalidIndexerExpression" xml:space="preserve">
    <value>Geçersiz dizin erişimcisi ifadesi</value>
  </data>
  <data name="parsTypeNameCannotBeEmpty" xml:space="preserve">
    <value>Tür adı boş olamaz.</value>
  </data>
  <data name="buildCouldNotFindSourceFile" xml:space="preserve">
    <value>Kaynak dosya '{0}' bulunamadı</value>
  </data>
  <data name="tcExpectModuleOrNamespaceParent" xml:space="preserve">
    <value>Modül veya ad alanı üst öğesi {0} bekleniyordu</value>
  </data>
  <data name="tcOnlySimpleBindingsCanBeUsedInConstructionExpressions" xml:space="preserve">
    <value>Yalnızca 'id = expr' biçimindeki basit bağlamalar oluşturma ifadelerinde kullanılabilir</value>
  </data>
  <data name="keywordDescriptionExtern" xml:space="preserve">
    <value>Bildirilen bir program öğesinin başka bir ikili dosyada veya bütünleştirilmiş kodda tanımlandığını belirtir.</value>
  </data>
  <data name="optsSourceLink" xml:space="preserve">
    <value>Taşınabilir PDB dosyasına eklenecek kaynak bağlantı bilgileri dosyası</value>
  </data>
  <data name="tcNewRequiresObjectConstructor" xml:space="preserve">
    <value>'new' yalnızca nesne oluşturucularla kullanılabilir</value>
  </data>
  <data name="csCodeLessGeneric" xml:space="preserve">
    <value>Bu kod, ek açıklamalarında belirtilenden daha az genel. '_' kullanılarak belirtilen bir ölçü biriminin '1', yani boyutsuz olduğu belirlendi. Kodu genel yapmayı veya '_' kullanımını kaldırmayı düşünün.</value>
  </data>
  <data name="tcIllegalStructTypeForConstantExpression" xml:space="preserve">
    <value>Bu geçerli bir sabit değer ifadesi değil. [&lt;Literal&gt;] özniteliği yok sayılacak.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2" xml:space="preserve">
    <value>İmzada bu türün ek değer olarak null değerleri kullanabileceği belirtilmesine rağmen uygulamada bu belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcTryWithMayNotBeUsedInQueries" xml:space="preserve">
    <value>'try/with' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="optsStandalone" xml:space="preserve">
    <value>F# kitaplığını ve ona bağlı tüm başvurulan DLL'leri, oluşturulmakta olan bütünleştirilmiş koda statik olarak bağla</value>
  </data>
  <data name="tcAttributeAutoOpenWasIgnored" xml:space="preserve">
    <value>'{1}' bütünleştirilmiş kodundaki 'AutoOpen(\"{0}\")' özniteliği bu bütünleştirilmiş koddaki geçerli bir modüle veya ad alanına başvurmadığından yok sayıldı</value>
  </data>
  <data name="tcFieldIsNotMutable" xml:space="preserve">
    <value>Bu alan değiştirilebilir değil</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind" xml:space="preserve">
    <value>Türler farklı çeşitlerde olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcEnumerationsCannotHaveInterfaceDeclaration" xml:space="preserve">
    <value>Sabit listelerinde arabirim bildirimleri olamaz</value>
  </data>
  <data name="optsBuildLibrary" xml:space="preserve">
    <value>Kitaplık oluştur (Kısa biçimi: -a)</value>
  </data>
  <data name="buildCouldNotResolveAssembly" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodu çözümlenemedi</value>
  </data>
  <data name="csMemberNotAccessible" xml:space="preserve">
    <value>{1} bağımsız değişken alan '{0}' adlı üyeye veya nesne oluşturucusuna bu kod konumundan erişilemiyor. '{2}' metodunun erişilebilen tüm sürümleri {3} bağımsız değişken alır.</value>
  </data>
  <data name="optsShortFormOf" xml:space="preserve">
    <value>'{0}' öğesinin kısa biçimi</value>
  </data>
  <data name="tcDefaultImplementationForInterfaceHasAlreadyBeenAdded" xml:space="preserve">
    <value>Bu arabirimin açık olarak uygulanması türün tanımında belirtilmediği için arabirimin varsayılan uygulaması zaten eklendi</value>
  </data>
  <data name="tcFieldNameIsUsedModeThanOnce" xml:space="preserve">
    <value>Adlandırılmış alan '{0}', birden çok kez kullanıldı.</value>
  </data>
  <data name="fscDeterministicDebugRequiresPortablePdb" xml:space="preserve">
    <value>Belirleyici derlemeler yalnızca taşınabilir PDB'leri (--debug:portable veya --debug:embedded) destekler</value>
  </data>
  <data name="tcInvalidObjectExpressionSyntaxForm" xml:space="preserve">
    <value>Geçersiz nesne ifadesi. Geçersiz kılmaların ve arabirimlerin olmadığı nesneler küme ayraçsız 'new Type(args)' ifade biçimini kullanmalıdır.</value>
  </data>
  <data name="typeInfoFromFirst" xml:space="preserve">
    <value>{0} dalından</value>
  </data>
  <data name="keywordDescriptionDownto" xml:space="preserve">
    <value>Bir for ifadesinde, tersten sayım sırasında kullanılır.</value>
  </data>
  <data name="tcTypeIsNotARecordType" xml:space="preserve">
    <value>Bu tür bir kayıt türü değil</value>
  </data>
  <data name="crefQuotationsCantContainAddressOf" xml:space="preserve">
    <value>Alıntılar, bir alanın adresini alan ifadeler içeremez</value>
  </data>
  <data name="tcImplementsIComparableExplicitly" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'System.IComparable' arabirimini açık olarak uyguluyor. Türe 'CustomComparison' özniteliğini uygulamanız gerekir.</value>
  </data>
  <data name="tcIfThenElseMayNotBeUsedWithinQueries" xml:space="preserve">
    <value>Sorgularda if/then/else ifadesi kullanılamaz. Ya if/then ifadesi kullanmayı düşünün ya da onun yerine dizi ifadesi kullanın.</value>
  </data>
  <data name="etStaticParameterAlreadyHasValue" xml:space="preserve">
    <value>'{0}' statik parametresine zaten bir değer verildi</value>
  </data>
  <data name="optsEmbedSource" xml:space="preserve">
    <value>Belirli kaynak dosyaları taşınabilir PDB dosyasına ekle</value>
  </data>
  <data name="chkByrefUsedInInvalidWay" xml:space="preserve">
    <value>Byref olarak belirtilmiş '{0}' değişkeni geçersiz bir biçimde kullanılmış. Byref değerleri, kapanışlar ile yakalanamaz veya iç işlevlere geçirilemez.</value>
  </data>
  <data name="tcPropertyCannotBeSet1" xml:space="preserve">
    <value>'{0}' özelliği ayarlanamaz</value>
  </data>
  <data name="tcPropertyCannotBeSet0" xml:space="preserve">
    <value>Bu özellik ayarlanamaz</value>
  </data>
  <data name="chkNoFirstClassAddressOf" xml:space="preserve">
    <value>Address-of işleçlerinin birinci sınıf kullanımlarına izin verilmiyor</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsConstructor" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri oluşturucu/özellik, diğeri değil</value>
  </data>
  <data name="tcObjectConstructionCanOnlyBeUsedInClassTypes" xml:space="preserve">
    <value>Nesne oluşturma ifadeleri yalnızca sınıf türlerinde oluşturucuları uygulamak için kullanılabilir</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldInSigButNotImpl" xml:space="preserve">
    <value>'{0}' alanı imza için gerekmesine karşın uygulama tarafından belirtilmediği için özel durum tanımları uyumlu değil. Modül,\n    {1}    \nözel durum tanımını içeriyor ancak imzasında\n\t{2} belirtiliyor.</value>
  </data>
  <data name="tcNumericLiteralRequiresModule" xml:space="preserve">
    <value>Bu sayısal sabit değer FromZero, FromOne, FromInt32, FromInt64 ve FromString işlevlerini tanımlayan '{0}' modülünün kapsamda olmasını gerektirir</value>
  </data>
  <data name="tcConstructorsIllegalForThisType" xml:space="preserve">
    <value>Oluşturucular bu tür için tanımlanamaz</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified" xml:space="preserve">
    <value>{2} alanı imza için gerekmesine rağmen uygulama tarafından belirtilmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcOptionalArgsOnlyOnMembers" xml:space="preserve">
    <value>İsteğe bağlı bağımsız değişkenlere yalnızca tür üyelerinde izin verilir</value>
  </data>
  <data name="etProvidedTypeReferenceMissingArgument" xml:space="preserve">
    <value>Sağlanan türe yapılan başvuruda '{0}' statik parametresinin bir değeri yoktu. Bir veya daha fazla başvurulan bütünleştirilmiş kodu yeniden derlemeniz gerekiyor.</value>
  </data>
  <data name="elseBranchHasWrongType" xml:space="preserve">
    <value>Bir 'if' ifadesinin tüm dalları aynı türe sahip olmalıdır. Bu ifadenin '{0}' türünde olması bekleniyordu ancak burada '{1}' türünde.</value>
  </data>
  <data name="erasedTo" xml:space="preserve">
    <value>Silindiği öğe:</value>
  </data>
  <data name="tcTypeParameterArityMismatch" xml:space="preserve">
    <value>Bu değer, tür veya metot {0} tür parametrelerini bekliyor ancak {1} verilmiş</value>
  </data>
  <data name="ExceptionDefsNotCompatibleFieldOrderDiffers" xml:space="preserve">
    <value>Alanların sırası imza ve uygulamada farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</value>
  </data>
  <data name="tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings" xml:space="preserve">
    <value>Özel işlem, bu hesaplama ifadesinin başka bir kısmında değersiz veya özyinelemeli 'let' bağlaması ile bağlantılı olarak kullanılamaz</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfTypeParameters" xml:space="preserve">
    <value>Üye '{0}', doğru sayıda metot türü parametresine sahip değil. Gereken imza: '{1}'.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden" xml:space="preserve">
    <value>Bir CLI tür temsili imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied1" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'StructuralComparison' özniteliğine sahip ancak tür parametresi '{1}' 'comparison' kısıtlamasını karşılamıyor. Tür parametresine 'comparison' kısıtlamasını eklemeyi düşünün</value>
  </data>
  <data name="tcStructuralComparisonNotSatisfied2" xml:space="preserve">
    <value>Yapı, kayıt veya birleşim türü '{0}', 'StructuralComparison' özniteliğine sahip ancak bileşen türü '{1}' 'comparison' kısıtlamasını karşılamıyor</value>
  </data>
  <data name="chkNoAddressOfAtThisPoint" xml:space="preserve">
    <value>'{0}' değişkeninin adresi bu noktada kullanılamaz</value>
  </data>
  <data name="typeInfoUnionCase" xml:space="preserve">
    <value>birleşim durumu</value>
  </data>
  <data name="assemblyResolutionGAC" xml:space="preserve">
    <value>Genel Bütünleştirilmiş Kod Önbelleği</value>
  </data>
  <data name="typrelDuplicateInterface" xml:space="preserve">
    <value>Yinelenen veya gereksiz arabirim</value>
  </data>
  <data name="optsInvalidResponseFile" xml:space="preserve">
    <value>Geçersiz yanıt dosyası '{0}' ( '{1}' )</value>
  </data>
  <data name="tcInvalidUseBangBinding" xml:space="preserve">
    <value>'use!' bağlamaları 'use! &lt;var&gt; = &lt;expr&gt;' biçiminde olmalıdır</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleTypeIsHidden" xml:space="preserve">
    <value>Bir tür temsili imza ile gizlendiğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcInvalidSequenceExpressionSyntaxForm" xml:space="preserve">
    <value>Geçersiz kayıt, dizi veya hesaplama ifadesi. Dizi ifadeleri 'seq {{ ... }}' biçiminde olmalıdır</value>
  </data>
  <data name="etEventNoAdd" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' olayının bir GetAddMethod() değeri yok</value>
  </data>
  <data name="keywordDescriptionInterface" xml:space="preserve">
    <value>Arabirimleri bildirmek ve uygulamak için kullanılır.</value>
  </data>
  <data name="ValueNotContainedMutabilityExtensionsDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri uzantı üyesi, diğeri değil</value>
  </data>
  <data name="parsSetSyntax" xml:space="preserve">
    <value>Özellik ayarlayıcıları 'set value = ', 'set idx value = ' veya 'set (idx1,...,idxN) value = ... ' kullanılarak tanımlanmalıdır</value>
  </data>
  <data name="tcInvalidArgForParameterizedPattern" xml:space="preserve">
    <value>Parametreli desen etiketine geçersiz bağımsız değişken</value>
  </data>
  <data name="ilSignInvalidBitLen" xml:space="preserve">
    <value>Bit Uzunluğu geçersiz</value>
  </data>
  <data name="lexHashIfMustBeFirst" xml:space="preserve">
    <value>#if yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</value>
  </data>
  <data name="etMultipleStaticParameterWithName" xml:space="preserve">
    <value>'{0}' adında birden çok statik parametre var</value>
  </data>
  <data name="tcVolatileFieldsMustBeMutable" xml:space="preserve">
    <value>Geçici alanlar 'mutable' olarak işaretlenmelidir ve bunlar statik iş parçacıklı olamaz</value>
  </data>
  <data name="tcReturnTypesForUnionMustBeSameAsType" xml:space="preserve">
    <value>Birleşim durumlarının dönüş türleri tanımlanmakta olan türle kısaltmalara kadar özdeş olmalıdır</value>
  </data>
  <data name="tcOverridesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Geçersiz kılmalarda veya arabirim uygulamalarında erişilebilirlik değiştiricilerine izin verilmez</value>
  </data>
  <data name="lexIndentOffForML" xml:space="preserve">
    <value>Bunun yerine uzantısı '.ml' veya '.mli' olan dosya kullanmayı düşünün</value>
  </data>
  <data name="tcAbstractPropertyMissingGetOrSet" xml:space="preserve">
    <value>Bu özellik, soyut bir özelliği geçersiz kılıyor veya uyguluyor ancak bu soyut özelliğe karşılık gelen bir {0} yok</value>
  </data>
  <data name="ilUnexpectedUnrealizedValue" xml:space="preserve">
    <value>Derleyici hatası: Beklenmeyen gerçekleşmemiş değer</value>
  </data>
  <data name="etProvidedTypeReferenceInvalidText" xml:space="preserve">
    <value>Sağlanan türe yapılan başvuruda statik parametre için geçersiz '{0}' değeri vardı. Bir veya daha fazla başvurulan bütünleştirilmiş kodu yeniden derlemeniz gerekiyor.</value>
  </data>
  <data name="ExceptionDefsNotCompatibleSignaturesDiffer" xml:space="preserve">
    <value>Özel durum kısaltmaları imza ve uygulamada farklı olduğu için özel durum tanımları uyumlu değil. Modül,\n    {0}    \nözel durum tanımını içeriyor ancak imzasında\n\t{1} belirtiliyor.</value>
  </data>
  <data name="chkInvalidCustAttrVal" xml:space="preserve">
    <value>Geçersiz özel öznitelik değeri (sabit veya değişmez değerli değil)</value>
  </data>
  <data name="tcExceptionAbbreviationsShouldNotHaveArgumentList" xml:space="preserve">
    <value>Özel durum kısaltmalarının bağımsız değişken listeleri olmamalıdır</value>
  </data>
  <data name="tcInvalidPropertyType" xml:space="preserve">
    <value>Bu özellikte geçersiz bir tür var. Birden çok dizin erişimcisi bağımsız değişkeni alan özelliklerin 'ty1 * ty2 -&gt; ty3' biçiminde türleri olmalıdır. İşlev döndüren özelliklerin '(ty1 -&gt; ty2)' biçiminde türleri olmalıdır.</value>
  </data>
  <data name="chkNoByrefAsTopValue" xml:space="preserve">
    <value>Türü byref olarak belirtilmiş bir değer buraya depolanacaktı. Üst düzeyde let ile bağlanmış byref değerlerine izin verilmez.</value>
  </data>
  <data name="tcMultipleVisibilityAttributesWithLet" xml:space="preserve">
    <value>Bu tanımlayıcı için birden çok görünürlük özniteliği belirtilmiş. İfade içlerindeki tüm 'let' bağlamaları her zaman özel olduğu gibi sınıflardaki 'let' bağlamaları da her zaman özeldir.</value>
  </data>
  <data name="crefQuotationsCantContainGenericFunctions" xml:space="preserve">
    <value>Alıntılar, genel olduğu çıkarılmış veya tanımlanmış işlev tanımları içeremez. Bunu geçerli bir alıntı ifadesi yapmak için bazı tür kısıtlamaları eklemeyi düşünün.</value>
  </data>
  <data name="forBadPrecision" xml:space="preserve">
    <value>Biçim tanımlayıcıda hatalı duyarlık</value>
  </data>
  <data name="tcTypeHasNoAccessibleConstructor" xml:space="preserve">
    <value>Bu türün erişilebilir bir nesne oluşturucusu yok</value>
  </data>
  <data name="etEmptyNamespaceOfTypeNotAllowed" xml:space="preserve">
    <value>'{1}' tür sağlayıcısından '{0}' türünün boş ad alanı var. Genel ad alanı için 'null' kullanın.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2" xml:space="preserve">
    <value>Uygulamada bu türün ek değer olarak null değerleri kullanabileceği belirtilmesine rağmen imzada bu belirtmediğinden, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcConstructorRequiresArguments" xml:space="preserve">
    <value>Bu nesne oluşturucusu bağımsız değişken gerektirir</value>
  </data>
  <data name="parsVisibilityIllegalOnInherit" xml:space="preserve">
    <value>'inherits' bildiriminde erişilebilirlik değiştiricilerine izin verilmez</value>
  </data>
  <data name="tcTypeRequiresDefinition" xml:space="preserve">
    <value>Bu tür için tanım gerekiyor</value>
  </data>
  <data name="ilLiteralFieldsCannotBeSet" xml:space="preserve">
    <value>Sabit değer alanları ayarlanamaz</value>
  </data>
  <data name="keywordDescriptionTo" xml:space="preserve">
    <value>For döngülerinde aralık belirtmek için kullanılır.</value>
  </data>
  <data name="keywordDescriptionOr" xml:space="preserve">
    <value>Bir Boolean değeri veya işleci olarak Boolean koşullarıyla birlikte kullanılır. Eşdeğeri || simgesidir. Ayrıca üye kısıtlamalarında kullanılır.</value>
  </data>
  <data name="keywordDescriptionOf" xml:space="preserve">
    <value>Değer kategorilerinin türünü belirtmek için ayırt edici birleşimlerde, temsilci ve özel durum bildirimlerinde kullanılır.</value>
  </data>
  <data name="keywordDescriptionIf" xml:space="preserve">
    <value>Koşullu dallanma yapılarında kullanılır.</value>
  </data>
  <data name="keywordDescriptionIn" xml:space="preserve">
    <value>Dizi ifadeleri için ve ayrıntılı söz diziminde ifadeleri bağlamalardan ayırmak için kullanılır.</value>
  </data>
  <data name="keywordDescriptionAs" xml:space="preserve">
    <value>Geçerli sınıf nesnesine bir nesne adı vermek için kullanılır. Desen eşleştirmesi içindeki bir tam desene ad vermek için de kullanılır.</value>
  </data>
  <data name="keywordDescriptionDo" xml:space="preserve">
    <value>Döngü yapılarında veya kesinlik temelli kod yürütmek için kullanılır.</value>
  </data>
  <data name="ValueNotContainedMutabilityAttributesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Değişebilirlik öznitelikleri farklı</value>
  </data>
  <data name="tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor" xml:space="preserve">
    <value>Ortak Ara Dil özel durum türlerinin kısaltmalarının kendileriyle eşleşen nesne oluşturucuları olmalıdır</value>
  </data>
  <data name="lexInvalidNumericLiteral" xml:space="preserve">
    <value>Bu geçerli bir sayısal sabit değer değil. Geçerli sayısal sabit değerler şunları içerir: 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger).</value>
  </data>
  <data name="augCustomEqNeedsNoCompOrCustomComp" xml:space="preserve">
    <value>'CustomEquality' özniteliği, 'NoComparison' veya 'CustomComparison' öznitelikleri ile bağlantılı kullanılmalıdır</value>
  </data>
  <data name="parsGetterAtMostOneArgument" xml:space="preserve">
    <value>Alıcı özelliğinin en çok bir bağımsız değişken grubu olabilir</value>
  </data>
  <data name="tcThisValueMayNotBeInlined" xml:space="preserve">
    <value>Bu üye, işlev veya değer bildirimi 'inline' olarak tanımlanamaz</value>
  </data>
  <data name="parsInvalidPrefixOperator" xml:space="preserve">
    <value>Geçersiz ön ek işleci</value>
  </data>
  <data name="parsUnexpectedSemicolon" xml:space="preserve">
    <value>Bu aşamada noktalı virgül beklenmiyor</value>
  </data>
  <data name="tcCustomOperationNotUsedCorrectly2" xml:space="preserve">
    <value>'{0}' doğru kullanılmadı. Kullanım: {1}. Bu, geçerli sorguda veya hesaplama ifadesinde özel bir işlemdir.</value>
  </data>
  <data name="typrelOverrideWasAmbiguous" xml:space="preserve">
    <value>'{0}' geçersiz kılma işlemi belirsizdi</value>
  </data>
  <data name="optsStrongKeyContainer" xml:space="preserve">
    <value>Tanımlayıcı ad anahtarı kapsayıcısı belirtin</value>
  </data>
  <data name="tcObjectOfIndeterminateTypeUsedRequireTypeConstraint" xml:space="preserve">
    <value>Bu program noktasından önceki bilgiler temelinde 'expr.[idx]' işleci belirsiz türdeki bir nesnede kullanılmış. Başka tür kısıtlamaları eklemeyi düşünün</value>
  </data>
  <data name="optsHelpBannerErrsAndWarns" xml:space="preserve">
    <value>- HATALAR VE UYARILAR -</value>
  </data>
  <data name="optsSimpleresolution" xml:space="preserve">
    <value>Bütünleştirilmiş kod başvurularını MSBuild çözümlemesi yerine dizin tabanlı kurallar kullanarak çözümle</value>
  </data>
  <data name="chkDuplicateMethodInheritedTypeWithSuffix" xml:space="preserve">
    <value>Yinelenen metot. Demetler, işlevler, ölçü birimleri ve/veya sağlanan türler silindikten sonra, soyut '{0}' metodu, devralınan türdeki soyut metotla aynı ada ve imzaya sahip.</value>
  </data>
  <data name="tcUnitsOfMeasureInvalidInTypeConstructor" xml:space="preserve">
    <value>Tür oluşturucu uygulamasında ölçü birimi kullanılamaz</value>
  </data>
  <data name="tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes" xml:space="preserve">
    <value>Nesne oluşturma ifadeleri (yani devralma belirtimleri olan kayıt ifadeleri) yalnızca nesne modeli türlerinde oluşturucuları uygulamak için kullanılabilir. Nesne modeli türlerinin örneklerini oluşturucuların dışında oluşturmak için 'new ObjectType(args)' kullanın</value>
  </data>
  <data name="lexCharNotAllowedInOperatorNames" xml:space="preserve">
    <value>İşleç adlarında karakter olarak '{0}' kullanılmasına izin verilmez; ileride kullanılmak üzere ayrılmıştır</value>
  </data>
  <data name="tcUseMayNotBeUsedInQueries" xml:space="preserve">
    <value>'use' ifadeleri sorgularda kullanılamaz</value>
  </data>
  <data name="tcTypeCannotBeEnumerated" xml:space="preserve">
    <value>'{0}' türü, değerleri bu sözdizimiyle sabit listesi oluşturabilen bir tür değildir, yani seq&lt;_&gt;, IEnumerable&lt;_&gt; veya IEnumerable ile uyumlu değildir ve GetEnumerator metodu yoktur</value>
  </data>
  <data name="nrUnexpectedEmptyLongId" xml:space="preserve">
    <value>Beklenmeyen boş long tanımlayıcısı</value>
  </data>
  <data name="buildInvalidHashrDirective" xml:space="preserve">
    <value>Geçersiz yönerge. Beklenen: '#r \"&lt;dosya-veya-bütünleştirilmiş kod&gt;\"'.</value>
  </data>
  <data name="checkNotSufficientlyGenericBecauseOfScopeAnon" xml:space="preserve">
    <value>Tür çıkarımı, bir tür değişkeninin kapsamından çıkmasına neden oldu. Tür açıklamaları ekleyerek kodunuzu daha az genel hale getirebilirsiniz.</value>
  </data>
  <data name="csTypeDoesNotSupportConversion" xml:space="preserve">
    <value>'{0}' türü '{1}' türüne dönüşümü desteklemez</value>
  </data>
  <data name="optsClirootDeprecatedMsg" xml:space="preserve">
    <value>Komut satırı seçeneği '--cliroot' kullanım dışı bırakıldı. Onun yerine özel bir mscorlib.dll kopyasına açık başvuru kullanın.</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleNamesDiffer" xml:space="preserve">
    <value>Adları farklı olduğundan, imza ve uygulamadaki {0} tanımları uyumlu değil. Türün adı, imzada '{1}' olmasına rağmen uygulamada '{2}'.</value>
  </data>
  <data name="ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen" xml:space="preserve">
    <value>Kod oluşturma sırasında geçersiz 'methodhandleof' bağımsız değişkeni</value>
  </data>
  <data name="parsUnexpectedSymbolEqualsInsteadOfIn" xml:space="preserve">
    <value>İfadede beklenmeyen '=' sembolü. Bunun yerine 'for x in y .. z do' kullanmak mı istemiştiniz?</value>
  </data>
  <data name="nrNoConstructorsAvailableForType" xml:space="preserve">
    <value>'{0}' türü için kullanılabilir bir oluşturucu yok</value>
  </data>
  <data name="tcDuplicateSpecOfInterface" xml:space="preserve">
    <value>Yinelenen arabirim belirtimi</value>
  </data>
  <data name="fscAssemblyNotFoundInDependencySet" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodu hedef ikilinin bağımlılık kümesinde bulunamadı. Statik olarak bağlanmış kökler, DLL veya EXE uzantısı olmadan bütünleştirilmiş kod adı kullanılarak belirtilmelidir. Bu bütünleştirilmiş koda açık olarak başvurulmuşsa bütünleştirilmiş koda aslında oluşturulan ikili dosya tarafından ihtiyaç duyulmamış olması mümkündür ve bu durumda statik olarak bağlanmamalıdır.</value>
  </data>
  <data name="typrelTypeImplementsIComparableShouldOverrideObjectEquals" xml:space="preserve">
    <value>'{0}' türü 'System.IComparable' metodunu uyguluyor. Ayrıca 'Object.Equals' için açık bir geçersiz kılma eklemeyi düşünün</value>
  </data>
  <data name="keyworkDescriptionAnd" xml:space="preserve">
    <value>Karşılıklı yinelemeli bağlamalarda, özellik bildirimlerinde ve genel parametreler üzerinde birden çok kısıtlamayla kullanılır.</value>
  </data>
  <data name="tcInvalidConstantExpression" xml:space="preserve">
    <value>Bu geçerli bir sabit ifade değil</value>
  </data>
  <data name="optsResponseFileNotFound" xml:space="preserve">
    <value>Yanıt dosyası '{0}', '{1}' içinde bulunamadı</value>
  </data>
  <data name="undefinedNameNamespace" xml:space="preserve">
    <value>'{0}' ad alanı tanımlı değil.</value>
  </data>
  <data name="csTypesDoNotSupportOperatorNullable" xml:space="preserve">
    <value>'{0}' türlerinin hiçbiri '{1}' işlecini desteklemez. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</value>
  </data>
  <data name="parsDoCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Erişilebilirlik değiştiricilerine 'do' bağlamalarında izin verilmez, ancak '{0}' belirtildi.</value>
  </data>
  <data name="pplexUnexpectedChar" xml:space="preserve">
    <value>Önişlemci ifadesinde beklenmeyen karakter: '{0}'</value>
  </data>
  <data name="parsOnlyOneWithAugmentationAllowed" xml:space="preserve">
    <value>En çok bir 'with' genişletmesine izin verilir</value>
  </data>
  <data name="tcParameterRequiresName" xml:space="preserve">
    <value>Öznitelikleri olan bir parametreye ayrıca bir ad verilmelidir, örn. '[&lt;Öznitelik&gt;] Name : Type'</value>
  </data>
  <data name="tcFieldsDoNotDetermineUniqueRecordType" xml:space="preserve">
    <value>Bu kayıt ifadesinin veya deseninin alan etiketleri ve beklenen türü, karşılık gelen bir kayıt türünü benzersiz olarak belirlemiyor</value>
  </data>
  <data name="tcRequireActivePatternWithOneResult" xml:space="preserve">
    <value>Yalnızca tam olarak bir sonuç döndüren etkin desenler bağımsız değişken kabul edilebilir</value>
  </data>
  <data name="memberOperatorDefinitionWithNonPairArgument" xml:space="preserve">
    <value>Infix işleç üyesi '{0}', {1} başlangıç bağımsız değişkenine sahip. 2 bağımsız değişkenli bir demet bekleniyordu, ör. statik üye (+) (x,y) = ...</value>
  </data>
  <data name="typeInfoArgument" xml:space="preserve">
    <value>bağımsız değişken</value>
  </data>
  <data name="mlCompatMessage" xml:space="preserve">
    <value>Bu yapı ML uyumluluğu içindir. {0}. '--mlcompatibility' veya '--nowarn:62' kullanarak bu uyarıyı devre dışı bırakabilirsiniz.</value>
  </data>
  <data name="forHashSpecifierIsInvalid" xml:space="preserve">
    <value># biçimlendirme değiştiricisi F# içinde geçersizdir</value>
  </data>
  <data name="optsDelaySign" xml:space="preserve">
    <value>Bütünleştirilmiş kodu tanımlayıcı ad anahtarının yalnızca ortak kısmını kullanarak gecikmeli imzala</value>
  </data>
  <data name="keywordDescriptionException" xml:space="preserve">
    <value>Bir özel durum türünü bildirmek için kullanılır.</value>
  </data>
  <data name="tcOverloadsCannotHaveCurriedArguments" xml:space="preserve">
    <value>Bu metodun bir veya daha fazla aşırı yüklemesinde eksiltimli bağımsız değişkenler var. Bu üyeleri grup olarak tanımlanmış biçimde bağımsız değişkenler alacak şekilde yeniden tasarlamayı düşünün.</value>
  </data>
  <data name="nrGlobalUsedOnlyAsFirstName" xml:space="preserve">
    <value>'global' yalnızca tam yoldaki ilk ad olarak kullanılabilir</value>
  </data>
  <data name="tcInvalidTypeForLiteralEnumeration" xml:space="preserve">
    <value>Sabit değer listelerinde int, uint, int16, uint16, int64, uint64, byte, sbyte veya char türü olmalıdır</value>
  </data>
  <data name="pickleMissingDefinition" xml:space="preserve">
    <value>'{2}' bütünleştirilmiş kodunun '{1}' tablosundaki {0} konumunda bulunan F# meta veri düğümü okunurken bir hata oluştu. Düğüm, eşleşen bildirim içermiyor. Lütfen bu uyarıyı bildirin. Kullandığınız F# bütünleştirilmiş kodunu yeniden derlemeniz gerekebilir.</value>
  </data>
  <data name="buildErrorOpeningBinaryFile" xml:space="preserve">
    <value>'{0}': {1} ikili dosyasını açma işleminde hata</value>
  </data>
  <data name="tcInvalidMemberNameCtor" xml:space="preserve">
    <value>Geçersiz üye adı. Üyelerin adı '.ctor' veya '.cctor' olamaz</value>
  </data>
  <data name="forBadFormatSpecifierGeneral" xml:space="preserve">
    <value>Hatalı biçim tanımlayıcı: '{0}'</value>
  </data>
  <data name="tcFieldNotLiteralCannotBeUsedInPattern" xml:space="preserve">
    <value>Bu alan sabit değer olmadığından desende kullanılamaz</value>
  </data>
  <data name="tcOnlyRecordFieldsAndSimpleLetCanBeMutable" xml:space="preserve">
    <value>Yalnızca kayıt alanları ve basit, özyinelemeli olmayan 'let' bağlamaları değişebilir olarak işaretlenebilir</value>
  </data>
  <data name="buildInvalidHashloadDirective" xml:space="preserve">
    <value>Geçersiz yönerge. Beklenen: '#load \"&lt;dosya&gt;\" ... \"&lt;dosya&gt;\"'.</value>
  </data>
  <data name="csMethodFoundButIsStatic" xml:space="preserve">
    <value>'{0}' türünün '{1}' metodu var (tam adı '{2}'), ancak bu metot statik</value>
  </data>
  <data name="tcNoMemberFoundForOverride" xml:space="preserve">
    <value>Bu geçersiz kılmaya karşılık gelen bir soyut üye veya arabirim üyesi bulunamadı</value>
  </data>
  <data name="tcInvalidPattern" xml:space="preserve">
    <value>Bu geçerli bir desen değil</value>
  </data>
  <data name="parsForDoExpected" xml:space="preserve">
    <value>'for' ifadesinde eksik 'do'. 'for &lt;pat&gt; in &lt;ifade&gt; do &lt;ifade&gt;' bekleniyordu.</value>
  </data>
  <data name="tcOverridingMethodRequiresAllOrNoTypeParameters" xml:space="preserve">
    <value>Genel soyut metodu geçersiz kılarken tür parametrelerinin ya tümünü açık olarak tanımlamanız ya da hiçbirini açık olarak tanımlamamanız gerekir</value>
  </data>
  <data name="etUnsupportedProvidedExpression" xml:space="preserve">
    <value>Tür sağlayıcısından desteklenmeyen '{0}' ifadesi. Bu tür sağlayıcısının yazarı sizseniz, farklı bir sağlanan ifade sağlayacak şekilde ayarlamayı düşünün.</value>
  </data>
  <data name="optsSubSystemVersion" xml:space="preserve">
    <value>Bu bütünleştirilmiş kodun alt sistem sürümünü belirtin</value>
  </data>
  <data name="tastUnexpectedByRef" xml:space="preserve">
    <value>Beklenmeyen byref olarak belirtilmiş değişken kullanımı</value>
  </data>
  <data name="optFailedToInlineValue" xml:space="preserve">
    <value>Muhtemelen özyinelemeli bir değer 'inline' olarak işaretlendiği için 'inline' olarak işaretlenmiş '{0}' değeri satır içine alınamadı</value>
  </data>
  <data name="keywordDescriptionRightArrow" xml:space="preserve">
    <value>İşlev türlerinde, bağımsız değişkenleri ve dönüş değerlerini ayırır. Bir ifade verir (dizi ifadelerinde); yield anahtar sözcüğüne eşdeğerdir. Eşleştirme ifadelerinde kullanılır</value>
  </data>
  <data name="tcStructsCannotHaveConstructorWithNoArguments" xml:space="preserve">
    <value>Yapıların bağımsız değişkensiz nesne oluşturucusu olamaz. Yapılar varsayılan oluşturucuyu otomatik olarak desteklediği için bu, tüm CLI dillerine getirilen bir kısıtlamadır.</value>
  </data>
  <data name="ilSignInvalidAlgId" xml:space="preserve">
    <value>Geçersiz algId - 'Üs' bekleniyordu</value>
  </data>
  <data name="returnUsedInsteadOfReturnBang" xml:space="preserve">
    <value>'return' yerine 'return!' kullanmayı deneyin.</value>
  </data>
  <data name="derefInsteadOfNot" xml:space="preserve">
    <value>'!' operatörü bir ref hücresine başvurmak için kullanılır. Burada 'not expr' kullanmayı deneyin.</value>
  </data>
  <data name="optsNoInterface" xml:space="preserve">
    <value>F#-özel meta verilerini içeren oluşturulmuş bütünleştirilmiş koda kaynak ekleme</value>
  </data>
  <data name="parsUnexpectedInfixOperator" xml:space="preserve">
    <value>Tür ifadesinde beklenmeyen içtakı işleci</value>
  </data>
  <data name="optsEmbeddedSourceRequirePortablePDBs" xml:space="preserve">
    <value>--embed anahtarı yalnızca Taşınabilir PDB gösterilirken desteklenir (--debug:portable veya --debug:embedded)</value>
  </data>
  <data name="parsInvalidPrefixOperatorDefinition" xml:space="preserve">
    <value>Geçersiz işleç tanımı. Ön ek işleç tanımları geçerli bir ön ek işleci adı kullanmalıdır.</value>
  </data>
  <data name="tcUnnamedArgumentsDoNotFormPrefix" xml:space="preserve">
    <value>Adlandırılmamış bağımsız değişkenler çağrılan metodun bağımsız değişkenlerinin ön ekini oluşturmaz</value>
  </data>
  <data name="invalidFullNameForProvidedType" xml:space="preserve">
    <value>sağlanan tür için geçersiz tam ad</value>
  </data>
  <data name="lexHashElseMustBeFirst" xml:space="preserve">
    <value>#else yönergesi satırdaki ilk boşluk olmayan karakter olarak görünmelidir</value>
  </data>
  <data name="tcUnionCaseFieldCannotBeUsedMoreThanOnce" xml:space="preserve">
    <value>'{0}' birleşim durumu/özel durumu alanı birden çok kez kullanılamaz.</value>
  </data>
  <data name="parsUnionCasesCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Birleşim durumlarında erişilebilirlik değiştiricilerine izin verilmez. Temsilin tamamına erişilebilirlik kazandırmak için 'type U = internal ...' veya 'type U = private ...' kullanın.</value>
  </data>
  <data name="chkErrorUseOfByref" xml:space="preserve">
    <value>Tür örnek oluşturma işlemi byref türünü içerir. Ortak Ara Dil (CIL) kurallarında buna izin verilmez.</value>
  </data>
  <data name="tcUnknownUnion" xml:space="preserve">
    <value>Bilinmeyen birleşim durumu</value>
  </data>
  <data name="tcInvalidMethodNameForRelationalOperator" xml:space="preserve">
    <value>'({0})' adı üye adı olarak kullanılmamalıdır. Türe yönelik karşılaştırma semantiğini tanımlamak için 'System.IComparable' arabirimini uygulayın. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</value>
  </data>
  <data name="tcTypeAbbreviationsCannotHaveAugmentations" xml:space="preserve">
    <value>Tür kısaltmalarının genişletmeleri olamaz</value>
  </data>
  <data name="ModuleContainsConstructorButAccessibilityDiffers" xml:space="preserve">
    <value>Modül\n    {0}    \noluşturucusunu içeriyor ancak imzasında\n    {1}    \nbelirtiliyor; imzada belirtilen erişilebilirlik uygulamada belirtilenden daha fazla</value>
  </data>
  <data name="ValueNotContainedMutabilityAritiesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzadaki parametre sayısı ile uygulamadaki farklı. İmzada '{3}' öğesinin en az {4} bağımsız değişken kabul eden bir işlem tanımı veya lambda ifadesi olduğu belirtiliyor, ancak uygulama hesaplanan bir işlev değeri. Hesaplanan işlev değerinin izin verilen bir uygulama olduğunu tanımlamak için imzada türünü ayraç içine almak yeterlidir, örn.\n\tval {6}: int -&gt; int -&gt; int\nyerine\n\tval {5}: int -&gt; (int -&gt; int).</value>
  </data>
  <data name="typeInfoOtherOverloads" xml:space="preserve">
    <value>ve {0} başka aşırı yükleme</value>
  </data>
  <data name="csTypeIsNotEnumType" xml:space="preserve">
    <value>'{0}' türü bir CLI enum türü değil</value>
  </data>
  <data name="parsModuleAbbreviationMustBeSimpleName" xml:space="preserve">
    <value>Modül kısaltması yol değil, basit ad olmalıdır</value>
  </data>
  <data name="tastRecursiveValuesMayNotAppearInConstructionOfType" xml:space="preserve">
    <value>Özyinelemeli değerler, özyinelemeli bir bağlama içinde '{0}' türünün doğrudan oluşturulması olarak görünemez. Bu özellik F# dilinden kaldırılmıştır. Onun yerine bir kayıt kullanmayı düşünün.</value>
  </data>
  <data name="buildProductNameCommunity" xml:space="preserve">
    <value>F# {0} için F# Derleyicisi</value>
  </data>
  <data name="typrelNamedArgumentHasBeenAssignedMoreThenOnce" xml:space="preserve">
    <value>Adlandırılmış bir bağımsız değişken birden fazla değere atanmış</value>
  </data>
  <data name="fscIgnoringMixedWhenLinking" xml:space="preserve">
    <value>Yönetilen/yönetilmeyen karışık '{0}' bütünleştirilmiş kodu statik bağlama sırasında yok sayılıyor</value>
  </data>
  <data name="tcOnlyStructsCanHaveStructLayout" xml:space="preserve">
    <value>Yalnızca birincil oluşturucuları olmayan yapılara ve sınıflara 'StructLayout' özniteliği verilebilir</value>
  </data>
  <data name="tcExpectedTypeParameter" xml:space="preserve">
    <value>Ölçü birimi parametresi değil tür parametresi bekleniyordu</value>
  </data>
  <data name="keywordDescriptionDefault" xml:space="preserve">
    <value>Soyut bir metodun uygulamasını belirtir; sanal metot oluşturmak üzere soyut metot bildirimi ile birlikte kullanılır.</value>
  </data>
  <data name="parsEofInTripleQuoteStringInComment" xml:space="preserve">
    <value>Üç tırnak işaretli açıklamaya gömülü dizede dosya sonu burada veya daha önce başlatıldı</value>
  </data>
  <data name="optsUseHighEntropyVA" xml:space="preserve">
    <value>Yüksek entropili ASLR'yi etkinleştir</value>
  </data>
  <data name="ilSignPrivateKeyExpected" xml:space="preserve">
    <value>Özel anahtar bekleniyordu</value>
  </data>
  <data name="typeInfoActivePatternResult" xml:space="preserve">
    <value>etkin desen sonucu</value>
  </data>
  <data name="tcUnsupportedMutRecDecl" xml:space="preserve">
    <value>Bu bildirim, özyinelemeli bildirim gruplarında desteklenmez</value>
  </data>
  <data name="ppparsMissingToken" xml:space="preserve">
    <value>Önişlemci ifadesinde eksik belirteç: '{0}'</value>
  </data>
  <data name="fscTooManyErrors" xml:space="preserve">
    <value>Çıkılıyor - çok fazla hata var</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectNumberOfArguments" xml:space="preserve">
    <value>Üye '{0}', doğru sayıda bağımsız değişkene sahip değil. Gereken imza: '{1}'.</value>
  </data>
  <data name="augInvalidAttrs" xml:space="preserve">
    <value>Bu tür, 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' ve 'StructuralComparison' özniteliklerini geçersiz bir karışımda kullanıyor</value>
  </data>
  <data name="tcLetAndDoRequiresImplicitConstructionSequence" xml:space="preserve">
    <value>Bu tanım yalnızca birincil oluşturucusu olan bir türde kullanılabilir. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</value>
  </data>
  <data name="chkAttrHasAllowMultiFalse" xml:space="preserve">
    <value>'{0}' öznitelik türünde 'AllowMultiple=false' değeri var. Bu özniteliğin birden çok örneği tek bir dil öğesine iliştirilemez.</value>
  </data>
  <data name="tcUseYieldBangForMultipleResults" xml:space="preserve">
    <value>Dizi ifadelerinde, 'yield!' kullanılarak birden çok sonuç oluşturulur</value>
  </data>
  <data name="csTypeDoesNotSupportOperatorNullable" xml:space="preserve">
    <value>'{0}' türü '{1}' işlecini desteklemez. 'Microsoft.FSharp.Linq.NullableOperators' modülünü açmayı düşünün.</value>
  </data>
  <data name="tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes" xml:space="preserve">
    <value>Yapılar, arabirimler, sabit listeleri ve temsilciler diğer türlerden devralamaz</value>
  </data>
  <data name="impInvalidNumberOfGenericArguments" xml:space="preserve">
    <value>Sağlanan türdeki '{0}' türünde geçersiz sayıda genel bağımsız değişken. '{1}' bağımsız değişken bekleniyordu, '{2}' verildi.</value>
  </data>
  <data name="tcMethodNotAccessible" xml:space="preserve">
    <value>'{0}' metoduna bu kod konumundan erişilemiyor</value>
  </data>
  <data name="ilSignInvalidMagicValue" xml:space="preserve">
    <value>CLR Üst Bilgisindeki Magic değeri geçersiz</value>
  </data>
  <data name="tcInvalidOptionalAssignmentToPropertyOrField" xml:space="preserve">
    <value>Özelliğe veya alana geçersiz isteğe bağlı atama</value>
  </data>
  <data name="csNoMemberTakesTheseArguments3" xml:space="preserve">
    <value>Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz. '{3}' adlandırılmış bağımsız değişkeni, herhangi bir aşırı yüklemeye yönelik hiçbir bağımsız değişkene veya ayarlanabilen dönüş özelliğine karşılık gelmiyor.</value>
  </data>
  <data name="csNoMemberTakesTheseArguments2" xml:space="preserve">
    <value>Hiçbir {0} üyesi veya '{1}' adlı nesne oluşturucusu {2} bağımsız değişken almaz. Bu üyeye çağrı yapılmasının {3} adlandırılmış bağımsız değişken sağladığına ayrıca dikkat edin.</value>
  </data>
  <data name="nrInvalidFieldLabel" xml:space="preserve">
    <value>Geçersiz alan etiketi</value>
  </data>
  <data name="ilMarshalAsAttributeCannotBeDecoded" xml:space="preserve">
    <value>MarshalAs özniteliğinin kodu çözülemedi</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleILDiffer" xml:space="preserve">
    <value>IL temsilleri farklı olduğundan, imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="buildUnexpectedTypeArgs" xml:space="preserve">
    <value>Genel olmayan '{0}' türü herhangi bir tür bağımsız değişkeni beklemez, ancak burada {1} tür bağımsız değişkenleri verilmiş</value>
  </data>
  <data name="undefinedNameValueConstructorNamespaceOrType" xml:space="preserve">
    <value>'{0}' değeri, oluşturucusu, ad alanı veya türü tanımlı değil.</value>
  </data>
  <data name="typeInfoNamespaceOrModule" xml:space="preserve">
    <value>ad alanı/modül</value>
  </data>
  <data name="recursiveClassHierarchy" xml:space="preserve">
    <value>'{0}' türünde özyinelemeli sınıf hiyerarşisi</value>
  </data>
  <data name="chkUnusedThisVariable" xml:space="preserve">
    <value>Özyinelemeli nesne başvurusu '{0}' kullanılmıyor. Özyinelemeli nesne başvurusunun varlığı, bu ve bundan türetilmiş türlerdeki üyelere çalışma zamanı başlatma denetimleri ekler. Bu özyinelemeli nesne başvurusunu kaldırmayı değerlendirin.</value>
  </data>
  <data name="augTypeCantHaveRefEqAndStructAttrs" xml:space="preserve">
    <value>Bir türde 'ReferenceEquality' ile 'StructuralEquality' veya 'StructuralComparison' öznitelikleri aynı anda olamaz</value>
  </data>
  <data name="tcConstructRequiresComputationExpression" xml:space="preserve">
    <value>Bu yapı yalnızca hesaplama ifadeleri içinde kullanılabilir</value>
  </data>
  <data name="tastValueMustBeLocalAndMutable" xml:space="preserve">
    <value>İçeriği değiştirmek veya değer türünün adresini almak için bir değerin değiştirilebilir olması gerekir, örn. 'let mutable x = ...'</value>
  </data>
  <data name="tcExceptionAbbreviationsMustReferToValidExceptions" xml:space="preserve">
    <value>Özel durum kısaltmaları mevcut özel durumlara veya System.Exception'dan türeyen F# türlerine başvurmalıdır</value>
  </data>
  <data name="optsEmbedAllSource" xml:space="preserve">
    <value>Tüm kaynak dosyaları taşınabilir PDB dosyasına ekle</value>
  </data>
  <data name="tcOnlySimplePatternsInLetRec" xml:space="preserve">
    <value>'let rec' yapılarında yalnızca basit değişken desenleri bağlanabilir</value>
  </data>
  <data name="parsSuccessiveArgsShouldBeSpacedOrTupled" xml:space="preserve">
    <value>Ardışık bağımsız değişkenler boşluklarla veya grup olarak tanımlayarak ayrılmalı ve işlev veya metot uygulamaları içeren bağımsız değişkenler ayraç içine alınmalıdır</value>
  </data>
  <data name="tcNotAnException" xml:space="preserve">
    <value>Özel durum değil</value>
  </data>
  <data name="tcInvalidIndexIntoActivePatternArray" xml:space="preserve">
    <value>İç hata. Etkin desen dizisi için geçersiz dizin</value>
  </data>
  <data name="fscAssumeStaticLinkContainsNoDependencies" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş koduna geçişli olarak başvuruldu ve bütünleştirilmiş kod otomatik olarak çözümlenemedi. Statik bağlantı, bu DLL'nin F# kitaplığına veya statik bağlanmış diğer DLL'lere hiçbir bağımlılığı olmadığını kabul eder. Bu DLL'ye açık başvuru eklemeyi düşünün.</value>
  </data>
  <data name="fscAssemblyCultureAttributeError" xml:space="preserve">
    <value>'System.Reflection.AssemblyCultureAttribute' özniteliği yayılırken hata oluştu -- 'Çalıştırılabilir dosyalar uydu bütünleştirilmiş kodlar olamaz, Kültür her zaman boş olmalıdır'</value>
  </data>
  <data name="parsInterfacesHaveSameVisibilityAsEnclosingType" xml:space="preserve">
    <value>Arabirimler her zaman kapsayan tür ile aynı görünürlüğe sahiptir</value>
  </data>
  <data name="ValueNotContainedMutabilityOneIsTypeFunction" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Biri tür işlevi, diğeri değil. Açık tür parametreleri uygulamada varsa imza için bunlar gerekiyor.</value>
  </data>
  <data name="parsSyntaxModuleStructEndDeprecated" xml:space="preserve">
    <value>'module ... = struct .. end' sözdizimi F# kodunda kullanılmaz. 'module ... = begin .. end' kullanmayı düşünün</value>
  </data>
  <data name="tcVolatileOnlyOnClassLetBindings" xml:space="preserve">
    <value>'VolatileField' özniteliği yalnızca sınıflardaki 'let' bağlamalarında kullanılabilir</value>
  </data>
  <data name="FieldNotContainedLiteralsDiffer" xml:space="preserve">
    <value>Modül\n    {0}    \nalanını içeriyor ancak imzasında\n    {1}    \nbelirtiliyor. 'literal' değiştiricileri farklı</value>
  </data>
  <data name="DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer" xml:space="preserve">
    <value>Kısaltmalar farklı olduğundan ({2} ve {3}), imza ve uygulamadaki '{1}' türü için {0} tanımları uyumlu değil</value>
  </data>
  <data name="tcExplicitStaticInitializerSyntax" xml:space="preserve">
    <value>Açık statik başlatıcı 'static new(args) = expr' sözdizimini kullanmalıdır</value>
  </data>
  <data name="tcOnlyFunctionsCanBeInline" xml:space="preserve">
    <value>Yalnızca işlevler 'inline' olarak işaretlenebilir</value>
  </data>
  <data name="tcTypeIsNotInterfaceType0" xml:space="preserve">
    <value>Bu tür bir arabirim türü değil</value>
  </data>
  <data name="tcTypeIsNotInterfaceType1" xml:space="preserve">
    <value>'{0}' türü bir arabirim türü değil</value>
  </data>
  <data name="chkObjCtorsCantUseExceptionHandling" xml:space="preserve">
    <value>Nesne oluşturucular, nesnenin başlatılmasından önce try/with ve try/finally ifadelerini doğrudan kullanamazlar. Buna bu yapıların kullanımını çeşitlendirebilen 'for x in ...' gibi yapılar da dahildir. Bu, Ortak Ara Dilin getirdiği bir kısıtlamadır.</value>
  </data>
  <data name="tcReturnMayNotBeUsedInQueries" xml:space="preserve">
    <value>'return' ve 'return!' sorgularda kullanılamaz</value>
  </data>
  <data name="parsRecordFieldsCannotHaveVisibilityDeclarations" xml:space="preserve">
    <value>Kayıt alanlarında erişilebilirlik değiştiricilerine izin verilmez. Temsilin tamamına erişilebilirlik kazandırmak için 'type R = internal ...' veya 'type R = private ...' kullanın.</value>
  </data>
  <data name="keywordDescriptionUseBang" xml:space="preserve">
    <value>Zaman uyumsuz iş akışlarında ve diğer hesaplama ifadelerinde Dispose'un boş kaynaklara çağrılmasını gerektiren değerler için let! yerine kullanılır.</value>
  </data>
  <data name="tcInheritIllegalHere" xml:space="preserve">
    <value>Devralma bildirimine burada izin verilmiyor</value>
  </data>
  <data name="etNullMemberDeclaringType" xml:space="preserve">
    <value>'{0}' sağlanan türünün '{1}' üye bilgisinde null tanımlama türü var</value>
  </data>
  <data name="etProvidedAppliedMethodHadWrongName" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}', 'ApplyStaticArgumentsForMethod' öğesinden geçersiz bir metot döndürdü. '{1}' adlı bir metot bekleniyordu ancak '{2}' adlı bir metot döndürüldü.</value>
  </data>
  <data name="lexInvalidUnicodeLiteral" xml:space="preserve">
    <value>\U{0} geçerli bir Unicode karakter kaçış sırası değil</value>
  </data>
  <data name="nrTypeInstantiationNeededToDisambiguateTypesWithSameName" xml:space="preserve">
    <value>Farklı sayıda genel parametreler alan '{0}' adlı birden çok tür var. Tür çözümleme belirsizliğini gidermek için bir tür örneği sağlayın, örn. '{1}'.</value>
  </data>
  <data name="typrelModuleNamespaceAttributesDifferInSigAndImpl" xml:space="preserve">
    <value>Ad alanı veya modül öznitelikleri imza ile uygulama arasında farklılık gösteriyor</value>
  </data>
  <data name="typrelNeedExplicitImplementation" xml:space="preserve">
    <value>'{0}' arabirimi, birden fazla açık olarak uygulanan arabirim türüne eklenmiş. Bu arabirimin açık uygulamasını ekleyin.</value>
  </data>
  <data name="eventHasNonStandardType" xml:space="preserve">
    <value>'{0}' olayı standard olmayan türe sahip. Bu olay başka bir CLI dilinde tanımlanıyorsa olayın açık {1} ve {2} metotlarını kullanarak bu olaya erişmeniz gerekebilir. Bu olay F# dilinde tanımlanıyorsa, olayın türünü bir 'IDelegateEvent&lt;_&gt;' veya 'IEvent&lt;_,_&gt;' örneklemesi yapın.</value>
  </data>
  <data name="tcReservedSyntaxForAugmentation" xml:space="preserve">
    <value>'type X with ...' sözdizimi genişletmeler için ayrılmıştır. Gösterimleri gizli olan ancak üyeleri olan türler artık 'type X = ...' kullanılarak imzalarda tanımlanmaktadır. İmzadaki tür tanımına '[&lt;Sealed&gt;] özniteliğini de eklemeniz gerekebilir</value>
  </data>
  <data name="undefinedNameSuggestionsIntro" xml:space="preserve">
    <value>Aşağıdakilerden birini arıyor olabilirsiniz:</value>
  </data>
  <data name="undefinedNameRecordLabel" xml:space="preserve">
    <value>'{0}' kayıt etiketi tanımlı değil.</value>
  </data>
  <data name="tcTypeTestLosesMeasures" xml:space="preserve">
    <value>Bu tür testi veya alt türe çevirme işlemi '{0}' ölçü birimini yok sayacak</value>
  </data>
  <data name="ilSignInvalidPKBlob" xml:space="preserve">
    <value>Ortak Anahtar blobu geçersiz</value>
  </data>
  <data name="fscStaticLinkingNoProfileMismatches" xml:space="preserve">
    <value>System.Runtime'a başvuran bir bütünleştirilmiş kod oluşturulurken (örneğin, .NET Core veya Taşınabilir bütünleştirilmiş kod), mscorlib'e başvuran bir bütünleştirilmiş kodda (örneğin, .NET Framework bütünleştirilmiş kodu) statik bağlama kullanılamaz.</value>
  </data>
  <data name="ValueNotContainedMutabilityGenericParametersDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. İmzadaki ve uygulamadaki genel parametrelerin sayısı farklı (imzada {3}, ancak uygulamada {4} tanımlanıyor</value>
  </data>
  <data name="typrelMemberDoesNotHaveCorrectKindsOfGenericParameters" xml:space="preserve">
    <value>Üye '{0}', doğru tür genel parametrelere sahip değil. Gereken imza: '{1}'.</value>
  </data>
  <data name="typrelSigImplNotCompatibleParamCountsDiffer" xml:space="preserve">
    <value>İlgili tür parametresi sayıları farklı olduğu için imza ve uygulama uyumlu değil</value>
  </data>
  <data name="tcTypeExceptionOrModule" xml:space="preserve">
    <value>tür, özel durum veya modül</value>
  </data>
  <data name="tcExpressionWithIfRequiresParenthesis" xml:space="preserve">
    <value>Liste veya dizi ifadesi 'if ... then ... else' biçiminde bir öğe içeriyor. Listenin veya dizinin bağımsız bir öğesi olduğunu belirtmek, dizi ifadesi kullanılarak oluşturulmuş listeden ayırt etmek için bu ifadeyi ayraç içine alın</value>
  </data>
  <data name="csTypeDoesNotHaveNull" xml:space="preserve">
    <value>'{0}' türünde uygun değer olarak 'null' yoktur</value>
  </data>
  <data name="parsVisibilityDeclarationsShouldComePriorToIdentifier" xml:space="preserve">
    <value>Erişilebilirlik değiştiricileri bir yapıyı adlandıran tanımlayıcıdan hemen önce gelmelidir</value>
  </data>
  <data name="parsUnmatchedUse" xml:space="preserve">
    <value>Eksik değer tanımı. Bu bir ifadeyse ifadenin gövdesi 'use' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</value>
  </data>
  <data name="parsUnmatchedLet" xml:space="preserve">
    <value>Eksik değer veya işlev tanımı. Bu bir ifadeyse ifadenin gövdesi 'let' anahtar sözcüğü ile aynı sütuna girintilenmelidir.</value>
  </data>
  <data name="tcUnionCaseConstructorDoesNotHaveFieldWithGivenName" xml:space="preserve">
    <value>'{0}' birleşim durumu/özel durumunda '{1}' adlı alan yok.</value>
  </data>
  <data name="tcInvalidMemberName" xml:space="preserve">
    <value>'({0})' adı üye adı olarak kullanılmamalıdır. Diğer CLI dillerinden kullanılacak statik bir üye tanımlıyorsanız onun yerine '{1}' adını kullanın.</value>
  </data>
  <data name="etProviderDoesNotHaveValidConstructor" xml:space="preserve">
    <value>Tür sağlayıcısının geçerli bir oluşturucusu yok. Hiç bağımsız değişken almayan veya 'TypeProviderConfig' türü bağımsız değişken alan bir oluşturucu bekleniyordu.</value>
  </data>
  <data name="tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute" xml:space="preserve">
    <value>Kayıtlar, birleşim, kısaltmalar ve yapı türlerinin 'AllowNullLiteral' özniteliği olamaz</value>
  </data>
  <data name="tcExpressionFormRequiresRecordTypes" xml:space="preserve">
    <value>{{ expr with ... }} ifade biçimi yalnızca kayıt türleriyle kullanılabilir. Nesne türleri oluşturmak için {{ new Type(...) with ... }} kullanın</value>
  </data>
  <data name="typrelNoImplementationGiven" xml:space="preserve">
    <value>'{0}' için bir uygulama verilmedi</value>
  </data>
  <data name="tcUnionCaseExpectsTupledArguments" xml:space="preserve">
    <value>Bu birleşim durumu grup olarak tanımlanmış biçimde {0} bağımsız değişken bekliyor</value>
  </data>
  <data name="tastDuplicateTypeDefinitionInAssembly" xml:space="preserve">
    <value>'{0}' adlı iki tür tanımı bu bütünleştirilmiş kodun iki yerinde '{1}' ad alanında geçiyor</value>
  </data>
  <data name="tcInvalidModuleName" xml:space="preserve">
    <value>Geçersiz modül adı</value>
  </data>
  <data name="considerUpcastOperator" xml:space="preserve">
    <value>{0} türünden {1} türüne dönüştürme, bir alt türe çevirme değil, derleme zamanında güvenli bir üst türe çevirmedir. :?&gt; (alt türe çevirme) işleci yerine :&gt; (üst türe çevirme) işlecini kullanmayı düşünün.</value>
  </data>
  <data name="forPositionalSpecifiersNotPermitted" xml:space="preserve">
    <value>Biçim dizelerinde konum tanımlayıcılara izin verilmiyor</value>
  </data>
  <data name="tcCustomOperationMayNotBeOverloaded" xml:space="preserve">
    <value>'{0}' özel işlemi aşırı yüklenmiş bir metoda başvuruyor. Özel işlemlerin uygulamaları aşırı yüklenemez.</value>
  </data>
  <data name="parsUseBindingsIllegalInModules" xml:space="preserve">
    <value>modüllerde 'use' bağlamalarına izin verilmez ve 'let' bağlamaları gibi işlem yapılır</value>
  </data>
  <data name="optsCodepage" xml:space="preserve">
    <value>Kaynak dosyaları okumak için kullanılan kod sayfasını belirtin</value>
  </data>
  <data name="elDeprecatedOperator" xml:space="preserve">
    <value>Bu işlecin işlemleri artık doğrudan F# derleyicisi tarafından işlendiğinden anlamı yeniden tanımlanamaz</value>
  </data>
  <data name="keywordDescriptionDynamicCast" xml:space="preserve">
    <value>Bir türü hiyerarşide daha aşağıdaki bir türe dönüştürür.</value>
  </data>
  <data name="buildCouldNotReadVersionInfoFromMscorlib" xml:space="preserve">
    <value>Sürüm, mscorlib.dll'den okunamadı</value>
  </data>
  <data name="etProviderErrorWithContext" xml:space="preserve">
    <value>Tür sağlayıcısı '{0}', sağlanan tür '{1}', üye '{2}' bağlamında bir hata bildirdi. Hata: {3}</value>
  </data>
  <data name="etErrorApplyingStaticArgumentsToType" xml:space="preserve">
    <value>Sağlanan türe statik bağımsız değişkenler uygulanırken bir hata oluştu</value>
  </data>
  <data name="optsHelpBannerInputFiles" xml:space="preserve">
    <value>- GİRİŞ DOSYALARI -</value>
  </data>
  <data name="parsIntegerForLoopRequiresSimpleIdentifier" xml:space="preserve">
    <value>Döngü tamsayısı basit tanımlayıcı kullanmalıdır</value>
  </data>
  <data name="lexOutsideEightBitSignedHex" xml:space="preserve">
    <value>Bu sayı, onaltılık 8 bit işaretli tamsayılar için izin verilen aralığın dışında</value>
  </data>
  <data name="patternMatchGuardIsNotBool" xml:space="preserve">
    <value>Bir desen eşleşmesi koruyucusunun 'bool' türünde olması gerekir, ancak bu 'when' ifadesi '{0}' türünde.</value>
  </data>
  <data name="parsEmptyTypeDefinition" xml:space="preserve">
    <value>Tür tanımı, bir veya daha fazla üyeyi ya da diğer tanımlamaları gerektirir. Boş bir class, struct veya interface tanımlamayı planlıyorsanız 'type ... = class end', 'interface end' veya 'struct end' kullanın.</value>
  </data>
  <data name="csGenericConstructRequiresReferenceSemantics" xml:space="preserve">
    <value>Genel bir yapı, '{0}' türünde başvuru semantiği olmasını gerektirir ancak bu söz konusu değil, yani bu bir struct</value>
  </data>
  <data name="ValueNotContainedMutabilityNamesDiffer" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Adlar farklı</value>
  </data>
  <data name="chkNoByrefInTypeAbbrev" xml:space="preserve">
    <value>Tür kısaltması byref değerleri içeriyor. F# dilinde buna izin verilmez.</value>
  </data>
  <data name="ilwriteErrorCreatingMdb" xml:space="preserve">
    <value>MDB hata ayıklama bilgileri oluşturulamıyor. 'MonoSymbolWriter' türü 'Mono.CompilerServices.SymbolWriter.dll' bütünleştirilmiş kodundan yüklenemedi.</value>
  </data>
  <data name="ilwriteErrorCreatingPdb" xml:space="preserve">
    <value>Hata ayıklama bilgileri dosyası '{0}' oluşturulurken beklenmeyen hata</value>
  </data>
  <data name="tcExpectedUnitOfMeasureMarkWithAttribute" xml:space="preserve">
    <value>Tür parametresi değil ölçü birimi parametresi bekleniyordu. Açık ölçü birimi parametreleri [&lt;Measure&gt;] özniteliğiyle işaretlenmelidir.</value>
  </data>
  <data name="tcUnableToParseFormatString" xml:space="preserve">
    <value>'{0}' biçim dizesi ayrıştırılamıyor</value>
  </data>
  <data name="tastUnexpectedDecodeOfAutoOpenAttribute" xml:space="preserve">
    <value>Beklenmeyen AutoOpenAttribute kod çözümü</value>
  </data>
  <data name="crefQuotationsCantCallTraitMembers" xml:space="preserve">
    <value>Alıntılar, üye kısıtlama çağrıları yapan veya örtük olarak üye kısıtlama çağrısına çözümlenen işleçler kullanan ifadeler içeremez</value>
  </data>
  <data name="noEqualSignAfterModule" xml:space="preserve">
    <value>Kitaplıklar veya çok dosyalı uygulamalardaki dosyalar bir ad alanı veya modül bildirimiyle başlamalıdır. Bir dosyanın başında modül bildirimi kullanılırken '=' işaretine izin verilmez. Bu bir üst düzey modülse, bu hatayı çözmek için = işaretini kaldırmayı düşünün.</value>
  </data>
  <data name="tcFieldAppearsTwiceInRecord" xml:space="preserve">
    <value>'{0}' alanı bu kayıt ifadesinde veya deseninde iki kez görünüyor</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedName" xml:space="preserve">
    <value>'{0}' adlı sağlanan tür bekleniyordu ancak sağlanan türde '{1}' değerli 'Name' öğesi var</value>
  </data>
  <data name="etProvidedTypeHasUnexpectedPath" xml:space="preserve">
    <value>Yolu '{0}' olan bir sağlanan tür bekleniyordu ancak sağlanan türde '{1}' yolu var</value>
  </data>
  <data name="tcCustomAttributeArgumentMismatch" xml:space="preserve">
    <value>Özel bir özniteliğin bağımsız değişken sayısı öznitelik oluşturucusunun beklenen bağımsız değişken sayısı ile eşleşmiyor</value>
  </data>
  <data name="chkMemberUsedInInvalidWay" xml:space="preserve">
    <value>'{0}' üyesi geçersiz bir biçimde kullanılmış. '{1}' kullanımı, '{2}' konumunda veya yakınındaki tanımından önce çıkarılmış. Bu geçersiz bir ileriye doğru başvurudur.</value>
  </data>
  <data name="etEventNoRemove" xml:space="preserve">
    <value>'{1}' sağlanan türündeki '{0}' olayının bir GetRemoveMethod() değeri yok</value>
  </data>
  <data name="ilSignRsaKeyExpected" xml:space="preserve">
    <value>RSA anahtarı bekleniyordu</value>
  </data>
  <data name="tcFSharpCoreRequiresExplicit" xml:space="preserve">
    <value>FSharp.Core.dll'sindeki tüm kayıt, birleşim ve yapı türleri 'StructuralComparison' veya 'NoComparison' ile açık olarak etiketlenmelidir</value>
  </data>
  <data name="nrUnionTypeNeedsQualifiedAccess" xml:space="preserve">
    <value>'{0}' birleşim durumunun birleşim türü RequireQualifiedAccessAttribute ile tanımlanmış. Kullandığınız ada birleşim türünün adını ('{1}') dahil edin.</value>
  </data>
  <data name="tastActivePatternsLimitedToSeven" xml:space="preserve">
    <value>Etkin desenler 7 olasılıktan fazlasını döndüremez</value>
  </data>
  <data name="undefinedNameValueOfConstructor" xml:space="preserve">
    <value>'{0}' değer veya oluşturucusu tanımlı değil.</value>
  </data>
  <data name="tcInheritConstructionCallNotPartOfImplicitSequence" xml:space="preserve">
    <value>Bu 'inherit' bildiriminin bağımsız değişkenleri var, ancak birincil oluşturucuya sahip bir türde bulunmuyor. Tür tanımınıza bağımsız değişkenler eklemeyi düşünün, örn. 'type X(args) = ...'.</value>
  </data>
  <data name="tcTypesAreAlwaysSealedDU" xml:space="preserve">
    <value>Ayırt edici birleşim türleri her zaman korumalıdır</value>
  </data>
  <data name="ilUnexpectedGetSetAnnotation" xml:space="preserve">
    <value>Özellikte beklenmeyen GetSet ek açıklaması</value>
  </data>
  <data name="tcInvalidEnumerationLiteral" xml:space="preserve">
    <value>Bu, sabit listesi değeri olarak geçerli bir değer değil</value>
  </data>
  <data name="nrInvalidModuleExprType" xml:space="preserve">
    <value>Geçersiz modül/ifade/tür</value>
  </data>
  <data name="nicePrintOtherOverloadsN" xml:space="preserve">
    <value>+ {0} aşırı yükleme</value>
  </data>
  <data name="nicePrintOtherOverloads1" xml:space="preserve">
    <value>+ 1 aşırı yükleme</value>
  </data>
  <data name="csExpectTypeWithOperatorButGivenTuple" xml:space="preserve">
    <value>'{0}' işlecini destekleyen bir tür bekleniyor ancak bir demet türü verildi.</value>
  </data>
  <data name="fscReferenceOnCommandLine" xml:space="preserve">
    <value>'{0}' bütünleştirilmiş kodu komut satırında listeleniyor. Bütünleştirilmiş kodlara '-r' gibi bir komut satırı bayrağı kullanılarak başvurulmalıdır.</value>
  </data>
  <data name="etProvidedTypeWithNullOrEmptyName" xml:space="preserve">
    <value>Sağlanan türün '{0}' öğesi null veya boştu.</value>
  </data>
  <data name="chkDuplicateMethodInheritedType" xml:space="preserve">
    <value>Yinelenen metot. Soyut '{0}' metodu, devralınan türdeki soyut metotla aynı ada ve imzaya sahip.</value>
  </data>
  <data name="typeInfoFromNext" xml:space="preserve">
    <value>ayrıca {0} öğesinden</value>
  </data>
  <data name="tcRuntimeSuppliedMethodCannotBeUsedInUserCode" xml:space="preserve">
    <value>Dizi metodu '{0}', çalışma zamanı tarafından sağlanır ve kodda doğrudan kullanılamaz. Dizi öğeleriyle işlemler için LanguagePrimitives.IntrinsicFunctions modülünden GetArray/SetArray işlev ailesini kullanmayı düşünün.</value>
  </data>
  <data name="parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate" xml:space="preserve">
    <value>Modül kısaltmasında '{0}' erişilebilirlik özniteliğine izin verilmez. Modül kısaltmaları her zaman özeldir.</value>
  </data>
  <data name="tcGeneratedTypesShouldBeInternalOrPrivate" xml:space="preserve">
    <value>Tür sağlayıcısının bu kullanımının oluşturduğu sağlanan türler diğer F# bütünleştirilmiş kodlarından kullanılamaz ve iç veya özel olarak işaretlenmeleri gerekir. 'type internal TypeName = ...' veya 'type private TypeName = ...' kullanmayı düşünün.</value>
  </data>
  <data name="addIndexerDot" xml:space="preserve">
    <value>Dizin oluşturucu erişimi için . ekleyin.</value>
  </data>
  <data name="tcDllImportNotAllowed" xml:space="preserve">
    <value>DLLImport bağlamaları bir sınıf içinde statik üyeler veya bir modül içinde işlev tanımları olmalıdır</value>
  </data>
  <data name="tcInferredGenericTypeGivesRiseToInconsistency" xml:space="preserve">
    <value>'{0}' işlevi veya üyesi, çıkartılan türlerin tutarlı olmasını sağlamak için tanımında başka tür ek açıklamaları gerektirecek şekilde kullanılmış. Çıkartılan imza: '{1}'.</value>
  </data>
  <data name="tcDefaultImplementationAlreadyExists" xml:space="preserve">
    <value>Bu metodun zaten varsayılan uygulaması var</value>
  </data>
  <data name="ValueNotContainedMutabilityInstanceButStatic" xml:space="preserve">
    <value>'{0}' modülü\n    {1}    \niçeriyor ancak imzasında\n    {2}    \nbelirtiliyor. Bu metodun derlenen gösterimi örnek üye olarak verilmiş, ancak imzada derlenen gösterim statik üye olarak belirtiliyor</value>
  </data>
  <data name="lexInvalidByteLiteral" xml:space="preserve">
    <value>Bu geçerli bir bayt sabit değeri değil</value>
  </data>
</root>