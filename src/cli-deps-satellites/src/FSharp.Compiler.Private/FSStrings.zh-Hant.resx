<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>符號 '||'</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> 在實作檔中</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>只根據名稱和引數計數，成員 '{0}' 未對應到唯一的抽象位置</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value>。多個實作的介面具有這個名稱和引數計數的成員</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value>。請考慮明確實作介面 '{0}' 和 '{1}'。</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value>。可能需要其他類型註釋，指示相關覆寫。使用 '#nowarn "70"' 或 '--nowarn:70' 可以停用這個警告。</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>語彙失敗</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>符號 '(*)'</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> 在 Lambda 運算式中</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>符號 '('</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>關鍵字 'constructor'</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> 在屬性清單中</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>此值不可變動。請考慮使用可變動的關鍵字，例如 'let mutable {0} = expression'。</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>前置運算子</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>這個向上轉型是不必要的 - 類型一樣</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>將隱含捨棄此等號比較運算式的結果。請考慮使用 'let' 將結果繫結至名稱，例如 'let result = expression'。</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>'{0}' 在這個模式中繫結兩次</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>模式中通常不應該使用大寫的變數識別項，這可能表示模式名稱拼字錯誤。</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> 在差別聯集宣告中</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>關鍵字 'to'</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>關鍵字 'if'</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>關鍵字 'in'</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>關鍵字 'as'</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>關鍵字 'or'</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>關鍵字 'of'</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>關鍵字 'do'</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>已隱含忽略運算式的結果。請考慮使用 'ignore' 以明確捨棄此值，例如 'expr |&gt; ignore'，或使用 'let' 將結果繫結至名稱，例如 'let result = expr'。</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>關鍵字 'interface'</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> 在模組或命名空間簽章中</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>#I 指示詞只能出現在 F# 指令碼檔案 (副檔名 .fsx 或 .fsscript) 中。請將這個程式碼移到指令碼檔案、為這個參考加入 '-I' 編譯器選項，或用 '#if INTERACTIVE'/'#endif' 分隔這個指示詞。</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>關鍵字 'constraint'</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0} (程式碼={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> 在成員定義中</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>關鍵字 'finally'</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> 在例外狀況定義中</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value>。必須是{0}、{1}、{2} 或其他語彙基元。</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>符號 ':?'</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>類型實作了介面 '{0}'，但是未由簽章顯示。您應該在簽章中列出這個介面，因為透過動態類型轉型和/或反映即可瀏覽這個介面。</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>關鍵字 'public'</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>符號 '::'</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value>。請參閱 {0}。</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>行註解</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>包含類型可以使用 'null' 做為其零元聯集的表示值。叫用抽象或虛擬成員或 null 值的介面實作將產生例外狀況。如有必要，請將虛擬資料值加入零元建構函式，以免將 'null' 當做這種類型的表示。</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>關鍵字 'upcast'</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>關鍵字 'override'</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>這個運算式的模式比對不完整。</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> 例如，值 '{0}' 可能表示模式未涵蓋的案例。</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> 例如，值 '{0}' 可能表示模式未涵蓋的案例。但是具有 'when' 子句的模式規則或許可以成功比對這個值。</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> 無對應的項目將會被忽略。</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>要編譯為 .NET 事件的定義不是採用需要的形式。只有屬性成員可以編譯為 .NET 事件。</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> 在 if/then/else 運算式中</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>字串常值</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>關鍵字 'struct'</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>關鍵字 'static'</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>符號 ']'</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>符號 '}'</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>符號 '-&gt;'</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>符號 ')'</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>引號結尾</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>遺漏需要的組件參考。您必須加入組件 '{0}' 的參考。</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>應該在類型的初始宣告上指定介面實作。</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>關鍵字 'inline'</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>這個和其他對所定義物件的遞迴參考，將在執行階段透過使用延遲參考來檢查初始化是否正確。這是因為您定義的是一個或多個遞迴物件，而不是遞迴函式。使用 '#nowarn "40"' 或 '--nowarn:40' 可以隱藏這個警告。</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>符號 ':?&gt;'</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>可能的多載: '{0}'。{1}。</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>這個欄位不是可變動的欄位</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>關鍵字 'member'</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>關鍵字 'module'</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> 在值簽章中</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>符號 '('</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>引號開頭</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>符號 '&lt;-'</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>關鍵字 'downcast'</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>符號 '{'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>符號 '['</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>這不是區域值</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>根據這個程式點之前的資訊，這個從類型\n    {0}    \n 到 \n    {1}    \n的執行階段強制型轉或類型測試涉及不定的類型。不允許在某些類型上使用執行階段類型測試。需要進一步的類型註釋。</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>符號 '|]'</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>型別參數遺漏條件約束 '{0}'</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>關鍵字</value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> 在模式中</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>關鍵字 'assert'</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> 在型別引數中</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>將隱含捨棄此等號比較運算式的結果。請考慮使用 'let' 將結果繫結至名稱，例如 'let result = expression'。若您要變動值，請將值標示為 [可變動] 並使用 '&lt;-' 運算子，例如 '{0} &lt;- expression'。</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>輸入的結尾</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>型別 '{0}' 需要 {1} 個型別引數，卻指定了 {2} 個</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>內部虛擬語彙基元</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>套用類型推斷變數的預設類型 '{0}' 時，發生類型條件約束不符。</value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> 請考慮加入進一步的類型條件約束</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>關鍵字 'delegate'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>關鍵字 'extern'</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>符號 '='</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>符號 '..'</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>關鍵字 'downto'</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>符號 '$'</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>從類型 {0} 到 {1} 的執行階段強制型轉或類型測試無效\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>類型不符。必須是\n    '{0}'    \n但指定的是\n    '{1}'    {2}\n</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>這個運算式必須為類型\n    '{1}'    \n但此處卻是類型\n    '{0}'    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>繫結器關鍵字</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> 在互動中</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>結構化建構開頭</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>增強指定中的介面實作現在已被取代。應該在類型的初始宣告上指定介面實作。</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>這個類型測試或向下轉型永遠有效</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>成員 '{0}' 沒有正確的類型可覆寫對應的抽象方法。</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> 需要的簽章是 '{0}'。</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>成員 '{0}' 沒有正確的類型可覆寫任何指定的虛擬方法</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>成員 '{0}' 以 'unit' 特製化，但無法用 'unit' 當作在傳回類型上參數化之抽象方法的傳回類型。</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> 在指示詞中</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>關鍵字 'global'</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> 在成員簽章中</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>前置運算子</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>關鍵字 'function'</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> 在繫結中</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value>。必須是{0} 或其他語彙基元。</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>關鍵字 'interface'</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>符號 ';;'</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (因縮排感知的語法所致)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>因為這個向前參考的關係，繫結可能未依序執行。</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>符號</value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>十進位常值</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>這個建構已被取代</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value>。{0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>關鍵字 'default'</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> 在記錄運算式中</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>根據這個程式點之前的資訊，查詢是針對不定類型的物件。在這個程式點之前可能需要類型註釋，以限制物件的類型。這樣或許可以讓查詢能夠解析。</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>Thread 靜態和 Context 靜態的 'let' 繫結已被取代。請改成在類別中使用 'static val mutable &lt;ident&gt; : &lt;type&gt;' 形式的宣告。將 'DefaultValue' 屬性加入這個宣告以表示會在每個新執行緒時將值初始化成預設值。</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>內部錯誤: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> 在類型條件約束中</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>運算子名稱</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>透過 '{0}' 參考的類型是定義在未參考的組件中。您必須加入組件 '{1}' 的參考。</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}。使用 '--nowarn:57' 或 '#nowarn "57"' 可以停用這個警告。</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>內部錯誤: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>剖析錯誤</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>剖析錯誤: 未預期的檔案結尾</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>載入的檔案只能是 F# 原始程式檔 (副檔名 .fs)。這個 F# 指令碼檔案 (.fsx 或 .fsscript) 將被視為 F# 原始程式檔</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>無法整合類型 '{0}' 與 '{1}'。</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>無法定義 {0} '{1}'，因為名稱 '{2}' 與這個類型或模組中的 {3} '{4}' 相衝突</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>重複的 {0} '{1}' 定義</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> 在公開宣告中</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>值 '{0}' 將在它自己的定義內評估</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>這個值最後將在它自己的定義內評估。您必須將這個值設為 Lazy 或函式。值 '{0}'{1}。</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>編譯器產生的常值</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>下列欄位需要值: {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>非作用中的程式碼</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>類型 '{0}' 與類型 '{1}'{2} 不相容</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>關鍵字 'abstract'</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>關鍵字 'namespace'</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>在以下或以下之前有結構不完整的建構: 這一點</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>將隱含捨棄此等號比較運算式的結果。請考慮使用 'let' 將結果繫結至名稱，例如 'let result = expression'。若您要設定屬性值，則使用 '&lt;-' 運算子，例如 '{0}.{1} &lt;- expression'。</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value>。必須是 {0}、{1} 或其他語彙基元。</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>符號 '??'</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>差別聯集和例外狀況標籤必須是大寫的識別項</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>這個 'or' 模式的兩邊各繫結不同的變數集合</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>無法載入檔案 '{0}'，因為它不存在或無法存取</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>這個運算式是函式值，也就是遺漏引數。它的類型是 {0}。</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>符號 '['</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>關鍵字 'mutable'</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> 在定義中</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>符號 '&gt;|]'</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>空白</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>關鍵字 'private'</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>#r 指示詞只能出現在 F# 指令碼檔案 (副檔名為 .fsx 或 .fsscript) 中。請將此程式碼移至指令碼檔案，或以 '-r' 編譯器選項取代此參考。若此指示詞要以使用者輸入的方式執行，可以使用 '#if INTERACTIVE'/'#endif' 加以分隔。</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>字串文字</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>整數</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> 在欄位宣告中</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>函式 '{0}' 的使用方式不符合由他處推斷的類型。函式的推斷類型是\n    {1}。 \n在這個使用點需要的函式類型是\n    {2}    {3}\n這個錯誤可能是 'let rec' 集合內或類別群組內泛型遞迴的相關限制所致。請考慮為遞迴呼叫的目標指定完整類型的簽章，包含引數和傳回型別兩者的類型註釋。</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>類型 '{0}' 沒有任何正確的子類型，不必做為靜態強制型轉的目標使用</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> 在 begin/end 運算式中</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>符號 '{&lt;'</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>符號 ':='</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>關鍵字 'inherit'</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>關鍵字 'try'</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>關鍵字 'sig'</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>關鍵字 'rec'</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>整數常值</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>關鍵字 'val'</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>關鍵字 'asr'</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>關鍵字 'and'</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>符號 '&amp;'</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>關鍵字 'do'</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>關鍵字 'new'</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>關鍵字 'end'</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>輸入的結尾</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>符號 '.'</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>符號 '|'</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>關鍵字 'fun'</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>關鍵字 'for'</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>這個建構會導致程式碼的一般程度低於其類型註釋所指示的程度。在 '{0}' 或附近使用 '#'、'_' 或其他類型註釋所隱含的類型變數已被限於必須是類型 '{1}'。</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>這個建構會導致程式碼的一般程度低於類型註釋所指示的程度。類型變數 '{0}' 已被限於必須是類型 '{1}'。</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>這個建構會導致程式碼的一般程度低於類型註釋所指示的程度。測量單位變數 '{0}' 已被限於必須是測量 '{1}'。</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>註解</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>增強指定中的覆寫實作現在已被取代。應該在類型的初始宣告上指定覆寫實作。</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>這個遞迴用途會在執行階段檢查初始化是否正確。這個警告通常是無害的，可以使用 '#nowarn "21"' 或 '--nowarn:21' 予以隱藏。</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>應該在類型的初始宣告上指定覆寫實作。</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>包含類型可以使用 'null' 做為其零元聯集的表示值。這個成員將編譯成靜態成員。</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>類型條件約束不符。類型\n    '{0}'    \n不相容於類型\n    '{1}'    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>在下列任何位置都找不到檔案 '{0}'\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>類型應用程式</value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>這個指示詞只能用在 F# 指令碼檔案 (副檔名 .fsx 或 .fsscript) 中。請移除指示詞，或將這個程式碼移到指令碼檔案，或用 '#if INTERACTIVE'/'#endif' 分隔這個指示詞。</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>類型 '{0}' 不符合類型 '{1}'</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>測量單位 '{0}' 不符合測量單位 '{1}'</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>關鍵字 'internal'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>符號 '[&lt;'</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>符號 '&gt;'</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>這個建構已被取代: 它只用在 F# 程式庫中</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>值限制。值 '{0}' 具有泛型類型\n    {1}    \n請將 '{2}' 設為具有明確引數的函式，或者如果不想將它設為泛型，請加入類型註釋。</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>值限制。這個成員已被推斷為具有泛型類型\n    {0}    \n建構函式和屬性 getter/setter 不能比封入類型更為泛型。請加入類型註釋，以指示涉及的確切類型。</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>值限制。值 '{0}' 具有泛型類型\n    {1}    \n請將 '{2}' 的引數設為明確的，或者如果不想將它設為泛型，請加入類型註釋。</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>值限制。值 '{0}' 已被推斷為具有泛型類型\n    {1}    \n請將 '{2}' 的引數設為明確的，或者如果不想將它設為泛型，請加入類型註釋。</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>值限制。值 '{0}' 已被推斷為具有泛型類型\n    {1}    \n請將 '{2}' 定義為簡單資料項、將它設為具有明確引數的函式，或者如果不想將它設為泛型，請加入類型註釋。</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> 在模式比對中</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>未預期的輸入結束</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> 在類型定義中</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> 在類型簽章中</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> 在簽章檔中</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> 在引號常值中</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>載入的檔案中有一個或多個警告。\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>載入的檔案中有一個或多個錯誤。\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>F# 編譯器會為名稱為 '{0}' 的成員條件約束指定特殊狀態，因為某些 .NET 類型會隱含用這個成員增強。如果您試圖從您自己的程式碼叫用這個成員條件約束，可能導致執行階段失敗。</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> 在繫結中</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>重複的 {0} '{1}' 定義</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>名稱為 '{0}' 的兩個成員具有相同的簽章</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>關鍵字 'instance'</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>使用原生指標可能產生無法驗證的 .NET IL 程式碼</value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>類型 '{0}' 沒有任何正確的子類型，不能做為類型測試或執行階段強制型轉的來源。</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>不能使用類型 '{0}' 做為類型測試或執行階段強制型轉的來源</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>關鍵字 'do!'</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>符號 '_'</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>結構的隱含物件建構函式必須至少接受一個引數</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>符號 '{0}</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>保留的關鍵字</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>符號 'splice'</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>對所定義物件的遞迴參考，將在執行階段透過使用延遲參考來檢查初始化是否正確。請考慮將自我參考放在成員中或 '&lt;ctor-expr&gt; then &lt;expr&gt;' 形式的尾端運算式內。</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>對所定義物件的遞迴參考，將在執行階段透過使用延遲參考來檢查初始化是否正確。請考慮將自我參考放在建構順序中最後一個 'let' 繫結後的 'do' 陳述式內。</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>符號 ':&gt;'</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>這個建構函式是套用到 {0} 個引數，但必須是 {1} 個</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>關鍵字 'function'</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>這個建構已被取代: {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>指示詞</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>這個類型是 'abstract'，因為尚未針對一些抽象成員指定實作。如果這是有意的作法，請將 '[&lt;AbstractClass&gt;]' 屬性加入您的類型。</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value> 在 FSharp.PowerPack.dll 中找到這個名稱的建構，它包含部分舊版 F# 中隱含參考的一些模組和類型。您可能必須加入這個 DLL 的明確參考，才能編譯這個程式碼。</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>未預期的 {0}</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>yield!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>yield</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>符號 '?'</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>引號符號</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>從實值類型 \n    {0}    \n到類型 \n    {1}    \n的強制型轉將涉及 Boxing。請考慮改用 'box'</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>識別項</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>關鍵字 'while'</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>關鍵字 'match'</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>符號 '-'</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>關鍵字 'with'</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>關鍵字 'then'</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>關鍵字 'else'</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>符號 ':'</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>符號 ','</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>關鍵字 'const'</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>關鍵字 'class'</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>關鍵字 'begin'</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>浮點常值</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>關鍵字 'fixed'</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>關鍵字 'false'</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>在這一點或之前有結構不完整的建構</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>模組 '{0}' 需要 {1} '{2}'</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> 在外部宣告中</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> 在類型中</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> 在運算式中</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> 在聯集中</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>位元組陣列常值</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> 將評估 '{0}'</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>這個規則絕不會比對到</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>模組 '{0}' 包含\n    {1}    \n但它的簽章卻指定\n    {2}    \n{3}。</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\n可能的最佳多載: '{0}'。</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>符號 '[|'</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>元組有 {0} 和 {1} 兩個不同長度</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>關鍵字 'type'</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>關鍵字 'true'</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>符號 '*'</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value>符號 #</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>關鍵字 'when'</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>關鍵字 'with'</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>關鍵字 'void'</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>符號 '&lt;'</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>關鍵字 'lazy'</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>關鍵字 'open'</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>關鍵字 'fun'</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>關鍵字 'let' 或 'use'</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>關鍵字 'null'</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>關鍵字 'elif'</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>關鍵字 'done'</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>字元常值</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>關鍵字 'base'</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>找不到組件參考 '{0}'，或者無效</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>語法錯誤</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>欄位 '{0}' 和 '{1}' 來自不同類型</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> 在類型名稱中</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>符號 '&amp;&amp;'</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>{1} 中的 InternalsVisibleTo 屬性有無效的組件名稱 '{0}'</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>InternalsVisibleTo 屬性中有無效的組件名稱 '{0}' (無法取得組件檔名)</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>這個函式接受太多引數，或是用在不需要函式的內容中</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>將隱含捨棄此等號比較運算式的結果。請考慮使用 'let' 將結果繫結至名稱，例如 'let result = expression'。若您要變動值，則使用 '&lt;-' 運算子，例如 '{0} &lt;- expression'。</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>根據這個程式點之前的資訊，從類型\n    {0}    \n到 \n    {1}    \n的靜態強制型轉涉及不定的類型。不允許在某些類型上執行靜態強制型轉。需要進一步的類型註釋。</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>使用這個建構可能導致產生無法驗證的 .NET IL 程式碼。使用 '--nowarn:9' 或 '#nowarn "9"' 可以停用這個警告。</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> 在定義中</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>符號 ';'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>中置運算子</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> 在物件運算式中</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>符號 '&gt;}'</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>符號 '&gt;]'</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>關鍵字 'exception'</value>
  </data>
</root>