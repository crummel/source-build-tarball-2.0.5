<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Parser.TOKEN.BAR.BAR" xml:space="preserve">
    <value>シンボル '||'</value>
  </data>
  <data name="NONTERM.Category.ImplementationFile" xml:space="preserve">
    <value> 実装ファイル内</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot1" xml:space="preserve">
    <value>名前と引数の数だけに基づいて、メンバー '{0}' を一意の抽象スロットに対応付けることができません</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot2" xml:space="preserve">
    <value>。実装された複数のインターフェイスに、この名前と引数の数を持つメンバーがあります</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot3" xml:space="preserve">
    <value>。インターフェイス '{0}' と '{1}' を明示的に実装してください。</value>
  </data>
  <data name="NonUniqueInferredAbstractSlot4" xml:space="preserve">
    <value>。場合によっては、関連するオーバーライドを示すために追加の型の参照が必要です。この警告を無効にするには、'#nowarn "70"' または '--nowarn:70' を使用してください。</value>
  </data>
  <data name="Parser.TOKEN.LEX.FAILURE" xml:space="preserve">
    <value>lex エラー</value>
  </data>
  <data name="Parser.TOKEN.LPAREN.STAR.RPAREN" xml:space="preserve">
    <value>シンボル '(*)'</value>
  </data>
  <data name="NONTERM.anonLambdaExpr" xml:space="preserve">
    <value> ラムダ式内</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.PAREN.APP" xml:space="preserve">
    <value>シンボル '('</value>
  </data>
  <data name="Parser.TOKEN.CONSTRUCTOR" xml:space="preserve">
    <value>キーワード 'constructor'</value>
  </data>
  <data name="NONTERM.attributeList" xml:space="preserve">
    <value> 属性リスト内</value>
  </data>
  <data name="ValNotMutable" xml:space="preserve">
    <value>この値は変更可能ではありません。変更可能なキーワードを使用することを検討してください。例: 'let mutable {0} = expression'。</value>
  </data>
  <data name="ReservedKeyword" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.PREFIX.OP" xml:space="preserve">
    <value>プレフィックス演算子</value>
  </data>
  <data name="UpcastUnnecessary" xml:space="preserve">
    <value>この upcast は不要です。型は同一です。</value>
  </data>
  <data name="UnitTypeExpectedWithEquality" xml:space="preserve">
    <value>この等式の結果は暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。</value>
  </data>
  <data name="VarBoundTwice" xml:space="preserve">
    <value>このパターンで '{0}' が 2 回バインドされています</value>
  </data>
  <data name="UpperCaseIdentifierInPattern" xml:space="preserve">
    <value>通常、大文字の変数識別子はパターンに使用しません。また、つづりが間違っているパターン名を示す可能性があります。</value>
  </data>
  <data name="NONTERM.unionCaseRepr" xml:space="preserve">
    <value> 判別された共用体ケースの宣言内</value>
  </data>
  <data name="Parser.TOKEN.TO" xml:space="preserve">
    <value>キーワード 'to'</value>
  </data>
  <data name="Parser.TOKEN.IF" xml:space="preserve">
    <value>キーワード 'if'</value>
  </data>
  <data name="Parser.TOKEN.IN" xml:space="preserve">
    <value>キーワード 'in'</value>
  </data>
  <data name="Parser.TOKEN.AS" xml:space="preserve">
    <value>キーワード 'as'</value>
  </data>
  <data name="Parser.TOKEN.OR" xml:space="preserve">
    <value>キーワード 'or'</value>
  </data>
  <data name="Parser.TOKEN.OF" xml:space="preserve">
    <value>キーワード 'of'</value>
  </data>
  <data name="Parser.TOKEN.DO" xml:space="preserve">
    <value>キーワード 'do'</value>
  </data>
  <data name="UnitTypeExpected" xml:space="preserve">
    <value>この式の結果は暗黙に無視されます。'expr |&gt; ignore' のように 'ignore' を使用してこの値を明示的に破棄するか、'let result = expr' のように 'let' を使用して結果を名前にバインドすることをご考慮ください。</value>
  </data>
  <data name="Parser.TOKEN.INTERFACE" xml:space="preserve">
    <value>キーワード 'interface'</value>
  </data>
  <data name="NONTERM.fileModuleSpec" xml:space="preserve">
    <value> モジュールまたは名前空間のシグネチャ内</value>
  </data>
  <data name="HashIncludeNotAllowedInNonScript" xml:space="preserve">
    <value>#I ディレクティブを使用できるのは F# スクリプト ファイル (拡張子は .fsx または .fsscript) のみです。このコードをスクリプト ファイルに移動するか、この参照に '-I' コンパイラー オプションを追加するか、ディレクティブを '#if INTERACTIVE'/'#endif' で区切ってください。</value>
  </data>
  <data name="Parser.TOKEN.CONSTRAINT" xml:space="preserve">
    <value>キーワード 'constraint'</value>
  </data>
  <data name="MSBuildReferenceResolutionError" xml:space="preserve">
    <value>{0} (Code={1})</value>
  </data>
  <data name="NONTERM.classDefnMember" xml:space="preserve">
    <value> メンバー定義内</value>
  </data>
  <data name="Parser.TOKEN.FINALLY" xml:space="preserve">
    <value>キーワード 'finally'</value>
  </data>
  <data name="NONTERM.exconCore" xml:space="preserve">
    <value> 例外の定義内</value>
  </data>
  <data name="TokenName1TokenName2TokenName3" xml:space="preserve">
    <value>。{0}、{1}、{2}、または他のトークンを指定してください。</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK" xml:space="preserve">
    <value>シンボル ':?'</value>
  </data>
  <data name="InterfaceNotRevealed" xml:space="preserve">
    <value>この型はインターフェイス '{0}' を実装していますが、シグネチャでは公開されていません。シグネチャにこのインターフェイスを列挙してください。動的な型のキャストやリフレクションによってインターフェイスを検出できるようになります。</value>
  </data>
  <data name="Parser.TOKEN.PUBLIC" xml:space="preserve">
    <value>キーワード 'public'</value>
  </data>
  <data name="Parser.TOKEN.COLON.COLON" xml:space="preserve">
    <value>シンボル '::'</value>
  </data>
  <data name="SeeAlso" xml:space="preserve">
    <value>。{0} も参照してください。</value>
  </data>
  <data name="Parser.TOKEN.LINE.COMMENT" xml:space="preserve">
    <value>行コメント</value>
  </data>
  <data name="VirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>含まれる型は、引数がない共用体ケースの表現値として 'null' を使用できます。null 値で抽象メンバー、仮想メンバー、またはインターフェイスの実装を呼び出すと、例外が発生します。必要に応じて、引数がないコンストラクターにダミーのデータ値を追加して、この型の表現として 'null' が使用されないようにしてください。</value>
  </data>
  <data name="Parser.TOKEN.UPCAST" xml:space="preserve">
    <value>キーワード 'upcast'</value>
  </data>
  <data name="Parser.TOKEN.OVERRIDE" xml:space="preserve">
    <value>キーワード 'override'</value>
  </data>
  <data name="MatchIncomplete1" xml:space="preserve">
    <value>この式のパターン マッチが不完全です</value>
  </data>
  <data name="MatchIncomplete2" xml:space="preserve">
    <value> たとえば、値 '{0}' はパターンに含まれないケースを示す可能性があります。</value>
  </data>
  <data name="MatchIncomplete3" xml:space="preserve">
    <value> たとえば、値 '{0}' はパターンに含まれないケースを示す可能性があります。ただし、'when' 句を含むパターン規則であれば、この値に一致する場合もあります。</value>
  </data>
  <data name="MatchIncomplete4" xml:space="preserve">
    <value> 一致しない要素は無視されます。</value>
  </data>
  <data name="BadEventTransformation" xml:space="preserve">
    <value>.NET イベントとしてコンパイルされる定義の形式に誤りがあります。.NET イベントとしてコンパイルできるのはプロパティ メンバーのみです。</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AT.HAT.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="NONTERM.ifExprCases" xml:space="preserve">
    <value> if/then/else 式内</value>
  </data>
  <data name="Parser.TOKEN.STRING" xml:space="preserve">
    <value>文字列リテラル</value>
  </data>
  <data name="Parser.TOKEN.STRUCT" xml:space="preserve">
    <value>キーワード 'struct'</value>
  </data>
  <data name="Parser.TOKEN.STATIC" xml:space="preserve">
    <value>キーワード 'static'</value>
  </data>
  <data name="Parser.TOKEN.RBRACK" xml:space="preserve">
    <value>シンボル ']'</value>
  </data>
  <data name="Parser.TOKEN.RBRACE" xml:space="preserve">
    <value>シンボル '}'</value>
  </data>
  <data name="Parser.TOKEN.RARROW" xml:space="preserve">
    <value>シンボル '-&gt;'</value>
  </data>
  <data name="Parser.TOKEN.RPAREN" xml:space="preserve">
    <value>シンボル ')'</value>
  </data>
  <data name="Parser.TOKEN.RQUOTE" xml:space="preserve">
    <value>引用の終わり</value>
  </data>
  <data name="UnresolvedReferenceNoRange" xml:space="preserve">
    <value>必要なアセンブリ参照が見つかりません。アセンブリ '{0}' に参照を追加してください。</value>
  </data>
  <data name="IntfImplInExtrinsicAugmentation" xml:space="preserve">
    <value>インターフェイスの実装は、型の最初の宣言で指定してください。</value>
  </data>
  <data name="Parser.TOKEN.INLINE" xml:space="preserve">
    <value>キーワード 'inline'</value>
  </data>
  <data name="LetRecCheckedAtRuntime" xml:space="preserve">
    <value>定義されるオブジェクトに対するこの再帰参照および他の再帰参照は、遅延参照を使用して、実行時に初期化の正常性がチェックされます。これは、再帰関数ではなく、1 つまたは複数の再帰オブジェクトを定義しているためです。この警告を抑制するには、'#nowarn "40"' または '--nowarn:40' を使用してください。</value>
  </data>
  <data name="Parser.TOKEN.COLON.QMARK.GREATER" xml:space="preserve">
    <value>シンボル ':?&gt;'</value>
  </data>
  <data name="PossibleOverload" xml:space="preserve">
    <value>使用できるオーバーロードは '{0}' です。{1}。</value>
  </data>
  <data name="FieldNotMutable" xml:space="preserve">
    <value>このフィールドは変更可能ではありません</value>
  </data>
  <data name="Parser.TOKEN.MEMBER" xml:space="preserve">
    <value>キーワード 'member'</value>
  </data>
  <data name="Parser.TOKEN.MODULE" xml:space="preserve">
    <value>キーワード 'module'</value>
  </data>
  <data name="NONTERM.valSpfn" xml:space="preserve">
    <value> 値のシグネチャ内</value>
  </data>
  <data name="Parser.TOKEN.LPAREN" xml:space="preserve">
    <value>シンボル '('</value>
  </data>
  <data name="Parser.TOKEN.LQUOTE" xml:space="preserve">
    <value>引用の開始</value>
  </data>
  <data name="Parser.TOKEN.INFIX.COMPARE.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="Parser.TOKEN.LARROW" xml:space="preserve">
    <value>シンボル '&lt;-'</value>
  </data>
  <data name="Parser.TOKEN.DOWNCAST" xml:space="preserve">
    <value>キーワード 'downcast'</value>
  </data>
  <data name="Parser.TOKEN.LBRACE" xml:space="preserve">
    <value>シンボル '{'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK" xml:space="preserve">
    <value>シンボル '['</value>
  </data>
  <data name="ValNotLocal" xml:space="preserve">
    <value>この値はローカルではありません</value>
  </data>
  <data name="IndeterminateRuntimeCoercion" xml:space="preserve">
    <value>この型\n    {0}    \nから型\n    {1}    \nへのランタイム型変換またはランタイム型テストには、このプログラムの場所の前方にある情報に基づく不確定の型が使用されています。ランタイム型テストが許可されていない型もあります。型の注釈を増やしてください。</value>
  </data>
  <data name="Parser.TOKEN.BAR.RBRACK" xml:space="preserve">
    <value>シンボル '|]'</value>
  </data>
  <data name="ConstraintSolverMissingConstraint" xml:space="preserve">
    <value>型パラメーターに制約 '{0}' がありません</value>
  </data>
  <data name="FixKeyword" xml:space="preserve">
    <value>キーワード </value>
  </data>
  <data name="NONTERM.Category.Pattern" xml:space="preserve">
    <value> パターン内</value>
  </data>
  <data name="Parser.TOKEN.ASSERT" xml:space="preserve">
    <value>キーワード 'assert'</value>
  </data>
  <data name="NONTERM.typeArgsActual" xml:space="preserve">
    <value> 型引数内</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignment" xml:space="preserve">
    <value>この等式の結果は暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。値を変換する場合は、値 'mutable' をマークして、'&lt;-' 演算子を使用します。例: '{0} &lt;- expression'。</value>
  </data>
  <data name="Parser.TOKEN.ORESET" xml:space="preserve">
    <value>入力の終わり</value>
  </data>
  <data name="TyconBadArgs" xml:space="preserve">
    <value>型 '{0}' には {1} 個の型引数が必要ですが、指定されたのは {2} 個です</value>
  </data>
  <data name="Parser.TOKEN.ODUMMY" xml:space="preserve">
    <value>内部ダミー トークン</value>
  </data>
  <data name="ErrorFromApplyingDefault1" xml:space="preserve">
    <value>既定の型 '{0}' を型推論の変数に適用するときに、型の制約が一致しませんでした。</value>
  </data>
  <data name="ErrorFromApplyingDefault2" xml:space="preserve">
    <value> 型の制約を増やしてください</value>
  </data>
  <data name="Parser.TOKEN.DELEGATE" xml:space="preserve">
    <value>キーワード 'delegate'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.DIV.MOD.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="Parser.TOKEN.EXTERN" xml:space="preserve">
    <value>キーワード 'extern'</value>
  </data>
  <data name="Parser.TOKEN.EQUALS" xml:space="preserve">
    <value>シンボル '='</value>
  </data>
  <data name="Parser.TOKEN.DOT.DOT" xml:space="preserve">
    <value>シンボル '..'</value>
  </data>
  <data name="Parser.TOKEN.DOWNTO" xml:space="preserve">
    <value>キーワード 'downto'</value>
  </data>
  <data name="Parser.TOKEN.DOLLAR" xml:space="preserve">
    <value>シンボル '$'</value>
  </data>
  <data name="InvalidRuntimeCoercion" xml:space="preserve">
    <value>型 {0} から型 {1} への無効なランタイム型変換または型テストです\n{2}</value>
  </data>
  <data name="ErrorFromAddingTypeEquation2" xml:space="preserve">
    <value>型が一致しません。\n    '{0}'    \nという指定が必要ですが、\n    '{1}'    {2}\nが指定されました。</value>
  </data>
  <data name="ErrorFromAddingTypeEquation1" xml:space="preserve">
    <value>この式に必要な型は\n    '{1}'    \nですが、ここでは次の型が指定されています\n    '{0}'    {2}</value>
  </data>
  <data name="Parser.TOKEN.BINDER" xml:space="preserve">
    <value>バインダー キーワード</value>
  </data>
  <data name="NONTERM.interaction" xml:space="preserve">
    <value> 相互作用内</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKBEGIN" xml:space="preserve">
    <value>構造化コンストラクトの開始</value>
  </data>
  <data name="Parser.TOKEN.INFIX.STAR.STAR.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="IntfImplInIntrinsicAugmentation" xml:space="preserve">
    <value>拡張内のインターフェイスの実装は使用されなくなりました。インターフェイスの実装は、型の最初の宣言で指定してください。</value>
  </data>
  <data name="TypeTestUnnecessary" xml:space="preserve">
    <value>この型テストまたはダウンキャストは常に維持されます</value>
  </data>
  <data name="OverrideDoesntOverride2" xml:space="preserve">
    <value>メンバー '{0}' には、対応する抽象メソッドをオーバーライドする正しい型がありません</value>
  </data>
  <data name="OverrideDoesntOverride3" xml:space="preserve">
    <value> 必要なシグネチャは '{0}' です。</value>
  </data>
  <data name="OverrideDoesntOverride1" xml:space="preserve">
    <value>メンバー '{0}' には、指定した仮想メソッドをオーバーライドする正しい型がありません</value>
  </data>
  <data name="OverrideDoesntOverride4" xml:space="preserve">
    <value>メンバー '{0}' は 'unit' で特定されますが、'unit' は、戻り値の型に関してパラメーター化された抽象メソッドの戻り値の型としては使用できません。</value>
  </data>
  <data name="NONTERM.hashDirective" xml:space="preserve">
    <value> ディレクティブ内</value>
  </data>
  <data name="Parser.TOKEN.GLOBAL" xml:space="preserve">
    <value>キーワード 'global'</value>
  </data>
  <data name="NONTERM.classMemberSpfn" xml:space="preserve">
    <value> メンバーのシグネチャ内</value>
  </data>
  <data name="Parser.TOKEN.ADJACENT.PREFIX.OP" xml:space="preserve">
    <value>プレフィックス演算子</value>
  </data>
  <data name="Parser.TOKEN.OFUNCTION" xml:space="preserve">
    <value>キーワード 'function'</value>
  </data>
  <data name="NONTERM.hardwhiteLetBindings" xml:space="preserve">
    <value> 束縛内</value>
  </data>
  <data name="TokenName1" xml:space="preserve">
    <value>。{0} または他のトークンを指定してください。</value>
  </data>
  <data name="Parser.TOKEN.OINTERFACE.MEMBER" xml:space="preserve">
    <value>キーワード 'interface'</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON.SEMICOLON" xml:space="preserve">
    <value>シンボル ';;'</value>
  </data>
  <data name="FixReplace" xml:space="preserve">
    <value> (インデント対応構文のため)</value>
  </data>
  <data name="LetRecEvaluatedOutOfOrder" xml:space="preserve">
    <value>この前方参照があるため、束縛が順序どおりに実行されない可能性があります。</value>
  </data>
  <data name="FixSymbol" xml:space="preserve">
    <value>シンボル </value>
  </data>
  <data name="Parser.TOKEN.DECIMAL" xml:space="preserve">
    <value>10 進リテラル</value>
  </data>
  <data name="Obsolete1" xml:space="preserve">
    <value>このコンストラクトは使用されなくなりました</value>
  </data>
  <data name="Obsolete2" xml:space="preserve">
    <value>。{0}</value>
  </data>
  <data name="Parser.TOKEN.DEFAULT" xml:space="preserve">
    <value>キーワード 'default'</value>
  </data>
  <data name="NONTERM.recdExpr" xml:space="preserve">
    <value> レコード式内</value>
  </data>
  <data name="IndeterminateType" xml:space="preserve">
    <value>このプログラムの場所の前方にある情報に基づく不確定の型のオブジェクトに対する参照です。場合によっては、オブジェクトの型を制約する型の注釈がこのプログラムの場所の前に必要です。この操作で参照が解決される可能性があります。</value>
  </data>
  <data name="DeprecatedThreadStaticBindingWarning" xml:space="preserve">
    <value>thread-static および context-static の 'let' 束縛は使用されなくなりました。代わりに、クラスには 'static val mutable &lt;ident&gt; : &lt;type&gt;' という形式の宣言を使用してください。また、この宣言に 'DefaultValue' 属性を追加し、新しいスレッドごとに値が既定値に初期化されることを示してください。</value>
  </data>
  <data name="TargetInvocationExceptionWrapper" xml:space="preserve">
    <value>内部エラー: {0}</value>
  </data>
  <data name="NONTERM.typeConstraint" xml:space="preserve">
    <value> 型制約内</value>
  </data>
  <data name="Parser.TOKEN.FUNKY.OPERATOR.NAME" xml:space="preserve">
    <value>演算子名</value>
  </data>
  <data name="UnresolvedPathReferenceNoRange" xml:space="preserve">
    <value>'{0}' によって参照される型が、参照されていないアセンブリで定義されています。アセンブリ '{1}' への参照を追加してください。</value>
  </data>
  <data name="Experimental" xml:space="preserve">
    <value>{0}。この警告を無効にするには、'--nowarn:57' または '#nowarn "57"' を使用します。</value>
  </data>
  <data name="Failure4" xml:space="preserve">
    <value>内部エラー: {0}</value>
  </data>
  <data name="Failure1" xml:space="preserve">
    <value>解析エラー</value>
  </data>
  <data name="Failure3" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Failure2" xml:space="preserve">
    <value>解析エラー: 予期しないファイルの終わりです</value>
  </data>
  <data name="HashLoadedScriptConsideredSource" xml:space="preserve">
    <value>読み込むことができるファイルは F# ソース ファイル (拡張子は .fs) のみです。この F# スクリプト ファイル (.fsx または .fsscript) は F# ソース ファイルとして扱われます。</value>
  </data>
  <data name="ConstraintSolverInfiniteTypes" xml:space="preserve">
    <value>型 '{0}' と型 '{1}' は統合できません。</value>
  </data>
  <data name="NameClash2" xml:space="preserve">
    <value>名前 '{2}' がこの型またはモジュールの {3} '{4}' と競合するため、{0} '{1}' を定義できません</value>
  </data>
  <data name="NameClash1" xml:space="preserve">
    <value>{0} '{1}' の定義が重複しています</value>
  </data>
  <data name="NONTERM.openDecl" xml:space="preserve">
    <value> open 宣言内</value>
  </data>
  <data name="LetRecUnsound1" xml:space="preserve">
    <value>値 '{0}' はその定義の一部として評価されます</value>
  </data>
  <data name="LetRecUnsound2" xml:space="preserve">
    <value>最終的に、この値はその定義の一部として評価されます。必要に応じて、値を 'lazy' にするか、関数にしてください。値 '{0}'{1}。</value>
  </data>
  <data name="Parser.TOKEN.KEYWORD_STRING" xml:space="preserve">
    <value>コンパイラーで生成されたリテラル</value>
  </data>
  <data name="MissingFields" xml:space="preserve">
    <value>次のフィールドには値が必要です: {0}</value>
  </data>
  <data name="Parser.TOKEN.INACTIVECODE" xml:space="preserve">
    <value>非アクティブ コード</value>
  </data>
  <data name="ConstraintSolverTypesNotInSubsumptionRelation" xml:space="preserve">
    <value>型 '{0}' は型 '{1}'{2} と互換性がありません</value>
  </data>
  <data name="Parser.TOKEN.ABSTRACT" xml:space="preserve">
    <value>キーワード 'abstract'</value>
  </data>
  <data name="Parser.TOKEN.NAMESPACE" xml:space="preserve">
    <value>キーワード 'namespace'</value>
  </data>
  <data name="Parser.TOKEN.OBLOCKEND" xml:space="preserve">
    <value>このポイントまたはその前にある構造化コンストラクトが不完全です</value>
  </data>
  <data name="UnitTypeExpectedWithPossiblePropertySetter" xml:space="preserve">
    <value>この等式の結果は暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。値をプロパティに設定する場合は、'&lt;-' 演算子を使用します。例: '{0}.{1} &lt;- expression'。</value>
  </data>
  <data name="TokenName1TokenName2" xml:space="preserve">
    <value>。{0}、{1}、または他のトークンを指定してください。</value>
  </data>
  <data name="Parser.TOKEN.QMARK.QMARK" xml:space="preserve">
    <value>シンボル '??'</value>
  </data>
  <data name="NotUpperCaseConstructor" xml:space="preserve">
    <value>判別された共用体ケースと例外のラベルは、大文字の識別子にする必要があります</value>
  </data>
  <data name="UnionPatternsBindDifferentNames" xml:space="preserve">
    <value>この 'or' パターンの両側は、異なる変数セットをバインドしています</value>
  </data>
  <data name="LoadedSourceNotFoundIgnoring" xml:space="preserve">
    <value>ファイル '{0}' が存在しないか、アクセスできないため、ファイルを読み込むことができません</value>
  </data>
  <data name="FunctionValueUnexpected" xml:space="preserve">
    <value>この式は関数値です (つまり、引数が足りません)。型は {0} です。</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.BRACK.APP" xml:space="preserve">
    <value>シンボル '['</value>
  </data>
  <data name="Parser.TOKEN.MUTABLE" xml:space="preserve">
    <value>キーワード 'mutable'</value>
  </data>
  <data name="NONTERM.Category.Definition" xml:space="preserve">
    <value> 定義内</value>
  </data>
  <data name="Parser.TOKEN.GREATER.BAR.RBRACK" xml:space="preserve">
    <value>シンボル '&gt;|]'</value>
  </data>
  <data name="IndentationProblem" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.WHITESPACE" xml:space="preserve">
    <value>スペース</value>
  </data>
  <data name="Parser.TOKEN.PRIVATE" xml:space="preserve">
    <value>キーワード 'private'</value>
  </data>
  <data name="HashReferenceNotAllowedInNonScript" xml:space="preserve">
    <value>#r ディレクティブは F# スクリプト ファイル (拡張子は .fsx または .fsscript) 内でのみ使用できます。このコードをスクリプト ファイルに移動するか、この参照を '-r' コンパイラ オプションに置き換えてください。このディレクティブがユーザー入力として実行されている場合は、'#if INTERACTIVE'/'#endif' でディレクティブを区切ることができます。</value>
  </data>
  <data name="Parser.TOKEN.STRING.TEXT" xml:space="preserve">
    <value>文字列テキスト</value>
  </data>
  <data name="Parser.TOKEN.INT32.DOT.DOT" xml:space="preserve">
    <value>整数..</value>
  </data>
  <data name="NONTERM.fieldDecl" xml:space="preserve">
    <value> フィールドの宣言内</value>
  </data>
  <data name="Recursion" xml:space="preserve">
    <value>関数 '{0}' の使用方法は、推論される型のいずれとも一致しません。この関数の推論される型は次のとおりです。\n    {1}    \nこの使用時点で必要な関数の型は次のとおりです。\n    {2}    {3}\nこのエラーの原因は、'let rec' コレクション内、またはクラスのグループ内のジェネリック再帰に関連する制限の可能性があります。引数と戻り値の型の両方に型の注釈を指定するなど、再帰呼び出しのターゲットに完全な型のシグネチャを指定してください。</value>
  </data>
  <data name="CoercionTargetSealed" xml:space="preserve">
    <value>型 '{0}' には適切なサブタイプが含まれないため、この型は必ずしも静的型変換のターゲットとして使用されません</value>
  </data>
  <data name="NONTERM.beginEndExpr" xml:space="preserve">
    <value> begin/end 式内</value>
  </data>
  <data name="Parser.TOKEN.LBRACE.LESS" xml:space="preserve">
    <value>シンボル '{&lt;'</value>
  </data>
  <data name="Parser.TOKEN.COLON.EQUALS" xml:space="preserve">
    <value>シンボル ':='</value>
  </data>
  <data name="Parser.TOKEN.INHERIT" xml:space="preserve">
    <value>キーワード 'inherit'</value>
  </data>
  <data name="Parser.TOKEN.TRY" xml:space="preserve">
    <value>キーワード 'try'</value>
  </data>
  <data name="Parser.TOKEN.SIG" xml:space="preserve">
    <value>キーワード 'sig'</value>
  </data>
  <data name="Parser.TOKEN.REC" xml:space="preserve">
    <value>キーワード 'rec'</value>
  </data>
  <data name="Parser.TOKEN.INT" xml:space="preserve">
    <value>整数リテラル</value>
  </data>
  <data name="Parser.TOKEN.VAL" xml:space="preserve">
    <value>キーワード 'val'</value>
  </data>
  <data name="Parser.TOKEN.ASR" xml:space="preserve">
    <value>キーワード 'asr'</value>
  </data>
  <data name="Parser.TOKEN.AND" xml:space="preserve">
    <value>キーワード 'and'</value>
  </data>
  <data name="Parser.TOKEN.AMP" xml:space="preserve">
    <value>シンボル '&amp;'</value>
  </data>
  <data name="Parser.TOKEN.ODO" xml:space="preserve">
    <value>キーワード 'do'</value>
  </data>
  <data name="Parser.TOKEN.NEW" xml:space="preserve">
    <value>キーワード 'new'</value>
  </data>
  <data name="Parser.TOKEN.END" xml:space="preserve">
    <value>キーワード 'end'</value>
  </data>
  <data name="Parser.TOKEN.EOF" xml:space="preserve">
    <value>入力の終わり</value>
  </data>
  <data name="Parser.TOKEN.DOT" xml:space="preserve">
    <value>シンボル '.'</value>
  </data>
  <data name="Parser.TOKEN.BAR" xml:space="preserve">
    <value>シンボル '|'</value>
  </data>
  <data name="Parser.TOKEN.FUN" xml:space="preserve">
    <value>キーワード 'fun'</value>
  </data>
  <data name="Parser.TOKEN.FOR" xml:space="preserve">
    <value>キーワード 'for'</value>
  </data>
  <data name="NonRigidTypar1" xml:space="preserve">
    <value>このコンストラクトによって、コードの総称性は型の注釈よりも低くなります。'{0}' またはその付近にある '#'、'_'、または他の型の注釈を使用して示された型変数は、型 '{1}' に制約されました。</value>
  </data>
  <data name="NonRigidTypar3" xml:space="preserve">
    <value>このコンストラクトによって、コードの総称性は型の注釈よりも低くなります。型変数 '{0}' は型 '{1}' に制約されました。</value>
  </data>
  <data name="NonRigidTypar2" xml:space="preserve">
    <value>このコンストラクトによって、コードの総称性は型の注釈よりも低くなります。単位変数 '{0}' は単位 '{1}' に制約されました。</value>
  </data>
  <data name="Parser.TOKEN.COMMENT" xml:space="preserve">
    <value>コメント</value>
  </data>
  <data name="OverrideInIntrinsicAugmentation" xml:space="preserve">
    <value>拡張内のオーバーライドの実装は使用されなくなりました。オーバーライドの実装は、型の最初の宣言の一部として指定してください。</value>
  </data>
  <data name="Parser.TOKEN.PLUS.MINUS.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="RecursiveUseCheckedAtRuntime" xml:space="preserve">
    <value>この再帰的な用法は、実行時に初期化の正常性がチェックされます。通常、この警告は害がないため、'#nowarn "21"' または '--nowarn:21' を使用して抑制することができます。</value>
  </data>
  <data name="OverrideInExtrinsicAugmentation" xml:space="preserve">
    <value>オーバーライドの実装は、型の最初の宣言の一部として指定してください。</value>
  </data>
  <data name="NonVirtualAugmentationOnNullValuedType" xml:space="preserve">
    <value>含まれる型は、引数がない共用体ケースの表現値として 'null' を使用できます。このメンバーは静的メンバーとしてコンパイルされます。</value>
  </data>
  <data name="ErrorsFromAddingSubsumptionConstraint" xml:space="preserve">
    <value>型の制約が一致しません。次の型\n    '{0}'    \nは次の型と互換性がありません\n    '{1}'    {2}\n</value>
  </data>
  <data name="FileNameNotResolved" xml:space="preserve">
    <value>次の中からファイル '{0}' が見つかりませんでした\n {1}</value>
  </data>
  <data name="Parser.TOKEN.HIGH.PRECEDENCE.TYAPP" xml:space="preserve">
    <value>型応用 </value>
  </data>
  <data name="HashDirectiveNotAllowedInNonScript" xml:space="preserve">
    <value>このディレクティブを使用できるのは F# スクリプト ファイル (拡張子は .fsx または .fsscript) のみです。ディレクティブを削除するか、このコードをスクリプト ファイルに移動するか、ディレクティブを '#if INTERACTIVE'/'#endif' で区切ってください。</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation2" xml:space="preserve">
    <value>型 '{0}' は型 '{1}' と一致しません</value>
  </data>
  <data name="ConstraintSolverTypesNotInEqualityRelation1" xml:space="preserve">
    <value>測定単位 '{0}' は測定単位 '{1}' と一致しません</value>
  </data>
  <data name="Parser.TOKEN.INTERNAL" xml:space="preserve">
    <value>キーワード 'internal'</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.LESS" xml:space="preserve">
    <value>シンボル '[&lt;'</value>
  </data>
  <data name="Parser.TOKEN.GREATER" xml:space="preserve">
    <value>シンボル '&gt;'</value>
  </data>
  <data name="LibraryUseOnly" xml:space="preserve">
    <value>このコンストラクトは使用されなくなりました。これは F# ライブラリでのみ使用されます。</value>
  </data>
  <data name="ValueRestriction2" xml:space="preserve">
    <value>値の制限。値 '{0}' は次のジェネリック型です。\n    {1}    \n明示的な引数を使用して '{2}' を関数にするか、ジェネリックにする意図がない場合は型の注釈を追加してください。</value>
  </data>
  <data name="ValueRestriction3" xml:space="preserve">
    <value>値の制限。このメンバーは次のジェネリック型を持つと推論されました。\n    {0}    \nコンストラクターとプロパティの get アクセス操作子/set アクセス操作子は、それを囲む型よりも総称性を高くすることができません。関係する正確な型を示すために、型の注釈を追加してください。</value>
  </data>
  <data name="ValueRestriction1" xml:space="preserve">
    <value>値の制限。値 '{0}' は次のジェネリック型です。\n    {1}    \n明示的に引数を '{2}' にするか、ジェネリックにする意図がない場合は型の注釈を追加してください。</value>
  </data>
  <data name="ValueRestriction4" xml:space="preserve">
    <value>値の制限。値 '{0}' は次のジェネリック型を持つと推論されました。\n    {1}    \n明示的に引数を '{2}' にするか、ジェネリックにする意図がない場合は型の注釈を追加してください。</value>
  </data>
  <data name="ValueRestriction5" xml:space="preserve">
    <value>値の制限。値 '{0}' は次のジェネリック型を持つと推論されました。\n    {1}    \n単純なデータ用語として '{2}' を定義するか、明示的な引数を使用して関数にするか、ジェネリックにする意図がない場合は型の注釈を追加してください。</value>
  </data>
  <data name="NONTERM.patternClauses" xml:space="preserve">
    <value> パターン マッチ内</value>
  </data>
  <data name="UnexpectedEndOfInput" xml:space="preserve">
    <value>予期しない入力の終わりです:</value>
  </data>
  <data name="NONTERM.tyconDefn" xml:space="preserve">
    <value> 型定義内</value>
  </data>
  <data name="NONTERM.tyconSpfn" xml:space="preserve">
    <value> 型のシグネチャ内</value>
  </data>
  <data name="NONTERM.Category.SignatureFile" xml:space="preserve">
    <value> シグネチャ ファイル内</value>
  </data>
  <data name="NONTERM.quoteExpr" xml:space="preserve">
    <value> 引用リテラル内</value>
  </data>
  <data name="HashLoadedSourceHasIssues1" xml:space="preserve">
    <value>読み込まれたファイルに 1 つまたは複数の警告があります。\n</value>
  </data>
  <data name="HashLoadedSourceHasIssues2" xml:space="preserve">
    <value>読み込まれたファイルに 1 つまたは複数のエラーがあります。\n</value>
  </data>
  <data name="BakedInMemberConstraintName" xml:space="preserve">
    <value>'{0}' というメンバーである .NET 型が暗黙的に拡張される場合、このメンバーの制約には F# コンパイラーによって特殊な状態が付与されます。その結果、作成したコードからこのメンバーの制約を呼び出そうとすると、ランタイム エラーが発生します。</value>
  </data>
  <data name="NONTERM.localBinding" xml:space="preserve">
    <value> 束縛内</value>
  </data>
  <data name="Duplicate2" xml:space="preserve">
    <value>{0} '{1}' の定義が重複しています</value>
  </data>
  <data name="Duplicate1" xml:space="preserve">
    <value>'{0}' という 2 つのメンバーが同じシグネチャを使用しています</value>
  </data>
  <data name="Parser.TOKEN.INSTANCE" xml:space="preserve">
    <value>キーワード 'instance'</value>
  </data>
  <data name="UseOfAddressOfOperator" xml:space="preserve">
    <value>ネイティブ ポインターを使用すると、.NET IL コードを検証できなくなる可能性があります</value>
  </data>
  <data name="RuntimeCoercionSourceSealed2" xml:space="preserve">
    <value>型 '{0}' には適切なサブタイプがないため、型テストまたはランタイム型変換のソースとして使用できません。</value>
  </data>
  <data name="RuntimeCoercionSourceSealed1" xml:space="preserve">
    <value>型 '{0}' は型テストまたはランタイム型変換のソースとして使用できません</value>
  </data>
  <data name="Parser.TOKEN.ODO.BANG" xml:space="preserve">
    <value>キーワード 'do!'</value>
  </data>
  <data name="Parser.TOKEN.UNDERSCORE" xml:space="preserve">
    <value>シンボル '_'</value>
  </data>
  <data name="ParameterlessStructCtor" xml:space="preserve">
    <value>構造体の暗黙的なオブジェクト コンストラクターには、少なくとも 1 つの引数が必要です</value>
  </data>
  <data name="Parser.TOKEN.PERCENT.OP" xml:space="preserve">
    <value>シンボル'{0}'</value>
  </data>
  <data name="Parser.TOKEN.RESERVED" xml:space="preserve">
    <value>予約済みのキーワード</value>
  </data>
  <data name="Parser.TOKEN.SPLICE.SYMBOL" xml:space="preserve">
    <value>シンボル 'splice'</value>
  </data>
  <data name="SelfRefObjCtor1" xml:space="preserve">
    <value>定義されるオブジェクトに対する再帰参照は、遅延参照を使用して、実行時に初期化の正常性がチェックされます。メンバー内、または '&lt;ctor-expr&gt; then &lt;expr&gt;' 形式の後続の式内に自己参照を配置してください。</value>
  </data>
  <data name="SelfRefObjCtor2" xml:space="preserve">
    <value>定義されるオブジェクトに対する再帰参照は、遅延参照を使用して、実行時に初期化の正常性がチェックされます。構築シーケンスの最後の 'let' 束縛の後にある 'do' ステートメント内に、自己参照を配置してください。</value>
  </data>
  <data name="Parser.TOKEN.COLON.GREATER" xml:space="preserve">
    <value>シンボル ':&gt;'</value>
  </data>
  <data name="UnionCaseWrongArguments" xml:space="preserve">
    <value>このコンストラクターには {0} 個の引数が適用されていますが、必要なのは {1} 個です</value>
  </data>
  <data name="Parser.TOKEN.FUNCTION" xml:space="preserve">
    <value>キーワード 'function'</value>
  </data>
  <data name="Deprecated" xml:space="preserve">
    <value>このコンストラクトは使用されなくなりました: {0}</value>
  </data>
  <data name="Parser.TOKEN.HASH.ENDIF" xml:space="preserve">
    <value>ディレクティブ</value>
  </data>
  <data name="TypeIsImplicitlyAbstract" xml:space="preserve">
    <value>一部の抽象メンバーが実装されなかったため、この型は 'abstract' です。これが意図的な場合、型に '[&lt;AbstractClass&gt;]' 属性を追加してください。</value>
  </data>
  <data name="UndefinedName2" xml:space="preserve">
    <value> この名前を持つコンストラクトが FSharp.PowerPack.dll に見つかりました。この DLL には、F# の以前のバージョンの一部で暗黙的に参照されていたモジュールおよび型がいくつか含まれます。場合によっては、このコードをコンパイルするために、この DLL への明示的な参照を追加する必要があります。</value>
  </data>
  <data name="Unexpected" xml:space="preserve">
    <value>予期しない {0} です</value>
  </data>
  <data name="Parser.TOKEN.YIELD.BANG" xml:space="preserve">
    <value>yield!</value>
  </data>
  <data name="Parser.TOKEN.YIELD" xml:space="preserve">
    <value>yield</value>
  </data>
  <data name="Parser.TOKEN.QMARK" xml:space="preserve">
    <value>シンボル '?'</value>
  </data>
  <data name="Parser.TOKEN.QUOTE" xml:space="preserve">
    <value>引用シンボル</value>
  </data>
  <data name="StaticCoercionShouldUseBox" xml:space="preserve">
    <value>次の値の型\n    {0}    \nから型\n    {1}    \nへの型変換はボックス化を伴います。代わりに 'box' を使用してください。</value>
  </data>
  <data name="Parser.TOKEN.IDENT" xml:space="preserve">
    <value>識別子</value>
  </data>
  <data name="Parser.TOKEN.WHILE" xml:space="preserve">
    <value>キーワード 'while'</value>
  </data>
  <data name="Parser.TOKEN.MATCH" xml:space="preserve">
    <value>キーワード 'match'</value>
  </data>
  <data name="Parser.TOKEN.MINUS" xml:space="preserve">
    <value>シンボル '-'</value>
  </data>
  <data name="Parser.TOKEN.OWITH" xml:space="preserve">
    <value>キーワード 'with'</value>
  </data>
  <data name="Parser.TOKEN.OTHEN" xml:space="preserve">
    <value>キーワード 'then'</value>
  </data>
  <data name="Parser.TOKEN.OELSE" xml:space="preserve">
    <value>キーワード 'else'</value>
  </data>
  <data name="Parser.TOKEN.COLON" xml:space="preserve">
    <value>シンボル ':'</value>
  </data>
  <data name="Parser.TOKEN.COMMA" xml:space="preserve">
    <value>シンボル ','</value>
  </data>
  <data name="Parser.TOKEN.CONST" xml:space="preserve">
    <value>キーワード 'const'</value>
  </data>
  <data name="Parser.TOKEN.CLASS" xml:space="preserve">
    <value>キーワード 'class'</value>
  </data>
  <data name="Parser.TOKEN.BEGIN" xml:space="preserve">
    <value>キーワード 'begin'</value>
  </data>
  <data name="Parser.TOKEN.FLOAT" xml:space="preserve">
    <value>浮動小数点リテラル</value>
  </data>
  <data name="Parser.TOKEN.FIXED" xml:space="preserve">
    <value>キーワード 'fixed'</value>
  </data>
  <data name="Parser.TOKEN.FALSE" xml:space="preserve">
    <value>キーワード 'false'</value>
  </data>
  <data name="BlockEndSentence" xml:space="preserve">
    <value>この場所またはその前にある構造化コンストラクトが不完全です</value>
  </data>
  <data name="RequiredButNotSpecified" xml:space="preserve">
    <value>モジュール '{0}' には {1} '{2}' が必要です</value>
  </data>
  <data name="NONTERM.cPrototype" xml:space="preserve">
    <value> extern 宣言内</value>
  </data>
  <data name="NONTERM.Category.Type" xml:space="preserve">
    <value> 型内</value>
  </data>
  <data name="NONTERM.Category.Expr" xml:space="preserve">
    <value> 式内</value>
  </data>
  <data name="NONTERM.attrUnionCaseDecl" xml:space="preserve">
    <value> 共用体ケース内</value>
  </data>
  <data name="Parser.TOKEN.BYTEARRAY" xml:space="preserve">
    <value>バイト配列リテラル</value>
  </data>
  <data name="LetRecUnsoundInner" xml:space="preserve">
    <value> は '{0}' を評価します</value>
  </data>
  <data name="RuleNeverMatched" xml:space="preserve">
    <value>この規則には一致しません</value>
  </data>
  <data name="ValueNotContained" xml:space="preserve">
    <value>モジュール '{0}' には\n    {1}    \nが含まれますが、シグネチャには\n    {2}    \nを指定しています。{3}。</value>
  </data>
  <data name="PossibleBestOverload" xml:space="preserve">
    <value>\n\n使用できる中で最適なオーバーロードは '{0}' です。</value>
  </data>
  <data name="Parser.TOKEN.LBRACK.BAR" xml:space="preserve">
    <value>シンボル '[|'</value>
  </data>
  <data name="ConstraintSolverTupleDiffLengths" xml:space="preserve">
    <value>タプルには異なる長さの {0} と {1} があります</value>
  </data>
  <data name="Parser.TOKEN.TYPE" xml:space="preserve">
    <value>キーワード 'type'</value>
  </data>
  <data name="Parser.TOKEN.TRUE" xml:space="preserve">
    <value>キーワード 'true'</value>
  </data>
  <data name="Parser.TOKEN.STAR" xml:space="preserve">
    <value>シンボル '*'</value>
  </data>
  <data name="Parser.TOKEN.HASH" xml:space="preserve">
    <value>シンボル #</value>
  </data>
  <data name="Parser.TOKEN.WHEN" xml:space="preserve">
    <value>キーワード 'when'</value>
  </data>
  <data name="Parser.TOKEN.WITH" xml:space="preserve">
    <value>キーワード 'with'</value>
  </data>
  <data name="Parser.TOKEN.VOID" xml:space="preserve">
    <value>キーワード 'void'</value>
  </data>
  <data name="Parser.TOKEN.LESS" xml:space="preserve">
    <value>シンボル '&lt;'</value>
  </data>
  <data name="Parser.TOKEN.LAZY" xml:space="preserve">
    <value>キーワード 'lazy'</value>
  </data>
  <data name="Parser.TOKEN.OPEN" xml:space="preserve">
    <value>キーワード 'open'</value>
  </data>
  <data name="Parser.TOKEN.OFUN" xml:space="preserve">
    <value>キーワード 'fun'</value>
  </data>
  <data name="Parser.TOKEN.OLET" xml:space="preserve">
    <value>キーワード 'let' または 'use'</value>
  </data>
  <data name="Parser.TOKEN.NULL" xml:space="preserve">
    <value>キーワード 'null'</value>
  </data>
  <data name="Parser.TOKEN.ELIF" xml:space="preserve">
    <value>キーワード 'elif'</value>
  </data>
  <data name="Parser.TOKEN.DONE" xml:space="preserve">
    <value>キーワード 'done'</value>
  </data>
  <data name="Parser.TOKEN.CHAR" xml:space="preserve">
    <value>文字リテラル</value>
  </data>
  <data name="Parser.TOKEN.BASE" xml:space="preserve">
    <value>キーワード 'base'</value>
  </data>
  <data name="AssemblyNotResolved" xml:space="preserve">
    <value>アセンブリ参照 '{0}' が見つからないか、無効です</value>
  </data>
  <data name="RecoverableParseError" xml:space="preserve">
    <value>構文エラーです</value>
  </data>
  <data name="FieldsFromDifferentTypes" xml:space="preserve">
    <value>フィールド '{0}' と '{1}' は異なる型です</value>
  </data>
  <data name="DefensiveCopyWarning" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="NONTERM.typeNameInfo" xml:space="preserve">
    <value> 型名内</value>
  </data>
  <data name="Parser.TOKEN.AMP.AMP" xml:space="preserve">
    <value>シンボル '&amp;&amp;'</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName1" xml:space="preserve">
    <value>{1} の InternalsVisibleTo 属性のアセンブリ名 '{0}' が無効です</value>
  </data>
  <data name="InvalidInternalsVisibleToAssemblyName2" xml:space="preserve">
    <value>InternalsVisibleTo 属性のアセンブリ名 '{0}' が無効です (アセンブリ ファイル名が使用できません)</value>
  </data>
  <data name="FunctionExpected" xml:space="preserve">
    <value>この関数の引数が多すぎるか、関数を使用できない場所で関数が使用されています</value>
  </data>
  <data name="UnitTypeExpectedWithPossibleAssignmentToMutable" xml:space="preserve">
    <value>この等式の結果は暗黙的に破棄されます。'let' を使用して結果を名前にバインドすることを検討してください。例: 'let result = expression'。値を変換する場合は、'&lt;-' 演算子を使用します。例: '{0} &lt;- expression'。</value>
  </data>
  <data name="IndeterminateStaticCoercion" xml:space="preserve">
    <value>型\n    {0}    \nから型\n    {1}    \nへの静的型変換には、このプログラムの場所の前方にある情報に基づく不確定の型が使用されています。静的型変換が許可されていない型もあります。型の注釈を増やしてください。</value>
  </data>
  <data name="PossibleUnverifiableCode" xml:space="preserve">
    <value>このコンストラクトを使用すると、検証できない .NET IL コードが生成される可能性があります。この警告を無効にするには、'--nowarn:9' または '#nowarn "9"' を使用してください。</value>
  </data>
  <data name="FullAbstraction" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="Parser.TOKEN.INFIX.AMP.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="NONTERM.defnBindings" xml:space="preserve">
    <value> 定義内</value>
  </data>
  <data name="Parser.TOKEN.SEMICOLON" xml:space="preserve">
    <value>シンボル ';'</value>
  </data>
  <data name="Parser.TOKEN.INFIX.BAR.OP" xml:space="preserve">
    <value>挿入演算子</value>
  </data>
  <data name="NONTERM.objectImplementationMembers" xml:space="preserve">
    <value> オブジェクト式内</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACE" xml:space="preserve">
    <value>シンボル '&gt;}'</value>
  </data>
  <data name="Parser.TOKEN.GREATER.RBRACK" xml:space="preserve">
    <value>シンボル '&gt;]'</value>
  </data>
  <data name="Parser.TOKEN.EXCEPTION" xml:space="preserve">
    <value>キーワード 'exception'</value>
  </data>
</root>