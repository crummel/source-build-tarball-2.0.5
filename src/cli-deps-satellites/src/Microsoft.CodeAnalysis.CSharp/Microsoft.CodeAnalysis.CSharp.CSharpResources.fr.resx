<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>L'option /out doit être spécifiée pour les sorties dépourvues de source</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>Division par zéro constant</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>'{0}' n'est pas un argument d'attribut nommé valide, car il n'est pas un type de paramètre d'attribut valide</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>Le code XML du commentaire XML est incorrect</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Certains types contenus dans l'assembly analyseur {0} ont été ignorés pour cause de ReflectionTypeLoadException : {1}.</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>Le champ est assigné, mais sa valeur n'est jamais utilisée</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir un opérateur d'assignation</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>Un ou plusieurs types requis pour compiler une expression dynamique sont introuvables. Une référence est-elle manquante ?</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}' est obsolète : '{1}'</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>L'attribut Conditional n'est pas valide sur '{0}', car il s'agit d'un constructeur, d'un destructeur, d'un opérateur ou d'une implémentation d'interface explicite</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Nom de module non valide : {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>'{0}' : les conversions définies par l'utilisateur vers ou à partir d'une classe de base ne sont pas autorisées</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>'{0}' : impossible de référencer un type par l'intermédiaire d'une expression ; essayez plutôt '{1}'</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>Version du compilateur : '{0}'. Version du langage : {1}.</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>itérateurs</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>Option /win32manifest ignorée pour le module, car elle s'applique uniquement aux assemblys</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>La page de '{0}' n'est pas correcte ou n'est pas installée</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>Le membre obsolète '{0}' se substitue au membre non obsolète '{1}'</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>Guillemet fermant manquant pour le littéral de chaîne.</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>Compilation annulée par l'utilisateur</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Les références de métadonnées ne sont pas prises en charge.</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>Un corps de requête doit terminer par une clause select ou une clause group</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>L'instruction switch contient plusieurs cas avec la valeur d'étiquette '{0}'</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>Identificateur attendu ; '{1}' est un mot clé</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>Valeur de '{0}' non valide : '{1}'.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une opération pointeur unsafe</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>Un caractère non valide a été trouvé dans une référence d'entité.</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir une méthode avec des arguments de variables</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>Le commutateur de ligne de commande n'est pas encore implémenté</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>Le compilateur a étendu une variable et son signe de façon implicite, avant d'utiliser la valeur obtenue dans une opération OR au niveau du bit. Ceci peut entraîner un comportement inattendu.</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>L'opérateur * ou -&gt; doit être appliqué à un pointeur</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>Nom non valide pour un symbole de prétraitement. '{0}' est un identificateur non valide</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>Impossible d'appliquer l'opérateur '{0}' aux opérandes de type '{1}' et '{2}'</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>Impossible d'indiquer que ce type est conforme CLS, car il est membre d'un type non conforme CLS</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute n'aura pas d'effet ; il est remplacé par CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField2" xml:space="preserve">
    <value>Impossible de retourner les membres de {0} '{1}' par référence accessible en écriture, car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>'{0}' ne peut pas déclarer un corps, car il est marqué comme abstract</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>Accessibilité incohérente : le type d'événement '{1}' est moins accessible que l'événement '{0}'</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>Le membre '{0}' se substitue au membre obsolète '{1}'. Ajoutez l'attribut Obsolete à '{0}'.</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Impossible d'atteindre le code détecté</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>Le type ou le membre n'a pas besoin d'un attribut CLSCompliant, car l'assembly n'a pas d'attribut CLSCompliant</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>Impossible de trouver une implémentation du modèle de requête pour le type source '{0}'. '{1}' introuvable. Spécifiez explicitement le type de la variable de portée '{2}'.</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>'{0}' n'est pas un numéro d'avertissement valide</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Il n'y a pas de conversion de référence implicite de '{3}' en '{1}'.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>La méthode, l'opérateur ou l'accesseur est marqué comme external et n'a pas d'attribut</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>Le nom du destructeur doit correspondre au nom de classe</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>Impossible de passer la variable de portée '{0}' en tant que paramètre out ou ref</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>Une boucle foreach doit déclarer ses variables d'itération.</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>L'attribut DllImport doit être spécifié sur une méthode marquée 'static' et 'extern'</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>méthode partielle</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>Le champ '{0}' est assigné, mais sa valeur n'est jamais utilisée</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>Impossible de générer dans le corps d'une clause finally</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;espace de noms&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>L'opérateur 'await' peut seulement être utilisé dans une expression de requête dans la première expression de collection de la clause 'from' initiale ou dans l'expression de collection d'une clause 'join'</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>La valeur par défaut spécifiée pour le paramètre '{0}' n'aura aucun effet, car elle s'applique à un membre utilisé dans des contextes qui n'autorisent pas les arguments facultatifs</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>'{0}' : une déclaration d'interface explicite ne peut être déclarée que dans une classe ou une structure</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>Vous ne pouvez pas redéfinir l'alias extern global</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>L'attribut CLSCompliant n'a pas de sens lorsqu'il est appliqué à des paramètres. Essayez de le placer dans la méthode à la place.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>Cet avertissement survient lorsqu'un bloc catch() n'a pas de type d'exception spécifié après un bloc catch (System.Exception e). L'avertissement vous informe du fait que le bloc catch() n'interceptera aucune exception.

Un bloc catch() après un bloc catch (System.Exception e) peut intercepter des exceptions non-CLS si le RuntimeCompatibilityAttribute est défini sur false dans le fichier AssemblyInfo.cs : [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Si cet attribut n'est pas défini sur false de façon explicite, toutes les exceptions non-CLS levées sont encapsulées en tant qu'exceptions et le bloc catch (System.Exception e) les intercepte.</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>Impossible d'attendre dans une clause catch</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>Impossible de déconstruire des objets dynamiques.</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>Impossible d'utiliser une expression dans ce contexte, car elle ne peut pas être passée ou retournée par référence</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>Une option /reference qui déclare un alias extern ne peut avoir qu'un seul nom de fichier. Pour spécifier plusieurs alias ou noms de fichiers, utilisez plusieurs options /reference.</value>
  </data>
  <data name="ERR_StackAllocConversionNotPossible" xml:space="preserve">
    <value>La conversion d'une expression stackalloc de type '{0}' en type '{1}' n'est pas possible.</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>Délimiteur de fin '}' manquant pour l'expression interpolée qui débute par '{'.</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>Vous devez spécifier l'attribut CLSCompliant sur l'assembly, non sur le module, pour activer la vérification de la conformité CLS</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>L'instruction foreach ne peut pas fonctionner sur des variables de type '{0}', car '{0}' ne contient pas de définition publique pour '{1}'</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Erreur lors de la lecture du fichier ruleset {0} - {1}</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Ne pas appeler directement votre méthode Finalize de la classe de base. La méthode est automatiquement appelée à partir de votre destructeur.</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>'{0}' : la valeur de l'énumérateur est trop grande pour ce type</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>Nom de fichier spécifié non valide pour la directive de préprocesseur. Le nom de fichier est trop long ou n'est pas valide.</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>Le type ou le membre est obsolète</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>Impossible de déduire les arguments de type pour la méthode '{0}' à partir de l'utilisation. Essayez de spécifier les arguments de type de façon explicite.</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>Attribut file manquant</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>Attribut path manquant</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>Type non managé '{0}' non valide pour les champs.</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Erreur lors de la signature de la sortie avec une clé publique du conteneur '{0}' -- {1}</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>L'opérateur '{0}' exige qu'un opérateur correspondant '{1}' soit aussi défini</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>Un initialiseur de champ ne peut pas faire référence au champ, à la méthode ou à la propriété non statique '{0}'</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>readonly a implémenté automatiquement les propriétés</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>Impossible d'utiliser les champs du champ readonly statique '{0}' en tant que valeur ref ou out (sauf dans un constructeur statique)</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>modificateurs d'accès sur des propriétés</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>Jeton '{0}' non valide dans la déclaration de membre de classe, de structure ou d'interface</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>Fichier de métadonnées '{0}' introuvable</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>'{0}' n'a pas de taille prédéfinie ; c'est pourquoi sizeof ne peut être utilisé que dans un contexte unsafe (utilisez System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>Chemin de recherche '{0}' non valide spécifié dans '{1}' -- '{2}'</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>Impossible de retourner les champs de '{0}' par référence, car il s'agit d'un '{1}'</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>Impossible de convertir {0} en type délégué '{1}', car les types de paramètre ne correspondent pas aux types de paramètre délégués</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>Seuls les membres conformes CLS peuvent être abstraits</value>
  </data>
  <data name="IDS_FeaturePrivateProtected" xml:space="preserve">
    <value>private protected</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>L'assembly et le module '{0}' ne peuvent pas cibler des processeurs différents.</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>Impossible d'attendre dans le corps d'une instruction lock</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>Impossible d'utiliser un champ readonly statique en tant que valeur ref ou out (sauf dans un constructeur statique)</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>L'attribut '{0}' n'est pas valide dans les accesseurs de propriété ou d'événement. Il n'est valide que dans les déclarations '{1}'.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>L'utilisation de tableaux en tant qu'arguments d'attributs n'est pas conforme CLS</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>Alias extern non utilisé</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>Nombre non valide</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>variance de type</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>répertoire inexistant</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>Pour que '{0}' soit applicable en tant qu'opérateur de court-circuit, son type déclarant '{1}' doit définir l'opérateur true et l'opérateur false</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>Un initialiseur de tableau imbriqué est attendu</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>Seuls les types classe peuvent contenir des destructeurs</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>En supposant que la référence d'assembly correspond à l'identité</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>La référence d'assembly '{0}' n'est pas valide et ne peut pas être résolue</value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>L'assignation de déconstruction nécessite une expression avec un type du côté droit.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Alignement de section de fichier non valide '{0}'</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Les méthodes anonymes, les expressions lambda et les expressions de requête dans des structs ne peuvent pas accéder aux membres d'instance de 'this'. Copiez 'this' dans une variable locale en dehors de la méthode anonyme, de l'expression lambda ou de l'expression de requête et utilisez la variable locale à la place.</value>
  </data>
  <data name="ERR_AssignReadonlyNotField2" xml:space="preserve">
    <value>Impossible d'effectuer l'assignation à un membre de {0} '{1}', car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>Le membre conditionnel '{0}' ne peut pas implémenter le membre d'interface '{1}' dans le type '{2}'</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>La classe static '{0}' ne peut pas dériver du type '{1}'. Les classes static doivent dériver d'un objet.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>Impossible de retourner les champs du champ readonly statique '{0}' par référence accessible en écriture</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>Le type '{0}' est défini dans cet assembly, mais un redirecteur de type est spécifié pour ce type</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>Une expression est trop longue ou complexe à compiler</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>Commentaire sur une seule ligne ou fin de ligne attendue après la directive #pragma</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>'{0}' : la propriété event doit avoir des accesseurs add et remove</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>{ ou ; ou =&gt; attendu</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>L'assembly référencé cible un processeur différent</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>La classe wrapper de coclasse managée '{0}' pour l'interface '{1}' est introuvable (vous manque-t-il une référence d'assembly ?)</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>'{0}' n'implémente pas le modèle '{1}'. '{2}' est ambigu avec '{3}'.</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>Option non valide '{0}' pour /langversion. Utilisez '/langversion:?' pour lister les valeurs prises en charge.</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>Un nom qualifié d'alias n'est pas une expression.</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>Un identificateur était attendu.</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>La valeur 'goto case' n'est pas implicitement convertible en type '{0}'</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>L'assignation dans une expression conditionnelle est toujours constante</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>Le membre conditionnel '{0}' ne peut pas avoir un paramètre out</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>Impossible d'attendre dans un contexte unsafe</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>L'instruction incorporée ne peut pas être une déclaration ni une instruction étiquetée</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>Le constructeur est marqué comme external</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>initialiseur de collection</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>Le type prédéfini '{0}' n'est pas défini ou importé</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>propriétés automatiquement implémentées</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>L'appel distribué dynamiquement à la méthode '{0}' peut échouer au moment de l'exécution, car une ou plusieurs surcharges applicables sont des méthodes conditionnelles.</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>Le type ou le membre est obsolète</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>Le constructeur '{0}' est marqué comme external</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>'{0}' : les classes static ne peuvent pas implémenter d'interfaces</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>La structure d'interopérabilité incorporée '{0}' ne peut contenir que des champs d'instance publics.</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>Dérivation de '{0}' impossible, car il s'agit d'un paramètre de type</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>Le type des variables locales déclaré dans une instruction fixed doit être un type pointeur</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>alias extern</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>Type de retour non valide dans l'attribut cref de commentaire XML</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>L'attribut CLSCompliant n'a pas de sens lorsqu'il est appliqué à des paramètres</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>Le premier opérande d'un opérateur "as" ne peut pas être un littéral de tuple sans type naturel.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Genre d'instrumentation non valide : {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>Impossible de déclarer un espace de noms dans le code de script</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>Le type d'une variable publique, protégée ou protégée en interne doit être conforme CLS.</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' ont des modificateurs d'accessibilité en conflit</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Le type Nullable '{3}' ne satisfait pas la contrainte de '{1}'.</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>Possibilité d'une comparaison de références involontaire ; la partie droite a besoin d'un cast</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>Impossible d'écrire dans le fichier de sortie '{0}' -- '{1}'</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>Mot clé 'this' ou 'base' attendu</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>Le résultat de l'expression est toujours le même, car une valeur de ce type n'est jamais égale à 'null'</value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>Impossible d'utiliser 'yield' dans du code de script de niveau supérieur</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>Cette méthode async n'a pas d'opérateur 'await' et elle s'exécutera de façon synchrone</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>Un type prédéfini est défini dans plusieurs assemblys de l'alias global </value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>'{0}' : un argument d'attribut ne peut pas utiliser de paramètres de type</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>Opérateur surchargeable attendu</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>Impossible d'assigner les champs du champ readonly statique '{0}' (sauf s'ils appartiennent à un constructeur statique ou un initialiseur de variable)</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>Aucun fichier source spécifié.</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>'{0}' n'a pas la signature appropriée pour être un point d'entrée</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>Des clauses Catch ne peuvent pas suivre la clause catch générale d'une instruction try</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>Argument manquant</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>Impossible de convertir une expression lambda en arborescence d'expression dont l'argument de type '{0}' n'est pas un type délégué</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>L'opération en question n'est pas définie sur les pointeurs void</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>Le délégué '{0}' n'a pas de méthode invoke ou une méthode invoke avec un type de retour ou des types de paramètre non pris en charge.</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>opérateur nameof</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>Impossible de prendre l'adresse, d'obtenir la taille ou de déclarer un pointeur vers un type managé ('{0}')</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>La fonctionnalité '{0}' ne fait pas partie de la spécification du langage C# ISO standardisée et peut ne pas être acceptée par d'autres compilateurs</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>L'attribut '{0}' spécifié dans un fichier source est en conflit avec l'option '{1}'.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>Vous ne pouvez pas spécifier l'attribut CLSCompliant sur un module qui diffère de l'attribut CLSCompliant de l'assembly</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>Le paramètre {0} ne doit pas être déclaré avec le mot clé '{1}'</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>Impossible d'attendre dans le corps d'une clause finally</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>Type objet, chaîne ou classe attendu</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>Les métadonnées netmodule liées doivent fournir une image PE complète : '{0}'.</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>La définition d'un alias nommé 'global' n'est pas recommandée</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>Les déclarations de variable de sortie et de variable de modèle ne sont pas autorisées dans les initialiseurs de constructeur, les initialiseurs de champ ou les initialiseurs de propriété.</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred ne peut être utilisé qu'avec /t:exe, /t:winexe et /t:appcontainerexe</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>'{0}' : une classe avec l'attribut ComImport ne peut pas spécifier une classe de base</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>Comme '{1}' possède l'attribut ComImport, '{0}' doit être extern ou abstract</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>variable fixed</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>Conflit de noms pour le nom {0}</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>Une clause catch précédente intercepte déjà toutes les exceptions de this ou d'un super type ('{0}')</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>Utilisation d'un champ potentiellement non assigné '{0}'</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>Vous ne pouvez pas spécifier à la fois des corps de bloc et des corps d'expression.</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>Impossible d'utiliser System.Void dans C# : utilisez typeof(void) pour obtenir l'objet de type void</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>Le mode de documentation fourni n'est pas pris en charge ou est non valide : '{0}'.</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>L'opérateur '{0}' est ambigu pour un opérande de type '{1}'</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>Le nom d'élément tuple est ignoré, car un autre nom est spécifié ou aucun nom n'est spécifié par la cible de l'assignation.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>L'assembly référencé n'a pas de nom fort</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>Une méthode partielle ne peut pas implémenter explicitement une méthode d'interface</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>expression lambda</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>Impossible d'utiliser '{0}' pour la méthode Main, car il est importé</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>Le paramètre d'un opérateur unaire doit être le type conteneur</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>Les structures ne peuvent pas contenir de constructeurs exempts de paramètres explicites</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>La meilleure méthode Add surchargée '{0}' pour l'élément initialiseur de collection est obsolète. {1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>La longueur de la constante de chaîne dépasse la limite de mémoire actuelle. Essayez de fractionner la chaîne en plusieurs constantes.</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>Le champ '{0}' doit être entièrement assigné avant que le contrôle soit retourné à l'appelant</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>Vous devez spécifier l'attribut CLSCompliant sur l'assembly, non sur le module, pour activer la vérification de la conformité CLS</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>L'assembly référencé '{0}' n'a pas de nom fort.</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>espace de noms</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>L'appel est ambigu entre les méthodes ou propriétés suivantes : '{0}' et '{1}'</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>La constante à virgule flottante sort de la plage du type '{0}'</value>
  </data>
  <data name="ERR_InvalidDebugInfo" xml:space="preserve">
    <value>Impossible de lire les informations de débogage de la méthode '{0}' (jeton 0x{1:X8}) dans l'assembly '{2}'</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>Impossible d'émettre des informations de débogage pour un texte source sans encodage.</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>Option non valide '{0}' ; la visibilité de la ressource doit être 'public' ou 'private'</value>
  </data>
  <data name="ERR_ExplicitReservedAttr" xml:space="preserve">
    <value>Ne pas utiliser '{0}'. Ceci est réservé au compilateur.</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>Désolé... Nous ne pouvons pas restaurer les avertissements, car ils ont été désactivés de façon globale</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>__arglist n'est pas autorisé dans la liste de paramètres des itérateurs</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>Impossible de convertir {0} async en type délégué '{1}'. Un {0} async peut retourner void, Task ou Task&lt;T&gt;, aucun n'étant convertible en '{1}'.</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>Attribut '{0}' en double</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>Une balise de fin était attendue pour l'élément '{0}'.</value>
  </data>
  <data name="IDS_FeatureLeadingDigitSeparator" xml:space="preserve">
    <value>séparateur numérique de début</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Les arguments de type ne sont pas autorisés dans l'opérateur nameof.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>Le nom de type ou d'espace de noms '{0}' n'existe pas dans l'espace de noms '{1}' (vous manque-t-il une référence d'assembly ?)</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>'{0}' : impossible de fournir des arguments lors de la création d'une instance d'un type de variable</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>Erreur lors de la lecture des ressources Win32 -- {0}</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Nom de type '{0}' introuvable dans l'espace de noms global. Ce type a été transmis à l'assembly '{1}'. Ajoutez une référence à cet assembly.</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>Impossible de retourner une expression de type 'void'</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>Un paramètre ref ou out ne peut pas avoir de valeur par défaut</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Le nom de type '{0}' est introuvable. Ce type a été transmis à l'assembly '{1}'. Ajoutez une référence à cet assembly.</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>Les itérateurs ne peuvent pas avoir de variables locales par référence</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>Impossible de spécifier une valeur par défaut pour le paramètre 'this'</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>L'expression donnée n'est jamais du type fourni ('{0}')</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise typeparam, alors qu'il n'existe aucun paramètre de type de ce nom</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>Soit les deux déclarations de méthode partielles sont unsafe, soit aucune ne l'est</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>Le second opérande d'un opérateur 'is' ou 'as' ne peut pas être du type static '{0}'</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>Un type de base est marqué comme n'ayant pas besoin d'être conforme CLS dans un assembly marqué comme devant être conforme CLS. Veuillez supprimer l'attribut indiquant que l'assembly est conforme CLS ou supprimer l'attribut indiquant que le type n'est pas conforme CLS.</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>Une méthode avec vararg ne peut pas être générique, se trouver dans un type générique ou avoir un paramètre params</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>'await' nécessite que le type '{0}' ait une méthode GetAwaiter appropriée. Vous manque-t-il une directive using pour 'System' ?</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>; ou = attendu (impossible de spécifier des arguments de constructeur dans une déclaration)</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>Le type de retour de l'opérateur True ou False doit être bool</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>La contrainte ne peut pas être la classe spéciale '{0}'</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>Le type '{0}' transmis à l'assembly '{1}' est en conflit avec le type '{2}' transmis à l'assembly '{3}'.</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>Les valeurs par défaut ne sont pas valides dans ce contexte.</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Le délégué '{0}' n'a pas de paramètre nommé '{1}'</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>'{0}' n'est pas conforme CLS, car l'interface de base '{1}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>L'interface source '{0}' n'a pas de méthode '{1}', qui est requise pour incorporer l'événement '{2}'.</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>Le paramètre de constructeur d'attribut '{0}' est facultatif, mais aucune valeur de paramètre par défaut n'a été spécifiée.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un opérateur de propagation null.</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>Alias '{0}' introuvable</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>Initialisation du membre '{0}' en double</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>Option '{0}' non valide pour /debug ; les options valides sont 'portable', 'embedded', 'full' ou 'pdbonly'</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>Vous ne pouvez prendre l'adresse d'une expression non fixed qu'à l'intérieur d'un initialiseur d'instruction fixed</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>'{0}' : une classe avec l'attribut ComImport ne peut pas spécifier d'initialiseurs de champ.</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>'{0}' : impossible de déclarer des indexeurs dans une classe static</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>'{0}' est déjà énuméré dans la liste des interfaces</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>L'objet 'this' ne peut pas être utilisé avant que tous ses champs soient assignés</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>'{0}' : une propriété ou un indexeur doit avoir au moins un accesseur</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>Les variables implicitement typées ne peuvent pas être constant</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>Une variable a été déclarée avec le même nom qu'une variable dans la classe de base. Cependant, le mot clé new n'a pas été utilisé. Cet avertissement vous informe que vous devez utiliser new ; la variable est déclarée comme si new avait été utilisé dans la déclaration.</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>Accessibilité incohérente : le type de retour '{1}' est moins accessible que la méthode '{0}'</value>
  </data>
  <data name="ERR_FieldsInRoStruct" xml:space="preserve">
    <value>Les champs d'instance de structs en lecture seule doivent être en lecture seule.</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>Utilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal pour créer des jetons de littéral de caractère.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>L'utilisation de tableaux en tant qu'arguments d'attributs n'est pas conforme CLS</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>La valeur d'alignement {0} a une magnitude supérieure à {1} et peut générer une chaîne formatée volumineuse.</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>déclaration de variable de sortie</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>La comparaison à la constante intégrale est inutile, car la constante est en dehors de la plage du type '{0}'</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>'expérimental'</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>Impossible d'utiliser le type '{0}' de l'assembly '{1}' au-delà des limites de l'assembly, car il a un argument de type générique qui est un type interop incorporé.</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction" xml:space="preserve">
    <value>La fonction locale '{0}' est déclarée, mais jamais utilisée</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>L'opérateur as doit être utilisé avec un type référence ou un type Nullable ('{0}' est un type valeur qui n'autorise pas les valeurs null)</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>La {0} abstraite '{1}' ne peut pas être marquée comme étant virtual</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>'{0}' : les classes static ne peuvent pas contenir d'opérateurs définis par l'utilisateur</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>L'étiquette '{0}' cache une autre étiquette qui porte le même nom dans une portée contenue</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>Le membre '{1}' se substitue à '{0}'. Il existe plusieurs candidats à la substitution au moment de l'exécution. La méthode appelée dépend de l'implémentation.</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>Accesseur get ou set attendu</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>N'utilisez pas 'System.ParamArrayAttribute'. Utilisez plutôt le mot clé 'params'.</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>Nouveau membre protégé déclaré dans la classe sealed</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Le type transmis '{0}' est en conflit avec le type déclaré dans le module principal de cet assembly.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>Les numéros de mise en production et/ou de version des deux assemblys diffèrent. Pour procéder à l'unification, veuillez spécifier les directives adéquates dans le fichier .config de l'application et fournir le nom fort correct d'un assembly.</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>Le constructeur '{0}' ne peut pas s'appeler lui-même via un autre constructeur</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>Le fichier référencé '{0}' n'est pas un assembly</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>L'opérateur binaire surchargé '{0}' prend deux paramètres</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>L'attribut Conditional n'est pas valide sur '{0}', car il s'agit d'une méthode override</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>L'adresse de la variable locale '{0}' ou de ses membres ne peut pas être prise et utilisée dans une méthode anonyme ou une expression lambda</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>SearchCriteria est attendu.</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de constructeurs</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>Comme '{0}' retourne void, un mot clé return ne doit pas être suivi d'une expression d'objet</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>L'opérateur défini par l'utilisateur ne peut pas prendre un objet du type englobant et le convertir en un objet du type englobant</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>Impossible de continuer, car la modification inclut une référence à un type incorporé : '{0}'.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Dans la mesure où cet appel n'est pas attendu, l'exécution de la méthode actuelle continue avant la fin de l'appel. Envisagez d'appliquer l'opérateur 'await' au résultat de l'appel.</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>'{0}' n'implémente pas le modèle '{1}'. '{2}' est static ou non public.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>Appelez System.IDisposable.Dispose() au niveau de l'instance allouée de {0} avant que toutes les références s'y rapportant soient hors de portée.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>L'instance allouée de {0} n'a pas été supprimée dans tous les chemins d'accès d'exception. Appelez System.IDisposable.Dispose() avant que toutes les références s'y rapportant soient hors de portée.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>Le nœud de syntaxe à extrapoler ne peut pas appartenir à une arborescence de syntaxe de la compilation actuelle.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>L'attribut de sécurité '{0}' a une valeur SecurityAction '{1}' non valide</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>Pour effectuer un cast d'une valeur négative, vous devez la mettre entre parenthèses.</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>Le nom local '{0}' est trop long pour PDB. Raccourcissez-le ou compilez sans /debug.</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>Définition de membre, instruction ou fin de fichier attendu</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>Dans la mesure où cet appel n'est pas attendu, l'exécution de la méthode actuelle continue avant la fin de l'appel</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>Une clause using doit précéder tous les autres éléments définis dans l'espace de noms sauf les déclarations d'alias extern</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>L'opérateur 'await' ne peut être utilisé que dans une méthode async. Marquez cette méthode avec le modificateur 'async' et changez son type de retour en 'Task'&lt;{0}&gt;'.</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>Une mémoire tampon fixe ne peut avoir qu'une seule dimension.</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>Le résultat de l'expression est toujours '{0}', car une valeur de type '{1}' n'est jamais égale à 'null' du type '{2}'</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>variable</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>Impossible d'utiliser l'alias '{0}' avec '::', car l'alias référence un type. Utilisez plutôt '.'.</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Marqueur de conflit de fusion rencontré</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>La référence d'assembly Friend '{0}' n'est pas valide. Les déclarations InternalsVisibleTo ne peuvent pas avoir une version, une culture, un jeton de clé publique ou une architecture de processeur spécifié.</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>Littéral de caractère vide</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>'{0}' ne peut pas être ajouté à cet assembly, car il s'agit déjà d'un assembly</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>La signature publique n'est pas prise en charge pour les netmodules.</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>Ni le champ, ni la propriété ne peuvent être de type '{0}'</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>Les noms d'élément tuple ne sont pas autorisés à gauche d'une déconstruction.</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un groupe de méthodes</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>Impossible de lier le délégué à '{0}' car il s'agit d'un membre de 'System.Nullable&lt;T&gt;'</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>méthode</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' doivent avoir les mêmes noms de paramètre de type dans le même ordre</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>Impossible d'utiliser le(s) caractère(s) '{0}' à cet emplacement.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>L'opérateur 'await' ne peut être utilisé que dans un {0} asynchrone. Marquez ce {0} avec le modificateur 'async'.</value>
  </data>
  <data name="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne" xml:space="preserve">
    <value>Le premier paramètre d'une méthode d'extension 'ref' '{0}' doit être un type valeur ou un type générique limité à struct.</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>Le chaînage d'un modèle sémantique spéculatif n'est pas pris en charge. Vous devez créer un modèle spéculatif à partir du ParentModel non spéculatif.</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>Plusieurs points d'entrée sont définis dans le programme. Compilez avec l'option /main pour spécifier le type qui contient le point d'entrée.</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>L'expression de filtre est une constante ; supprimez le filtre</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_2" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 7.2. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible dans C# 7.1. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>Impossible d'inclure le fragment XML '{1}' du fichier '{0}' -- {2}</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>Le type '{0}' exporté à partir du module '{1}' est en conflit avec le type '{2}' exporté à partir du module '{3}'.</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>Un point d'entrée ne peut pas être générique ou d'un type générique</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>'{0}' n'a pas de méthode Main statique appropriée</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>Le nom qualifié complet de '{0}' est trop long pour les informations de débogage. Compilez sans l'option '/debug'.</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>Les paramètres facultatifs doivent apparaître après tous les paramètres requis</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>L'avertissement remplace une erreur</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>Cette étiquette n'est pas référencée</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>La variable '{0}' est déclarée, mais jamais utilisée</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>L'utilisation du {1} générique '{0}' nécessite des arguments de type {2}</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>directive #endif attendue</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>La méthode actuelle appelle une méthode async qui retourne Task ou Task&lt;TResult&gt;. Par ailleurs, elle n'applique pas l'opérateur await au résultat. L'appel de la méthode async démarre une tâche asynchrone. Cependant, comme aucun opérateur await n'est appliqué, le programme continue sans attendre la fin de la tâche. Généralement, ce comportement n'est pas celui que vous attendez. La plupart du temps, les autres aspects de la méthode d'appel dépendent du résultat de l'appel ou, au minimum, la méthode appelée doit s'achever avant le retour de la méthode contenant l'appel.

Un problème de même importance est ce qui arrive aux exceptions levées dans la méthode async appelée. Une exception levée dans une méthode qui retourne Task ou Task&lt;TResult&gt; est stockée dans la tâche retournée. Si vous n'attendez pas la tâche ou la vérification explicite d'exceptions, l'exception est perdue. Si vous attendez la tâche, son exception est à nouveau levée.

Nous vous recommandons de toujours attendre l'appel.

Supprimez l'avertissement seulement si vous êtes sûr de ne pas vouloir attendre la fin de l'appel asynchrone, et que la méthode appelée ne lèvera aucune exception. Dans ce cas, vous pouvez supprimer l'avertissement en affectant le résultat de la tâche de l'appel à une variable.</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>expression de requête</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>Valeur non valide pour l'argument de l'attribut '{0}'</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>Un assembly agnostique ne peut pas avoir un module '{0}' propre au processeur.</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>Un spécificateur de format ne doit contenir aucun espace blanc de fin.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>La variable est assignée mais sa valeur n'est jamais utilisée</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>Un accesseur add ou remove doit avoir un corps</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>L'implémentation de la méthode explicite '{0}' ne peut pas implémenter '{1}', car il s'agit d'un accesseur</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>Un membre implémente un membre d'interface avec plusieurs correspondances au moment de l'exécution</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>Le commentaire XML a une balise param en double pour '{0}'</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>Le nom d'énumérateur '{0}' est réservé et ne peut pas être utilisé</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un initialiseur de dictionnaire.</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>Le membre '{0}' ne masque pas de membre accessible. Le mot clé new n'est pas nécessaire.</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation" xml:space="preserve">
    <value>Les spécifications d'argument nommé doivent s'afficher après la spécification de tous les arguments fixes dans un appel dynamique.</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>Un numéro transmis à la directive de préprocesseur d'avertissement #pragma n'est pas correct. Veuillez vérifier que ce numéro représente un avertissement et non une erreur.</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>attendre dans des blocs catch et des blocs finally</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>'{0}' : un point d'entrée ne peut pas être générique ou d'un type générique</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>'{0}' ne contient pas de définition pour '{1}' et la meilleure surcharge de méthode d'extension '{2}' nécessite un récepteur de type '{3}'</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#r n'est autorisé que dans les scripts</value>
  </data>
  <data name="ERR_DynamicLocalFunctionTypeParameter" xml:space="preserve">
    <value>Impossible de passer un argument ayant un type dynamique à une fonction locale générique '{0}' avec des arguments de type déduits.</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Arborescence de syntaxe déjà présente</value>
  </data>
  <data name="ERR_BadParameterModifiersOrder" xml:space="preserve">
    <value>Impossible d'utiliser le modificateur de paramètre '{0}' après le modificateur '{1}'</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Nom de sortie non valide : {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>Une classe avec l'attribut ComImport ne peut pas avoir un constructeur défini par l'utilisateur</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>L'expression de retour doit être de type '{0}', car cette méthode effectue un retour par référence</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Les propriétés implémentées automatiquement doivent avoir des accesseurs get.</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>L'identificateur '{0}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Erreur lors de la lecture des informations de débogage pour '{0}'</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>Les classes static ne peuvent pas contenir de destructeurs</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>L'expression donnée est toujours du type fourni ('{0}')</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>Les références du fichier source ne sont pas prises en charge.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>Il n'existe pas de classement défini entre les champs dans plusieurs déclarations de la structure partielle '{0}'. Pour spécifier un classement, tous les champs d'instance doivent se trouver dans la même déclaration.</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>Accessibilité incohérente : le type de retour d'indexeur '{1}' est moins accessible que l'indexeur '{0}'</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>Le champ conforme CLS ne peut pas être volatile</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>Accessibilité incohérente : le type de paramètre '{1}' est moins accessible que la méthode '{0}'</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>l'arborescence doit avoir un nœud racine avec SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>Seuls une assignation, un appel, un incrément, un décrément et des expressions d'objet new peuvent être utilisés comme instruction</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>CallerFilePathAttribute, qui est appliqué au paramètre '{0}', n'aura aucun effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas les arguments facultatifs</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>params n'est pas valide dans ce contexte</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un paramètre out ou ref</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>Impossible d'initialiser le type '{0}' avec un initialiseur de collection, car il n'implémente pas 'System.Collections.IEnumerable'</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>Le premier opérande d'un opérateur de décalage surchargé doit être du même type que le type conteneur et le type du second opérande doit être int</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>initialiseur auto-property</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>Erreur lors de la lecture de la ressource '{0}' -- '{1}'</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>Directive de préprocesseur attendue</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>'await' ne peut pas être utilisé dans une expression contenant le type '{0}'</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>Impossible de spécifier des modificateurs d'accessibilité pour les accesseurs de la propriété ou de l'indexeur '{0}'</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Les noms d'éléments d'un tuple doivent être uniques.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>Le nom de ce langage n'est pas correct</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}' : impossible d'appeler explicitement un opérateur ou un accesseur</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>'{0}' ne peut pas être externe et avoir un initialiseur de constructeur</value>
  </data>
  <data name="IDS_StackAllocExpression" xml:space="preserve">
    <value>stackalloc {0}[{1}]</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>Les propriétés implémentées automatiquement ne peuvent pas effectuer de retour par référence</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>L'espace blanc obligatoire est manquant.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Référence à netmodule '{0}' manquante.</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>L'opération a provoqué un dépassement de capacité de la pile.</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>variable d'itération foreach</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>'{0}' : substitution impossible ; '{1}' n'est pas un événement</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>'{0}' est un doublon de TypeForwardedToAttribute</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>Les mémoires tampons de taille fixe doivent avoir une longueur supérieure à zéro</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>'await' ne peut pas être utilisé comme identificateur dans une méthode async ou une expression lambda</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>Impossible de convertir la valeur de constante '{0}' en '{1}' (utilisez la syntaxe 'unchecked)</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>L'identificateur n'est pas conforme CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>initialiseur de dictionnaire</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>chaînes interpolées</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>Les chemins de code ne retournent pas tous une valeur dans {0} de type '{1}'</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>Possibilité d'une comparaison de références involontaire ; la partie gauche a besoin d'un cast</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>Impossible de résoudre le chemin d'accès au fichier '{0}' spécifié pour l'argument nommé '{1}' de l'attribut PermissionSet</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>Nombre non valide</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>L'assembly référencé '{0}' a un paramètre de culture différent : '{1}'.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>La référence de l'attribut cref est ambiguë</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>Le premier paramètre d'une méthode d'extension ne peut pas être de type '{0}'</value>
  </data>
  <data name="IDS_FeatureReadOnlyReferences" xml:space="preserve">
    <value>références en lecture seule</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>'{0}' est un {1}, qui n'est pas valide dans le contexte donné</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>La méthode surchargée '{0}', qui se différencie uniquement au niveau de ref ou out ou du rang de tableau, n'est pas conforme CLS</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>Type de paramètre non valide 'void'</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>Les contraintes ne sont pas autorisées sur des déclarations non génériques</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>Le commentaire XML comporte une erreur de syntaxe au niveau de l'attribut cref</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>méthodes anonymes</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir d'expression throw.</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>Impossible de convertir le type '{0}' en '{1}'</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>Impossible de spécifier plusieurs fois l'argument nommé '{0}'</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>Le spécificateur de type tableau, [], doit apparaître avant le nom de paramètre</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>Impossible de convertir null en '{0}', car il s'agit d'un type valeur qui n'autorise pas les valeurs null</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>Le modificateur 'partial' ne peut apparaître qu'immédiatement avant 'class', 'struct', 'interface' ou 'void'</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>Le type de l'argument de l'attribut DefaultParameterValue doit correspondre au type de paramètre</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>Option d'alias de référence non valide : '{0}=' -- nom de fichier manquant</value>
  </data>
  <data name="ERR_FieldAutoPropCantBeByRefLike" xml:space="preserve">
    <value>Le champ ou la propriété implémentée automatiquement ne peut pas être de type '{0}', sauf s'il s'agit d'un membre d'instance d'un struct par référence.</value>
  </data>
  <data name="ERR_BadNonTrailingNamedArgument" xml:space="preserve">
    <value>L'argument nommé '{0}' est utilisé hors-position mais est suivi d'un argument sans nom</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>Impossible de retourner les membres du champ readonly '{0}' par référence accessible en écriture</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>Impossible d'utiliser une expression de type '{0}' comme argument pour une opération distribuée dynamiquement.</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>Les expressions de requête sur le type de source 'dynamic' ou avec une séquence de jointure de type 'dynamic' ne sont pas autorisées</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>L'option '{0}' se substitue à l'attribut '{1}' spécifié dans un fichier source ou un module ajouté</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>'{0}' : les noms de membres doivent être différents de leur type englobant</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>Le mot clé contextuel 'var' ne peut apparaître que dans une déclaration de variable locale ou dans un script de code</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>Numéro de base d'image non valide '{0}'</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>Un événement Windows Runtime ne peut pas être passé comme paramètre out ou ref.</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>Impossible d'utiliser une instance de type '{0}' dans une fonction imbriquée, une expression de requête, un bloc itérateur ou une méthode async</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'. '{2}' ne peut pas implémenter '{1}', car il ne possède pas le type de retour correspondant '{3}'.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>Le type de l'une des expressions dans la clause {0} est incorrect. L'inférence de type a échoué dans l'appel à '{1}'.</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>Le commentaire XML possède un attribut cref qui fait référence à un paramètre de type</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>Nom de méthode attendu</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>Impossible d'utiliser la variable locale fixe '{0}' dans une méthode anonyme, une expression lambda ou une expression de requête</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>__arglist n'est pas valide dans ce contexte</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Les éléments ne peuvent pas avoir la valeur null.</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>Symbole non C#.</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>'{0}' : les types static ne peuvent pas être utilisés comme paramètres</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Le type '{0}' exporté à partir du module '{1}' est en conflit avec le type déclaré dans le module principal de cet assembly.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>Le format de la chaîne de version spécifiée n'est pas conforme au format requis - major[.minor[.build[.revision]]]</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>L'instruction foreach ne peut pas fonctionner sur des variables de type '{0}', car elle implémente plusieurs instanciations de '{1}' ; essayez d'effectuer un cast en une instanciation d'interface spécifique</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise param, alors qu'il n'existe aucun paramètre de ce nom</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>Le type de retour par référence 'ref {0}' n'est pas pris en charge.</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>Identificateur attendu</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>critères spéciaux</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute n'aura pas d'effet ; il est remplacé par CallerFilePathAttribute</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir un accès de base</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>Un paramètre ne peut avoir qu'un seul modificateur '{0}'</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>Il n'existe pas d'étiquette '{0}' dans la portée de l'instruction goto</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>Du code unsafe ne peut apparaître qu'en cas de compilation avec /unsafe</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>Impossible d'utiliser 'await' dans une expression contenant un appel à '{0}', car il effectue un retour par référence</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>'{0}' : les membres virtual ou abstract ne peuvent pas être private</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>L'assembly référencé a un paramètre de culture différent</value>
  </data>
  <data name="ERR_InExtensionMustBeValueType" xml:space="preserve">
    <value>Le premier paramètre d'une méthode d'extension 'in' '{0}' doit être un type valeur.</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>Impossible d'utiliser une valeur de type '{0}' comme paramètre par défaut pour le paramètre Nullable '{1}', car '{0}' n'est pas un type simple</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>Impossible d'utiliser une valeur de type '{0}' comme paramètre par défaut, car il n'existe pas de conversion standard en type '{1}'</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>'{0}' est abstract, mais il est contenu dans la classe non abstraite '{1}'</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>Le module '{0}' dans l'assembly '{1}' transfère le type '{2}' à plusieurs assemblys : '{3}' et '{4}'.</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>Disable ou restore attendu après l'avertissement #pragma</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>La valeur SecurityAction '{0}' n'est pas valide pour les attributs de sécurité appliqués à un type ou à une méthode</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>'{0}' est un {1} mais est utilisé comme un {2}</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>Les directives du préprocesseur doivent être le premier caractère (autre qu'un espace blanc) d'une ligne</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>champ</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>alias using</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>Un type n'implémente pas le modèle de la collection ; un membre est statique ou n'est pas public</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>séparateurs numériques</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>événement</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>Le modificateur '{0}' 'n'est pas valide pour cet élément</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>Le fichier de clé '{0}' ne comprend pas la clé privée nécessaire à la signature</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>étiquette</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>Une expression __arglist ne peut apparaître qu'à l'intérieur d'un appel ou d'une expression new</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>Algorithme '{0}' non pris en charge</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>La méthode doit avoir un type de retour</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>paramètre de type</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>Les enums ne peuvent pas contenir de constructeurs sans paramètre explicites</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>Ceci n'est pas un emplacement d'attribut valide pour cette déclaration</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Échec de chiffrement pendant la création de hachages.</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>Cette méthode ne peut être utilisée que pour créer des jetons - {0} n'est pas un genre de jeton.</value>
  </data>
  <data name="ERR_OverloadRefKind" xml:space="preserve">
    <value>'{0}' ne peut pas définir un {1} surchargé qui se différencie uniquement par les modificateurs de paramètres '{2}' et '{3}'</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>Le nom '{0}' n'existe pas dans le contexte actuel (vous manque-t-il une référence à l'assembly '{1}' ?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>Le mot clé 'base' n'est pas disponible dans le contexte actuel</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>Impossible d'utiliser la variable locale '{0}' tant qu'elle n'est pas déclarée</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>La chaîne littérale ']]&gt;' n'est pas autorisée dans le contenu de l'élément.</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>'{0}' : impossible d'implémenter une interface dynamique '{1}'</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Paramètre non valide pour le type non managé spécifié.</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>option /REFERENCEPATH</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir de référence à une fonction locale</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>Le champ contient plusieurs valeurs de constante distinctes.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} version {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>Copyright (C) Microsoft Corporation. Tous droits réservés.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>L'attribut de sécurité '{0}' n'est pas valide dans ce type de déclaration. Les attributs de sécurité ne sont valides que dans les déclarations d'assembly, de type et de méthode.</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>using static</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Le membre '{0}' ajouté durant la session de débogage actuelle est uniquement accessible à partir de son assembly de déclaration '{1}'.</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>Impossible d'utiliser #load à la suite du premier jeton du fichier</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une déclaration de variable d'argument out.</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>Type non valide pour le paramètre {0} dans l'attribut cref du commentaire XML : '{1}'</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>Accessibilité incohérente : le type de contrainte '{1}' est moins accessible que '{0}'</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>'{0}' ne peut pas être à la fois abstract et sealed</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>Caractère inattendu '{0}'</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>'{0}' n'est pas un argument d'attribut nommé valide. Les arguments d'attribut nommé doivent être des champs qui ne sont pas readonly, statiques ou constants, ou des propriétés en lecture-écriture qui sont publiques et non statiques.</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>Directive #pragma non reconnue</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>Impossible de déclarer une variable de type static '{0}'</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>Vous avez ajouté une référence à un assembly en utilisant /link (la propriété Incorporer les types interop est définie sur True). Cette commande ordonne au compilateur d'incorporer les informations de type interop à partir de cet assembly. Cependant, le compilateur ne peut pas incorporer les informations de type interop à partir de cet assembly, car un autre assembly que vous avez référencé référence également cet assembly en utilisant /reference (la propriété Incorporer les types interop est définie sur False).

Pour incorporer les informations de type interop pour chaque assembly, utilisez la commande /link pour les références de chaque assembly (définissez la propriété Incorporer les types interop sur True).

Pour supprimer l'avertissement, vous pouvez utiliser la commande /reference (définissez la propriété Incorporer les types interop sur False). Dans ce cas, un assembly PIA (Primary Interop Assembly) fournit des informations de type interop.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>accesseur de propriété du corps d'expression</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>'{0}' définit l'opérateur == ou l'opérateur != mais ne se substitue pas à Object.Equals(object o)</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Nombre incorrect d'arguments de type</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>'{0}' n'implémente pas le modèle '{1}'. '{2}' a une signature erronée.</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>Une déclaration d'espace de noms ne peut pas avoir de modificateurs ou d'attributs</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>'{0}' : les types de champ d'instance marqués avec StructLayout(LayoutKind.Explicit) doivent avoir un attribut FieldOffset</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>Impossible de créer une instance de la classe abstraite ou de l'interface '{0}'</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>Une implémentation d'interface explicite d'un événement doit utiliser la syntaxe des accesseurs d'événement</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>L'évaluation de la valeur de constante de '{0}' implique une définition circulaire</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>'{0}' n'est pas un emplacement d'attribut valide pour cette déclaration. Les emplacements d'attributs valides pour cette déclaration sont '{1}'. Tous les attributs de ce bloc seront ignorés.</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>'{0}' est ambigu entre '{1}' et '{2}' ; utilisez '@{0}' ou '{0}Attribute'</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>; attendu</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>L'appel distribué dynamiquement peut échouer au moment de l'exécution, car une ou plusieurs surcharges applicables sont des méthodes conditionnelles</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>L'espace de noms est en conflit avec le type importé</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>Une méthode partielle ne peut pas avoir plusieurs déclarations d'implémentation</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>Impossible d'utiliser '{0}' en tant que valeur ref ou out, car il s'agit d'un '{1}'</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>Un accès Friend a été concédé par '{0}', mais l'état de signature avec nom fort de l'assembly de sortie ne correspond pas à celui de l'assembly concédant.</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>La contrainte ne peut pas être un type dynamic '{0}'</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>Impossible d'appliquer l'opérateur '{0}' à un opérande de type '{1}'</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>'{0}' : une référence à un champ volatile ne sera pas considérée comme volatile</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une opération dynamique</value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>Les variables locales implicitement typées ne peuvent pas être fixed</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>Le type importé '{0}' n'est pas valide. Il contient une dépendance de classe de base circulaire.</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>Plusieurs implémentations du modèle de requête ont été trouvées pour le type source '{0}'. Appel ambigu à '{1}'.</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>Le commutateur de ligne de commande '{0}' n'est pas encore implémenté et a été ignoré.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>La méthode, l'opérateur ou l'accesseur '{0}' est marqué comme external et n'a pas d'attribut. Ajoutez un attribut DllImport pour spécifier l'implémentation externe.</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>Accessibilité incohérente : le type de paramètre '{1}' est moins accessible que l'indexeur '{0}'</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>propriété expression-bodied</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>L'attribut FieldOffset n'est pas autorisé sur des champs static ou const</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>Impossible d'utiliser ref local '{0}' dans une méthode anonyme, une expression lambda ou une expression de requête</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>L'opérateur '{0}' est ambigu pour des opérandes de type '{1}' et '{2}'</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>Le type de retour de '{0}' n'est pas conforme CLS</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>En supposant que la référence d'assembly correspond à l'identité</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>'{0}' ne contient pas de définition pour '{1}' et aucune méthode d'extension '{1}' acceptant un premier argument de type '{0}' n'a été trouvée (vous manque-t-il une directive using pour '{2}' ?)</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>La signature différée a été spécifiée et nécessite une clé publique, mais aucune clé publique n'a été spécifiée</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>L'expression fera toujours intervenir System.NullReferenceException, car la valeur par défaut de '{0}' est null</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>Les indexeurs doivent posséder au moins un paramètre</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>L'utilisation de '{0}' pour tester la compatibilité avec '{1}' est fondamentalement identique au test de la compatibilité avec '{2}' et elle aboutit pour toutes les valeurs non null</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>La valeur d'un type intégral est attendue</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>Cette fonctionnalité de langage ('{0}') n'est pas encore implémentée.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>L'arborescence de syntaxe doit être créée à partir d'une soumission.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>Le nom complet est trop long pour les informations de débogage</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>Aucune valeur n'a été trouvée pour RuntimeMetadataVersion. Aucun assembly contenant System.Object n'a été trouvé et aucune valeur n'a été spécifiée pour RuntimeMetadataVersion via les options.</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>Interface marquée avec 'CoClassAttribute' et non avec 'ComImportAttribute'</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>L'instance allouée n'a pas été supprimée dans tous les chemins d'accès de l'exception</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>'in' attendu</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>Il existe une erreur dans un assembly référencé '{0}'.</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>Le nom d'élément de tuple '{0}' est interdit à toutes les positions.</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>Indexation d'un tableau avec un index négatif (les index de tableau commencent toujours à zéro)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>L'attribut CLSCompliant n'a pas de sens lorsqu'il est appliqué à des types de retour. Essayez de le placer dans la méthode à la place.</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>'{0}' spécifié pour la méthode Main doit être une classe ou une structure non générique valide</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>La meilleure méthode Add surchargée '{0}' pour l'élément initialiseur de collection est obsolète. {1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>La vérification de conformité CLS ne sera pas effectuée, car l'objet inspecté n'est pas visible hors de cet assembly</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' ont des contraintes incohérentes pour le paramètre de type '{1}'</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>'{0}' spécifié pour la méthode Main est introuvable</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>L'utilisation d'un champ d'une classe marshalée-par-référence en tant que valeur ref ou out, ou la prise de son adresse, peut provoquer une exception runtime</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>'{0}' : les modificateurs d'accessibilité ne peuvent pas être utilisés sur les accesseurs d'une interface</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>Parmi les arguments spécifiés, aucun ne correspond au paramètre formel obligatoire '{0}' de '{1}'</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>Le genre de code source fourni n'est pas pris en charge ou est non valide : '{0}'</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>Impossible de spécifier une valeur par défaut pour un tableau de paramètres</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>Assignation effectuée à la même variable</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>Nom non valide pour un symbole de prétraitement. '{0}' est un identificateur non valide</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>'{0}' ne peut pas implémenter '{1}' et '{2}', car ils peuvent être réunis pour des substitutions de paramètre de type</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>Le type '{0}' transmis à l'assembly '{1}' est en conflit avec le type '{2}' exporté à partir du module '{3}'.</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>Le type '{2}' doit être un type valeur non Nullable afin d'être utilisé comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>La méthode n'a pas la signature appropriée pour être un point d'entrée</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>Modificateur '{0}' en double</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>par contravariance</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>Mot clé, identificateur ou chaîne attendue après le spécificateur textuel : @</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>L'accesseur '{1}' est manquant dans l'implémentation d'interface explicite '{0}'</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' doit être un type non abstrait avec un constructeur sans paramètre public afin de l'utiliser comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>'{0}' : le type conteneur n'implémente pas l'interface '{1}'</value>
  </data>
  <data name="ERR_RefStructInterfaceImpl" xml:space="preserve">
    <value>'{0}' : les structs par référence ne peuvent pas implémenter d'interfaces</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>Impossible de trouver une implémentation du modèle de requête pour le type source '{0}'. '{1}' introuvable. Vous manque-t-il une référence à 'System.Core.dll' ou une directive using pour 'System.Linq' ?</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>Les opérateurs définis par l'utilisateur ne peuvent pas retourner void</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>littéraux binaires</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>Impossible de créer un tableau avec une taille négative</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>classes static</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>L'instruction yield ne peut pas être utilisée dans une méthode anonyme ou une expression lambda</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>Impossible d'incorporer le type '{0}', car il a un argument générique. Attribuez à la propriété 'Incorporer les types interop' la valeur false.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>Le fichier source a dépassé la limite de 16 707 565 lignes pouvant être représentées dans le PDB ; les informations de débogage seront incorrectes</value>
  </data>
  <data name="IDS_FeatureRefStructs" xml:space="preserve">
    <value>structs par référence</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>Les propriétés implémentées automatiquement dans les interfaces ne peuvent pas avoir d'initialiseurs.</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'. '{2}' n'est pas public.</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>'{1}' ne définit pas le paramètre de type '{0}'</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>L'opérateur typeof ne peut pas être utilisé sur le type dynamic</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>L'opérande d'un opérateur d'incrémentation ou de décrémentation doit être une variable, une propriété ou un indexeur</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>Le commutateur /embed est uniquement pris en charge durant l'émission d'un fichier PDB.</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>'{0}' ne peut pas être à la fois extern et abstract</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>Un objet d'un type convertible en '{0}' est requis</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>Impossible de créer une instance de la classe static '{0}'</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>'{0}' masque le membre hérité '{1}'. Utilisez le mot clé new si le masquage est intentionnel.</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Caractère Unicode non valide.</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>Les expressions lambda qui effectuent un retour par référence ne peuvent pas être converties en arborescences d'expression</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>Impossible de définir une classe ou un membre qui utilise des tuples, car le type '{0}' nécessaire au compilateur est introuvable. Une référence est-elle manquante ?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Erreur lors de la signature de la sortie avec une clé publique du fichier '{0}' -- {1}</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>'{0}' : impossible de spécifier à la fois une classe de contrainte et la contrainte 'class' ou 'struct'</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>Une directive 'using static' ne peut être appliquée qu'aux types ; '{0}' est un espace de noms, pas un type. Utilisez plutôt une directive 'using namespace'</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>Impossible d'utiliser une expression lambda comme argument pour une opération distribuée dynamiquement sans tout d'abord en effectuer un cast en type délégué ou en type d'arborescence de l'expression.</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>Les retours par valeur ne peuvent être utilisés que dans les méthodes qui effectuent un retour par valeur</value>
  </data>
  <data name="ERR_EscapeStackAlloc" xml:space="preserve">
    <value>Impossible d'utiliser un résultat d'une expression stackalloc de type '{0}' dans ce contexte, car il peut être exposé en dehors de la méthode conteneur</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>Type non valide spécifié comme argument pour l'attribut TypeForwardedTo</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>Impossible de créer un délégué avec '{0}', car celui-ci ou une méthode qu'il remplace a un attribut Conditional</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>L'utilisation d'un littéral par défaut est non valide dans ce contexte</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>Impossible de convertir implicitement le type '{0}' en '{1}'. Une conversion explicite existe (un cast est-il manquant ?)</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>Impossible de créer une instance de l'analyseur {0} à partir de {1} : {2}.</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>La directive using est apparue précédemment dans cet espace de noms</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>Désolé... Nous ne pouvons pas résoudre l'attribut cref du commentaire XML</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>Impossible de référencer 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitement. Utilisez la syntaxe des tuples pour définir les noms de tuples.</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>L'expression de filtre est une constante</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>Nombre non valide</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>Le délégué '{0}' n'accepte pas d'arguments {1}</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>'{0}' masque le membre abstrait hérité '{1}'</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>Paramètre de type '{0}' en double</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>Un événement dans une interface ne peut pas avoir d'accesseurs add ou remove</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>La meilleure méthode Add surchargée pour l'élément initialiseur de collection est obsolète</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>Valeurs de checksum différentes spécifiées pour '{0}'</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>'{0}' : l'événement doit être de type délégué</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>Expression attendue après yield return</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>Le commutateur /sourcelink est uniquement pris en charge durant l'émission d'un fichier PDB.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>Le premier argument d'un attribut de sécurité doit être un SecurityAction valide</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>Le mot clé contextuel 'var' ne peut pas être utilisé dans une déclaration de variable de portée</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>Alias extern non valide pour '/reference' ; '{0}' n'est pas un identificateur valide</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>Un membre masque un membre hérité ; le mot clé override est manquant</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>L'attribut FieldOffset ne peut être placé que sur des membres de types marqués avec StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise param en double</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>type</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>'{0}' : impossible d'utiliser les types static en tant qu'arguments de type</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>Une expression throw n'est pas autorisée dans ce contexte.</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>CallerLineNumberAttribute, qui est appliqué au paramètre '{0}', n'aura aucun effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas les arguments facultatifs</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>Opérateur binaire surchargeable attendu</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>Aucun meilleur type trouvé pour le tableau implicitement typé</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>L'espace blanc n'est pas autorisé à cet emplacement.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>Le commentaire XML n'est pas placé dans un élément valide du langage</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>Impossible d'utiliser une taille négative avec stackalloc</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>Erreur de syntaxe de ligne de commande : '{0}' manquant pour l'option '{1}'</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>Les pointeurs et les mémoires tampons de taille fixe ne peuvent être utilisés que dans un contexte unsafe</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>La méthode surchargée, qui se différencie uniquement par les types de tableau sans nom, n'est pas conforme CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>Erreur lors de la génération des ressources Win32 -- {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>Les méthodes partielles avec uniquement une déclaration de définition ou des méthodes conditionnelles supprimées ne peuvent pas être utilisées dans des arborescences d'expressions</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>Le nom d'élément de tuple '{0}' est déduit. Utilisez la version de langage {1} ou une version supérieure pour accéder à un élément par son nom déduit.</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>Possibilité d'une comparaison de références involontaire ; pour obtenir une comparaison de valeurs, effectuez un cast de la partie droite en type '{0}'</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise typeparam en double</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>L'assembly '{0}' avec l'identité '{1}' utilise '{2}' dont la version est supérieure à celle de l'assembly référencé '{3}' avec l'identité '{4}'</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>Impossible d'utiliser le {1} '{0}' non générique avec des arguments de type</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>Le nom d'assembly '{0}' est réservé et ne peut pas servir de référence dans une session interactive</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>Le type définit l'opérateur == ou l'opérateur != mais ne se substitue pas à Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>'{0}' : le type doit être '{2}' pour correspondre au membre substitué '{1}'</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>Opérateur de bits or utilisé sur un opérande de signe étendu ; effectuez un cast en type plus faible non signé</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>Vous ne pouvez pas utiliser des mémoires tampons de taille fixe contenues dans des expressions non fixed. Essayez d'utiliser l'instruction fixed.</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>Impossible de prendre l'adresse de l'expression donnée</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression ne peut pas contenir '{0}'</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>Impossible de spécifier une valeur de paramètre par défaut conjointement à DefaultParameterAttribute ou OptionalAttribute</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>Aucune instance de déconstruction ou méthode d'extension convenable pour le type '{0}' avec les paramètres de sortie {1} et un type de retour void.</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>La méthode d'extension doit être définie dans une classe statique non générique</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>'{0}' est de type '{1}'. Un champ const d'un type référence autre que string ne peut être initialisé qu'avec null.</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>La contrainte 'new()' ne peut pas être utilisée avec la contrainte 'struct'</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>__arglist n'est pas autorisé dans la liste de paramètres de méthodes async</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>N'utilisez pas 'System.Runtime.CompilerServices.ExtensionAttribute'. Utilisez plutôt le mot clé 'this'.</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>Un accesseur add ou remove est attendu</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>Le contrôle ne peut pas quitter le corps d'une méthode anonyme ou d'une expression lambda</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>Un membre obsolète se substitue à un membre non obsolète</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>La contrainte de type classe '{0}' doit précéder toute autre contrainte</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>'{0}' doit correspondre au retour par référence du membre substitué '{1}'</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>CallerFilePathAttribute n'aura pas d'effet ; il est remplacé par CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>Les groupes de méthode d'extension ne sont pas autorisés en tant qu'arguments pour 'nameof'.</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>Impossible d'initialiser une variable par valeur avec une référence</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>'{0}' ne contient pas de définition pour '{1}' et aucune méthode d'extension '{1}' acceptant un premier argument de type '{0}' n'a été trouvée (une directive using ou une référence d'assembly est-elle manquante ?)</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>Impossible d'utiliser le {1} '{0}' avec des arguments de type</value>
  </data>
  <data name="ERR_EscapeLocal" xml:space="preserve">
    <value>Impossible d'utiliser un '{0}' local dans ce contexte, car il peut exposer des variables référencées en dehors de la portée de leur déclaration</value>
  </data>
  <data name="ERR_EscapeOther" xml:space="preserve">
    <value>Impossible d'utiliser l'expression dans ce contexte, car elle peut exposer indirectement des variables en dehors de la portée de leur déclaration</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>Une méthode partielle ne peut pas avoir plusieurs déclarations de définition</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>La référence d'assembly '{0}' n'est pas valide et ne peut pas être résolue</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>Les classes static ne peuvent pas avoir de constructeurs d'instance</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>'await' nécessite que le type {0} ait une méthode GetAwaiter appropriée</value>
  </data>
  <data name="ERR_EscapeCall2" xml:space="preserve">
    <value>Impossible d'utiliser un membre du résultat de '{0}' dans ce contexte, car il peut exposer les variables référencées par le paramètre '{1}' en dehors de la portée de leur déclaration</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>Le type '{1}' réserve déjà un membre appelé '{0}' avec les mêmes types de paramètre</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>Le type d'argument n'est pas conforme CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>Séquence d'échappement non reconnue</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>Le paramètre n'a pas de balise param correspondante dans le commentaire XML (contrairement à d'autres paramètres)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>L'interface héritée '{1}' provoque un cycle dans la hiérarchie des interfaces de '{0}'</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>Nom de type ou d'espace de noms '{0}' introuvable dans l'espace de noms global (vous manque-t-il une référence d'assembly ?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>Impossible d'attendre dans l'expression de filtre d'une clause catch</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>Les expressions d'initialiseur de tableau ne peuvent être utilisées que pour assigner des types tableau. Essayez plutôt d'utiliser une expression new.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>Les variables implicitement typées doivent être initialisées</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>La déclaration du paramètre de type doit être un identificateur et non un type</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>'{0}' : nouveau membre protected déclaré dans struct</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>'{0}' : les classes static ne peuvent pas contenir de membres protected</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>'{0}' : impossible de déclarer des membres d'instance dans une classe static</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Les exécutables ne peuvent pas être des assemblys satellites ; la culture doit toujours être vide</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>L'utilisation du mot clé 'base' n'est pas valide dans ce contexte</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>Le type '{0}' est défini dans un assembly qui n'est pas référencé. Vous devez ajouter une référence à l'assembly '{1}'.</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>'{0}' ajoute un accesseur introuvable dans le membre d'interface '{1}'</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>Option non reconnue : '{0}'</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>Les méthodes Async ne sont pas autorisées dans une interface, une classe ou une structure qui a un attribut 'SecurityCritical' ou 'SecuritySafeCritical'.</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>Le premier opérande d'un opérateur 'is' ou 'as' ne peut pas être une expression lambda, une méthode anonyme ou un groupe de méthodes.</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>L'accès au tableau ne peut pas avoir un spécificateur d'argument nommé</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>Impossible d'utiliser un groupe de méthodes comme argument pour une opération distribuée dynamiquement. Souhaitiez-vous appeler la méthode ?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>Impossible d'utiliser un champ readonly en tant que valeur ref ou out (sauf dans un constructeur)</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>GetDeclarationName appelé pour un nœud de déclaration susceptible de contenir plusieurs déclarateurs de variable.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>Cette erreur survient si vous avez une méthode surchargée qui prend un tableau en escalier et que la seule différence entre les signatures de méthode est le type d'élément du tableau. Pour éviter cette erreur, nous vous conseillons les méthodes suivantes : utilisez un tableau rectangulaire plutôt qu'un tableau en escalier, utilisez un paramètre supplémentaire pour supprimer l'ambiguïté de l'appel de fonction, renommez une ou plusieurs des méthodes surchargées ou, si la conformité CLS est facultative, supprimez l'attribut CLSCompliantAttribute.</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>Les noms d'éléments tuples de la signature de la méthode '{0}' doivent correspondre aux noms d'éléments tuples de la méthode d'interface '{1}' (notamment pour le type de retour).</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>Attribut '{0}' en double dans '{1}'</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>fonction async</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Format des informations de débogage non valide : {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>Voulez-vous utiliser l'étiquette de changement par défaut ('default:') à la place de 'case default:' ? Si vous souhaitez vraiment utiliser le littéral par défaut, choisissez 'case (default):' ou un autre littéral ('case 0:' ou 'case null:') selon les besoins.</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>Les méthodes ne peuvent pas avoir de paramètres unsafe ou de types de retour</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>Un membre se substitue au membre obsolète</value>
  </data>
  <data name="ERR_AssignReadonlyNotField" xml:space="preserve">
    <value>Impossible d'effectuer l'assignation à {0} '{1}', car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>Les méthodes async ne peuvent pas avoir de variables locales par référence</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>Seules les propriétés implémentées automatiquement peuvent avoir des initialiseurs.</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>Impossible de créer le nom de fichier court '{0}', car il existe déjà un nom de fichier long avec ce même nom de fichier court</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#warning : '{0}'</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>Un membre statique '{0}' ne peut pas être marqué comme override, virtual ou abstract</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>La partie gauche d'une assignation doit être une variable, une propriété ou un indexeur</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>Un membre '{0}' marqué comme override ne peut pas être marqué comme new ou virtual</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>Les deux déclarations de méthodes partielles, '{0}' et '{1}', doivent utiliser les mêmes noms d'éléments tuples.</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>Les membres struct ne peuvent pas retourner 'this' ou d'autres membres d'instance par référence</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>'{0}' : les chemins de code ne retournent pas tous une valeur</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>Le switch case a déjà été pris en charge par un case antérieur.</value>
  </data>
  <data name="ERR_EscapeCall" xml:space="preserve">
    <value>Impossible d'utiliser un résultat de '{0}' dans ce contexte, car il peut exposer les variables référencées par le paramètre '{1}' en dehors de la portée de leur déclaration</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>Impossible de transmettre le type '{0}', car il s'agit d'un type imbriqué de '{1}'</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>Commentaire sur une seule ligne ou fin de ligne attendue</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>La contrainte ne peut pas être du type dynamic</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>Le paramètre out '{0}' doit être assigné avant que le contrôle quitte la méthode actuelle</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>Nom non valide pour un symbole de prétraitement. Identificateur non valide</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>Le suffixe 'l' risque d'être facilement confondu avec le chiffre '1' -- utilisez plutôt 'L'</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>'{0}' dans une déclaration d'interface explicite n'est pas une interface</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>'{0}' : impossible de substituer '{1}', car il n'est pas pris en charge par le langage</value>
  </data>
  <data name="ERR_BadParameterModifiers" xml:space="preserve">
    <value> Impossible d'utiliser le modificateur de paramètre '{0}' avec '{1}'</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>Impossible d'utiliser un membre '{0}' ne pouvant pas être appelé comme une méthode.</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>Une valeur ref ou out doit être une variable qui peut être assignée</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>SyntaxTreeSemanticModel doit être indiqué pour fournir une qualification de type minimale.</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>Le type '{0}' est défini dans un module qui n'a pas été ajouté. Vous devez ajouter le module '{1}'.</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>L'espace de noms '{1}' dans '{0}' est en conflit avec le type '{3}' dans '{2}'</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>'{0}' : un constructeur statique ne doit pas avoir de paramètres</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>Un paramètre out ne peut pas avoir l'attribut In</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>groupe de méthodes</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>Le champ n'est jamais assigné et aura toujours sa valeur par défaut</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>La méthode '{0}' a un modificateur de paramètre 'this' qui ne figure pas dans le premier paramètre</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>Les guillemets non ASCII ne peuvent pas être utilisés avec les littéraux de chaîne.</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>Une classe de base est requise pour une référence 'base'</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>Directive de préprocesseur inattendue</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>La vérification de conformité CLS ne sera pas effectuée sur '{0}', car il n'est pas visible hors de cet assembly</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>'{0}' : substitution impossible, car '{1}' n'est pas une propriété</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>Une expression de type '{0}' ne peut pas être gérée par un modèle de type '{1}' en C# {2}. Utilisez la version de langage {3} ou une version ultérieure.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>La variable '{0}' est assignée, mais sa valeur n'est jamais utilisée</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>Le nom d'élément de tuple '{0}' est uniquement autorisé à la position {1}.</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>Présence de plusieurs modificateurs de protection</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>La syntaxe de l'attribut cref '{0}' du commentaire XML est incorrecte</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>'{0}' n'est pas pris en charge par le langage</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise paramref, alors qu'il n'existe aucun paramètre de ce nom</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>L'opérateur 'await' peut seulement être utilisé dans une méthode async. Marquez cette méthode avec le modificateur 'async' et changez son type de retour en 'Task'.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>Impossible de mettre à jour '{0}' ; l'attribut '{1}' est manquant.</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>'{0}' : nouveau membre protected déclaré dans la classe sealed</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>Le contrôle ne peut pas passer d'une étiquette case ('{0}') à une autre</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>Impossible de convertir {0} en type '{1}', car il ne s'agit pas d'un type délégué</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>Une expression lambda avec un corps d'instruction ne peut pas être convertie en arborescence de l'expression</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Compilateur Microsoft (R) Visual C#</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>Impossible de convertir le type '{0}' en '{1}' via une conversion de référence, une conversion boxing, une conversion unboxing, une conversion wrapping ou une conversion null type</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>Un pointeur ne doit être indexé que par une seule valeur</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>Numéro d'avertissement incorrect</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>variables locales et retours byref</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>Impossible de passer un argument avec un type dynamique au paramètre params '{0}' de la fonction locale '{1}'.</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>La méthode interop incorporée '{0}' contient un corps.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>La meilleure méthode Add surchargée '{0}' pour l'élément initialiseur de collection est obsolète.</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>dynamique</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>Impossible d'utiliser la variable locale '{0}' tant qu'elle n'est pas déclarée. La déclaration de la variable locale masque le champ '{1}'.</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>Impossible de définir/annuler la définition des symboles de préprocesseur à la suite du premier jeton du fichier</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>Les options de compilation '{0}' et '{1}' ne peuvent pas être spécifiées toutes les deux en même temps.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute n'aura pas d'effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas d'arguments facultatifs</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>L'opération engendre un dépassement de capacité au moment de la compilation dans le mode checked</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>qualificateur d'alias d'espace de noms</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>Une instruction throw sans argument n'est pas autorisée à l'extérieur d'une clause catch</value>
  </data>
  <data name="ERR_BadSpecialByRefIterator" xml:space="preserve">
    <value>L'instruction foreach ne peut pas fonctionner sur les énumérateurs de type '{0}' dans les méthodes asynchrones ou les méthodes d'itérateurs, car '{0}' est un struct par référence.</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>L'événement '{0}' n'est jamais utilisé</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>Le commentaire XML n'est pas placé dans un élément valide du langage</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Erreur d'écriture dans le fichier de documentation XML : {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>génériques</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>Interface '{0}' marquée avec 'CoClassAttribute' et non avec 'ComImportAttribute'</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>Impossible d'utiliser les champs de '{0}' en tant que valeur ref ou out, car il s'agit d'un '{1}'</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>Utilisation d'une propriété implémentée automatiquement éventuellement non assignée : '{0}'</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>Le champ '{0}' n'est jamais utilisé</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>Cette étiquette n'est pas référencée</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>Argument d'attribut nommé '{0}' en double</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>Impossible de faire référence à une variable de type '{0}'</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>L'opérateur 'await' peut seulement être utilisé lorsqu'il est contenu dans une méthode ou une expression lambda marquée avec le modificateur 'async'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir un littéral de tuple.</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>Comparaison effectuée avec la même variable</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>Impossible d'utiliser un littéral par défaut en tant qu'argument d'une opération distribuée dynamiquement.</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>Les expressions d'initialiseur d'objet et de collection ne peuvent pas être appliquées à une expression de création de délégué</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>Le commentaire XML a une balise typeparam en double pour '{0}'</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>'{0}' : les conversions définies par l'utilisateur vers ou à partir d'une classe dérivée ne sont pas autorisées</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>'{0}' n'est pas un spécificateur de format valide</value>
  </data>
  <data name="ERR_RefConditionalAndAwait" xml:space="preserve">
    <value>'await' ne peut pas être utilisé dans une expression contenant un opérateur conditionnel ref</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>Un assembly avec le même nom simple '{0}' a déjà été importé. Essayez de supprimer une des références (par exemple, '{1}') ou signez-les pour permettre le côte à côte.</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>L'opérateur 'await' ne peut pas être utilisé dans un initialiseur de variable de script statique.</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>Impossible d'hériter de l'interface '{0}' avec les paramètres de type spécifiés, car cela entraîne des surcharges dans la méthode '{1}' qui diffèrent uniquement au niveau des paramètres ref et out</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>Le nom '{0}' n'est pas dans la portée à gauche de 'equals'. Échangez les expressions de chaque côté de 'equals'.</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>Impossible d'appliquer CallerFilePathAttribute, car il n'existe pas de conversion standard du type '{0}' en type '{1}'</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>L'identificateur '{0}', qui se différencie uniquement dans case, n'est pas conforme CLS</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>Accessibilité incohérente : le type de propriété '{1}' est moins accessible que la propriété '{0}'</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>Erreur lors de l'ouverture du fichier de ressources Win32 '{0}' -- '{1}'</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>Spécificateur de format vide.</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>Opérateur OU au niveau du bit utilisé sur un opérande de signe étendu</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>Le résultat de l'expression est toujours le même, car une valeur de ce type n'est jamais égale à 'null'</value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>Échec de l'accès de membre à identificateur transparent pour le champ '{0}' de '{1}'. Les données interrogées implémentent-elles le modèle de requête ?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>Impossible d'appliquer CallerLineNumberAttribute, car il n'existe pas de conversion standard du type '{0}' en type '{1}'</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>'extern alias' n'est pas valide dans ce contexte</value>
  </data>
  <data name="ERR_RefConditionalNeedsTwoRefs" xml:space="preserve">
    <value>Les deux valeurs d'opérateur conditionnel doivent être des valeurs ref. Sinon, aucune d'elles ne doit être une valeur ref</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>Impossible d'incorporer le type '{0}', car il s'agit d'un type imbriqué. Attribuez à la propriété 'Incorporer les types interop' la valeur false.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>Vous ne pouvez pas spécifier l'attribut CLSCompliant sur un module qui diffère de l'attribut CLSCompliant de l'assembly</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}. Voir aussi l'erreur CS{1}.</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>Type de base non valide</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>Le nom de type '{0}' n'existe pas dans le type '{1}'</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value> Aucun élément correspondant n'a été trouvé pour la balise include suivante </value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>Le type se substitue à Object.Equals(object o) mais pas à Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>La valeur 'goto case' n'est pas implicitement convertible en type switch</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>L'option de compilateur /doc a été spécifiée, mais un ou plusieurs constructeurs n'avaient pas de commentaires.</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>'{0}' : impossible de substituer le membre hérité '{1}', car il n'est pas marqué comme virtual, abstract ou override</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>Le nom de paramètre '{0}' est un doublon</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>'{0}' : les modificateurs d'accès ne sont pas autorisés sur les constructeurs statiques</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>Utilisation inattendue d'un nom générique indépendant</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>L'accesseur '{0}' ne peut pas implémenter le membre d'interface '{1}' pour le type '{2}'. Utilisez une implémentation d'interface explicite.</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>Soit les deux déclarations de méthode partielles sont des méthodes d'extension, soit aucune ne l'est</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Catch ou finally attendu</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>Une expression new exige que type soit suivi de (), [] ou {}</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>La variable est déclarée mais jamais utilisée</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>Fin de fichier trouvée, '*/' attendu</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>Impossible de référencer la compilation de type '{0}' à partir de la compilation {1}.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>'{0}' masque le membre hérité '{1}'. Pour que le membre actif se substitue à cette implémentation, ajoutez le mot clé override. Sinon, ajoutez le mot clé new.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'. '{2}' ne peut pas implémenter un membre d'interface, car il n'est pas public.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>SemanticModel {0} attendu.</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>opérateur par défaut</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>Les déclarations de variable de sortie et de variable de modèle ne sont pas autorisées dans une clause de requête.</value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>Impossible d'assigner une valeur de type 'void'.</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>littéral par défaut</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>Une expression de type '{0}' ne peut pas être gérée par un modèle de type '{1}'.</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>Options spécifiées en conflit : fichier de ressources Win32 ; icône Win32</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>L'attribut est ignoré quand une signature publique est spécifiée.</value>
  </data>
  <data name="ERR_TypeReserved" xml:space="preserve">
    <value>L'utilisation du nom de type '{0}' est réservée au compilateur.</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>Le nom '{0}' n'est pas dans la portée à droite de 'equals'. Échangez les expressions de chaque côté de 'equals'.</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>'{0}' : impossible de changer les noms d'éléments tuples en cas de substitution du membre hérité '{1}'</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>La longueur combinée des chaînes utilisateur que le programme utilise dépasse la limite autorisée. Essayez de réduire le nombre de littéraux de chaîne.</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>{ attendue</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>Le suffixe 'l' risque d'être facilement confondu avec le chiffre '1'</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>Caractère inattendu à cet emplacement.</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>'&gt;' ou '/&gt;' était attendu pour fermer la balise '{0}'.</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>Le type de paramètre n'a pas de balise typeparam correspondante dans le commentaire XML (contrairement à d'autres paramètres)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>La définition d'un alias nommé 'global' n'est pas très judicieuse dans la mesure où 'global::' fait toujours référence à l'espace de noms global et non à un alias</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>CallerMemberNameAttribute, appliqué au paramètre '{0}', n'aura aucun effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas les arguments facultatifs</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>Le paramètre de constructeur d'attribut '{0}' est de type '{1}', qui n'est pas un type de paramètre d'attribut valide</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>Modificateur de variance non valide. Seuls les paramètres de type d'interface et délégué peuvent être spécifiés comme étant variants.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>La méthode surchargée qui se différencie uniquement au niveau de ref ou out ou du rang de tableau n'est pas conforme CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>'{0}' : un champ volatile ne peut pas être de type '{1}'</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>Une expression stackalloc exige la présence de [] à la suite du type</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>Déclarateur de membre de type anonyme non valide. Les membres de type anonyme doivent être déclarés avec une assignation de membre, un nom simple ou un accès membre.</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>Un tuple ne doit pas contenir de valeur de type 'void'.</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>Impossible de spécifier uniquement un attribut Out sur un paramètre ref. Utilisez les deux attributs In et Out ou aucun des deux.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>Fichier source '{0}' indiqué plusieurs fois</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>Les membres de la propriété '{0}' de type '{1}' ne peuvent pas être assignés avec un initialiseur d'objet, car il s'agit d'un type valeur</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>'{0}' : les structs ne peuvent pas appeler les constructeurs de classe de base</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>Un type n'implémente pas le modèle de la collection ; les membres sont ambigus</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>stackalloc ne peut être utilisé dans un bloc catch ou finally</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>Un littéral de chaîne était attendu, mais aucun guillemet ouvrant n'a été trouvé.</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>'{0}' ne peut pas être extern et déclarer un corps</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>Expression de préprocesseur non valide</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>Le mot clé 'this' n'est pas disponible dans le contexte actuel</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>Le SyntaxTree '{0}' résulte d'une directive #load, et ne peut pas être supprimé ou remplacé directement.</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>Directive #pragma non reconnue</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>Un type anonyme ne peut pas avoir plusieurs propriétés du même nom</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>Le nom '{0}' dépasse la longueur maximale autorisée dans les métadonnées.</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>Une directive 'using static' ne peut pas être utilisée pour déclarer un alias</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>Assignation effectuée à la même variable ; souhaitiez-vous assigner un autre élément ?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>L'événement n'est jamais utilisé</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>L'événement '{0}' ne peut apparaître qu'à gauche de += ou -=</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> Balise include non valide </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>Le redirecteur de type pour le type '{0}' dans l'assembly '{1}' provoque un cycle</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>Le type '{0}' contient déjà une définition pour '{1}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir un appel qui utilise des arguments facultatifs</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>Impossible d'ouvrir le fichier de métadonnées '{0}' -- {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>La comparaison avec null de type '{0}' produit toujours 'false'</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>module en tant que spécificateur cible d'attribut</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>Cet avertissement peut être généré lorsque deux méthodes d'interface sont uniquement différenciées si un paramètre particulier est marqué avec ref ou avec out. Nous vous recommandons de modifier votre code pour éviter cet avertissement, car la méthode appelée au démarrage n'est ni évidente, ni garantie.

Même si le langage C# permet de faire la différence entre out et ref, ce n'est pas le cas pour le CLR. Lors du choix de la méthode d'implémentation de l'interface, le CLR en sélectionne simplement une.

Permettez au compilateur de différencier les méthodes. Par exemple, vous pouvez leur donner différents noms ou fournir un paramètre supplémentaire à l'une d'elles.</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>Impossible d'utiliser #r à la suite du premier jeton du fichier</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'. '{2}' ne peut pas implémenter un membre d'interface, car il est static.</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>Impossible d'initialiser une variable par référence avec une valeur</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>argument nommé</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>Le type prédéfini '{0}' est défini dans plusieurs assemblys de l'alias global ; utilisation de la définition de '{1}'</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir d'appel à une méthode, une propriété ou un indexeur qui effectue un retour par référence</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>Une méthode partielle ne peut pas avoir de modificateurs d'accès ou de modificateurs virtual, abstract, override, new, sealed ou extern</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>Signe égal manquant entre l'attribut et la valeur d'attribut.</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>Impossible de déconstruire un tuple de '{0}' éléments en '{1}' variables.</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre abstrait hérité '{1}'</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>Impossible de créer une instance du type de variable '{0}', car il n'a pas de contrainte new()</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>Impossible de déduire le type de '{0}', car son initialiseur fait directement ou indirectement référence à la définition.</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#load n'est autorisé que dans les scripts</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>La méthode surchargée '{0}', qui se différencie uniquement par les types de tableau sans nom, n'est pas conforme CLS</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>La contrainte 'class' ou 'struct' doit être placée avant toutes les autres contraintes</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>Un argument d'attribut doit être une expression constante, une expression typeof ou une expression de création de tableau d'un type de paramètre d'attribut</value>
  </data>
  <data name="IDS_FeatureReadOnlyStructs" xml:space="preserve">
    <value>structs en lecture seule</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;expression throw&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>types partiels</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>Le paramètre générique est definition alors que la référence attendue était {0}</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>La syntaxe 'var (...)' en tant que lvalue est réservée.</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>Option /noconfig ignorée, car elle était spécifiée dans un fichier réponse</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>Opérande non valide pour les critères spéciaux ; la valeur nécessaire n'est pas celle trouvée, '{0}'.</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>'{0}' : une propriété ou un indexeur ne peut pas être de type void</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>'{0}' : impossible de substituer le membre hérité '{1}', car il est sealed</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>Les itérateurs ne peuvent pas avoir de paramètres ref ou out</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>Tous les arguments de la propriété indexée '{0}' doivent être facultatifs</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>Utilisation du paramètre lambda incohérente ; les types de paramètres doivent être tous explicites ou tous implicites</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>Impossible de charger l'assembly Analyseur</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>Impossible de déduire le type d'une variable implicitement typée abandonnée.</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>Le type '{0}' dans la liste des interfaces n'est pas une interface</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>élément</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>Le paramètre __arglist doit être le dernier paramètre spécifié dans une liste de paramètres formels</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir l'opérateur de comparaison avec critères spéciaux 'is'.</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>Les attributs ne sont pas autorisés sur les paramètres de fonction locale ou les paramètres de type</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>Conversions définies par l'utilisateur ambiguës '{0}' et '{1}' lors de la conversion de '{2}' en '{3}'</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>Impossible d'incorporer le type interop '{0}'. Utilisez plutôt l'interface applicable.</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>L'expression doit être de type '{0}', car elle est assignée par référence</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>L'assembly ne contient pas d'analyseur</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>Indexation d'un tableau avec un index négatif</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>Les propriétés qui effectuent un retour par référence ne peuvent pas avoir d'accesseurs set</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>Erreur de syntaxe de ligne de commande : ':&lt;numéro&gt;' manquant pour l'option '{0}'</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>Une référence au type '{0}' déclare qu'il est défini dans '{1}', mais il est introuvable</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>Assignation potentiellement incorrecte à la variable locale '{0}', qui est l'argument d'une instruction using ou lock. L'appel Dispose ou le déverrouillage se produira sur la valeur d'origine de la variable locale.</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>Impossible de convertir un tuple avec {0} éléments en type '{1}'.</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>Le caractère '&lt;' ne peut pas être utilisé dans une valeur d'attribut.</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>Syntaxe de #pragma checksum non valide ; doit être #pragma checksum "nom_fichier" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>par invariance</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>'{0}' est utilisé à des fins d'évaluation uniquement. Il sera peut-être changé ou supprimé au cours des prochaines mises à jour.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>La position ne se trouve pas dans l'étendue complète {0} de l'arborescence de syntaxe</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>Impossible de définir une nouvelle méthode d'extension, car le type requis par le compilateur '{0}' est introuvable. Vous manque-t-il une référence à System.Core.dll ?</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>Pour être applicable en tant qu'opérateur de court-circuit, un opérateur logique défini par l'utilisateur ('{0}') doit avoir le même type de retour et les mêmes types de paramètre</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>Comparaison effectuée avec la même variable ; souhaitiez-vous comparer autre chose ?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>Un identificateur qui se différencie uniquement par la casse n'est pas conforme CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>Littéral réel non valide.</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>Vous ne pouvez pas utiliser l'instruction fixed pour prendre l'adresse d'une expression qui est déjà fixed</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>'{0}' n'a aucun constructeur accessible qui utilise uniquement des types conformes CLS</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>Échec de l'évaluation de l'expression constante décimale</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>L'étiquette '{0}' est un doublon</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>Un champ readonly ne peut pas être assigné (sauf s'il appartient à un constructeur ou un initialiseur de variable)</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>L'alias using '{0}' est apparu précédemment dans cet espace de noms</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>L'argument {0} doit être passé avec le mot clé '{1}'</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>Valeur non valide pour l'argument d'attribut nommé '{0}'</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>Contrainte '{0}' en double pour le paramètre de type '{1}'</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>Les membres du champ readonly '{0}' de type '{1}' ne peuvent pas être assignés avec un initialiseur d'objet, car il s'agit d'un type valeur</value>
  </data>
  <data name="ERR_FieldlikeEventsInRoStruct" xml:space="preserve">
    <value>Les événements comparables à des champs ne sont pas autorisés dans les structs en lecture seule.</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>Le modificateur 'async' ne peut être utilisé que dans des méthodes ayant un corps.</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' ne doivent pas spécifier des classes de base différentes</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>'{0}' est inaccessible en raison de son niveau de protection</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>Les membres hérités '{0}' et '{1}' ayant la même signature dans le type '{2}', ils ne peuvent pas être substitués</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>L'accès de l'indexeur doit être distribué dynamiquement, mais ne peut pas l'être car il fait partie d'une expression d'accès de base. Effectuez un cast des arguments dynamiques ou supprimez l'accès de base.</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>'{0}' n'a aucune méthode applicable nommée '{1}' mais semble avoir une méthode d'extension portant ce nom. Les méthodes d'extension ne peuvent pas être distribuées de façon dynamique. Effectuez un cast des arguments dynamiques ou appelez la méthode d'extension sans la syntaxe de méthode d'extension.</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>'{0}' : les propriétés abstraites ne peuvent pas avoir d'accesseurs private</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>L'expression donnée de l'expression 'is' n'est jamais du type fourni</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>Le format de la chaîne de version spécifiée n'est pas conforme au format requis - major.minor.build.revision</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>Erreur lors de l'ouverture du fichier manifeste Win32 {0} -- {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>'{0}' est un nouveau membre virtuel de la classe sealed '{1}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une propriété indexée</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>Syntaxe de checksum #pragma incorrecte</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>LookupOptions a une combinaison d'options non valide</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>Un initialiseur de tableau de longueur '{0}' est attendu</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>Impossible de retourner un champ readonly par référence accessible en écriture</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>Une expression switch ou une étiquette case doit être de type bool, char, string, integral, enum ou Nullable correspondant en C# 6 et dans les versions antérieures.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>L'emplacement doit être indiqué pour fournir une qualification de type minimale.</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>Les modules ajoutés doivent être marqués avec l'attribut CLSCompliant pour correspondre à l'assembly</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>Le type '{2}' doit être un type référence afin d'être utilisé comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>Une soumission ne peut inclure que du code de script.</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>'{0}' : substitution impossible, car '{1}' n'a pas d'accesseur get substituable</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>Une clause catch précédente intercepte déjà toutes les exceptions</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir d'opérateurs</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>'{0}' est un fichier binaire et non un fichier texte</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>L'expression switch doit être une valeur. '{0}' trouvé.</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>Impossible d'assigner '{0}' à une propriété de type anonyme</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>Impossible d'ouvrir '{0}' en écriture -- '{1}'</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>Possibilité d'instruction vide erronée</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>Impossible de créer un délégué à partir de la méthode '{0}', car il s'agit d'une méthode partielle sans déclaration d'implémentation</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>Ne pas substituer object.Finalize. Fournir un destructeur à la place.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>constructeur et destructeur du corps d'expression</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>'{0}' : impossible d'utiliser des propriétés implémentées automatiquement dans un type marqué avec StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>Nom de fichier entre guillemets, commentaire sur une seule ligne ou fin de ligne attendu</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>L'attribut cref '{0}' du commentaire XML fait référence à un paramètre de type</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>Le délégué '{0}' n'a pas de constructeur valide</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>La déconstruction doit contenir au moins deux variables.</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>La méthode d'extension '{0}' définie dans le type valeur '{1}' ne peut pas être utilisée pour créer des délégués</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>Accessibilité incohérente : la classe de base '{1}' est moins accessible que la classe '{0}'</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>Un goto case n'est valide qu'au sein d'une instruction switch</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>La classe System.Object ne peut pas posséder de classe de base ni implémenter une interface</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>'{0}' : impossible de modifier les modificateurs d'accès en cas de substitution du membre hérité '{2}' de '{1}'</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>Les indexeurs ne peuvent pas être de type void</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>Accessibilité incohérente : le type de paramètre '{1}' est moins accessible que l'opérateur '{0}'</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>Un champ const nécessite une valeur</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>Impossible de restaurer un avertissement 'CS{0}', car il a été désactivé globalement</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>L'introduction d'une méthode 'Finalize' peut interférer avec un appel destructeur. Souhaitiez-vous déclarer un destructeur ?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>Le corps de '{0}' ne peut pas être un bloc itérateur, car '{0}' effectue un retour par référence</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>Nombre d'index incorrect dans [] ; {0} attendu</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>La signature différée a été spécifiée et nécessite une clé publique, mais aucune clé publique n'a été spécifiée</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>Une méthode partielle ne peut pas avoir de paramètres out</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>Terme d'expression '{0}' non valide</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>Le modificateur d'accessibilité de l'accesseur '{0}' doit être plus restrictif que la propriété ou l'indexeur '{1}'</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>Le CallerFilePathAttribute peut seulement être appliqué aux paramètres avec des valeurs par défaut</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>Spécification de fichier manquante pour l'option '{0}'</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>Nom de fichier entre guillemets attendu</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>La conversion définie par l'utilisateur dans le type '{0}' est en double</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>Type byte, sbyte, short, ushort, int, uint, long ou ulong attendu</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>Utilisation inattendue d'un nom générique</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>'{0}' n'a pas besoin d'attribut CLSCompliant, car l'assembly n'en a pas</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>La signature de classe wrapper de coclasse managée '{0}' pour l'interface '{1}' n'est pas une signature de nom de classe valide</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>Le type '{1}' existe dans '{0}' et '{2}'</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>Le type est en conflit avec le type importé</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>Un caractère '{0}' ne peut faire l'objet d'une séquence d'échappement qu'en doublant '{0}{0}' dans une chaîne interpolée.</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>Élément include XML incorrect</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>Cet avertissement survient lorsque vous créez une classe avec une méthode dont la signature est public virtual void Finalize.

Si une telle classe est utilisée en tant que classe de base et si la classe dérivée définit un destructeur, celui-ci remplacera la méthode Finalize de la classe de base, et non Finalize.</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>N'utilisez pas l'attribut 'System.Runtime.CompilerServices.FixedBuffer'. Utilisez le modificateur de champ 'fixed' à la place.</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>L'utilisation de null n'est pas valide dans ce contexte</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>Le qualificateur d'alias d'espace de noms '::' est toujours résolu en type ou en espace de noms ; il est donc non conforme ici. Utilisez '.' à la place.</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>Impossible d'utiliser le paramètre de type '{0}' avec l'opérateur 'as', car il n'a pas de contrainte de type classe ni de contrainte 'class'</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>Le mot clé 'base' n'est pas disponible dans une méthode statique</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>Impossible d'initialiser le membre '{0}'. Il ne s'agit pas d'un champ ou d'une propriété.</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>Ambiguïté entre '{0}' et '{1}'</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction_Title" xml:space="preserve">
    <value>La fonction locale est déclarée mais jamais utilisée</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Erreur de syntaxe de ligne de commande : Guid manquant pour l'option '{1}'</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>L'assembly référencé '{0}' cible un processeur différent.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>Impossible d'assigner {0} à une variable implicitement typée</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Une erreur s'est produite durant l'écriture du fichier de sortie : {0}.</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>'{0}' : un constructeur statique ne peut pas avoir d'appel de constructeur 'this' ou 'base' explicite</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>variable d'environnement LIB</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>'{0}' ne peut pas implémenter '{1}', car '{2}' est un événement Windows Runtime et '{3}' est un événement .NET normal.</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>'{0}' est obsolète</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>'{0}' est de type '{1}'. Le type spécifié dans une déclaration de constante doit être sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, un type enum ou un type référence.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>Le format de la chaîne de version spécifiée n'est pas conforme au format requis - major.minor.build.revision</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>Le paramètre '{0}' n'a pas de balise param correspondante dans le commentaire XML pour '{1}' (contrairement à d'autres paramètres)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>La propriété indexée '{0}' a des arguments non facultatifs qui doivent être fournis</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>Pour que le type '{0}' soit utilisé comme AsyncMethodBuilder du type '{1}', sa propriété Task doit retourner le type '{1}' à la place du type '{2}'.</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>'{0}' : un champ ne peut pas être à la fois volatile et readonly</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>directive #endregion attendue</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>Le nom de paramètre '{0}' est en conflit avec un nom de paramètre généré automatiquement</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>Les paramètres de type ne sont pas autorisés sur un groupe de méthodes en tant qu'argument pour 'nameof'.</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>Accessibilité incohérente : le type de paramètre '{1}' est moins accessible que le délégué '{0}'</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>Une clause catch précédente intercepte déjà toutes les exceptions. Tous les objets levés autres que les exceptions seront inclus dans un wrapper dans System.Runtime.CompilerServices.RuntimeWrappedException.</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value> Impossible d'insérer tout ou partie du code XML inclus </value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>Impossible d'attendre '{0}'</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>Une déconstruction ne peut pas contenir à la fois des déclarations et des expressions à gauche.</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>Une valeur de constante est attendue</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>Le paramètre de type '{0}' a le même nom que le paramètre de type du type externe '{1}'</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>Impossible de convertir implicitement un littéral de type double en type '{1}' ; utilisez un suffixe '{0}' pour créer un littéral de ce type</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Options du compilateur Visual C#

                        - FICHIERS DE SORTIE -
 /out:&lt;fichier&gt;                Spécifier un nom de fichier de sortie (par défaut : nom de base du
                               fichier avec classe principale ou premier fichier)
 /target:exe                   Générer un fichier exécutable console (par défaut) (forme
                               abrégée : /t:exe)
 /target:winexe                Générer un fichier exécutable Windows (forme abrégée :
                               /t:winexe)
 /target:library               Générer une bibliothèque (forme abrégée : /t:library)
 /target:module                Générer un module qui peut être ajouté à un autre
                               assembly (forme abrégée : /t:module)
 /target:appcontainerexe       Générer un exécutable Appcontainer (forme abrégée :
                               /t:appcontainerexe)
 /target:winmdobj              Générer un fichier intermédiaire Windows Runtime
                               consommé par WinMDExp (forme abrégée : /t:winmdobj)
 /doc:&lt;fichier&gt;                Fichier de documentation XML à générer
 /refout:&lt;fichier&gt;             Référencer la sortie d'assembly à générer
 /platform:&lt;chaîne&gt;            Limiter les plateformes sur lesquelles ce code peut s'exécuter : x86,
                               Itanium, x64, arm, anycpu32bitpreferred ou
                               anycpu. La valeur par défaut est anycpu.

                        - FICHIERS D'ENTRÉE -
 /recurse:&lt;générique&gt;          Inclure tous les fichiers dans le répertoire et
                               les sous-répertoires actifs en fonction des
                               spécifications de caractères génériques
 /reference:&lt;alias&gt;=&lt;fichier&gt;  Référencer les métadonnées à partir du
                               fichier d'assembly spécifié via l'alias indiqué (forme abrégée : /r)
 /reference:&lt;liste_fichiers&gt;   Référencer les métadonnées à partir
                               des fichiers d'assembly spécifiés (forme abrégée : /r)
 /addmodule:&lt;liste_fichiers&gt;   Lier les modules spécifiés dans cet assembly
 /link:&lt;liste_fichiers&gt;        Incorporer les métadonnées à partir des
                               fichiers d'assembly d'interopérabilité spécifiés (forme abrégée : /l)
 /analyzer:&lt;liste_fichiers&gt;    Exécuter les analyseurs à partir de cet assembly
                               (Forme abrégée : /a)
 /additionalfile:&lt;liste_fich.&gt; Fichiers supplémentaires qui n'affectent pas directement
                               la génération de code mais qui peuvent être utilisés par les analyseurs pour produire
                               des erreurs ou des avertissements.
 /embed                        Incorporer tous les fichiers sources dans le fichier PDB.
 /embed:&lt;liste_fichiers&gt;       Incorporer des fichiers spécifiques dans le fichier PDB

                        - RESSOURCES -
 /win32res:&lt;fichier&gt;           Spécifier un fichier de ressources Win32 (.res)
 /win32icon:&lt;fichier&gt;          Utiliser cette icône pour la sortie
 /win32manifest:&lt;fichier&gt;      Spécifier un fichier manifeste (.xml) Win32
 /nowin32manifest              Ne pas inclure le manifeste Win32 par défaut
 /resource:&lt;resinfo&gt;           Incorporer la ressource spécifiée (forme abrégée : /res)
 /linkresource:&lt;resinfo&gt;       Lier la ressource spécifiée à cet assembly
                               (forme abrégée : /linkres), où le format resinfo
                               est &lt;fichier&gt;[,&lt;nom_chaîne&gt;[,public|private]]

                        - GÉNÉRATION DE CODE -
 /debug[+|-]                   Émettre des informations de débogage
 /debug:{full|pdbonly|portable|embedded}
                               Spécifier le type de débogage ('full' est la valeur par défaut,
                               'portable' est un format multiplateforme,
                               'embedded' est un format multiplateforme incorporé dans
                               le fichier .dll ou .exe cible)
 /optimize[+|-]                Activer les optimisations (forme abrégée : /o)
 /deterministic                Produire un assembly déterministe
                               (en incluant le GUID et l'horodatage de la version du module)
 /refonly                      Produire un assembly de référence à la place de la sortie principale
 /instrument:TestCoverage      Produire un assembly instrumenté pour collecter
                               les informations de couverture
 /sourcelink:&lt;fichier&gt;         Informations du lien source à incorporer dans le fichier PDB.

                        - ERREURS ET AVERTISSEMENTS -
 /warnaserror[+|-]             Signaler tous les avertissements comme des erreurs
 /warnaserror[+|-]:&lt;avertiss.&gt; Signaler des avertissements spécifiques comme des erreurs
 /warn:&lt;n&gt;                     Définir le niveau d'avertissement (0-4) (forme abrégée : /w)
 /nowarn:&lt;liste avertiss.&gt;     Désactiver des messages d'avertissement spécifiques
 /ruleset:&lt;fichier&gt;            Spécifier un fichier ruleset qui désactive des
                               diagnostics spécifiques.
 /errorlog:&lt;fichier&gt;           Spécifier un fichier pour journaliser tous les diagnostics du compilateur
                               et de l'analyseur.
 /reportanalyzer               Signaler des informations supplémentaires sur l'analyseur, comme
                               la durée d'exécution.

                        - LANGAGE -
 /checked[+|-]                 Générer des contrôles de dépassement de capacité
 /unsafe[+|-]                  Autoriser du code 'unsafe'
 /define:&lt;liste_symboles&gt;      Définir les symboles de compilation conditionnelle (forme
                               abrégée : /d)
 /langversion:?                Afficher les valeurs autorisées pour la version du langage
 /langversion:&lt;chaîne&gt;         Spécifier la version du langage, par exemple
                               'default' (dernière version principale) ou
                               'latest' (dernière version, en incluant les versions mineures),
                               ou des versions spécifiques comme '6' ou '7.1'

                        - SÉCURITÉ -
 /delaysign[+|-]               Différer la signature de l'assembly en utilisant uniquement
                               la partie publique de la clé de nom fort
 /publicsign[+|-]              Signer publiquement l'assembly en utilisant uniquement
                               la partie publique de la clé de nom fort
 /keyfile:&lt;fichier&gt;            Spécifier un fichier de clé de nom fort
 /keycontainer:&lt;chaîne&gt;        Spécifier un conteneur de clé de nom fort
 /highentropyva[+|-]           Activer la randomisation du format d'espace d'adresse d'entropie élevée

                        - DIVERS -
 @&lt;fichier&gt;                    Lire le fichier réponse pour plus d'options
 /help                         Afficher ce message d'utilisation (forme abrégée : /?)
 /nologo                       Supprimer le message de copyright du compilateur
 /noconfig                     Ne pas inclure automatiquement un fichier CSC.RSP
 /parallel[+|-]                Build simultanée.
 /version                      Afficher le numéro de version du compilateur et quitter le processus.

                        - AVANCÉ -
 /baseaddress:&lt;adresse&gt;        Adresse de base de la bibliothèque à générer
 /checksumalgorithm:&lt;alg&gt;      Spécifier l'algorithme de calcul de la somme de contrôle
                               de fichier source stockée dans le fichier PDB. Valeurs prises en charge :
                               SHA1 (par défaut) ou SHA256.
 /codepage:&lt;n&gt;                 Spécifier la page de codes à utiliser à l'ouverture
                               des fichiers sources
 /utf8output                   Messages du compilateur de sortie encodés en UTF-8
 /main:&lt;type&gt;                  Spécifier le type qui contient le point d'entrée
                               (ignorer tous les autres points d'entrée possibles) (forme
                               abrégée : /m)
 /fullpaths                    Le compilateur génère des chemins qualifiés complets
 /filealign:&lt;n&gt;                Spécifier l'alignement utilisé pour les
                               sections du fichier de sortie
 /pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                               Spécifier un mappage pour les noms de chemins sources sortis par
                               le compilateur.
 /pdb:&lt;fichier&gt;                Spécifier le nom du fichier des informations de débogage (par défaut :
                               nom du fichier de sortie avec l'extension .pdb)
 /errorendlocation             Ligne et colonne de sortie de l'emplacement final de
                               chaque erreur
 /preferreduilang              Spécifier le nom du langage de sortie préféré.
 /nostdlib[+|-]                Ne pas référencer la bibliothèque standard (mscorlib.dll)
 /subsystemversion:&lt;chaîne&gt;    Spécifier la version du sous-système de cet assembly
 /lib:&lt;liste_fichiers&gt;         Spécifier des répertoires supplémentaires dans lesquels rechercher les
                               références
 /errorreport:&lt;chaîne&gt;         Spécifier comment prendre en charge les erreurs internes du compilateur :
                               prompt, send, queue ou none. La valeur par défaut est
                               queue.
 /appconfig:&lt;fichier&gt;          Spécifier un fichier de configuration de l'application
                               contenant des paramètres de liaison d'assembly
 /moduleassemblyname:&lt;chaîne&gt;  Nom de l'assembly dont ce module
                               doit faire partie
 /modulename:&lt;chaîne&gt;          Spécifier le nom du module source
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>Erreur de syntaxe ; valeur attendue</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>'{0}' ne peut pas être sealed, car il ne s'agit pas d'une substitution</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#error : '{0}'</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>La variable de portée '{0}' a déjà été déclarée</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>Une clé publique de signature non valide a été spécifiée dans AssemblySignatureKeyAttribute.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>Le nom d'élément tuple '{0}' est ignoré, car un autre nom est spécifié ou aucun nom n'est spécifié par le type cible '{1}'.</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>Cet avertissement survient lorsque vous essayez d'appeler une méthode, une propriété ou un indexeur sur le membre d'une classe dérivant de MarshalByRefObject, et que ce membre est un type de valeur. Les objets héritant de MarshalByRefObject doivent généralement être marshalés par référence dans un domaine d'application. Si un code tente d'accéder directement au membre de type valeur d'un tel objet dans un domaine d'application, cela entraîne une exception de runtime. Pour résoudre cet avertissement, veuillez d'abord copier le membre dans une variable locale, avant d'appeler la méthode sur cette variable.</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>Deux indexeurs ont des noms différents ; l'attribut IndexerName doit être utilisé avec le même nom sur chaque indexeur d'un type</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>'await' nécessite que le type de retour '{0}' de '{1}.GetAwaiter()' ait des membres IsCompleted, OnCompleted et GetResult appropriés et qu'ils implémentent INotifyCompletion ou ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>'{0}' est une référence ambiguë entre '{1}' et '{2}'</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>L'option se substitue à l'attribut spécifié dans un fichier source ou un module ajouté</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>Les méthodes partielles doivent avoir un type de retour void</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>Dépendance de classe de base circulaire impliquant '{0}' et '{1}'</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>Identificateur ou littéral numérique attendu</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>Impossible de convertir implicitement le type '{0}' en '{1}'</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>Impossible d'inclure le fragment XML</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>'{0}' : l'événement dans l'interface ne peut pas avoir d'initialiseur</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>Le constructeur '{0}' ne peut pas s'appeler lui-même</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>Un commentaire sur une seule ligne ne doit pas être utilisé dans une chaîne interpolée.</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>Une variable ou une fonction locale nommée '{0}' est déjà définie dans cette portée</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>Les numéros de mise en production et/ou de version des deux assemblys diffèrent. Pour procéder à l'unification, veuillez spécifier les directives adéquates dans le fichier .config de l'application et fournir le nom fort correct d'un assembly.</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>Impossible de modifier la valeur de retour de '{0}' car il ne s'agit pas d'une variable</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>'{0}' : le type de base '{1}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>Impossible d'assigner à '{0}', car il est en lecture seule</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>Le paramètre {0} est déclaré comme type '{1}{2}' mais doit être '{3}{4}'</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Erreur lors de la lecture du fichier '{0}' spécifié pour l'argument nommé '{1}' pour l'attribut PermissionSet : '{2}'</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>Une clause de contrainte a déjà été spécifiée pour le paramètre de type '{0}'. Toutes les contraintes spécifiées pour un paramètre de type doivent l'être dans une seule clause where.</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>Impossible d'attendre 'void'</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>Impossible de retourner la variable locale '{0}' par référence, car il ne s'agit pas d'une variable locale de référence</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>L'appel du constructeur doit être distribué dynamiquement, mais ne peut pas l'être car il fait partie d'un initialiseur de constructeur. Effectuez un cast des arguments dynamiques.</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>Impossible de déduire le type de variable de sortie implicitement typée. '{0}'.</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>Impossible d'incorporer les types interop de l'assembly '{0}', car l'attribut '{1}' est manquant.</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>initialiseur d'objet</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>Les variables implicitement typées ne peuvent pas avoir plusieurs déclarateurs</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField" xml:space="preserve">
    <value>Impossible de retourner {0} '{1}' par référence accessible en écriture, car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>Un espace de noms ne peut pas contenir directement des membres tels que des champs ou des méthodes</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>La modificateur de membre '{0}' doit précéder le type et le nom de membre</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>} attendue</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>Bloc switch vide</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>Argument d'attribut nommé attendu</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>Le paramètre contient plusieurs valeurs par défaut distinctes.</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>L'argument de type '{0}' n'est pas applicable pour l'attribut DefaultParameterValue</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>La conversion définie par l'utilisateur doit convertir vers le type englobant ou à partir de celui-ci</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>Le membre '{0}' de la structure de type '{1}' engendre un cycle dans la disposition de la structure</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>Le type de contrainte n'est pas conforme CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>Impossible d'appliquer la classe d'attributs '{0}', car elle est abstract</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>'{0}' doit déclarer un corps, car il n'est pas marqué comme abstract, extern ou partial</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Impossible d'atteindre le code détecté</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>Cette méthode async n'a pas d'opérateur 'await' et elle s'exécutera de façon synchrone. Utilisez l'opérateur 'await' pour attendre les appels d'API non bloquants ou 'await Task.Run(…)' pour effectuer un travail utilisant le processeur sur un thread d'arrière-plan.</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>La variable de portée '{0}' ne peut pas avoir le même nom qu'un paramètre de type de méthode</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>Aucun constructeur n'est défini pour le type '{0}'</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>méthode anonyme</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Un script est attendu (fichier .csx), mais aucun n'est spécifié</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>types Nullable</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>Option /noconfig ignorée, car elle était spécifiée dans un fichier réponse</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>La déconstruction de 'var (...)' form interdit un type spécifique pour 'var'.</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>Le numéro de ligne spécifié pour la directive #line est manquant ou non valide</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> Impossible d'inclure le fichier XML "{0}" incorrect </value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>Impossible de charger l'assembly Analyseur {0} : {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>L'opérateur défini par l'utilisateur '{0}' doit être déclaré static et public</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>Déclaration non valide ; utilisez plutôt l'opérateur '{0} &lt;dest-type&gt; (...'</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>'{0}' : les types static ne peuvent pas être utilisés en tant que types de retour</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>'{0}' ne doit pas avoir de paramètre params, car '{1}' n'en possède pas</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>Impossible de créer le fichier temporaire -- {0}</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>La meilleure surcharge pour '{0}' n'a pas de paramètre nommé '{1}'</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>Le paramètre de type '{0}' a le même nom que le type conteneur ou la méthode</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>Un membre masque un membre hérité ; le mot clé new est manquant</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>Une méthode partielle doit être déclarée au sein d'une classe partielle ou d'une structure partielle</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>Le type '{1}' dans '{0}' est en conflit avec l'espace de noms importé '{3}' dans '{2}'. Utilisation du type défini dans '{0}'.</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>L'espace de noms '{1}' dans '{0}' est en conflit avec le type importé '{3}' dans '{2}'. Utilisation de l'espace de noms défini dans '{0}'.</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>La méthode Add surchargée '{0}' correspondant le mieux à l'initialiseur de collection a des arguments non valides</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>La création de tableau doit posséder une taille de tableau ou un initialiseur de tableau</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>Le paramètre de type '{0}' n'a pas de balise typeparam correspondante dans le commentaire XML de '{1}' (contrairement à d'autres paramètres de type)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>L'assignation dans une expression conditionnelle est toujours constante ; voulez-vous utiliser == au lieu de = ?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>Impossible d'appliquer la classe d'attributs '{0}', car elle est générique</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>Erreur lors de la lecture du fichier manifeste Win32 '{0}' -- '{1}'</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>L'attribut '{0}' du module '{1}' sera ignoré au profit de l'instance présente dans la source</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>Impossible d'assigner {0} à une variable de portée</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>Un paramètre params doit être le dernier paramètre dans une liste de paramètres formels</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>Une instruction throw sans argument n'est pas autorisée dans une clause finally qui est imbriquée dans la clause catch englobante la plus proche</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>Le tuple doit contenir au moins deux éléments.</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>Le type '{0}' ne peut pas être utilisé comme argument de type</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>Impossible d'incorporer le type interop '{0}', car il lui manque l'attribut '{1}' obligatoire.</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>Une expression lambda async convertie en délégué retournant 'Task' ne peut pas retourner une valeur. Souhaitiez-vous retourner 'Task&lt;T&gt;' ?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>Le nom de langue '{0}' n'est pas valide.</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>Impossible d'utiliser plusieurs types dans une instruction for, using, fixed ou declaration</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>La variable de portée '{0}' ne peut pas être assignée à -- elle est en lecture seule</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>'{0}' ne contient pas de constructeur qui accepte des arguments {1}</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>Les chaînes de culture d'assembly ne peuvent pas contenir de caractères null incorporés.</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>Il n'est pas correct d'utiliser le type Nullable '{0}' dans un modèle. Utilisez le type sous-jacent '{1}' à la place.</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>Soit les deux déclarations de méthode partielles utilisent un paramètre params, soit aucune des deux</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>'{0}' dans la déclaration d'interface explicite n'est pas un membre d'interface</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>Le type '{1}' dans '{0}' est en conflit avec le type importé '{3}' dans '{2}'. Utilisation du type défini dans '{0}'.</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>Les éléments de tableau ne peuvent pas être de type '{0}'</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>Les modificateurs ne peuvent pas être placés sur des déclarations d'accesseurs d'événement</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>La classe de base '{0}' doit précéder les interfaces</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Options spécifiées en conflit : fichier de ressources Win32 ; manifeste Win32</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>Les itérateurs ne peuvent pas avoir de paramètres unsafe ou de types yield</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>Impossible d'appliquer CallerMemberNameAttribute, car il n'existe pas de conversion standard du type '{0}' en type '{1}'</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>Impossible de retourner par référence un membre du paramètre '{0}', car il ne s'agit pas d'un paramètre ref ou out</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(Emplacement du symbole par rapport à l'erreur précédente)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>Impossible de générer une valeur dans le corps d'une clause catch</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>S'agissant d'une méthode async, l'expression de retour doit être de type '{0}' plutôt que 'Task&lt;{0}&gt;'</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>{ ou ; attendu</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>Le mot clé 'this' n'est pas valide dans un initialiseur de propriété statique, de méthode statique ou de champ statique</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>paramètre facultatif</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>Le chemin de recherche spécifié n'est pas correct</value>
  </data>
  <data name="ERR_RefReturnThis" xml:space="preserve">
    <value>Impossible de retourner 'this' par référence.</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>Le type interop qui correspond au type interop incorporé '{0}' est introuvable. Vous manque-t-il une référence d'assembly ?</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>Cet avertissement survient si les attributs de l'assembly AssemblyKeyFileAttribute ou AssemblyKeyNameAttribute trouvés dans la source entrent en conflit avec l'option de ligne de commande /keyfile ou /keycontainer ou le nom de fichier clé ou le conteneur clé indiqué dans les propriétés du projet.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>Cet avertissement indique qu'un attribut, tel que InternalsVisibleToAttribute, n'a pas été spécifié correctement.</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>Une déclaration de variable par référence doit avoir un initialiseur</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>'MethodImplOptions.Synchronized' ne peut pas être appliqué à une méthode async</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>Impossible de retourner un paramètre '{0}' par référence, car il ne s'agit pas d'un paramètre ref ou out</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>Les éléments définis dans un espace de noms ne peuvent pas être explicitement déclarés comme private, protected ou protected internal ou private protected</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>L'option /moduleassemblyname ne peut être spécifiée que lors de la génération d'un type cible de 'module'</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>Le paramètre de type '{0}' hérite des contraintes en conflit '{1}' et '{2}'</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>L'identificateur de ressource '{0}' a déjà été utilisé dans cet assembly</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>La valeur de paramètre par défaut pour '{0}' doit être constante au moment de la compilation</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>Le programme ne contient pas de méthode 'Main' statique adaptée à un point d'entrée</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>Cette erreur survient quand un type de système prédéfini tel que System.Int32 est trouvé dans deux assemblys. Cela peut se produire quand vous référencez mscorlib ou System.Runtime.dll depuis deux emplacements différents, comme si vous tentiez d'exécuter deux versions du .NET Framework côte à côte.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>Impossible d'effectuer un retour par référence d'un membre de '{0}', car il a été initialisé à une valeur qui ne peut pas être retournée par référence</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>Les méthodes qui possèdent des arguments de variables ne sont pas conformes CLS</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>Utilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal pour créer des jetons de littéral numérique.</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>Soit les deux déclarations de méthode partielles sont statiques, soit aucune ne l'est</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>'{0}' n'est pas un type référence requis par l'instruction lock</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>Impossible de retourner un champ readonly statique par référence accessible en écriture</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>Les interfaces conformes CLS doivent uniquement avoir des membres conformes CLS</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>Les modules ajoutés doivent être marqués avec l'attribut CLSCompliant pour correspondre à l'assembly</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>'{0}' : un paramètre, une variable locale ou une fonction locale ne peut pas avoir le même nom qu'un paramètre de type de méthode</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>Le type de retour n'est pas conforme CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>Erreur lors de l'ouverture du fichier d'icône {0} -- {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>SyntaxTree '{0}' à supprimer introuvable</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>Impossible de déduire le type de la variable de déconstruction implicitement typée '{0}'.</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>Les contraintes pour les méthodes d'implémentation d'interface override et explicite sont héritées de la méthode de base et ne peuvent donc pas être spécifiées directement</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>Nom de fichier spécifié non valide pour la directive de préprocesseur</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>Un caractère '{0}' doit faire l'objet d'une séquence d'échappement (par doublement) dans une chaîne interpolée.</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>méthode d'extension</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>L'expression n'a pas de nom.</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>Erreur inattendue lors de l'écriture des informations de débogage -- '{0}'</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>Compilation (C#) : </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>Le type n'est pas conforme CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>Impossible de convertir en type static '{0}'</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>Le type n'a pas de constructeur accessible utilisant uniquement des types conformes CLS</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>Impossible de marquer '{0}' comme conforme CLS, car il s'agit d'un membre de type '{1}' non conforme CLS</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>types anonymes</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>La constante '{0}' ne peut pas être marquée comme static</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car il lui manque l'accesseur get</value>
  </data>
  <data name="ERR_AutoPropsInRoStruct" xml:space="preserve">
    <value>Les propriétés d'instance implémentées automatiquement dans les structs en lecture seule doivent être en lecture seule.</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>La version de langage spécifiée '{0}' ne peut pas avoir de zéros non significatifs</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>Erreur lors de l'ouverture du fichier réponse '{0}'</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>La meilleure méthode Add surchargée pour l'élément initialiseur de collection est obsolète</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>Accessibilité incohérente : le type de retour '{1}' est moins accessible que l'opérateur '{0}'</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>Alias extern non utilisé.</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>Faire référence à une variable de sortie implicitement typée '{0}' n'est pas autorisé dans la même liste d'arguments.</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>Modificateur partiel manquant dans la déclaration de type '{0}' ; il existe une autre déclaration partielle de ce type</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>'{0}' : substitution impossible, car '{1}' n'a pas d'accesseur set substituable</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>L'alias extern '{0}' n'a pas été spécifié dans une option /reference</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>Voulez-vous utiliser l'étiquette de changement par défaut ('default:') à la place de 'case default:' ? Si vous souhaitez vraiment utiliser le littéral par défaut, choisissez 'case (default):' ou un autre littéral ('case 0:' ou 'case null:') selon les besoins.</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>'{0}' n'est pas un emplacement d'attribut reconnu. Les emplacements d'attributs valides pour cette déclaration sont '{1}'. Tous les attributs de ce bloc seront ignorés.</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>Le paramètre {0} doit être déclaré avec le mot clé '{1}'</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>L'interface '{0}' a une interface source non valide qui est nécessaire à l'incorporation de l'événement '{1}'.</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>La méthode surchargée '{0}' correspondant le mieux à l'élément de l'initialiseur de collection ne peut pas être utilisée. Les méthodes 'Add' de l'initialiseur de collection ne peuvent pas avoir de paramètres ref ou out.</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>'{0}' : aucune méthode appropriée n'a été trouvée pour la substitution</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;liste de chemins d'accès&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>Impossible de supprimer les membres de '{0}', car il s'agit d'un '{1}'</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>'{0}' : seuls les membres conformes CLS peuvent être abstract</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>Directive using non nécessaire</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>Impossible de lier des fichiers de ressources lors de la création d'un module</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;espace de noms global&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>Dépendance de contrainte circulaire utilisant '{0}' et '{1}'</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>'{0}' définit l'opérateur == ou l'opérateur != mais ne se substitue pas à Object.GetHashCode()</value>
  </data>
  <data name="IDS_LangVersions" xml:space="preserve">
    <value>Versions de langage prises en charge :</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>Un des paramètres d'un opérateur binaire doit être le type conteneur</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>'{0}' n'implémente pas '{1}'</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>Impossible d'accéder au membre protégé '{0}' par l'intermédiaire d'un qualificateur de type '{1}' ; le qualificateur doit être de type '{2}' (ou dérivé de celui-ci)</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>Membre requis par le compilateur '{0}.{1}' manquant</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>Les attributs d'assembly et de module ne sont pas autorisés dans ce contexte</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>Commentaire sur une seule ligne ou fin de ligne attendue</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>Un membre ne masque pas un membre hérité ; le mot clé new n'est pas requis</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>Les structs sans constructeurs explicites ne peuvent pas contenir de membres avec initialiseurs</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>'{0}' : les classes static ne peuvent pas être utilisées en tant que contraintes</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>Le type de retour d'une méthode async doit être void, Task ou Task&lt;T&gt;</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>Impossible de résoudre l'attribut cref '{0}' du commentaire XML</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>Nom de type '{0}' introuvable dans l'espace de noms '{1}'. Ce type a été transmis à l'assembly '{2}'. Ajoutez une référence à cet assembly.</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Foreach ne peut pas fonctionner sur un '{0}'. Souhaitiez-vous appeler '{0}' ?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>Une référence à un champ volatile ne sera pas considérée comme volatile</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>L'accès à un membre sur le champ d'une classe marshalée-par-référence peut entraîner une exception de runtime</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>Un champ ne peut pas être de type void</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>Le type de base n'est pas conforme CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>Les méthodes d'extension doivent être définies dans une classe statique de niveau supérieur ; {0} est une classe imbriquée</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>Le module '{0}' est déjà défini dans cet assembly. Chaque module doit avoir un nom de fichier unique.</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>Les attributs ne sont pas valides dans ce contexte</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>mémoires tampons de taille fixe</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>Point-virgule non valide après un bloc de méthode ou d'accesseur</value>
  </data>
  <data name="ERR_RefReadonlyNotField2" xml:space="preserve">
    <value>Impossible d'utiliser les membres de {0} '{1}' en tant que valeur ref ou out, car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>L'incorporation du type interop '{0}' de l'assembly '{1}' entraîne un conflit de noms dans l'assembly actuel. Attribuez à la propriété 'Incorporer les types interop' la valeur false.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>Les méthodes qui possèdent des arguments de variables ne sont pas conformes CLS</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>'{0}' : les modificateurs d'accessibilité au niveau des accesseurs ne peuvent être utilisés que si la propriété ou l'indexeur a un accesseur get et un accesseur set</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>Impossible de définir une classe ou un membre qui utilise 'dynamic', car le type requis par le compilateur '{0}' est introuvable. Vous manque-t-il une référence ?</value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>Le modificateur 'abstract' n'est pas valide dans les champs. Essayez d'utiliser une propriété à la place.</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>commutateur sur type booléen</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>Le résultat de l'expression est toujours 'null' de type '{0}'</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>L'attribut CLSCompliant n'a pas de sens lorsqu'il est appliqué à des types de retour</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>Impossible de convertir {0} dans le type de délégué souhaité, car certains types de retour ne sont pas implicitement convertibles en type de retour délégué</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>Commentaire XML manquant pour le type ou le membre visible publiquement '{0}'</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>Le membre '{0}' implémente le membre d'interface '{1}' dans le type '{2}'. Il existe plusieurs correspondances pour le membre d'interface au moment de l'exécution. La méthode appelée dépend de l'implémentation.</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>Le compilateur émet cet avertissement lorsqu'il remplace une erreur par un avertissement. Pour plus d'informations sur ce problème, recherchez le code d'erreur indiqué.</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>variable using</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>La contrainte new() doit être la dernière contrainte spécifiée</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>'{0}' est déjà listé dans la liste d'interfaces du type '{2}' avec d'autres noms d'éléments tuples, notamment '{1}'.</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>Le champ '{0}' n'est jamais assigné et aura toujours sa valeur par défaut {1}</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>La référence d'assembly Friend '{0}' n'est pas valide. Les assemblys signés avec un nom fort doivent spécifier une clé publique dans leurs déclarations InternalsVisibleTo.</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>Le type n'est pas conforme CLS, car l'interface de base n'est pas conforme CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>Le type '{1}' définit déjà un membre appelé '{0}' avec les mêmes types de paramètre</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;!-- Commentaire XML incorrect pour le membre "{0}" --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>Impossible de convertir un bloc de méthode anonyme sans une liste de paramètres en type délégué '{0}', car il compte un ou plusieurs paramètres out</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>L'attribut '{0}' n'est valide que sur les méthodes ou les classes d'attributs</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>Le mot clé 'void' ne peut pas être utilisé dans ce contexte</value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>L'espace de noms '{1}' contient déjà une définition pour '{0}'</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>éléments : ne doivent pas être vides</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>Identificateur ou littéral numérique attendu.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>Le commentaire XML sur '{1}' a une balise paramref pour '{0}', alors qu'il n'existe aucun paramètre de ce nom</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>Opérateur unaire surchargeable attendu</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>Impossible d'appliquer l'opérateur '{0}' à un opérande '{1}'</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>Impossible de rechercher un membre dans '{0}', car il s'agit d'un paramètre de type</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>Le nom de module '{0}' stocké dans '{1}' doit correspondre à son nom de fichier.</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>L'utilisation de '{0}' en tant que valeur ref ou out, ou la prise de son adresse, peut provoquer une exception runtime, car il s'agit d'un champ d'une classe marshalée par référence</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>Le format de la chaîne de version spécifiée n'est pas conforme au format requis - major.minor.build.revision</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>'{0}' : les éléments de tableau ne peuvent pas être de type static</value>
  </data>
  <data name="IDS_SK_CONSTRUCTOR" xml:space="preserve">
    <value>constructeur</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>Impossible de déterminer le type d'expression conditionnelle, car il n'existe pas de conversion implicite entre '{0}' et '{1}'</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>Impossible d'assigner à '{0}', car il s'agit d'un '{1}'</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>L'événement '{0}' ne peut apparaître qu'à gauche de += ou -= (sauf quand il est utilisé à partir du type '{1}')</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car l'accesseur set n'est pas accessible</value>
  </data>
  <data name="IConversionExpressionIsNotCSharpConversion" xml:space="preserve">
    <value>{0} n'est pas une expression de conversion C# valide</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>L'argument nommé '{0}' spécifie un paramètre pour lequel un paramètre positionnel a déjà été donné</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>Impossible de convertir le groupe de méthodes '{0}' en type non-délégué '{1}'. Souhaitiez-vous appeler la méthode ?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>Option /win32manifest ignorée pour le module, car elle s'applique uniquement aux assemblys</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>foreach exige que le type de retour '{0}' de '{1}' ait une méthode MoveNext publique appropriée et une propriété Current publique</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(Emplacement du symbole par rapport à l'avertissement précédent)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>Les initialiseurs de tableau ne peuvent être utilisés que dans un initialiseur de champ ou de variable. Essayez plutôt d'utiliser une expression new.</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;Null&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;texte&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>Incompatibilité de référence entre '{0}' et le délégué '{1}'</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>'{0}' : substitution impossible, car '{1}' n'est pas une fonction</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>variable locale implicitement typée</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>Le type prédéfini '{0}' doit être un struct.</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>tableau implicitement typé</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>Utilisez Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier ou Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier pour créer des jetons d'identificateur.</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>'{0}' : impossible d'avoir des propriétés d'instance ou des initialiseurs de champ dans des structs</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Les instructions yield ne peuvent pas figurer au niveau supérieur dans le code interactif.</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>'{0}' : le type utilisé dans une instruction using doit être implicitement convertible en 'System.IDisposable'</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>Possibilité d'une comparaison de références involontaire ; pour obtenir une comparaison de valeurs, effectuez un cast de la partie gauche en type '{0}'</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>Spécificateur de rang non valide : ',' ou ']' attendu</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>Accesseur de propriété déjà défini</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>Impossible d'initialiser une variable implicitement typée avec un initialiseur de tableau</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>Saut de ligne dans la constante</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>Un type générique ne peut pas dériver de '{0}', car il s'agit d'une classe d'attributs</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>Désolé... Nous ne pouvons pas créer d'instance d'analyseur</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>Le corps de '{0}' ne peut pas être un bloc itérateur, car '{1}' n'est pas un type d'interface itérateur</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>L'expression assignée à '{0}' doit être constante</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>La taille du tableau ne peut pas être spécifiée dans une déclaration de variable (essayez d'initialiser avec une expression 'new')</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>'{0}' : un événement abstrait ne peut pas avoir d'initialiseur</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>Plusieurs assemblys ayant une identité équivalente ont été importés : '{0}' et '{1}'. Supprimez une des références en double.</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>Le type '{1}' dans '{0}' est en conflit avec l'espace de noms '{3}' dans '{2}'</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerLineNumberAttribute n'aura pas d'effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas d'arguments facultatifs</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>Type attendu</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>La position doit se trouver dans l'étendue de l'arborescence de syntaxe.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir un initialiseur de tableau à plusieurs dimensions</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>Les interfaces ne peuvent pas contenir de champs</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>Impossible de retourner '{0}' par référence, car il a été initialisé à une valeur qui ne peut pas être retournée par référence</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>Utilisation inattendue d'un nom doté d'un alias</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>Un tableau de paramètres ne peut pas être utilisé avec le modificateur 'this' dans une méthode d'extension</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>L'appel à la méthode '{0}' doit être distribué dynamiquement mais ne peut pas l'être, car il fait partie d'une expression d'accès de base. Effectuez un cast des arguments dynamiques ou supprimez l'accès de base.</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>'{0}' : une classe ne peut pas être à la fois static et sealed</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' ne doivent être que des classes, des structs ou des interfaces</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>Le champ conforme CLS '{0}' ne peut pas être volatile</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>Mot clé contextuel 'equals' attendu</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>La syntaxe 'id#' n'est plus prise en charge. Utilisez '$id' à la place.</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>Le point d'entrée du programme est du code de script global ; ce point d'entrée est ignoré</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>Le champ n'est jamais utilisé</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>L'objet '{0}' peut être supprimé plusieurs fois.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>'{0}' n'implémente pas le membre d'interface '{1}'. '{2}' ne peut pas implémenter '{1}', car il n'a pas de retour par référence correspondant.</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>Les mémoires tampons de taille fixe ne sont accessibles que via des variables locales ou des champs</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>Le commentaire XML sur '{1}' a une balise typeparamref pour '{0}', alors qu'il n'existe aucun paramètre de type de ce nom</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>Dans les attributs cref, les types imbriqués de types génériques doivent être qualifiés</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une spécification d'argument nommé</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>Type de cible non valide pour /target : vous devez spécifier 'exe', 'winexe', 'library' ou 'module'</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>Un champ readonly statique ne peut pas être assigné (sauf s'il appartient à un constructeur statique ou un initialiseur de variable)</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>Le membre '{0}' est inaccessible avec une référence d'instance ; qualifiez-le avec un nom de type</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>Assignation potentiellement incorrecte à la variable locale qui est l'argument d'une instruction using ou lock</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>Le contrôle ne peut pas laisser le corps d'une clause finally</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>Le nœud de syntaxe ne se trouve pas dans l'arborescence de syntaxe</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>Les retours par référence ne peuvent être utilisés que dans les méthodes qui effectuent un retour par référence</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>Le type '{0}' ne peut pas être déclaré const</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>Les méthodes Async ne peuvent pas avoir de paramètres ref ou out</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>Le contrôle ne peut pas sortir du commutateur à partir de l'étiquette case finale ('{0}')</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>La directive using de '{0}' est apparue précédemment dans cet espace de noms</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>La propriété, l'indexeur ou l'événement '{0}' n'est pas pris en charge par le langage ; essayez d'appeler directement la méthode d'accesseur '{1}'</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>La propriété, l'indexeur ou l'événement '{0}' n'est pas pris en charge par le langage ; essayez d'appeler directement les méthodes d'accesseur '{1}' ou '{2}'</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>'{0}' : les conversions définies par l'utilisateur vers ou à partir d'une interface ne sont pas autorisées</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>N'utilisez pas refout quand vous utilisez refonly.</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>Impossible d'utiliser le paramètre ref ou out '{0}' dans une méthode anonyme, une expression lambda ou une expression de requête</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>Le résultat de l'expression est toujours 'null'</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>Échec de l'émission du module '{0}'.</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>expression throw</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>La méthode '{0}' ne peut pas implémenter l'accesseur d'interface '{1}' pour le type '{2}'. Utilisez une implémentation d'interface explicite.</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>L'alias '{0}' est en conflit avec la définition de {1}</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>'{0}' ne contient pas de définition pour '{1}'</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>Constante intégrale trop grande</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>Fichier introuvable.</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>Une déclaration n'est pas autorisée dans ce contexte.</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>Un point d'entrée qui retourne void ou int ne peut pas être async</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>Le commentaire XML a une balise typeparamref, alors qu'il n'existe aucun paramètre de type de ce nom</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>Le nom local est trop long pour PDB</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>L'attribut Guid doit être spécifié avec l'attribut ComImport</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>Impossible de générer une valeur dans le corps d'un bloc try avec une clause catch</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>L'implémentation d'interface explicite correspond à plusieurs membres d'interface</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>Impossible de spécifier /main en cas de génération d'un module ou d'une bibliothèque</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>Le type est utilisé à des fins d'évaluation uniquement. Il sera peut-être changé ou supprimé au cours des prochaines mises à jour.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>Une expression de type '{0}' n'est pas autorisée dans une clause from ultérieure dans une expression de requête avec un type source '{1}'. L'inférence de type a échoué dans l'appel à '{2}'.</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>opérateur de propagation null</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>Les assemblys '{0}' et '{1}' font référence aux mêmes métadonnées, mais un seul est une référence liée (spécifiée avec l'option using /link) ; supprimez une des références.</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>covariant</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>Les champs de mémoire tampon de taille fixe ne peuvent être membres que de structs</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une conversion de tuple.</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>Impossible de lire le fichier de configuration '{0}' -- '{1}'</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>Les expressions lambda Async ne peuvent pas être converties en arborescences de l'expression</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>Le paramètre de type '{1}' a la contrainte 'struct', donc '{1}' ne peut pas être utilisé comme contrainte pour '{0}'</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>Le type prédéfini '{0}' n'est pas défini ou importé, ou il est déclaré dans plusieurs assemblys référencés</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>L'argument de type ne peut pas avoir la valeur null</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>Une déclaration d'alias extern doit précéder tous les autres éléments définis dans l'espace de noms</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>Option non valide '{0}' pour /platform ; doit être anycpu, x86, Itanium ou x64</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>L'argument de l'attribut '{0}' doit être un identificateur valide</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>CallerMemberNameAttribute, qui est appliqué au paramètre '{0}', n'aura aucun effet. Il est remplacé par CallerFilePathAttribute.</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>Accessibilité incohérente : le type de retour '{1}' est moins accessible que le délégué '{0}'</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>Impossible d'appliquer l'attribut de sécurité '{0}' à une méthode Async.</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>Les attributs de l'assembly et du module doivent précéder tous les autres éléments définis dans un fichier à l'exception des clauses using et des déclarations d'alias extern</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>Une référence a été créée pour l'assembly d'interopérabilité incorporé en raison d'une référence indirecte à cet assembly</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>Le type non managé '{0}' n'est valide que pour les champs.</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>La propriété implémentée automatiquement '{0}' doit être entièrement assignée avant que le contrôle soit retourné à l'appelant.</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>L'opérateur unaire surchargé '{0}' prend un paramètre</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>Impossible d'utiliser le type unsafe '{0}' dans la création d'objet</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>Utilisation du paramètre out non assigné '{0}'</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>contravariant</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>L'attribut Conditional n'est pas valide sur les membres d'interface</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>Impossible de modifier le résultat d'une conversion unboxing</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>ref et out ne sont pas valides dans ce contexte</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>La balise de fin '{0}' ne correspond pas à la balise de début '{1}'.</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>La partie droite d'une assignation d'instruction fixed peut ne pas être une expression de cast</value>
  </data>
  <data name="IDS_FeatureRefExtensionMethods" xml:space="preserve">
    <value>méthodes d'extension par référence</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>Impossible de modifier les membres d'un champ readonly '{0}' (sauf s'ils appartiennent à un constructeur ou un initialiseur de variable)</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>En supposant que la référence d'assembly '{0}' utilisée par '{1}' correspond à l'identité '{2}' de '{3}', il se peut que vous deviez fournir une stratégie runtime</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>La valeur SecurityAction '{0}' n'est pas valide pour les attributs de sécurité appliqués à un assembly</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>La variable de portée '{0}' est en conflit avec une déclaration précédente de '{0}'</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>Le nom de type ou d'espace de noms '{0}' est introuvable (vous manque-t-il une directive using ou une référence d'assembly ?)</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>Mot clé contextuel 'on' attendu</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>Mot clé contextuel 'by' attendu</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas implémentée dans ce compilateur.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Il n'y a pas de conversion boxing de '{3}' en '{1}'.</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>La méthode d'extension doit être statique</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>Type de retour non valide dans l'attribut cref de commentaire XML</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}' est obsolète : '{1}'</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>L'assembly {0} ne contient pas d'analyseurs.</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>par covariance</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>Une référence a été créée pour l'assembly d'interopérabilité incorporé '{0}' en raison d'une référence indirecte à cet assembly créée par l'assembly '{1}'. Modifiez la propriété 'Incorporer les types interop' sur l'un ou l'autre de ces assemblys.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>Le fichier source a dépassé la limite de 16 707 565 lignes pouvant être représentées dans le PDB ; les informations de débogage seront incorrectes</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>collection</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>N'utilisez pas 'System.Runtime.CompilerServices.DynamicAttribute'. Utilisez plutôt le mot clé 'dynamic'.</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>Le nom de fichier '{0}' est vide, contient des caractères non valides, spécifie un lecteur sans chemin d'accès absolu ou est trop long</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>Impossible de marquer '{0}' comme conforme CLS, car l'assembly n'a pas d'attribut CLSCompliant</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>La version de langage fournie n'est pas prise en charge ou est non valide : '{0}'.</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>'{0}' : les membres d'interface ne peuvent pas avoir une définition</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>Expression ou instruction de déclaration attendue.</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>Impossible d'assigner la propriété ou l'indexeur '{0}' -- il est en lecture seule</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>Ni la méthode, ni le délégué ne peuvent retourner un type '{0}'</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>Accessibilité incohérente : le type de champ '{1}' est moins accessible que le champ '{0}'</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>L'option /pdb exige que l'option /debug soit également utilisée</value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>L'expression donnée de l'expression 'is' est toujours du type fourni</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>Chaque ressource et module liés doivent avoir un nom de fichier unique. Le nom de fichier '{0}' est indiqué plusieurs fois dans cet assembly</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>Appelez System.IDisposable.Dispose() sur l'instance allouée avant que toutes les références pointant vers lui soient hors de portée</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un appel COM avec des arguments où ref a été omis</value>
  </data>
  <data name="ERR_ParamsCantBeWithModifier" xml:space="preserve">
    <value>Impossible de déclarer le paramètre params en tant que {0}</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>Le type et l'identificateur sont tous deux requis dans une instruction foreach</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>Argument {0} : conversion impossible de '{1}' en '{2}'</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Les spécifications d'argument nommé doivent s'afficher après la spécification de tous les arguments fixes. Utilisez la version de langage {0} ou une version ultérieure pour autoriser les arguments nommés non placés en position de fin.</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>Les contraintes pour le paramètre de type '{0}' de la méthode '{1}' doivent correspondre aux contraintes pour le paramètre de type '{2}' de la méthode d'interface '{3}'. Utilisez plutôt une implémentation d'interface explicite.</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>Impossible de retourner la variable de portée '{0}' par référence</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>Du code unsafe ne peut pas s'afficher dans des itérateurs</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>La construction __arglist est valide uniquement avec une méthode à arguments de variables</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>Impossible de déterminer le type d'expression conditionnelle, car '{0}' et '{1}' sont convertis implicitement l'un en l'autre</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>Impossible d'utiliser 'new' avec le type tuple. Utilisez une expression littérale de tuple à la place.</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>Jeton inattendu '{0}'</value>
  </data>
  <data name="ERR_RefConditionalDifferentTypes" xml:space="preserve">
    <value>L'expression doit être de type '{0}' pour correspondre à la valeur ref de remplacement</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>'{0}' : dérivation du type sealed '{1}' impossible</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>Le point d'entrée de débogage doit être une définition d'une méthode déclarée dans la compilation actuelle.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>Il n'existe pas de classement défini entre les champs dans plusieurs déclarations de struct partiel</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>En supposant que la référence d'assembly '{0}' utilisée par '{1}' correspond à l'identité '{2}' de '{3}', il se peut que vous deviez fournir une stratégie runtime</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>Le commentaire XML a une balise typeparam pour '{0}', alors qu'il n'existe aucun paramètre de type de ce nom</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Le paramètre d'attribut '{0}' ou '{1}' doit être spécifié.</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Le paramètre d'attribut '{0}' doit être spécifié.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>méthode expression-bodied</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerFilePathAttribute n'aura pas d'effet, car il s'applique à un membre utilisé dans des contextes qui n'autorisent pas d'arguments facultatifs</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>Impossible de compiler les modules net en utilisant /refout ou /refonly.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Le type Nullable '{3}' ne satisfait pas la contrainte de '{1}'. Les types Nullable ne peuvent pas satisfaire les contraintes d'interface.</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>Le fichier de commentaires inclus comporte du code XML incorrect</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>L'espace de noms '{1}' contient une définition en conflit avec l'alias '{0}'</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Nom d'assembly non valide : {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir d'abandon.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>L'utilisation de 'is' pour tester la compatibilité avec 'dynamic' est fondamentalement identique au test de la compatibilité avec 'Object'</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>Une directive 'using namespace' ne peut être appliquée qu'aux espaces de noms ; '{0}' est un type, pas un espace de noms. Utilisez plutôt une directive 'using static'</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>Impossible d'utiliser les membres du champ readonly '{0}' en tant que valeur ref ou out (sauf dans un constructeur)</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Erreur de syntaxe de ligne de commande : format de Guid '{0}' non valide pour l'option '{1}'</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>Dans les attributs cref, les types imbriqués de types génériques doivent être qualifiés.</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>Le CallerLineNumberAttribute peut seulement être appliqué aux paramètres avec des valeurs par défaut</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>Le résultat de l'expression est toujours '{0}', car une valeur de type '{1}' n'est jamais égale à 'null' du type '{2}'</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>Impossible de retourner une valeur à partir d'un itérateur. Utilisez l'instruction yield return pour retourner une valeur, ou yield break pour mettre fin à l'itération.</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>Disable ou restore attendu</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>L'option '{0}' doit être un chemin absolu.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Version {0} non valide pour /subsystemversion. La version doit être 6.02 ou supérieure pour ARM ou AppContainerExe, et 4.00 ou supérieure dans les autres cas</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>Déclarateur de membre initialiseur non valide</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>Le format de l'option pathmap est incorrect.</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>Le type de mémoire tampon de taille fixe doit être : bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float ou double</value>
  </data>
  <data name="ERR_CallArgMixing" xml:space="preserve">
    <value>Cette combinaison d'arguments pour '{0}' n'est pas autorisée, car elle peut exposer les variables référencées par le paramètre '{1}' en dehors de la portée de leur déclaration</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>Impossible de convertir la valeur de constante '{0}' en '{1}'</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>L'argument {0} ne doit pas être passé avec le mot clé '{1}'</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car l'accesseur get n'est pas accessible</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>fonctions locales</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>tuples</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>alias extern</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>Élément include XML non valide -- {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>La valeur d'alignement a une magnitude pouvant générer une chaîne formatée volumineuse</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>Le type intercepté ou levé doit être dérivé de System.Exception</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>Aucun fichier source spécifié</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>L'attribut '{0}' est ignoré quand une signature publique est spécifiée.</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>La mémoire tampon de taille fixe de longueur {0} et de type '{1}' est trop volumineuse</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>'{0}' ne peut pas implémenter '{1}', car ceci n'est pas pris en charge par le langage</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 2. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 3. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 1. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 6. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 7.0. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 4. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>La fonctionnalité '{0}' n'est pas disponible en C# 5. Utilisez la version de langage {1} ou une version ultérieure.</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>option /LIB</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>L'attribut Conditional n'est pas valide sur '{0}', car son type de retour n'est pas void</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>Impossible d'appliquer l'attribut DllImport à une méthode générique ou contenue dans un type générique.</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>Utilisation d'une variable locale non assignée '{0}'</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>Impossible de passer une propriété ou un indexeur en tant que paramètre de sortie (out) ni de référence (ref)</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>Un membre remplace un membre de base avec plusieurs candidats à la substitution au moment de l'exécution</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>Impossible de retourner '{0}' par référence, car il s'agit d'un '{1}'</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Ignorer le chargement de types dans un assembly d’analyseur qui échouent en raison d’une ReflectionTypeLoadException</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>Les paramètres ou variables locales de type '{0}' ne peuvent pas être déclarés dans des méthodes async ou des expressions lambda.</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>Aucune déclaration de définition trouvée pour la déclaration d'implémentation de la méthode partielle '{0}'</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>Une référence au type '{0}' déclare qu'il est défini dans cet assembly, mais il n'est pas défini dans la source ou dans les modules ajoutés</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>Impossible de passer null pour un nom d'assembly friend</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>La valeur par défaut spécifiée pour le paramètre n'aura aucun effet, car elle s'applique à un membre utilisé dans des contextes qui n'autorisent pas les arguments facultatifs</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>Bloc switch vide</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>'{0}' : une classe abstraite ne peut pas être sealed ou static</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>L'introduction d'une méthode 'Finalize' peut interférer avec un appel destructeur</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>Vous devez fournir un initialiseur dans une déclaration d'instruction fixed ou using</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>Le type de retour pour l'opérateur ++ ou -- doit correspondre au type de paramètre ou en être dérivé</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>Variance non valide : le paramètre de type '{1}' doit être un {3} valide sur '{0}'. '{1}' est {2}.</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>'{0}' : les conversions définies par l'utilisateur vers ou à partir du type dynamic ne sont pas autorisées</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>AppConfigPath doit être absolu.</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>CallerFilePathAttribute, qui est appliqué au paramètre '{0}', n'aura aucun effet. Il est remplacé par CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>Possibilité d'instruction vide erronée</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Il n'y a pas de conversion boxing ou de conversion de paramètre de type de '{3}' en '{1}'.</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>Le fichier de commentaires inclus comporte du code XML incorrect -- '{0}'</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>Les propriétés implémentées automatiquement doivent substituer tous les accesseurs de la propriété substituée.</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>Une sous-expression ne peut pas être utilisée dans un argument de nameof.</value>
  </data>
  <data name="ERR_MismatchedRefEscapeInTernary" xml:space="preserve">
    <value>Les branches d'un opérateur ternaire ref ne peuvent pas faire référence à des variables ayant des portées de déclaration incompatibles</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>Un champ de mémoire tampon de taille fixe doit utiliser le spécificateur de la taille du tableau après le nom du champ</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>Directive #warning</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>Aucune surcharge pour la méthode '{0}' n'accepte les arguments {1}</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>Impossible d'appliquer l'indexation à l'aide de [] à une expression de type '{0}'</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>'{0}' n'est pas une contrainte valide. Un type utilisé comme contrainte doit être une interface, une classe non-sealed ou un paramètre de type.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>Référence ambiguë dans l'attribut cref : '{0}'. '{1}' pris par défaut, mais peut aussi correspondre à d'autres surcharges, notamment '{2}'.</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>La classe '{0}' ne peut pas avoir plusieurs classes de base : '{1}' et '{2}'</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>'{0}' se substitue à Object.Equals(object o) mais pas à Object.GetHashCode()</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>Directive using non nécessaire.</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>Le nom '{0}' n'existe pas dans le contexte actuel</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>Absence de boucle englobant 'break' ou 'continue'</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>L'implémentation d'interface explicite '{0}' correspond à plusieurs membres d'interface. Le membre d'interface choisi dépend de l'implémentation. Utilisez plutôt une implémentation non explicite.</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>Référence à l'entité non définie '{0}'.</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>Le code XML du commentaire XML est incorrect -- '{0}'</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Les propriétés qui effectuent un retour par référence doivent avoir un accesseur get</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>Accessibilité incohérente : l'interface de base '{1}' est moins accessible que l'interface '{0}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>Une arborescence de l'expression ne peut pas contenir une expression de méthode anonyme</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>expression lambda</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>Définition de type ou d'espace de noms, ou fin de fichier attendue</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>Littéral de chaîne inachevé</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>Type de contrainte non valide. Un type utilisé comme contrainte doit être une interface, une classe non-sealed ou un paramètre de type.</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>L'expression fera toujours intervenir System.NullReferenceException, car la valeur par défaut du type est null</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>'is' et 'as' ne sont pas valides sur les types pointeur</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>Le paramètre de type a le même nom que le paramètre de type du type externe</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>'{0}' : les interfaces conformes CLS doivent avoir uniquement des membres conformes CLS</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>Une expression de méthode anonyme ne peut pas être convertie en arborescence de l'expression</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Le fichier source a été spécifié plusieurs fois</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>Une syntaxe incorrecte a été utilisée dans un commentaire.</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>Une méthode Add d'extension n'est pas prise en charge pour un initialiseur de collection dans une expression lambda.</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>L'attribut '{0}' n'est valide que sur un indexeur qui n'est pas une déclaration de membre d'interface explicite</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>'{0}' n'est pas une classe d'attributs</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>Impossible d'utiliser un type anonyme dans une expression constante</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>Les expressions et instructions ne peuvent figurer que dans le corps d'une méthode</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>Le type de '{0}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>L'opérateur '{0}' est ambigu sur les opérandes 'default' et 'default'</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>Le type d'argument '{0}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>Le paramètre params doit être un tableau à une seule dimension</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>Le point d'entrée du programme est du code de script global ; point d'entrée '{0}' ignoré.</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>Impossible d'appeler un membre de base abstrait : '{0}'</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>Impossible de convertir null en paramètre de type '{0}' car il peut s'agir d'un type valeur qui n'autorise pas les valeurs null. Utilisez 'default({0})' à la place.</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>Cette fonctionnalité ne fait pas partie de la spécification du langage C# ISO standardisée ; il est possible qu'elle ne soit pas acceptée par d'autres compilateurs</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>Impossible de retourner un membre de la variable locale '{0}' par référence, car il ne s'agit pas d'une variable locale de référence</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>'{0}' n'a pas de classe de base et ne peut pas appeler de constructeur de base</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>La méthode surchargée correspondant le mieux à '{0}' n'a pas la bonne signature pour l'élément initialiseur. Add initialisable doit être une méthode d'instance accessible.</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>La signature publique a été spécifiée et nécessite une clé publique. Toutefois, aucune clé publique n'a été spécifiée.</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>) attendue</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>Fichier source '{0}' introuvable.</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>propriété</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>Impossible de retourner '{0}' par référence, car il est en lecture seule</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>Une fonction anonyme convertie en délégué retournant void ne peut pas retourner une valeur</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>Vous ne devez pas utiliser le type 'dynamic' dans un modèle.</value>
  </data>
  <data name="ERR_RefReadonlyNotField" xml:space="preserve">
    <value>Impossible d'utiliser {0} '{1}' en tant que valeur ref ou out, car il s'agit d'une variable en lecture seule</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>Impossible d'appeler directement des destructeurs et object.Finalize. Appelez IDisposable.Dispose s'il est disponible.</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>Trop de caractères dans le littéral de caractère</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>Valeurs de checksum différentes spécifiées pour #pragma</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>La valeur SecurityAction '{0}' n'est pas valide pour l'attribut PrincipalPermission</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>Déclarateur de tableau erroné. Pour déclarer un tableau managé, le spécificateur de rang précède l'identificateur de la variable. Pour déclarer un champ de mémoire tampon de taille fixe, utilisez le mot clé fixed avant le type de champ.</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>Les déclarations partielles de '{0}' doivent avoir les mêmes noms de paramètre de type et modificateurs de variance dans le même ordre</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>'{0}' ne peut pas dériver de la classe spéciale '{1}'</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>'{0}' étant une méthode async qui retourne 'Task', un mot clé return ne doit pas être suivi d'une expression d'objet. Souhaitiez-vous retourner 'Task&lt;T&gt;' ?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>Impossible d'utiliser '{0}' en tant que valeur ref ou out, car il est en lecture seule</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>Impossible de trouver une implémentation du modèle de requête pour le type source '{0}'. '{1}' introuvable.</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>Le CallerMemberNameAttribute peut seulement être appliqué aux paramètres avec des valeurs par défaut</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>Le type est en conflit avec l'espace de noms importé</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>Le commentaire XML a une balise param pour '{0}', alors qu'il n'existe aucun paramètre de ce nom</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>Commentaire XML manquant pour le type ou le membre visible publiquement</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>La comparaison à la constante intégrale est inutile, car la constante est en dehors de la plage du type</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>Le type définit l'opérateur == ou l'opérateur != mais ne se substitue pas à Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>L'attribut sera ignoré en faveur de l'instance présente dans la source</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>Impossible d'ouvrir le fichier source '{0}' -- {1}</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>L'attribut '{0}' n'est pas valide dans ce type de déclaration. Il n'est valide que dans les déclarations '{1}'.</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>Impossible de déclarer une variable locale ou un paramètre nommé '{0}' dans cette portée, car ce nom est utilisé dans une portée locale englobante pour définir une variable locale ou un paramètre</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>'{0}' est de type '{1}'. Une valeur de paramètre par défaut d'un type référence autre que string ne peut être initialisé qu'avec null</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>Impossible d'incorporer les types interop de l'assembly '{0}', car l'attribut '{1}' ou '{2}' est manquant.</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>Le type de contrainte '{0}' n'est pas conforme CLS</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>Impossible d'assigner le champ ou la propriété statique '{0}' dans un initialiseur d'objet</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>Attribut '{0}' en double</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>L'attribut '{0}' n'est valide que dans les classes dérivées de System.Attribute</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>La comparaison avec null de type struct produit toujours 'false'</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>L'attribut RequiredAttribute n'est pas autorisé sur les types C#</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>Seules sont autorisées 65 534 variables locales, y compris celles générées par le compilateur</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>Normalement, un champ volatile ne doit pas être utilisé en tant que valeur ref ou out, car il n'est pas considéré comme volatile. Il existe des exceptions à cette situation, par exemple l'appel d'une API à blocage.</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>Impossible d'incorporer le type interop '{0}' trouvé dans les assemblys '{1}' et '{2}'. Attribuez à la propriété 'Incorporer les types interop' la valeur false.</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>chemin d'accès trop long ou non valide</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>'{1} {0}' n'a pas le type de retour correct</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>Un type n'implémente pas le modèle de la collection ; un membre n'a pas la bonne signature</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>async main</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>Le membre '{0}' est introuvable sur le type '{1}' de l'assembly '{2}'.</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>Une balise de fin n'était pas attendue à cet emplacement.</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>'{1}' : dérivation impossible à partir de la classe static '{0}'</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>L'accès à un membre de '{0}' peut occasionner une exception runtime, car il s'agit d'un champ d'une classe marshalée par référence</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>Le type doit être 'var'.</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>Expression attendue</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>Un accès Friend a été concédé par '{0}', mais la clé publique de l'assembly de sortie ne correspond pas à celle spécifiée par l'attribut concédant.</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>'{0}' est un type qui n'est pas pris en charge par le langage</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>L'expression doit être explicitement convertible en booléen ou son type '{0}' doit définir l'opérateur '{1}'.</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>L'objet peut être supprimé plusieurs fois</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>CallerMemberNameAttribute, qui est appliqué au paramètre '{0}', n'aura aucun effet. Il est remplacé par CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>La référence d'assembly n'est pas valide et ne peut pas être résolue</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>Le type de paramètre pour l'opérateur ++ ou -- doit être le type conteneur</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>Aucune valeur détectée pour RuntimeMetadataVersion</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>Une référence d'objet est requise pour la propriété, la méthode ou le champ non statique '{0}'</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>'{0}' : les interfaces ne peuvent pas déclarer de types</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>Vous ne pouvez pas indiquer que le type ou le membre est conforme CLS, car l'assembly n'a pas d'attribut CLSCompliant</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>'{0}' : le type de retour doit être '{2}' pour correspondre au membre substitué '{1}'</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>Une soumission peut avoir au plus une arborescence de syntaxe.</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>Aucune surcharge pour '{0}' ne correspond au délégué '{1}'</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>Type non valide pour le paramètre dans l'attribut cref du commentaire XML</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>Impossible de spécifier l'attribut DefaultMember sur un type contenant un indexeur</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>Le niveau d'avertissement doit être compris entre 0 et 4</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>indexeur expression-bodied</value>
  </data>
  <data name="ERR_LocalFunctionMissingBody" xml:space="preserve">
    <value>'{0}' est une fonction locale et doit donc toujours avoir un corps.</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>'{0}' : dérivation impossible du type dynamic</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>arborescence non intégrée à la compilation</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>Une arborescence d'expression lambda ne peut pas contenir un opérateur de fusion avec une partie gauche de littéral ayant une valeur null ou une valeur par défaut</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>Erreur de syntaxe, '{0}' attendu</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>Cet emplacement d'attribut n'est pas reconnu</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>L'initialiseur d'élément ne peut pas être vide</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>Le type de l'expression dans la clause {0} est incorrect. L'inférence de type a échoué dans l'appel à '{1}'.</value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>filtre d'exception</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>Les déclarations de méthode partielles de '{0}' ont des contraintes de paramètre de type incohérentes</value>
  </data>
</root>