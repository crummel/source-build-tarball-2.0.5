<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>Los resultados sin origen deben tener la opción /out especificada</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>División entre constante cero</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>'{0}' no es un argumento de atributo con nombre válido porque no es un tipo de parámetro de atributo válido</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>El comentario XML tiene XML formado incorrectamente</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Omisión de algunos tipos en el ensamblado de analizador {0} por una ReflectionTypeLoadException: {1}.</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>El campo está asignado pero nunca se usa su valor</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un operador de asignación</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>No se encuentran uno o varios tipos necesarios para compilar una expresión dinámica. ¿Falta alguna referencia?</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}' está obsoleto: '{1}'</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>El atributo Conditional no es válido en '{0}' porque es un constructor, destructor, operador o la implementación de interfaz explícita</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Nombre de módulo no válido: {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>'{0}': no se permiten conversiones definidas por el usuario ni a una clase base ni desde ella</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>'{0}': no se puede hacer referencia a un tipo a través de una expresión; pruebe con '{1}'</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>Versión de compilador: "{0}". Versión de lenguaje: {1}.</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>iteradores</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>Se omitirá /win32manifest para el módulo porque solo se aplica a ensamblados</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>La página de código '{0}' no es válida o no está instalada</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>El miembro obsoleto '{0}' invalida el miembro no obsoleto '{1}'</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>Falta la comilla de cierre en el literal de cadena.</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>Compilación cancelada por el usuario</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Las referencias de metadatos no son compatibles.</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>El cuerpo de una consulta debe terminar con una cláusula select o group</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>La instrucción switch contiene varios casos con el valor de etiqueta '{0}'</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>Se esperaba un identificador; '{1}' es una palabra clave</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>Valor de '{0}' no válido: '{1}'.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una operación de puntero no segura</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>Se encontró un carácter no válido dentro de una referencia de entidad.</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener un método con argumentos variables</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>El switch de la línea de comandos aún no está implementado</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>El compilador amplió y extendió el signo de una variable. Luego, utilizó el valor resultante en una operación OR bit a bit. Esto puede provocar un comportamiento inesperado.</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>El operador * o -&gt; se debe aplicar a un puntero</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>Nombre no válido para un símbolo de preprocesamiento; "{0}" no es un identificador válido</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar a operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>No se puede marcar al tipo como conforme a CLS porque es miembro de un tipo no conforme a CLS</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>El atributo CallerMemberNameAttribute no tendrá efecto: lo reemplaza el atributo CallerMemberNameAttribute</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField2" xml:space="preserve">
    <value>Los miembros de {0} "{1}" no se pueden devolver por referencia grabable porque es una variable readonly.</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>'{0}' no puede declarar un cuerpo porque está marcado como abstracto</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de evento '{1}' es menos accesible que el evento '{0}'</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>El miembro '{0}' invalida el miembro obsoleto '{1}'. Agregue el atributo Obsolete a '{0}'.</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Se ha detectado código inaccesible</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>El tipo o el miembro no necesitan un atributo CLSCompliant porque el ensamblador no tiene un atributo CLSCompliant</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>No se encontró ninguna implementación del patrón de consulta para el tipo de origen '{0}'. No se encontró '{1}'. Puede especificar de forma explícita el tipo de la variable de rango '{2}'.</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>'{0}' no es un número de advertencia válido</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay ninguna conversión de referencia implícita de '{3}' a '{1}'.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>El método, el operador o el descriptor de acceso están marcados como externos y no tienen atributos</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>El nombre del destructor debe coincidir con el nombre de la clase</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>No se puede pasar la variable de rango '{0}' como parámetro out o ref</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>Un bucle foreach debe declarar sus variables de iteración.</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>El atributo DllImport se debe especificar en un método marcado como 'static' y 'extern'</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>método parcial</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>El campo '{0}' está asignado pero su valor nunca se usa</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>No se pueden proporcionar resultados en el cuerpo de una cláusula finally</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;espacio de nombres&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>El operador 'await' solo se puede usar en una expresión de consulta dentro de la primera expresión de colección de la cláusula 'from' inicial o de la expresión de colección de una cláusula 'join'</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>El valor predeterminado especificado para el parámetro '{0}' no tendrá efecto porque se aplica a un miembro que se usa en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>'{0}': la declaración explícita de la interfaz solo se puede declarar en una clase o una estructura</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>No se puede definir de nuevo el alias externo global</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>El atributo CLSCompliant no tiene ningún significado cuando se aplica a parámetros. Pruebe a incluirlo en el método.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>Esta advertencia se produce cuando un bloque catch() no tiene especificado un tipo de excepción después de un bloque catch (System.Exception e). La advertencia avisa de que el bloque catch() no abarcará ninguna excepción.

Un bloque catch() después de un bloque catch (System.Exception e) puede abarcar excepciones que no sean CLS si RuntimeCompatibilityAttribute se establece como falso en el archivo AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Si este atributo no se establece explícitamente como falso, todas las excepciones que no sean CLS lanzadas se ajustarán como Excepciones y el bloque catch (System.Exception e) las abarcará.</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>No se puede usar await en una cláusula catch</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>No se pueden deconstruir los objetos dinámicos.</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>No se puede usar una expresión en este contexto porque no se puede pasar ni devolver por referencia.</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>Una opción /reference que declara un alias externo solo puede tener un nombre de archivo. Para especificar varios alias o nombres de archivo, utilice varias opciones /reference.</value>
  </data>
  <data name="ERR_StackAllocConversionNotPossible" xml:space="preserve">
    <value>La conversión de una expresión stackalloc del tipo "{0}" al tipo "{1}" no es posible.</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>Falta el delimitador de cierre '}' de la expresión interpolada que empieza por '{'.</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>Debe especificar el atributo CLSCompliant en el ensamblado, no en el módulo, para habilitar la comprobación de conformidad con CLS</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>La instrucción foreach no puede funcionar en variables de tipo '{0}' porque '{0}' no contiene ninguna definición pública para '{1}'</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Error al leer el archivo de conjunto de reglas {0}: {1}</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>No llame directamente al método Finalize de la clase base. Se llama automáticamente desde el destructor.</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>'{0}': el valor del enumerador es demasiado grande para ajustarse a su tipo</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>Nombre de archivo no válido especificado para la directiva del preprocesador. Nombre de archivo demasiado largo o no válido.</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>El tipo o el miembro están obsoletos</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>Los argumentos de tipo para el método '{0}' no se pueden inferir a partir del uso. Pruebe a especificar los argumentos de tipo explícitamente.</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>Falta el atributo de archivo</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>Falta el atributo 'path'</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>El tipo '{0}' sin administrar no es válido para los campos.</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Error al firmar la salida con una clave pública del contenedor '{0}': {1}</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>El operador '{0}' requiere que también se defina un operador coincidente '{1}'</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>Un inicializador de campo no puede hacer referencia al campo, método o propiedad no estáticos '{0}'</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>propiedades de solo lectura implementadas automáticamente</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>No se pueden usar campos del campo estático de solo lectura '{0}' como valores out o ref (excepto en un constructor estático).</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>modificadores de acceso en propiedades</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>El token '{0}' no es válido en una clase, una estructura o una declaración de miembro de interfaz</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>No se encontró el archivo de metadatos '{0}'</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>'{0}' no tiene un tamaño predefinido; por tanto, sizeof solo se puede usar en un contexto no seguro (use System.Runtime.InteropServices.Marshal.SizeOf).</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>Se ha especificado una ruta de acceso de búsqueda '{0}' no válida en '{1}': '{2}'</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>Los campos de '{0}' no se pueden devolver por referencia porque es un '{1}'.</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>No se puede convertir {0} en el tipo delegado '{1}' porque los tipos de parámetros no coinciden con los tipos de parámetros delegados</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>Solo los miembros conformes a CLS pueden ser abstractos</value>
  </data>
  <data name="IDS_FeaturePrivateProtected" xml:space="preserve">
    <value>private protected</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>El ensamblado y el módulo '{0}' no pueden tener como destino procesadores distintos.</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>No se puede usar await en el cuerpo de una instrucción lock</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>No se puede usar un campo estático de solo lectura como valor out o ref (excepto en un constructor estático).</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>El atributo '{0}' no es válido en descriptores de acceso de propiedades o eventos. Solo es válido en declaraciones '{1}'.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>El uso de matrices como argumentos de atributo no es conforme a CLS</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>Alias externo sin usar</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>Número no válido</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>varianza de tipo</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>el directorio no existe</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>Para que '{0}' sea aplicable como operador de cortocircuito, su tipo declarativo '{1}' debe definir un operador true y otro false</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>Se espera un inicializador de matriz anidada</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>Solo los tipos de clase pueden contener destructores</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>Asumiendo que la referencia al ensamblaje coincide con la identidad</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>La referencia de ensamblado '{0}' no es válida y no se puede resolver</value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>La asignación de deconstrucción requiere una expresión con un tipo en el lado derecho.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Alineación de sección de archivo no válida "{0}"</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Los métodos anónimos, las expresiones lambda y las expresiones de consulta incluidos en estructuras no pueden obtener acceso a miembros de instancia de 'this'. Puede copiar 'this' en una variable local fuera del método anónimo, la expresión lambda o la expresión de consulta y usar la variable local en su lugar.</value>
  </data>
  <data name="ERR_AssignReadonlyNotField2" xml:space="preserve">
    <value>No se puede asignar a un miembro de {0} "{1}" porque es una variable readonly.</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>El miembro condicional '{0}' no puede implementar el miembro de interfaz '{1}' en el tipo '{2}'</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>La clase estática '{0}' no se puede derivar del tipo '{1}'. Las clases estáticas se deben derivar del objeto.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>Los campos del campo estático de solo lectura "{0}" no se pueden devolver por referencia grabable.</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>El tipo '{0}' está definido en este ensamblado, pero se ha especificado un reenviador de tipos para él</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>Una expresión es demasiado larga o compleja para compilarla</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>Se esperaba un comentario de una línea o un final de línea después de la directiva #pragma</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>'{0}': la propiedad del evento debe tener los descriptores de acceso add y remove</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>Se esperaba { o ; o =&gt;.</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>El ensamblador al que se hace referencia tiene como objetivo a otro procesador</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>No se encuentra la clase contenedora '{0}' de la coclase administrada para la interfaz '{1}' (¿falta alguna referencia de ensamblado?)</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>'{0}' no implementa el patrón '{1}'. '{2}' es ambiguo con '{3}'.</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>Opción "{0}" no válida para /langversion. Use "/langversion:?" para enumerar los valores admitidos.</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>Un nombre calificado con el alias no es una expresión.</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>Se esperaba un identificador.</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>El valor 'goto case' no se puede convertir implícitamente en el tipo '{0}'</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>La asignación en una expresión condicional siempre es constante</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>El miembro condicional '{0}' no puede tener ningún parámetro out</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>No se puede usar await en un contexto no seguro.</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>Una instrucción incrustada no puede ser una declaración o una instrucción con etiqueta</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>El constructor está marcado como externo</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>inicializador de colección</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>El tipo predefinido '{0}' no está definido ni importado</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>propiedades implementadas automáticamente</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>La llamada al método '{0}' enviada de forma dinámica puede dar error en tiempo de ejecución porque una o varias sobrecargas aplicables son métodos condicionales.</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>El tipo o el miembro están obsoletos</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>El constructor '{0}' está marcado como externo</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>'{0}': las clases estáticas no pueden implementar interfaces</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>La estructura de interoperabilidad incrustada '{0}' solo puede contener campos de instancia públicos.</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>No puede derivar de '{0}' porque es un parámetro de tipo</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>El tipo de una variable local declarado en una instrucción fixed debe ser un tipo de puntero</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>alias externo</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>Tipo de valor devuelto no válido en el atributo cref del comentario XML</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>El atributo CLSCompliant no tiene ningún significado cuando se aplica a parámetros</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>El primer operando de un operador "as" no puede ser un literal de tupla sin un tipo natural.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Clase de instrumentación no válida: {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>No se puede declarar un espacio de nombres en el código del script</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>Una variable interna pública o protegida debe ser de un tipo conforme a Common Language Specification (CLS).</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' tienen modificadores de accesibilidad que entran en conflicto</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'.</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>Posible comparación de referencias involuntaria. El lado de la mano derecha necesita conversión</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>No se puede escribir en el archivo de salida '{0}': '{1}'</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>Se esperaba la palabra clave 'this' o 'base'</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>El resultado de la expresión siempre es el mismo ya que un valor de este tipo siempre es igual a "null"</value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>No se puede usar 'yield' en el código de script de nivel superior</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>El método asincrónico carece de operadores "await" y se ejecutará de forma sincrónica</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>El tipo predefinido está definido en varios ensamblajes en el alias global</value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>'{0}': un argumento de atributo no puede usar parámetros de tipo</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>Se esperaba un operador sobrecargable</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>No se puede asignar a los campos del campo estático de solo lectura '{0}' (excepto en un constructor estático o un inicializador de variable)</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>No se especificaron archivos de código fuente.</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>'{0}' tiene una firma incorrecta para ser un punto de entrada</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>No puede haber cláusulas catch después de la cláusula catch general de una instrucción try</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>Falta un argumento</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>No se puede convertir una expresión lambda en un árbol de expresión cuyo argumento de tipo '{0}' no sea un tipo delegado</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>La operación en cuestión no está definida en punteros void</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>El delegado '{0}' no tiene método 'invoke' o tiene un método 'invoke' con un tipo de valor devuelto o unos tipos de parámetro que no son compatibles.</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>nombre de operador</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>No se puede adquirir la dirección, obtener el tamaño ni declarar un puntero a un tipo administrado ('{0}')</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>La funcionalidad '{0}' no forma parte de la especificación de idioma C# ISO normalizado y puede que otros compiladores no la admitan</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>El atributo '{0}' indicado en un archivo de origen entra en conflicto con la opción '{1}'.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>No se puede especificar el atributo CLSCompliant en un módulo que sea distinto del atributo CLSCompliant del ensamblado</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>El parámetro {0} no se debe declarar con la palabra clave '{1}'</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>No se puede usar await en el cuerpo de una cláusula finally</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>Un objeto, una cadena o un tipo de clase esperados</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>El metadato netmodule vinculado debe proporcionar una imagen PE completa: '{0}'.</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>No se recomienda definir un alias con el nombre 'global'</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>La variable out y las declaraciones de variable de patrón no se permiten en los inicializadores de constructor, de campo o de propiedades.</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred solamente se puede usar con /t:exe, /t:winexe y /t:appcontainerexe</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>'{0}': una clase con el atributo ComImport no puede especificar ninguna clase base</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>Como '{1}' tiene el atributo ComImport, '{0}' debe ser externo o abstracto</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>variable fixed</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>Conflicto de nombre en el nombre {0}</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>Una cláusula catch previa ya detecta todas las excepciones de este tipo o de tipo superior ('{0}')</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>Uso del campo '{0}' posiblemente sin asignar</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>No se pueden proporcionar tanto los cuerpos de bloque como los cuerpos de expresión.</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>System.Void no se puede usar en C#; use typeof(void) para obtener el objeto de tipo void</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>El modo de documentación proporcionado no se admite o no es válido: "{0}".</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>El operador '{0}' es ambiguo en un operando del tipo '{1}'</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>No se tiene en cuenta el nombre de elemento de tupla porque el destino de la asignación ha especificado otro nombre o no ha especificado ninguno.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>El ensamblaje referenciado no tiene un nombre seguro</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>Un método parcial no puede implementar explícitamente un método de interfaz</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>expresión lambda</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>No se puede usar '{0}' para el método Main porque se ha importado</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>El parámetro de un operador unario debe ser el tipo contenedor</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>Los structs no pueden contener constructores explícitos sin parámetros</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>El mejor método Add sobrecargado '{0}' para el elemento inicializador de la colección está obsoleto. {1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>La longitud de la constante de cadena supera el límite de memoria actual. Pruebe dividiendo la cadena en varias constantes.</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>El campo '{0}' debe estar totalmente asignado antes de que se devuelva el control al llamador</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>Debe especificar el atributo CLSCompliant en el ensamblado, no en el módulo, para habilitar la comprobación de conformidad con CLS</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>El ensamblado '{0}' al que se hace referencia no tiene un nombre seguro.</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>espacio de nombres</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>La llamada es ambigua entre los métodos o las propiedades siguientes: '{0}' y '{1}'</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>La constante de punto flotante está fuera del intervalo del tipo '{0}'</value>
  </data>
  <data name="ERR_InvalidDebugInfo" xml:space="preserve">
    <value>No se puede leer la información de depuración del método "{0}" (token 0x{1:X8}) desde el ensamblado "{2}".</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>No se puede emitir información de depuración para un texto de origen sin descodificar.</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>Opción '{0}' no válida; la visibilidad de los recursos debe ser 'public' o 'private'</value>
  </data>
  <data name="ERR_ExplicitReservedAttr" xml:space="preserve">
    <value>No use "{0}". Está reservado para uso del compilador.</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>No se puede restaurar la advertencia porque se ha deshabilitado globalmente</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>__arglist no se permite en la lista de parámetros de iteradores</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>No se puede convertir el elemento {0} asincrónico en el tipo delegado '{1}'. Un elemento {0} asincrónico puede devolver void, Task o Task&lt;T&gt;, ninguno de los cuales se puede convertir en '{1}'.</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>Atributo '{0}' duplicado</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>Se esperaba una etiqueta final para el elemento '{0}'.</value>
  </data>
  <data name="IDS_FeatureLeadingDigitSeparator" xml:space="preserve">
    <value>separador de dígito inicial</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Los argumentos de tipo no están permitidos en el nombre del operador.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>El tipo o el nombre del espacio de nombres '{0}' no existe en el espacio de nombres '{1}' (¿falta alguna referencia de ensamblado?)</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>'{0}': no se pueden proporcionar argumentos al crear una instancia de un tipo variable</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>Error al leer los recursos de Win32: {0}</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>No se encuentra el nombre de tipo '{0}' en el espacio de nombres global. Este tipo se ha reenviado al ensamblado '{1}'. Puede agregar una referencia a ese ensamblado.</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>No se puede devolver una expresión de tipo 'void'</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>Un parámetro ref o out no puede tener un valor predeterminado</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>No se encontró el nombre del tipo '{0}'. Este tipo se ha reenviado al ensamblado '{1}'. Puede agregar una referencia a ese ensamblado.</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>Los iteradores no pueden tener variables locales por referencia.</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>No se puede especificar un valor predeterminado para el parámetro 'this'</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>La expresión dada nunca es del tipo proporcionado ('{0}')</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta typeparam, pero no hay ningún parámetro de tipo con ese nombre</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>Ambas declaraciones de métodos parciales deben ser no seguras o ninguna de ellas puede ser no segura</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>El segundo operando de un operador 'is' o 'as' no puede ser el tipo estático '{0}'</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>Se ha marcado al tipo de base para que no tenga que ser conforme a Common Language Specification (CLS) en un ensamblador que se ha marcado como conforme a CLS. Elimine el atributo que especifica que el ensamblador es conforme a CLS o elimine el atributo que indica que el tipo no es conforme a CLS.</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>Un método con vararg no puede ser genérico, estar en un tipo genérico ni tener un parámetro params</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>'await' requiere que el tipo '{0}' tenga un método GetAwaiter adecuado. ¿Falta alguna directiva using para 'System'?</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>Se esperaba ; o = (no se pueden especificar argumentos de constructor en la declaración)</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>El tipo de valor devuelto del operador True o False debe ser bool</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>La restricción no puede ser la clase especial '{0}'</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>El tipo '{0}' reenviado al ensamblado '{1}' entra en conflicto con el tipo '{2}' reenviado al ensamblado '{3}'.</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>Los valores predeterminados no son válidos en este contexto.</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>El delegado '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>'{0}' no es conforme a CLS porque la interfaz base '{1}' no lo es</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>A la interfaz de origen '{0}' le falta el método '{1}', que es necesario para incrustar el evento '{2}'.</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>El parámetro del constructor de atributo '{0}' es opcional, pero no se especificó ningún valor de parámetro predeterminado.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener un operador de propagación NULL.</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>Alias '{0}' no encontrado</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>Inicialización del miembro '{0}' duplicada</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>Opción '{0}' no válida para /debug; debe ser 'portable', 'embedded', 'full' o 'pdbonly'</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>Solo se puede adquirir la dirección de una expresión de tipo unfixed de un inicializador de instrucción fixed</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>'{0}': una clase con el atributo ComImport no puede especificar inicializadores de campo.</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>'{0}': no se pueden declarar indizadores en una clase estática</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>'{0}' ya aparece en la lista de interfaces</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>El objeto 'this' no se puede utilizar antes de que se hayan asignado todos sus campos</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>'{0}': la propiedad o el indizador deben tener, al menos, un descriptor de acceso</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>Las variables con tipo implícito no pueden ser constantes</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>Se declaró una variable con el mismo nombre como una variable en la clase base. Sin embargo, la nueva palabra clave no está en uso. Esta advertencia le informa de que debería usar new. La variable se declaró como si new se hubiera usado en la declaración.</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de valor devuelto '{1}' es menos accesible que el método '{0}'</value>
  </data>
  <data name="ERR_FieldsInRoStruct" xml:space="preserve">
    <value>Los campos de instancia de las estructuras readonly deben ser readonly.</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para crear tokens literales de carácter.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>El uso de matrices como argumentos de atributo no es conforme a CLS</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>El valor de alineación {0} tiene una magnitud superior a {1} y puede dar lugar a una cadena con formato grande.</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>declaración de variable out</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>La comparación con la constante integral no es válida; la constante está fuera del intervalo del tipo '{0}'</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>'experimental'</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>El tipo "{0}" del ensamblado "{1}" no se puede usar en los distintos límites de ensamblado porque tiene un argumento de tipo genérico que es un tipo de interoperabilidad incrustado.</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction" xml:space="preserve">
    <value>La función local "{0}" se declara pero nunca se usa.</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>El operador as se debe usar con un tipo de referencia o un tipo que acepte valores NULL ('{0}' es un tipo de valor que no acepta valores NULL)</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>El objeto {0} abstracto "{1}" no se puede marcar como virtual.</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>'{0}': las clases estáticas no pueden contener operadores definidos por el usuario</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>La etiqueta '{0}' oculta otra etiqueta del mismo nombre en un ámbito contenido</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>El miembro '{1}' invalida '{0}'. Hay varios candidatos de invalidación en tiempo de ejecución. El método que se llamará depende de la implementación.</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>Se esperaba un descriptor de acceso get o set</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>No use 'System.ParamArrayAttribute'. Use la palabra clave 'params' en su lugar.</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>Nuevo miembro protegido declarado en la clase sealed</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>El tipo reenviado '{0}' entra en conflicto con el tipo declarado en el módulo primario de este ensamblado.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>Los dos ensamblajes difieren en el número de versión y/o compilación. Para que haya unificación, debe especificar directivas en el archivo .config de la aplicación y debe proveer el nombre seguro correcto de un ensamblaje.</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>El constructor '{0}' no puede llamarse a sí mismo a través de otro constructor</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>El archivo '{0}' al que se hace referencia no es un ensamblado</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>El operador binario sobrecargado '{0}' toma dos parámetros</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>El atributo Conditional no es válido en '{0}' porque es un método de reemplazo</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>La variable local '{0}' o sus miembros no pueden ceder su dirección para usarse en un método anónimo o una expresión lambda</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>Se espera SearchCriteria.</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>Las interfaces no pueden incluir constructores</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>Como '{0}' devuelve void, una palabra clave return no debe ir seguida de una expresión de objeto</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>Un operador definido por el usuario no puede adquirir un objeto de tipo envolvente ni convertirlo en un objeto de tipo envolvente</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>No se puede continuar porque la edición incluye una referencia a un tipo incrustado: '{0}'.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Como esta llamada no es 'awaited', la ejecución del método actual continuará antes de que se complete la llamada. Puede aplicar el operador 'await' al resultado de la llamada.</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>'{0}' no implementa el patrón '{1}'. '{2}' es estático o no público.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>Llame a System.IDisposable.Dispose() en la instancia asignada de {0} antes de que todas las referencias a él estén fuera de ámbito.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>La instancia asignada de {0} no se desecha en todas las rutas de acceso de excepciones. Llame a System.IDisposable.Dispose() antes de que todas las referencias a él estén fuera de ámbito.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>El nodo de sintaxis que se va a especular no puede pertenecer a un árbol de sintaxis de la compilación actual.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>El atributo de seguridad '{0}' tiene un valor '{1}' de SecurityAction no válido</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>Para convertir un valor negativo, el valor debe ir entre paréntesis</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>El nombre local '{0}' es demasiado largo para PDB. Puede acortar o compilar sin /debug.</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>Se esperaba una definición, una instrucción o un fin de archivo</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>Ya que no se esperaba esta llamada, la ejecución del método actual continúa antes de que se complete la llamada</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>Una cláusula using debe preceder al resto de elementos definidos en el espacio de nombres, excepto las declaraciones de alias externos</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>El operador 'await' solo se puede usar dentro de un método asincrónico. Puede marcar este método con el modificador 'async' y cambiar su tipo de valor devuelto a 'Task&lt;{0}&gt;'.</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>Un búfer fijo solo puede tener una dimensión.</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>El resultado de la expresión siempre es '{0}' porque un valor del tipo '{1}' nunca es igual a 'NULL' de tipo '{2}'</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>variable</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>No se puede usar el alias '{0}' con '::' porque el alias hace referencia a un tipo. Use '.'.</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Se encontró un marcador de conflicto de fusión mediante combinación</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>La referencia de ensamblado de confianza '{0}' no es válida. Las declaraciones InternalsVisibleTo no pueden tener especificada una versión, una referencia cultural, un token de clave pública ni una arquitectura de procesador.</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>Literal de carácter vacío</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>'{0}' no se puede agregar a este ensamblado porque ya es un ensamblado</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>No se admite la firma pública para netmodules.</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>El campo o la propiedad no pueden ser del tipo '{0}'</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>No se permiten nombres de elementos de tupla en el lado izquierdo de una deconstrucción.</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener un grupo de métodos</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>No se puede enlazar el delegado con '{0}' porque es un miembro de 'System.Nullable&lt;T&gt;'</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>método</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' deben tener los mismos nombres de parámetros de tipo en el mismo orden</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>El/los carácter/caracteres '{0}' no se puede/n usar en esta ubicación.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>El operador 'await' solo se puede usar dentro de un {0} asincrónico. Puede marcar este {0} con el modificador 'async'.</value>
  </data>
  <data name="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne" xml:space="preserve">
    <value>El primer parámetro de un método de extensión "ref" "{0}" debe ser un tipo de valor o un tipo genérico restringido a struct.</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>No se puede encadenar el modelo semántico especulativo. Tiene que crear un modelo especulativo desde el modelo principal no especulativo.</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>El programa tiene más de un punto de entrada definido. Compile con /main para especificar el tipo que contiene el punto de entrada.</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>La expresión de filtro es una constante, puede quitar el filtro</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_2" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 7.2. Use la versión {1} del lenguaje o una posterior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 7.1. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>No se puede incluir el fragmento de código XML '{1}' del archivo '{0}': {2}</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>El tipo '{0}' exportado del módulo '{1}' entra en conflicto con el tipo '{2}' exportado del módulo '{3}'.</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>Un punto de entrada no puede ser genérico ni estar en un tipo genérico</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>'{0}' no tiene ningún método Main estático adecuado</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>El nombre completo de '{0}' es demasiado largo para la información de depuración. Compile sin la opción '/debug'.</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>Los parámetros opcionales deben aparecer después de todos los parámetros necesarios</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>La advertencia está remplazando a un error</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>No existe ninguna referencia a esta etiqueta</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>La variable '{0}' se ha declarado pero nunca se usa</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>El uso de {1} de tipo genérico '{0}' requiere argumentos de tipo {2}</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>Se esperaba la directiva #endif</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>El método actual llama a un método asincrónico que devuelve una tarea o un Task&lt;TResult&gt;, y no aplica el operador Await al resultado. La llamada al método asincrónico inicia una tarea asincrónica. Sin embargo, debido a que no se aplica ningún operador Await, el programa continúa sin esperar a que finalice la tarea. En la mayoría de los casos, este comportamiento no es el esperado. Generalmente, otros aspectos del método de llamada dependen de los resultados de la llamada. O bien, se espera como mínimo que el método al que se llama se complete antes de volver al método que contiene la llamada.

Un problema de igual importancia es el que se genera con las excepciones que se producen en el método asincrónico al que se llama. Las excepciones que se producen en un método que devuelve una tarea o un Task&lt;TResult&gt; se almacenan en la tarea devuelta. Si no espera por la tarea o no realiza una comprobación explícita de excepciones, la excepción se pierde. Si espera por la tarea, su excepción se vuelve a producir.

Como procedimiento recomendado, siempre debe esperar por la llamada.

Considere la posibilidad de suprimir la advertencia solo si tiene la seguridad de que no desea esperar a que la llamada asincrónica se complete y que el método al que se llama no producirá excepciones. En ese caso, puede suprimir la advertencia asignando el resultado de la tarea de la llamada a una variable.</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>expresión de consulta</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>Valor no válido para el argumento del atributo '{0}'</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>El ensamblado válido no puede tener un módulo específico de procesador '{0}'.</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>Los especificadores de formato no pueden contener espacios en blanco al final.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>La variable está asignada pero nunca se usa su valor</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>Un descriptor de acceso add o remove debe tener un cuerpo</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>La implementación del método explícito '{0}' no puede implementar '{1}' porque es un descriptor de acceso</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>El miembro implementa el miembro de la interfaz con varias coincidencias en el tiempo de ejecución</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta param duplicada para '{0}'</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>El nombre de enumerador '{0}' está reservado y no se puede usar</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener un inicializador de diccionarios.</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>El miembro '{0}' no oculta un miembro accesible. La palabra clave new no es necesaria.</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation" xml:space="preserve">
    <value>Las especificaciones de argumento con nombre deben aparecer después de haber especificado todos los argumentos fijos en una invocación dinámica.</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>Un número que se aprobó en la directiva de preprocesador de advertencia #pragma no es un número de advertencia válido. Verifique que ese número representa una advertencia y no un error.</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>await en bloques catch y finally</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>'{0}': un punto de entrada no puede ser genérico ni estar en un tipo genérico</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>'{0}' no implementa el miembro de interfaz '{1}'</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}' y la mejor sobrecarga del método de extensión '{2}' requiere un receptor del tipo '{3}'</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#r solo se puede usar en scripts</value>
  </data>
  <data name="ERR_DynamicLocalFunctionTypeParameter" xml:space="preserve">
    <value>No se puede pasar un argumento con tipo dinámico a función local genérica "{0}" con argumentos de tipo inferido.</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Ya hay un árbol de sintaxis</value>
  </data>
  <data name="ERR_BadParameterModifiersOrder" xml:space="preserve">
    <value>El modificador de parámetro "{0}" no se puede usar después del modificador "{1}".</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Nombre de archivo salida no válido: {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>Una clase con el atributo ComImport no puede tener un constructor definido por el usuario</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>La expresión return debe ser de tipo '{0}' porque este método devuelve datos por referencia.</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Las propiedades implementadas automáticamente deben tener descriptores de acceso get.</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>El identificador '{0}' no es conforme a CLS</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Error al leer información de depuración de '{0}'</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>Las clases estáticas no pueden contener destructores</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>La expresión dada siempre es del tipo proporcionado ('{0}')</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>Las referencias de archivo de origen no son compatibles.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>No hay ningún orden definido entre campos en varias declaraciones de estructura parcial '{0}'. Para especificar un orden, todos los campos de instancia deben estar en la misma declaración.</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de valor devuelto de indizador '{1}' es menos accesible que el indizador '{0}'</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>El campo no conforme a CLS no puede ser volátil</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de parámetro '{1}' es menos accesible que el método '{0}'</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>el árbol debe tener un nodo raíz con SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>Solo las expresiones de asignación, llamada, incremento, decremento y objeto nuevo se pueden usar como instrucción</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>El CallerFilePathAttribute aplicado al parámetro '{0}' no tendrá efecto porque se aplica a un miembro que se usa en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>params no es válido en este contexto</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener un parámetro out o ref</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>No se puede inicializar el tipo '{0}' con un inicializador de colección porque no implementa 'System.Collections.IEnumerable'</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>El primer operando de un operador de desplazamiento sobrecargado debe tener el mismo tipo que el tipo contenedor, y el tipo del segundo operando debe ser int</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>inicializador de propiedad automático</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>Error al leer el recurso '{0}': '{1}'</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>Se esperaba una directiva de preprocesador</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>'await' no se puede usar en una expresión que contenga el tipo '{0}'</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>No se pueden especificar modificadores de accesibilidad para ambos descriptores de acceso de la propiedad o del indizador '{0}'</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Los nombres de elemento de tupla deben ser únicos.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>El nombre de idioma no es válido</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}': no se puede llamar explícitamente al operador ni al descriptor de acceso</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>'{0}' no puede ser externo y tener un inicializador de constructor</value>
  </data>
  <data name="IDS_StackAllocExpression" xml:space="preserve">
    <value>stackalloc {0}[{1}]</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>Las propiedades implementadas automáticamente no pueden devolver datos por referencia.</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>Falta el espacio en blanco necesario.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Falta la referencia al netmodule '{0}'.</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>La operación ha provocado un desbordamiento de pila.</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>variable de iteración foreach</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>'{0}': no se puede invalidar; '{1}' no es un evento</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>Elemento TypeForwardedToAttribute duplicado en '{0}'</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>Los búferes de tamaño fijo deben tener una longitud mayor que cero</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>'await' no se puede usar como identificador dentro de un método asincrónico o expresión lambda</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}' (use la sintaxis 'unchecked' para invalidar)</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>El identificador no es conforme a CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>inicializador de diccionarios</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>cadenas interpoladas</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>No todas las rutas de acceso de código devuelven un valor en {0} de tipo '{1}'</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>Posible comparación de referencias involuntaria: El lado de la mano izquierda necesita conversión</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>No se pudo resolver la ruta de acceso de archivo '{0}' especificada para el argumento con nombre '{1}' del atributo PermissionSet</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>Número no válido</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>El ensamblado '{0}' al que se hace referencia tiene una configuración de referencia cultural distinta de '{1}'.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>Referencia ambigua en el atributo cref</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>El primer parámetro de un método de extensión no puede ser del tipo '{0}'</value>
  </data>
  <data name="IDS_FeatureReadOnlyReferences" xml:space="preserve">
    <value>referencias readonly</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>'{0}' es {1}, que no es válida en el contexto indicado</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>El método sobrecargado '{0}' que solo se diferencia en out o ref, o en el rango de matriz, no es conforme a CLS</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>El tipo de parámetro 'void' no es válido</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>No se permiten restricciones en declaraciones no genéricas</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref sintácticamente incorrecto</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>métodos anónimos</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una expresión throw.</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>No se puede convertir el tipo '{0}' en '{1}'</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>El argumento con nombre '{0}' no se puede especificar varias veces</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>El especificador de tipo de matriz, [], debe ir delante del nombre del parámetro</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>No se puede convertir NULL en '{0}' porque es un tipo de valor que no acepta valores NULL.</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>El modificador 'partial' solo puede aparecer inmediatamente antes de 'class', 'struct', 'interface' o 'void'</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>El tipo de argumento para el atributo DefaultParameterValue debe coincidir con el tipo de parámetro</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>Opción de alias de referencia no válida: '{0}=', falta el nombre de archivo</value>
  </data>
  <data name="ERR_FieldAutoPropCantBeByRefLike" xml:space="preserve">
    <value>Un campo o una propiedad implementada automáticamente no pueden ser de tipo "{0}", a menos que sea un miembro de instancia de una estructura ref.</value>
  </data>
  <data name="ERR_BadNonTrailingNamedArgument" xml:space="preserve">
    <value>El argumento "{0}" con nombre se usa fuera de posición, pero va seguido de un argumento sin nombre.</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>Los miembros del campo de solo lectura "{0}" no se pueden devolver por referencia grabable.</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>No se puede usar una expresión del tipo '{0}' como argumento de una operación enviada de forma dinámica.</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>No se permiten expresiones de consulta con el tipo de origen 'dynamic' o con una secuencia de unión de tipo 'dynamic'</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>La opción '{0}' invalida el atributo '{1}' especificado en un archivo de código fuente o en un módulo agregado</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>'{0}': los nombres de los miembros no pueden coincidir con sus tipos envolventes</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>La palabra clave contextual 'var' solo puede aparecer dentro de una declaración de variable local o en código de script</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>El número base de la imagen '{0}' no es válido</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>Un evento de Windows Runtime no se puede pasar como parámetro out o ref.</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>La instancia de tipo "{0}" no se puede usar dentro de una función anidada, una expresión de consulta, un bloque iterador ni un método asincrónico.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>'{0}' no implementa el miembro de interfaz '{1}'. '{2}' no puede implementar '{1}' porque no tiene el tipo de valor devuelto coincidente de '{3}'.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>El tipo de una de las expresiones de la cláusula {0} es incorrecto. No se pudo realizar la inferencia de tipos en la llamada a '{1}'.</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref que hace referencia a un parámetro de tipo</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>Se espera un nombre de método</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>No se puede usar el valor local fijo '{0}' dentro de un método anónimo, una expresión lambda o una expresión de consulta</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>__arglist no es válido en este contexto</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Los elementos no pueden ser NULL.</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>No es un símbolo C#.</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>'{0}': los tipos estáticos no se pueden usar como parámetros</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>El tipo '{0}' exportado del módulo '{1}' entra en conflicto con el tipo declarado en el módulo primario de este ensamblado.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>La cadena de versión especificada no se ajusta al formato requerido: principal[.secundaria[.compilación[.revisión]]]</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>La instrucción foreach no puede funcionar en variables de tipo '{0}' porque implementa varias creaciones de instancias de '{1}'; intente convertirla en una creación de instancia de interfaz específica</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta param, pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>El tipo de valor devuelto por referencia 'ref {0}' no es compatible.</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>Se esperaba un identificador</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>coincidencia de patrones</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>El atributo CallerMemberNameAttribute no tendrá efecto: lo reemplaza el atributo CallerFilePathAttribute</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un acceso base</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>Un parámetro solo puede tener un modificador '{0}'</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>No existe la etiqueta '{0}' en el ámbito de la instrucción goto</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>El código no seguro solo puede aparecer si se compila con /unsafe</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>No se puede usar 'await' en una expresión que contiene una llamada a '{0}' porque devuelve datos por referencia.</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>'{0}': los miembros virtuales o abstractos no pueden ser privados</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>El ensamblaje referenciado tiene una configuración de cultura diferente</value>
  </data>
  <data name="ERR_InExtensionMustBeValueType" xml:space="preserve">
    <value>El primer parámetro de un método de extensión "in" "{0}" debe ser un tipo de valor.</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>Un valor de tipo '{0}' no se puede usar como parámetro predeterminado para el parámetro '{1}' que acepta valores NULL porque '{0}' no es un tipo simple</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>Un valor de tipo '{0}' no se puede usar como parámetro predeterminado porque no hay conversiones estándar al tipo '{1}'</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>'{0}' es abstracto pero está contenido en la clase no abstracta '{1}'</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>El módulo "{0}" del ensamblado "{1}" va a reenviar el tipo "{2}" a varios ensamblados: "{3}" y "{4}".</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>Deshabilitación o recuperación después de la advertencia de #pragma esperada</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>El valor '{0}' de SecurityAction no es válido para los atributos de seguridad aplicados a un tipo o método</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>'{0}' es {1} pero se usa como {2}</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>Las directivas de preprocesador deben ser el primer carácter de una línea que no sea un espacio en blanco</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>campo</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>alias using</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>El tipo no implementa la trama de colección. El miembro es estático o no es público</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>separadores de dígitos</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>evento</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>El modificador '{0}' no es válido para este elemento</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>Al archivo de clave '{0}' le falta la clave privada necesaria para firmar</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>etiqueta</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>La expresión __arglist solo puede aparecer dentro de una llamada o una expresión new</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>No se admite el algoritmo '{0}'</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>El método debe tener un tipo de valor devuelto</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>parámetro de tipo</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>Las enumeraciones no pueden contener constructores explícitos sin parámetros</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>No hay ninguna ubicación de atributo válida para esta declaración</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Error criptográfico al crear hashes.</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>Este método solo se puede usar para crear tokens: {0} no es un tipo de token.</value>
  </data>
  <data name="ERR_OverloadRefKind" xml:space="preserve">
    <value>"{0}" no puede definir un elemento {1} sobrecargado que difiere solo en los modificadores de parámetro "{2}" y "{3}".</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>El nombre '{0}' no existe en el contexto actual (¿falta alguna referencia al ensamblado '{1}'?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>La palabra clave 'base' no está disponible en el contexto actual</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>No se puede usar la variable local '{0}' antes de declararla</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>La cadena literal ']]&gt;' no se permite en el contenido de elemento.</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>'{0}': no puede implementar una interfaz dinámica '{1}'</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Parámetro no válido para el tipo no administrado especificado.</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>opción /REFERENCEPATH</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una referencia a una función local.</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>El campo tiene varios valores constantes distintos.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} versión {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>Copyright (C) Microsoft Corporation. Todos los derechos reservados.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>El valor '{0}' de SecurityAction no es válido en este tipo de declaración. Los atributos de seguridad solo son válidos en las declaraciones de ensamblado, de tipo y de método.</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>uso de versión estática</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Al miembro '{0}' agregado durante la sesión de depuración actual solo se puede acceder desde el ensamblado donde se declara, '{1}'.</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>No se puede usar #load después del primer token del archivo</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una declaración de variable de argumento out.</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>Tipo no válido para el parámetro {0} en el atributo cref del comentario XML: '{1}'</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de restricción '{1}' es menos accesible que '{0}'</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>'{0}' no puede ser abstracto y estar sellado a la vez</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>Carácter '{0}' inesperado</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>'{0}' no es un argumento de atributo con nombre válido. Los argumentos de atributo con nombre deben ser campos que no sean readonly, static ni const, o bien propiedades read-write que sean public y no static.</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>Directiva #pragma no reconocida</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>No se puede declarar una variable de tipo estático '{0}'</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>Ha añadido una referencia a un ensamblaje con /link (con la propiedad Embed Interop Types establecida como verdadera). Esto instruye al compilador para que inserte información del tipo de interoperabilidad desde ese ensamblaje. Sin embargo, el compilador no puede insertar información del tipo de interoperabilidad desde ese ensamblaje porque hay otro ensamblaje que ha referenciado que hace referencia a ese ensamblaje con /reference (con la propiedad Embed Interop Types establecida como falsa).

Para insertar información del tipo de interoperabilidad en ambos ensamblajes, use /link para las referencias de ambos ensamblajes (establezca la propiedad Embed Interop Types como verdadera).

Para eliminar la advertencia puede usar /reference (establezca la propiedad Embed Interop Types como falsa). En este caso, un ensamblaje de interoperabilidad primario (PIA) provee información del tipo de interoperabilidad.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>descriptor de acceso de propiedades del cuerpo de expresión</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>'{0}' define el operador == o el operador != pero no invalida Object.Equals(object o)</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Número de argumentos de tipo incorrecto</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>'{0}' no implementa el patrón '{1}'. '{2}' tiene una firma incorrecta.</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>Una declaración de espacio de nombres no puede tener modificadores ni atributos</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>'{0}': los tipos de campo de instancia marcados con StructLayout(LayoutKind.Explicit) deben tener un atributo FieldOffset</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>No se puede crear una instancia de la clase o interfaz abstracta '{0}'</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>Una implementación de interfaz explícita de un evento debe usar la sintaxis de descriptor de acceso de eventos</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>La evaluación del valor constante de '{0}' comprende una definición circular</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>'{0}' no es una ubicación de atributos válida para esta declaración. Las ubicaciones de atributos válidas son '{1}'. Todos los atributos de este bloque se omitirán.</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>'{0}' es ambiguo entre '{1}' y '{2}'; use '@{0}' o '{0}Attribute'</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>Se esperaba ;</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>La llamada distribuida dinámicamente puede fallar en el tiempo de ejecución porque una o más sobrecargas aplicables son métodos condicionales</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>El espacio de nombres entra en conflicto con un tipo importado</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>Un método parcial no puede tener varias declaraciones de implementación</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>No se puede usar '{0}' como valor out o ref porque es un '{1}'.</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>'{0}' ha concedido acceso de confianza, pero el nombre seguro que firma el estado del ensamblado de salida no coincide con el del ensamblado de concesión.</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>La restricción no puede ser un tipo dinámico '{0}'</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar al operando del tipo '{1}'</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>'{0}': una referencia a un campo volátil no se tratará como tal</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una operación dinámica</value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>Las variables locales con tipo implícito no pueden ser fijas</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>El tipo importado '{0}' no es válido. Contiene una dependencia de clase base circular.</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>Se encontraron varias implementaciones del patrón de consulta para el tipo de origen '{0}'. Llamada ambigua a '{1}'.</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>El modificador de línea de comandos '{0}' todavía no está implementado y se omitió.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>El método, operador o descriptor de acceso '{0}' está marcado como externo y no tiene atributos. Puede agregar un atributo DllImport para especificar la implementación externa.</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de parámetro '{1}' es menos accesible que el indizador '{0}'</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>propiedad con forma de expresión</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>El atributo FieldOffset no se permite en campos static ni const</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>No se puede usar la variable local de tipo ref '{0}' dentro de un método anónimo, una expresión lambda o una expresión de consulta.</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>El operador '{0}' es ambiguo en operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>El tipo de valor devuelto de '{0}' no es conforme a CLS</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>Asumiendo que la referencia al ensamblaje coincide con la identidad</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}' y no se encontró ningún método de extensión '{1}' que acepte un primer argumento de tipo '{0}' (¿falta alguna directiva using para '{2}'?)</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>Se especificó retrasar la firma y esto requiere una clave pública, pero no se ha especificado ninguna clave pública</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>La expresión siempre producirá System.NullReferenceException porque el valor predeterminado de '{0}' es NULL</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>Los indizadores deben tener al menos un parámetro</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>Usar '{0}' para probar la compatibilidad con '{1}' es, básicamente, lo mismo que probar la compatibilidad con '{2}' y surtirá efecto para todos los valores distintos de NULL</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>Se espera un valor de tipo entero</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>Esta funcionalidad de idioma ('{0}') todavía no está implementada.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>El árbol de sintaxis debe crearse desde un envío.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>El nombre completo es demasiado largo para la información de depuración</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>No se encontró ningún valor para RuntimeMetadataVersion. No se encontró ningún ensamblado que contuviese System.Object ni se especificó ningún valor para RuntimeMetadataVersion a través de las opciones.</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>La interfaz marcada con el atributo 'CoClassAttribute' no está marcada con el atributo 'ComImportAttribute'</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>La instancia asignada no está eliminada en todas las rutas de acceso de excepción</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>Se esperaba 'in'</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>Hay un error en un ensamblado al que se hace referencia: '{0}'.</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>El nombre '{0}' del elemento de tupla no se permite en ninguna posición.</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>Indizando una matriz con un índice negativo (los índices de matriz siempre comienzan por cero)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>El atributo CLSCompliant no tiene ningún significado cuando se aplica a tipos de valor devuelto. Pruebe a incluirlo en el método.</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>'{0}' especificada para el método Main debe ser una estructura o una clase no genérica válida</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>El mejor método Add sobrecargado '{0}' para el elemento inicializador de la colección está obsoleto. {1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>No se puede realizar la comprobación de conformidad a CLS porque no es visible fuera de este ensamblador</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' tienen restricciones incoherentes para el parámetro de tipo '{1}'</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>No se encontró '{0}' especificado para el método Main</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>Si se utiliza un campo de una clase de serialización por referencia como valor ref o out, o se acepta su dirección, se puede producir una excepción en tiempo de ejecución.</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>'{0}': no se pueden usar modificadores de accesibilidad en los descriptores de acceso de una interfaz</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>No se ha dado ningún argumento que corresponda al parámetro formal requerido '{0}' de '{1}'</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>El tipo de código fuente proporcionado no se admite o no es válido: "{0}"</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>No se puede especificar un valor predeterminado para una matriz de parámetros</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>Se ha asignado a la misma variable</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>Nombre no válido para un símbolo de preprocesamiento; "{0}" no es un identificador válido</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>'{0}' no puede implementar '{1}' y '{2}' a la vez porque se pueden unificar para algunas sustituciones de parámetros de tipo</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>El tipo '{0}' reenviado al ensamblado '{1}' entra en conflicto con el tipo '{2}' exportado del módulo '{3}'.</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de valor que no acepte valores NULL para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>El método tiene la firma incorrecta para ser un punto de entrada</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>Modificador '{0}' duplicado</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>de forma contravariante</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>Se esperaba una palabra clave, un identificador o una cadena detrás del especificador textual: @</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>A la implementación de interfaz explícita '{0}' le falta el descriptor de acceso '{1}'</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' debe ser un tipo no abstracto con un constructor público sin parámetros para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>'{0}': el tipo contenedor no implementa la interfaz '{1}'</value>
  </data>
  <data name="ERR_RefStructInterfaceImpl" xml:space="preserve">
    <value>"{0}": las estructuras ref no pueden implementar interfaces.</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>No se encontró ninguna implementación del patrón de consulta para el tipo de origen '{0}'. No se encontró '{1}'. ¿Falta alguna referencia a 'System.Core.dll' o alguna directiva using para 'System.Linq'?</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>Los operadores definidos por el usuario no pueden devolver un valor void</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>literales binarios</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>No se puede crear una matriz con un tamaño negativo</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>clases estáticas</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>La instrucción yield no se puede usar dentro de un método anónimo o una expresión lambda</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>El tipo '{0}' no se puede incrustar porque tiene un argumento genérico. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>El archivo de origen ha superado el límite de 16.707.565 líneas representables en el PDB. La información de depuración no será correcta</value>
  </data>
  <data name="IDS_FeatureRefStructs" xml:space="preserve">
    <value>estructuras ref</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>Las propiedades implementadas automáticamente dentro de las interfaces no pueden tener inicializadores.</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>'{0}' no implementa el miembro de interfaz '{1}'. '{2}' no es público.</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>'{1}' no define el parámetro de tipo '{0}'</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>El operador typeof no se puede usar en el tipo dinámico</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>El operando de un operador de incremento o decremento debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>El modificador /embed solo se admite al emitir un PDB.</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>'{0}' no puede ser externo y abstracto a la vez</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>Se requiere un objeto cuyo tipo se pueda convertir en '{0}'</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>No se puede crear ninguna instancia de la clase estática '{0}'</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>'{0}' oculta el miembro heredado '{1}'. Use la palabra clave new si su intención era ocultarlo.</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Carácter Unicode no válido.</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>Las expresiones lambda que devuelven datos por referencia no se pueden convertir en árboles de expresión.</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>No se puede definir una clase o un miembro que utiliza tuplas porque no se encuentra el tipo requerido de compilador '{0}'. ¿Falta alguna referencia?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Error al firmar la salida con una clave pública del archivo '{0}': {1}</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>'{0}': no se puede especificar a la vez una clase de restricción y la restricción 'class' o 'struct'</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>Las directivas de uso de versión estática solo se pueden aplicar a tipos. '{0}' es un espacio de nombres, no un tipo. Puede que deba utilizar una directiva de uso de espacio de nombres en su lugar</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>No se puede usar una expresión lambda como argumento de una operación enviada de forma dinámica sin convertirla antes en un tipo delegado o de árbol de expresión.</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>Las devoluciones por valor solo se pueden usar en métodos que devuelven datos por valor.</value>
  </data>
  <data name="ERR_EscapeStackAlloc" xml:space="preserve">
    <value>El resultado de una expresión stackalloc de tipo "{0}" no se puede usar en este contexto porque puede exponerse fuera del método contenedor.</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>Tipo no válido especificado como argumento para el atributo TypeForwardedTo</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>No se puede crear un delegado con '{0}' porque él mismo o un método que él invalida tiene un atributo Conditional</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>El uso del literal predeterminado no es válido en este contexto.</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'. Ya existe una conversión explícita (compruebe si le falta una conversión)</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>No se puede crear una instancia de analizador {0} desde {1} : {2}.</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>La directiva using apareció anteriormente en este espacio de nombre</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref que no se pudo resolver</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>No se puede hacer referencia a 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explícitamente. Use la sintaxis de tupla para definir nombres de tupla.</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>La expresión de filtro es una constante</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>Número no válido</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>El delegado '{0}' no toma {1} argumentos</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>'{0}' oculta el miembro abstracto heredado '{1}'</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>Parámetro de tipo duplicado '{0}'</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>Un evento de una interfaz no puede tener los descriptores de acceso add y remove</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>El mejor método Add sobrecargado para el elemento inicializador de la colección está obsoleto</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>Se han proporcionado distintos valores de suma de comprobación para '{0}'</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>'{0}': el evento debe ser de tipo delegado</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>Se esperaba una expresión tras la instrucción yield return</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>El modificador /sourcelink solo se admite al emitir PDB.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>El primer argumento de un atributo de seguridad debe ser una SecurityAction válida</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>La palabra clave contextual 'var' no se puede usar en una declaración de variable de rango</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>Alias externo no válido para '/reference'; '{0}' no es un identificador válido</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>El miembro oculta el miembro heredado. Falta una contraseña de invalidación</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>El atributo FieldOffset solo se puede colocar en miembros de tipos marcados con StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta de parámetro duplicada</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>tipo</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>'{0}': los tipos estáticos no se pueden usar como argumentos de tipo</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>No se permite una expresión throw en este contexto.</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>El CallerLineNumberAttribute aplicado al parámetro '{0}' no tendrá efecto porque se aplica a un miembro que se usa en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>Se esperaba un operador binario sobrecargable</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>No se encontró el mejor tipo para la matriz con tipo implícito</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>No se permite un espacio en blanco en esta ubicación.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>El comentario XML no está situado en un elemento válido del idioma</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>No se puede utilizar un tamaño negativo con stackalloc</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>Error de sintaxis de línea de comandos: falta '{0}' para la opción '{1}'</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>Los punteros y los búferes de tamaño fijo solo se pueden utilizar en un contexto no seguro</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>El método sobrecargado que solo difiere por tipos de matriz sin nombre no es conforme a CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>Error al compilar recursos de Win32: {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>En los árboles de expresión no se pueden usar métodos parciales con solo una declaración de definición ni métodos condicionales quitados</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>El nombre "{0}" del elemento de tupla se ha deducido. Use la versión {1} del lenguaje, o una versión posterior, para acceder a un elemento por el nombre deducido.</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>Posible comparación de referencias no intencionada; para obtener una comparación de valores, convierta el lado de la derecha en el tipo '{0}'</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta typeparam duplicada</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>El ensamblado '{0}' con la identidad '{1}' usa '{2}', que tiene una versión superior a la del ensamblado '{3}' al que se hace referencia y que tiene la identidad '{4}'</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>El {1} '{0}' no genérico no se puede usar con argumentos de tipo</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>El nombre de ensamblado '{0}' está reservado y no se puede usar como referencia en una sesión interactiva</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>El tipo define operator == or operator !=, pero no reemplaza a override Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>'{0}': el tipo debe ser '{2}' para que coincida con el miembro invalidado '{1}'</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>Operador OR bit a bit usado en un operando con extensión de signo; puede convertir primero a un tipo sin signo más pequeño</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>No puede utilizar los búferes de tamaño fijo contenidos en expresiones de tipo unfixed. Pruebe a usar la instrucción fixed.</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>No se puede adquirir la dirección de la expresión dada</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>Un árbol de expresión no puede contener '{0}'</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>No se puede especificar un valor de parámetro predeterminado junto con DefaultParameterAttribute u OptionalAttribute</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>No se encontró ninguna instancia de deconstrucción o método de extensión adecuado para el tipo "{0}", con {1} parámetros out y un tipo de valor devuelto void.</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>Un método de extensión debe definirse en una clase estática no genérica</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>'{0}' es de tipo '{1}'. Un campo const de un tipo de referencia que no sea de cadena solo se puede inicializar con NULL.</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>La restricción 'new()' no se puede utilizar con la restricción 'struct'</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>No se permite __arglist en la lista de parámetros de métodos asincrónicos</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>No use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use la palabra clave 'this' en su lugar.</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>Se esperaba un descriptor de acceso add o remove</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>El control no puede abandonar el cuerpo de un método anónimo o de una expresión lambda</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>El miembro obsoleto invalida un miembro no obsoleto</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>La restricción de tipo de clase '{0}' debe preceder a cualquier otra restricción</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>"{0}" debe coincidir por referencia con el tipo de valor devuelto del miembro invalidado "{1}".</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>El atributo CallerFilePathAttribute no tendrá efecto: lo reemplaza el atributo CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>Los grupos de métodos de extensión como argumento de 'nameof' no están permitidos.</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>No se puede inicializar una variable por valor con una referencia.</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}' ni se encuentra ningún método de extensión '{1}' que acepte un primer argumento del tipo '{0}' (¿falta alguna directiva using o una referencia de ensamblado?)</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} '{0}' no se puede usar con argumentos de tipo</value>
  </data>
  <data name="ERR_EscapeLocal" xml:space="preserve">
    <value>No se puede usar un elemento "{0}" local en este contexto porque puede exponer variables a las que se hace referencia fuera de su ámbito de declaración.</value>
  </data>
  <data name="ERR_EscapeOther" xml:space="preserve">
    <value>No se puede usar una expresión en este contexto porque puede exponer variables indirectamente fuera de su ámbito de declaración.</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>Un método parcial no puede tener varias declaraciones de definición</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>La referencia de ensamblado '{0}' no es válida y no se puede resolver</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>Las clases estáticas no pueden tener constructores de instancia</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>'await' requiere que el tipo {0} tenga un método GetAwaiter adecuado</value>
  </data>
  <data name="ERR_EscapeCall2" xml:space="preserve">
    <value>No se puede usar un miembro del resultado de "{0}" en este contexto porque puede exponer variables a las que el parámetro "{1}" hace referencia fuera de su ámbito de declaración.</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>El tipo '{1}' reserva ya un miembro denominado '{0}' con los mismos tipos de parámetro</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>El tipo de argumento no es conforme a CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>Secuencia de escape no reconocida</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>El parámetro no tiene una etiqueta param coincidente en el comentario XML (pero otros parámetros sí)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>La interfaz heredada '{1}' crea un ciclo en la jerarquía de interfaz de '{0}'</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>El nombre del tipo o del espacio de nombres '{0}' no se encontró en el espacio de nombres global (¿falta alguna referencia de ensamblado?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>No se puede usar await en la expresión de filtro de una cláusula catch</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>Solo se pueden usar expresiones de inicializador de matriz como asignación a tipos de matriz. Pruebe a utilizar una expresión new en su lugar.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>Las variables con tipo implícito se deben inicializar</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>La declaración de parámetros de tipo debe ser un identificador, no un tipo</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>'{0}': nuevo miembro protegido declarado en estructura</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>'{0}': las clases estáticas no pueden contener miembros protegidos</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>'{0}': no se puede declarar miembros de instancia en una clase estática</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Los archivos ejecutables no pueden ser ensamblados satélite y no deben tener referencia cultural</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>El uso de la palabra clave 'base' no es válido en este contexto</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>El tipo '{0}' está definido en un ensamblado al que no se hace referencia. Debe agregar una referencia al ensamblado '{1}'.</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>'{0}' agrega un descriptor de acceso que no se encuentra en el miembro de interfaz '{1}'</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>Opción no reconocida: '{0}'</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>Los métodos Async no se permiten en interfaces, clases ni estructuras que tienen el atributo 'SecurityCritical' o 'SecuritySafeCritical'.</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>Es posible que el primer operando de un operador 'is' o 'as' no sea una expresión lambda, un método anónimo ni un grupo de métodos.</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>Un acceso de matriz no puede tener un especificador de argumento con nombre</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>No se puede usar un grupo de métodos como argumento de una operación enviada de forma dinámica. ¿Quería invocar el método?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>No se puede usar un campo de solo lectura como valor out o ref (excepto en un constructor).</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>Se ha llamado a GetDeclarationName para un nodo de declaración que puede contener varios declaradores de variables.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>Este error se produce cuando tiene un método sobrecargado que toma una matriz escalonada y cuando la única diferencia entre firmas del método es el tipo de elemento del rango. Para evitar este error, considere utilizar una matriz rectangular en vez de una matriz escalonada. Utilice un parámetro adicional para desambiguar la función de llamada. Cambie el nombre de uno o de varios métodos sobrecargados. Si no necesita la conformidad a CLS, elimine el atributo CLSCompliantAttribute.</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>Los nombres de elementos de tupla en la firma del método '{0}' deben coincidir con los del método de interfaz '{1}' (que se incluye en el tipo de valor devuelto).</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>Atributo '{0}' duplicado en '{1}'</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>función asincrónica</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Formato de la información de depuración no válido: {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>¿Pretendía utilizar la etiqueta de conmutador predeterminada (`default:`) en lugar de `case default:`? Si de verdad pretendía utilizar el literal predeterminado, considere el uso de `case (default):` u otro literal (`case 0:` o `case null:`) según corresponda.</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>Los métodos asincrónicos no pueden tener parámetros no seguros o tipos de valor devuelto</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>El miembro invalida los miembros obsoletos</value>
  </data>
  <data name="ERR_AssignReadonlyNotField" xml:space="preserve">
    <value>No se puede asignar a {0} "{1}" porque es una variable readonly.</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>Los métodos asincrónicos no pueden tener variables locales por referencia.</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>Solo las propiedades implementadas automáticamente pueden tener inicializadores.</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>No se puede crear el nombre de archivo corto '{0}' cuando ya existe un nombre de archivo largo con el mismo nombre de archivo corto</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#advertencia: '{0}'</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>Un miembro estático '{0}' no se puede marcar como invalidación, virtual o abstracto</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>La parte izquierda de una asignación debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>Un miembro '{0}' marcado como override no se puede marcar como new o virtual</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>Ambas declaraciones de método parcial, '{0}' y '{1}', deben usar los mismos nombres de elementos de tupla.</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>Los miembros de struct no pueden devolver 'this' ni otros miembros de instancia por referencia.</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>'{0}': no todas las rutas de acceso de código devuelven un valor</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>El caso del modificador ya se ha gestionado en un caso anterior.</value>
  </data>
  <data name="ERR_EscapeCall" xml:space="preserve">
    <value>No se puede usar un resultado de "{0}" en este contexto porque puede exponer variables a las que el parámetro "{1}" hace referencia fuera de su ámbito de declaración.</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>El tipo '{0}' no se puede reenviar porque es un tipo anidado de '{1}'</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>Se esperaba un comentario de una línea o un fin de línea</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>La restricción no puede ser el tipo dinámico</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>Es necesario asignar el parámetro '{0}' out antes de que el control abandone el método actual</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>Nombre no válido para un símbolo de preprocesamiento; no es un identificador válido</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>El sufijo 'l' se confunde fácilmente con el dígito '1': utilice 'L' para mayor claridad</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>'{0}' en la declaración explícita de la interfaz no es una interfaz</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>'{0}': no se puede invalidar '{1}' porque el lenguaje no lo admite</value>
  </data>
  <data name="ERR_BadParameterModifiers" xml:space="preserve">
    <value> El modificador de parámetro "{0}" no se puede usar con "{1}".</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>No se puede usar como método el miembro '{0}' no invocable.</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>Un valor out o ref debe ser una variable asignable.</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>Se debe indicar SyntaxTreeSemanticModel para proporcionar una cualificación de tipo mínima.</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>El tipo '{0}' está definido en un módulo que todavía no se ha agregado. Debe agregar el módulo '{1}'.</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>El espacio de nombres '{1}' de '{0}' está en conflicto con el tipo '{3}' de '{2}'</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>'{0}': un constructor estático no debe tener parámetros</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>Un parámetro Out no puede tener un atributo In</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>grupo de métodos</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>El campo nunca se asigna y siempre tendrá su valor predeterminado</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>El método '{0}' tiene un modificador de parámetro 'this' que no está en el primer parámetro</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>No se pueden usar comillas no ASCII en los literales de cadena.</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>Clase base requerida para una referencia 'base'</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>Directiva de preprocesador inesperada</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>La comprobación de conformidad con CLS no se realizará en '{0}' porque no es visible desde fuera de este ensamblado</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>'{0}': no se puede invalidar porque '{1}' no es una propiedad</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>Un patrón de tipo "{1}" no puede controlar una expresión de tipo "{0}" en C# {2}. Use la versión {3} del lenguaje o una versión posterior.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>La variable '{0}' está asignada pero su valor nunca se usa</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>El nombre '{0}' del elemento de tupla solo se permite en la posición {1}.</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>Hay más de un modificador de protección</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref '{0}' con sintaxis incorrecta</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>'{0}' no es compatible con el idioma</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta paramref, pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>El operador 'await' solo se puede usar dentro de un método asincrónico. Puede marcar este método con el modificador 'async' y cambiar su tipo de valor devuelto a 'Task'.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>No se puede actualizar '{0}'; falta el atributo '{1}'.</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>'{0}': nuevo miembro protegido declarado en clase sellada</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>El control no puede pasar explícitamente de una etiqueta case ('{0}') a otra</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>No se puede convertir {0} en el tipo '{1}' porque no es un tipo delegado</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>Una expresión lambda con un cuerpo de instrucción no se puede convertir en un árbol de expresión</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Compilador de Microsoft (R) Visual C#</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>No se puede convertir el tipo '{0}' en '{1}' mediante una conversión de referencia, boxing, unboxing, de ajuste del texto o de tipo NULL</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>Un puntero solo puede estar indizado por un valor</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>Número de advertencia no válido</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>variables locales y devoluciones por referencia</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>No se puede pasar un argumento de tipo dinámico al parámetro params '{0}' de la función local '{1}'.</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>El método de interoperabilidad incrustado '{0}' contiene un cuerpo.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>El mejor método Add sobrecargado '{0}' para el elemento inicializador de la colección está obsoleto.</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>dinámico</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>No se puede usar la variable local '{0}' antes de declararla. La declaración de la variable local oculta el campo '{1}'.</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>No se puede definir o anular la definición de símbolos de preprocesador después del primer token del archivo</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>No se pueden especificar a la vez las opciones de compilación '{0}' y '{1}'.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>El atributo CallerMemberNameAttribute no tendrá efecto porque se aplica a un miembro que se utiliza en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>La operación se desborda en el momento de la compilación en modo checked</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>calificador de alias de espacio de nombres</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>No se permite una instrucción throw sin argumentos fuera de una cláusula catch</value>
  </data>
  <data name="ERR_BadSpecialByRefIterator" xml:space="preserve">
    <value>La instrucción foreach no puede funcionar en enumeradores de tipo "{0}" en métodos async o iterator porque "{0}" es una estructura ref.</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>El evento '{0}' nunca se usa</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>El comentario XML no está situado en un elemento de idioma válido</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Error al escribir en el archivo de documentación XML: {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>genéricos</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>La interfaz '{0}' marcada con 'CoClassAttribute' no está marcada con 'ComImportAttribute'</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>No se pueden usar campos de '{0}' como valores out o ref porque es un '{1}'.</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>Uso de una propiedad implementada automáticamente posiblemente sin asignar '{0}'</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>El campo '{0}' nunca se usa</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>No existe ninguna referencia a esta etiqueta</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>'{0}' es un argumento de atributo con nombre duplicado</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>No se puede establecer una referencia a una variable de tipo '{0}'</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>El operador 'await' solo se puede usar cuando está contenido dentro de un método o una expresión lambda marcada con el modificador 'async'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un literal de tupla.</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>Comparación hecha a la misma variable</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>No se puede utilizar un literal predeterminado como argumento para una operación distribuida dinámicamente.</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>No se pueden aplicar expresiones de inicializador de objeto y colección a una expresión de creación de delegado</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta typeparam duplicada para '{0}'</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>'{0}': no se permiten conversiones definidas por el usuario ni a una clase derivada ni desde ella</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>'{0}' no es un especificador de formato válido</value>
  </data>
  <data name="ERR_RefConditionalAndAwait" xml:space="preserve">
    <value>No se puede usar "await" en una expresión que contiene un operador condicional ref.</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>Ya se ha importado un ensamblado con el mismo nombre sencillo '{0}'. Intente quitar una de las referencias (por ej., '{1}') o fírmelas para habilitar la función en paralelo.</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>El operador 'await' no se puede usar en un inicializador de variable de script estático.</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>No se puede heredar la interfaz '{0}' con los parámetros de tipo especificados porque da lugar a que el método '{1}' contenga sobrecargas que difieren solo en ref y out</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>El nombre '{0}' no está dentro del ámbito en el lado izquierdo de 'equals'. Puede intercambiar las expresiones en cualquier lado de 'equals'.</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>CallerFilePathAttribute no se puede aplicar porque no hay conversiones estándar del tipo '{0}' al tipo '{1}'</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>El identificador '{0}' que solo se diferencia por el uso de mayúsculas o minúsculas no es conforme a CLS</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de propiedad '{1}' es menos accesible que la propiedad '{0}'</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>Error al abrir el archivo de recursos de Win32 '{0}': '{1}'</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato vacío.</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>Operador OR bit a bit utilizado en un operando de extensión de signo</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>El resultado de la expresión siempre es el mismo ya que un valor de este tipo siempre es igual a "null"</value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>Error en el acceso del miembro de identificador transparente para el campo '{0}' de '{1}'. ¿Los datos consultados implementan el patrón de consulta?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>CallerLineNumberAttribute no se puede aplicar porque no hay conversiones estándar del tipo '{0}' al tipo '{1}'</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>'extern alias' no es válido en este contexto</value>
  </data>
  <data name="ERR_RefConditionalNeedsTwoRefs" xml:space="preserve">
    <value>Ambos valores de operador condicional deben ser valores ref o ninguno de ellos debe ser un valor ref.</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>El tipo '{0}' no se puede incrustar porque es un tipo anidado. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>No se puede especificar el atributo CLSCompliant en un módulo que sea distinto del atributo CLSCompliant del ensamblado</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}. Vea también el error CS{1}.</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>Tipo base no válido</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>El nombre de tipo '{0}' no existe en el tipo '{1}'</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value> No se encontraron elementos coincidentes para la siguiente etiqueta de inclusión </value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>El tipo reemplaza a Object.Equals(object o), pero no reemplaza a Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>El valor "goto case" no es implícitamente convertible al tipo switch</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>Se especificó la opción del compilador /doc, pero una o más construcciones no tenían comentarios.</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>'{0}': no se puede invalidar el miembro heredado '{1}' porque no está marcado como virtual, abstract ni override</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>El nombre de parámetro '{0}' está duplicado</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>'{0}': no se permiten modificadores de acceso en constructores estáticos</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>Uso inesperado de un nombre genérico sin enlazar</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>El descriptor de acceso '{0}' no puede implementar el miembro de interfaz '{1}' para el tipo '{2}'. Use una implementación de interfaz explícita.</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>Ambas declaraciones de método parcial deben ser métodos de extensión; si no, no puede serlo ninguna de las dos</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Se esperaba catch o finally</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>Una expresión new requiere (), [] o {} después del tipo</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>La variable está declarada pero nunca se usa</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>Se encontró el fin del archivo y se esperaba '*/'</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>No se puede hacer referencia a la compilación de tipo '{0}' desde {1} compilación.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>'{0}' oculta el miembro heredado '{1}'. Para hacer que el miembro actual invalide esa implementación, agregue la palabra clave override. Si no, agregue la palabra clave new.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>'{0}' no implementa el miembro de interfaz '{1}'. '{2}' no puede implementar un miembro de interfaz porque no es público.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>Se esperaba un SemanticModel de {0}.</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>operador predeterminado</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>No se permiten declaraciones de variable out y variable pattern dentro de una cláusula de consulta.</value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>No se puede asignar un valor de tipo "void".</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>literal predeterminado</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>Un patrón de tipo "{1}" no puede controlar una expresión de tipo "{0}".</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>Se especificaron opciones conflictivas: archivo de recursos de Win32; icono de Win32</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>El atributo se omite cuando se especifica la firma pública.</value>
  </data>
  <data name="ERR_TypeReserved" xml:space="preserve">
    <value>El nombre de tipo "{0}" está reservado para uso del compilador.</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>El nombre '{0}' no está dentro del ámbito en el lado derecho de 'equals'. Puede cambiar las expresiones en cualquier lado de 'equals'.</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>'{0}': no se pueden cambiar los nombres de elementos de tupla al reemplazar el miembro heredado '{1}'</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>La longitud combinada de las cadenas de usuario que el programa utiliza supera el límite permitido. Intente disminuir el uso de literales de cadena.</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>Se esperaba {</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>El sufijo "l" se confunde fácilmente con el número "1"</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>Carácter inesperado en esta ubicación.</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>Se esperaba '&gt;' o '/&gt;' para cerrar la etiqueta '{0}'.</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>El parámetro de tipo no tiene una etiqueta typeparam coincidente en el comentario XML (pero otros parámetros de tipo sí)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>No es aconsejable definir ningún alias denominado 'global' porque 'global::' siempre hace referencia al espacio de nombres global y no a un alias</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>El CallerMemberNameAttribute aplicado al parámetro '{0}' no tendrá efecto porque se aplica a un miembro que se usa en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>El parámetro del constructor de atributo '{0}' tiene el tipo '{1}', que no es un tipo de parámetro de atributo válido</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>Modificador de varianza no válido. Solo se pueden especificar como variantes parámetros de tipo de interfaz y delegado.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>El método sobrecargado solo difiere en ref o out, o bien en el rango de matriz. No es conforme a CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>'{0}': un campo volátil no puede ser del tipo '{1}'</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>Una expresión stackalloc requiere [] después del tipo</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>Declarador de miembro de tipo anónimo no válido. Los miembros de tipo anónimo deben declararse con una asignación de miembro, un nombre simple o un acceso al miembro.</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>Una tupla no puede contener un valor de tipo "void".</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>No puede especificar solo el atributo Out en un parámetro ref. Use los atributos In y Out, o bien no utilice ninguno.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>El archivo de código fuente '{0}' se especificó varias veces</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>Los miembros de la propiedad '{0}' de tipo '{1}' no se pueden asignar con un inicializador de objeto porque es de un tipo de valor</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>'{0}': las estructuras no pueden llamar a constructores de clase base</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>El tipo no implementa la trama de colección. Los miembros son ambiguos</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>stackalloc no se puede usar en un bloque catch o finally</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>Se esperaba un literal de cadena, pero no se encontró la comilla de apertura.</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>'{0}' no puede ser externo y declarar un cuerpo</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>Expresión de preprocesador no válida</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>La palabra clave 'this' no está disponible en el contexto actual</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>SyntaxTree '{0}' se obtuvo de una directiva #load y no se puede quitar ni reemplazar directamente.</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>Directiva #pragma no reconocida</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>Un tipo anónimo no puede tener varias propiedades con el mismo nombre</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>El nombre '{0}' supera la longitud máxima permitida en los metadatos.</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>No se puede usar una directiva de uso de versión estática para declarar un alias</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>Asignación a la misma variable. ¿Quería asignar otro elemento?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>Nunca se usa el evento</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>El evento '{0}' solo puede aparecer a la izquierda de += o -=.</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> La etiqueta de inclusión no es válida </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>El reenviador del tipo '{0}' en el ensamblado '{1}' crea un ciclo</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>El tipo '{0}' ya contiene una definición para '{1}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una llamada o invocación que use argumentos opcionales</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>No se pudo abrir el archivo de metadatos '{0}': {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>La comparación con NULL de tipo '{0}' siempre genera 'false'</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>módulo como especificador de destino de atributo</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>Esta advertencia puede producirse cuando dos métodos de interfaz solo se diferencian por la marca de un parámetro particular con ref o out. Es mejor cambiar su código para evitar esta advertencia porque no es obvio ni se garantiza qué método se llamará en el tiempo de ejecución.

A pesar de que C# distingue entre out y ref, el CLR los ve como iguales. Cuando decida qué método implementa la interfaz, el CLR escoge uno.

Indique al compilador alguna forma de diferenciar los métodos. Por ejemplo, puede darles nombres diferentes o dar un parámetro adicional a uno de ellos.</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>No se puede usar #r después del primer token del archivo</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>'{0}' no implementa el miembro de interfaz '{1}'. '{2}' no puede implementar un miembro de interfaz porque es estático.</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>No se puede inicializar una variable por referencia con un valor.</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>argumento con nombre</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>El tipo predefinido '{0}' está definido en varios ensamblados del alias global; se usa la definición de '{1}'</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>Un lambda de árbol de expresión no puede contener una llamada a un método, una propiedad o un indexador que devuelva datos por referencia.</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>Un método parcial no puede tener modificadores de acceso ni los modificadores virtual, abstracto, invalidación, nuevo, sellado o externo</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>Falta el signo igual entre el atributo y el valor de atributo.</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>No se puede deconstruir una tupla de '{0}' elementos en '{1}' variables.</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>'{0}' no implementa el miembro abstracto heredado '{1}'</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>No se puede crear una instancia del tipo de variable '{0}' porque no tiene la restricción new()</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>El tipo de '{0}' no se puede inferir porque su inicializador hace referencia, directa o indirectamente, a la definición.</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#load solo se permite en scripts</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>El método sobrecargado '{0}' que solo se diferencia por tipos de matriz sin nombre no es conforme a CLS</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>Las restricciones 'class' o 'struct' deben preceder a cualquier otra restricción</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>Un argumento de atributo debe ser una expresión constante, una expresión typeof o una expresión de creación de matrices de un tipo de parámetro de atributo</value>
  </data>
  <data name="IDS_FeatureReadOnlyStructs" xml:space="preserve">
    <value>estructuras readonly</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;expresión throw&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>tipos parciales</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>El parámetro genérico es definición cuando se espera que sea la referencia {0}</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>La sintaxis 'var (...)' como valor L está reservada.</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>Omitiendo la opción /noconfig porque se especificó en un archivo de respuesta</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>Operando no válido para la coincidencia de patrones. Se requería un valor, pero se encontró '{0}'.</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>'{0}': la propiedad o el indizador no pueden tener el tipo void</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>'{0}': no se puede invalidar el miembro heredado '{1}' porque está sellado</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>Los iteradores no pueden tener parámetros ref ni out</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>La propiedad indizada '{0}' debe tener todos los argumentos opcionales</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>Uso incoherente del parámetro lambda; los tipos de parámetro deben ser todos explícitos o todos implícitos</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>No es posible cargar el ensamblaje del analizador</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>No se puede deducir el tipo de descarte con tipo implícito.</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>El tipo '{0}' de la lista de interfaces no es una interfaz</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>elemento</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>El parámetro __arglist debe ser el último en una lista de parámetros formales</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un operador de coincidencia de patrones 'is'.</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>No se permiten atributos en los parámetros de tipo o parámetros de funciones locales.</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>Conversiones ambiguas definidas por el usuario '{0}' y '{1}' al convertir de '{2}' a '{3}'</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>El tipo de interoperabilidad '{0}' no se puede incrustar. En su lugar, use la interfaz aplicable.</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>La expresión debe ser de tipo '{0}' porque se asigna por referencia.</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>El ensamblaje no contiene ningún analizador</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>Indexando una matriz con un índice negativo</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>Las propiedades que devuelven datos por referencia no pueden tener descriptores de acceso.</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>Error de sintaxis de línea de comandos: falta ':&lt;número&gt;' para la opción '{0}'</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>La referencia al tipo '{0}' confirma que está definida en '{1}', pero no se encontró</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>Asignación posiblemente incorrecta a la variable local '{0}', que es el argumento pasado a una instrucción using o lock. La llamada Dispose o el desbloqueo se producirán en el valor original de la variable local.</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>La tupla con {0} elementos no se puede convertir al tipo '{1}'.</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>El carácter '&lt;' no se puede usar en un valor de atributo.</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>Sintaxis de #pragma checksum no válida; debe ser #pragma checksum "nombre de archivo" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>de forma no variante</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>"{0}" se incluye con fines de evaluación y está sujeto a cambios o a que se elimine en próximas actualizaciones.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>La posición no está dentro del árbol de sintaxis con el intervalo completo {0}</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>No se puede definir un nuevo método de extensión porque no se encontró el tipo '{0}' requerido por el compilador. ¿Falta alguna referencia a System.Core.dll?</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>Para que se pueda aplicar un operador de cortocircuito, el operador lógico definido por el usuario ('{0}') debe tener el mismo tipo de valor devuelto y los mismos tipos de parámetros</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>La comparación se ha hecho con la misma variable. ¿Quería comparar otro elemento?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>El identificador difiere solo en caso de que no sea conforme a CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>Literal real no válido.</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>No se puede usar la instrucción fixed para adquirir la dirección de una expresión de tipo fixed</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>'{0}' no tiene constructores accesibles que usen solo tipos conformes a CLS</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>No se pudo realizar la evaluación de la expresión de la constante decimal y se produjo un error</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>La etiqueta '{0}' está duplicada</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>No se puede asignar un campo de solo lectura (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>El alias using '{0}' aparece previamente en este espacio de nombres</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>El argumento {0} se debe pasar con la palabra clave '{1}'</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>Valor no válido para el argumento '{0}' del atributo con nombre</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>Restricción '{0}' duplicada para el tipo de parámetro '{1}'</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>Los miembros del campo de solo lectura '{0}' de tipo '{1}' no se pueden asignar con un inicializador de objeto porque es de un tipo de valor</value>
  </data>
  <data name="ERR_FieldlikeEventsInRoStruct" xml:space="preserve">
    <value>No se admiten eventos de tipo campo en estructuras readonly.</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>El modificador 'async' solo se puede usar en métodos que tengan un cuerpo.</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' no deben especificar clases base diferentes</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>'{0}' no es accesible debido a su nivel de protección</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>Los miembros heredados '{0}' y '{1}' tienen la misma firma en el tipo '{2}', por lo que no se pueden reemplazar</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>El acceso de indizador debe enviarse de forma dinámica, pero no se puede porque forma parte de una expresión de acceso base. Puede convertir los argumentos dinámicos o eliminar el acceso base.</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>'{0}' no tiene ningún método aplicable denominado '{1}', pero tiene un método de extensión con ese nombre. Los métodos de extensión no se pueden enviar de forma dinámica. Puede convertir los argumentos dinámicos o llamar al método de extensión sin la sintaxis de método de extensión.</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>'{0}': las propiedades abstractas no pueden tener descriptores de acceso privados</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>La expresión dada de la expresión "is" nunca tiene el tipo provisto</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>La cadena de versión especificada no se ajusta al formato requerido: principal.secundaria.compilación.revisión</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>Error al abrir el archivo de manifiesto de Win32 {0}: {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>'{0}' es un nuevo miembro virtual en una clase sellada '{1}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una propiedad indizada</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>Sintaxis de suma de comprobación de #pragma no válida</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>LookupOptions tiene una combinación de opciones no válida</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>Se espera un inicializador de matriz con la longitud '{0}'</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>No se puede devolver un campo de solo lectura por referencia grabable.</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>Una expresión switch o etiqueta de caso debe ser del tipo bool, char, string, integral, enum o del correspondiente tipo que acepte valores NULL en C# 6 y versiones anteriores.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>La ubicación se debe indicar para proporcionar una cualificación de tipo mínima.</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>Los módulos agregados se deben marcar con el atributo CLSCompliant para que coincidan con el ensamblado</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de referencia para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>El envío solo puede incluir código de script.</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>'{0}': no se puede invalidar porque '{1}' no tiene un descriptor de acceso get invalidable</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>Una cláusula catch ya abarca todas las excepciones</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>Las interfaces no pueden contener operadores</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>'{0}' es un archivo binario en vez de uno de texto</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>La expresión switch debe ser un valor. Se encontró {0}.</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>No se puede asignar "{0}" a una propiedad de tipo anónimo</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>No se puede abrir '{0}' para escribir: '{1}'</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>Posible instrucción vacía errónea</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>No se puede crear un delegado a partir del método '{0}' porque es un método parcial sin declaración de implementación</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>No invalide object.Finalize. En su lugar, proporcione un destructor.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>constructor y destructor del cuerpo de expresión</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>'{0}': no se pueden usar las propiedades implementadas automáticamente dentro de un tipo marcado con StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>Se esperaba un nombre de archivo entre comillas, un comentario de una línea o un final de línea</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref '{0}' que hace referencia a un parámetro de tipo</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>El delegado '{0}' no tiene un constructor válido</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>La desconstrucción debe contener al menos dos variables.</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>Los métodos de extensión '{0}' definidos en el tipo de valor '{1}' no se pueden usar para crear delegados</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>Incoherencia de accesibilidad: la clase base '{1}' es menos accesible que la clase '{0}'</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>Una instrucción goto case solo es válida dentro de una instrucción switch</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>La clase System.Object no puede tener una clase base o implementar una interfaz</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>'{0}': no se pueden cambiar los modificadores de acceso al invalidar el miembro heredado '{2}' de '{1}'</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>Los indizadores no pueden tener un tipo void</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de parámetro '{1}' es menos accesible que el operador '{0}'</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>El campo const requiere que se proporcione un valor</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>No se puede restaurar la advertencia 'CS{0}' porque estaba deshabilitada globalmente</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>La introducción de un método 'Finalize' puede afectar a la invocación del destructor. ¿Quería declarar un destructor?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>El cuerpo de '{0}' no puede ser un bloque de iteradores porque '{0}' devuelve datos por referencia.</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>Número incorrecto de índices dentro de []; se esperaba {0}.</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>Se especificó retrasar la firma y esto requiere una clave pública, pero no se ha especificado ninguna clave pública</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>Un método parcial no puede tener parámetros out</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>El término de expresión '{0}' no es válido</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>El modificador de accesibilidad del descriptor de acceso '{0}' debe ser más restrictivo que la propiedad o el indizador '{1}'</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerFilePathAttribute solo se puede aplicar a parámetros con valores predeterminados</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>Falta la especificación de archivo de la opción '{0}'</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>Se esperaba un nombre de archivo entre comillas</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>Conversión definida por el usuario duplicada en el tipo '{0}'</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>Se esperaba el tipo byte, sbyte, short, ushort, int, uint, long o ulong</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>Uso inesperado de un nombre genérico</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>'{0}' no necesita ningún atributo CLSCompliant porque el ensamblado no tiene ningún atributo CLSCompliant</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>La firma de la clase contenedora de coclases administradas '{0}' para la interfaz '{1}' no es una signatura de nombre de clase válida</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>El tipo '{1}' existe en '{0}' y en '{2}'</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>El tipo entra en conflicto con un tipo importado</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>El carácter '{0}' solo se puede escapar duplicando '{0}{0}' en una cadena interpolada.</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>Elemento de inclusión XML no válido</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>Esta advertencia se produce cuando crea una clase con un método cuya firma es public virtual void Finalize.

Si se utiliza una clase de este tipo como clase base y si la clase derivada define un destructor, este reemplazará al método Finalize de la clase base, no a Finalize.</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>No utilice el atributo 'System.Runtime.CompilerServices.FixedBuffer'. En su lugar, use el modificador de campo 'fixed'.</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>No se permite utilizar NULL en este contexto</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>El calificador de alias del espacio de nombres '::' siempre se resuelve en un tipo o espacio de nombres, por tanto, aquí no es válido. En su lugar puede usar '.'.</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>El parámetro de tipo '{0}' no se puede utilizar con el operador 'as' porque no tiene ninguna restricción de tipo de clase ni una restricción 'class'</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>La palabra clave 'base' no está disponible en ningún método estático</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>No se puede inicializar el miembro '{0}'. No es un campo ni una propiedad.</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>Ambigüedad entre '{0}' y '{1}'</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction_Title" xml:space="preserve">
    <value>La función local se declara pero nunca se usa</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Error de sintaxis de línea de comandos: falta el GUID para la opción '{1}'</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>El ensamblado '{0}' al que se hace referencia está destinado a un procesador diferente.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>No se puede asignar {0} a una variable con tipo implícito</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Error al escribir en el archivo de salida: {0}.</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>'{0}': el constructor estático no puede tener ninguna llamada de constructor 'this' o 'base' explícita</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>variable de entorno LIB</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>'{0}' no puede implementar '{1}' porque '{2}' es un evento de Windows Runtime y '{3}' es un evento normal de .NET.</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>'{0}' está obsoleto</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>'{0}' es de tipo '{1}'. El tipo especificado en una declaración de constantes debe ser sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, un tipo de enumeración o un tipo de referencia.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>La cadena de versión especificada no se ajusta al formato recomendado: principal.secundaria.compilación.revisión</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>El parámetro '{0}' no tiene la etiqueta param correspondiente en el comentario XML para '{1}' (pero otros parámetros sí)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>La propiedad indizada '{0}' tiene argumentos no opcionales que se deben proporcionar</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>Para que el tipo "{0}" se utilice como AsyncMethodBuilder para el tipo "{1}", su propiedad Task debe devolver el tipo "{1}" en lugar del tipo "{2}".</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>'{0}': un campo no puede ser tanto volátil como de solo lectura</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>Se esperaba la directiva #endregion</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>El nombre de parámetro '{0}' entra en conflicto con un nombre de parámetro generado automáticamente</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>Los parámetros de tipo no se permiten en un grupo de método como argumento de "nameof".</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de parámetro '{1}' es menos accesible que el delegado '{0}'</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>Una cláusula catch previa ya detecta todas las excepciones. Las no excepciones producidas se incluirán en System.Runtime.CompilerServices.RuntimeWrappedException.</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value> Error al insertar algunos de los XML de inclusión o todos ellos</value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>No se puede usar await con '{0}'</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>Una deconstrucción no puede mezclar declaraciones y expresiones en el lado izquierdo.</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>Se espera un valor constante</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>El parámetro de tipo '{0}' tiene el mismo nombre que el parámetro de tipo del tipo externo '{1}'</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>El literal de tipo double no se puede convertir implícitamente en el tipo '{1}'; use un sufijo '{0}' para crear un literal de este tipo</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Opciones del compilador de Visual C#

                        - ARCHIVOS DE SALIDA -
 /out:&lt;archivo&gt;                   Especificar el nombre del archivo de salida (predeterminado: nombre base del archivo
                               con clase principal o primer archivo)
 /target:exe                   Compilar un archivo ejecutable de consola (predeterminado) (forma
                               corta: /t:exe)
 /target:winexe                Compilar un archivo ejecutable de Windows (forma corta:
                               /t:winexe)
 /target:library               Compilar una biblioteca (forma corta: /t:library)
 /target:module                Compilar un módulo que se puede agregar a otro
                               ensamblado (forma corta: /t:module)
 /target:appcontainerexe       Compilar un archivo ejecutable Appcontainer (forma corta:
                               /t:appcontainerexe)
 /target:winmdobj              Compilar un archivo intermedio de Windows Runtime que
                               WinMDExp consume (forma corta: /t:winmdobj)
 /doc:&lt;archivo&gt;                   Archivo de documentación XML para generar
 /refout:&lt;archivo&gt;                Salida del ensamblado de referencia para generar
 /platform:&lt;cadena&gt;            Limitar en qué plataformas se puede ejecutar este código: x86,
                               Itanium, x64, arm, anycpu32bitpreferred o
                               anycpu. El valor predeterminado es anycpu.

                        - ARCHIVOS DE ENTRADA -
 /recurse:&lt;carácter comodín&gt;           Incluir todos los archivos en el directorio y los
                               subdirectorios actuales según las especificaciones del 
                               carácter comodín
 /reference:&lt;alias&gt;=&lt;archivo&gt;     Metadatos de referencia del archivo de ensamblado
                               especificado mediante el alias dado (forma corta: /r)
 /reference:&lt;lista de archivos &gt;        Metadatos de referencia de los archivos de ensamblado
                               especificados (forma corta: /r)
 /addmodule:&lt;lista de archivos &gt;        Vincular los módulos especificados en este ensamblado
 /link:&lt;lista de archivos &gt;             Insertar metadatos de los archivos de ensamblado de
                               interoperabilidad especificados (forma corta: /l)
 /analyzer:&lt;lista de archivos&gt;         Ejecutar los analizadores de este ensamblado
                               (forma corta: /a)
 /additionalfile:&lt;lista de archivos&gt;   Archivos adicionales que no afectan directamente a la
                               generación de código, pero que pueden usar los analizadores para producir
                               errores o advertencias.
 /embed                        Insertar todos los archivos de origen en el PDB.
 /embed:&lt;lista de archivos &gt;            Insertar archivos específicos en el PDB

                        - RECURSOS -
 /win32res:&lt;archivo&gt;              Especificar un archivo de recursos Win32 (.res)
 /win32icon:&lt;archivo&gt;             Usar este icono para la salida
 /win32manifest:&lt;archivo&gt;         Especificar un archivo de manifiesto Win32 (.xml)
 /nowin32manifest              No incluir el manifiesto Win32 predeterminado
 /resource:&lt;info recurso&gt;           Insertar el recurso especificado (forma corta: /res)
 /linkresource:&lt;info recurso&gt;       Vincular el recurso especificado a este ensamblado
                               (forma corta: /linkres), donde el formato de la información del recurso 
                               es &lt;archivo&gt;[,&lt;nombre de cadena &gt;[,public|private]]

                        - GENERACIÓN DE CÓDIGO -
 /debug[+|-]                   Emitir información de depuración
 /debug:{full|pdbonly|portable|embedded}
                               Especificar tipo de depuración (“full” es el valor predeterminado,
                               “portable” es un formato multiplataforma,
                               “embedded” es un formato multiplataforma insertado en
                               el archivo.dll o .exe de destino)
 /optimize[+|-]                Habilitar optimizaciones (forma corta: /o)
 /deterministic                Producir un ensamblado determinista
                               (que incluya el GUID y la marca de tiempo de la versión del módulo)
 /refonly                      Producir un ensamblado de referencia en lugar de la salida principal
 /instrument:TestCoverage      Producir un ensamblado instrumentado para recopilar
                               información de cobertura 
 /sourcelink:&lt;archivo&gt;            Información del vínculo de origen para insertar en el PDB.

                        - ERRORES Y ADVERTENCIAS -
 /warnaserror[+|-]             Notificar todas las advertencias como errores
 /warnaserror[+|-]:&lt;lista de advertencias &gt; Notificar advertencias específicas como errores
 /warn:&lt;n&gt;                     Establecer nivel de advertencia (de 0 a 4) (forma corta: /w)
 /nowarn:&lt;lista de advertencias &gt;           Deshabilitar mensajes de advertencia específicos
 /ruleset:&lt;archivo&gt;               Especificar un archivo de conjunto de reglas que deshabilite
                               diagnósticos específicos.
 /errorlog:&lt;archivo&gt;              Especificar un archivo para registrar todos los diagnósticos del compilador y del
                               analizador.
 /reportanalyzer               Notificar información adicional del analizador, como el
                               tiempo de ejecución.

                        - LENGUAJE -
 /checked[+|-]                 Generar comprobaciones de desbordamiento
 /unsafe[+|-]                  Permitir código “no seguro”
 /define:&lt;lista de símbolos &gt;         Definir símbolos de compilación condicional (forma
                               corta: /d)
 /langversion:?                Mostrar los valores permitidos para la versión del lenguaje
 /langversion:&lt;cadena&gt;         Especificar la versión del lenguaje como
                               “predeterminada” (versión principal más reciente) o
                               “última” (última versión, incluidas las versiones secundarias)
                               o versiones específicas como la “6” o “7.1”

                        - SEGURIDAD -
 /delaysign[+|-]               Retrasar firma del ensamblado usando solo la parte pública
                               de la clave de nombre seguro
 /publicsign[+|-]              Publicar firma del ensamblado usando solo la parte pública
                               de la clave de nombre seguro
 /keyfile:&lt;archivo&gt;               Especificar un archivo de clave de nombre seguro
 /keycontainer:&lt;cadena&gt;        Especificar un contenedor de claves de nombres seguros
 /highentropyva[+|-]           Habilitar ASLR de alta entropía

                        - VARIOS -
 @&lt;archivo&gt;                       Leer archivo de respuesta para ver más opciones
 /help                         Mostrar este mensaje de uso (forma corta: /?)
 /nologo                       Suprimir mensaje de copyright del compilador
 /noconfig                     No incluir automáticamente el archivo CSC.RSP
 /parallel[+|-]                Compilación simultánea.
 /version                      Mostrar el número de versión del compilador y salir.

                        - AVANZADO -
 /baseaddress:&lt;dirección&gt;        Dirección base de la biblioteca que se compilará
 /checksumalgorithm:&lt;algoritmo&gt;      Especificar el algoritmo para calcular la suma de comprobación
                               del archivo de origen que se almacena en PDB. Los valores admitidos son:
                               SHA1 (predeterminado) o SHA256.
 /codepage:&lt;n&gt;                 Especificar la página de código que se usará al abrir los archivos de
                               código fuente
 /utf8output                   Mensajes de compilador de salida en codificación UTF-8
 /main:&lt;tipo&gt;                  Especificar el tipo que contiene el punto de entrada
                               (ignorar todos los demás puntos de entrada posibles) (forma
                               corta: /m)
 /fullpaths                    El compilador genera rutas de acceso completas
 /filealign:&lt;n&gt;                Especificar la alineación usada para las secciones del
                               archivo de salida
 /pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                               Especificar una asignación para los nombres de rutas de acceso de origen
                               emitidos por el compilador.
 /pdb:&lt;archivo&gt;                   Especificar nombre de archivo de información de depuración (valor predeterminado:
                               nombre del archivo de salida con la extensión .pdb)
 /errorendlocation             Línea y columna de salida de la ubicación final de
                               cada error
 /preferreduilang              Especificar el nombre del lenguaje de salida preferido.
 /nostdlib[+|-]                No hacer referencia a la biblioteca estándar (mscorlib.dll)
 /subsystemversion:&lt;cadena&gt;    Especificar versión del subsistema de este ensamblado
 /lib:&lt;lista de archivos&gt;              Especificar directorios adicionales en los que buscar
                               referencias
 /errorreport:&lt;cadena&gt;         Especificar cómo tratar los errores internos del compilador:
                               avisar, enviar, poner en cola o ninguno. El valor predeterminado es
                               poner en cola.
 /appconfig:&lt;archivo&gt;             Especificar un archivo de configuración de aplicación
                               que contenga opciones de enlace de ensamblado
 /moduleassemblyname:&lt;cadena&gt;  Nombre del ensamblado del que este módulo
                               formará parte 
 /modulename:&lt;cadena&gt;          Especificar el nombre del módulo de origen
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>Error de sintaxis; se esperaba un valor</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>'{0}' no puede estar sellado porque no es una invalidación</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#error: '{0}'</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>La variable de rango '{0}' ya se ha declarado</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>Se especificó una clave pública de firma no válida en AssemblySignatureKeyAttribute.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>No se tiene en cuenta el nombre de elemento de tupla "{0}" porque el tipo de destino "{1}" ha especificado otro nombre o no ha especificado ninguno.</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>Esta advertencia se produce cuando intenta llamar a un método, a una propiedad o a un indizador en un miembro de una clase que deriva de MarshallByRefObject y el miembro es un tipo de valor. Los objetos que se heredan de MarshallByRefObject suelen estar diseñados para serializarse por referencia a través del dominio de una aplicación. Si, alguna vez, algún tipo de código intenta acceder directamente al miembro del tipo de valor de un objeto así a través del dominio de una aplicación, se producirá una excepción en tiempo de ejecución. Para resolver la advertencia, primero debe copiar el miembro en una variable local y llamar al método en esa variable.</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>Dos indizadores tienen nombres distintos; el atributo IndexerName se debe utilizar con el mismo nombre en todos los indizadores de un tipo</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>'await' requiere que el tipo de valor devuelto '{0}' de '{1}.GetAwaiter()' tenga unos miembros IsCompleted, OnCompleted y GetResult adecuados, e implemente INotifyCompletion o ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>'{0}' es una referencia ambigua entre '{1}' y '{2}'</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>La opción reemplaza el atributo proporcionado en el archivo de origen o en el módulo añadido</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>Los métodos parciales deben tener un tipo de valor devuelto void</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>Dependencia de clase base circular que requiere '{0}' y '{1}'</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>Identificador o literal numérico esperado</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>No se pudo incluir el fragmento XML</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>'{0}': el evento de la interfaz no puede tener un inicializador</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>El constructor '{0}' no se puede llamar a sí mismo</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>Es posible que no se use un comentario de una sola línea en una cadena interpolada.</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>Una variable o función local denominada '{0}' ya se ha definido en este ámbito</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>Los dos ensamblajes difieren en el número de versión y/o compilación. Para que haya unificación, debe especificar directivas en el archivo .config de la aplicación y debe proveer el nombre seguro correcto de un ensamblaje.</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>No se puede modificar el valor devuelto de '{0}' porque no es una variable</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>'{0}': el tipo base '{1}' no es conforme a CLS</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es de solo lectura</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>El parámetro {0} se declara como tipo '{1}{2}', pero debería ser '{3}{4}'</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Error al leer el archivo '{0}' especificado para el argumento con nombre '{1}' del atributo PermissionSet: '{2}'</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>Ya se ha especificado una cláusula de restricciones para el parámetro de tipo '{0}'. Todas las restricciones correspondientes a un parámetro de tipo se deben especificar en una sola cláusula where.</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>No se puede usar await con 'void'</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>No se puede devolver por referencia la variable local '{0}' porque no es de tipo ref.</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>La llamada de constructor debe enviarse de forma dinámica, pero no se puede porque forma parte de un inicializador de constructor. Puede convertir los argumentos dinámicos.</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>No se puede inferir el tipo de variable out con tipo implícito '{0}'.</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>No se pueden incrustar tipos de interoperabilidad desde el ensamblado '{0}' porque no tiene el atributo '{1}'.</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>inicializador de objeto</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>Las variables con tipo implícito no pueden tener varios declaradores</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField" xml:space="preserve">
    <value>No se puede devolver {0} "{1}" por referencia grabable porque es una variable readonly.</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>Un espacio de nombres no puede contener directamente miembros como campos o métodos.</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>El modificador de miembro '{0}' debe ir delante del tipo y nombre de miembro</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>Se esperaba }</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>Bloque switch vacío</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>Se esperaba un argumento de atributo con nombre</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>El parámetro tiene varios valores predeterminados distintos.</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>El argumento de tipo '{0}' no se puede aplicar al atributo DefaultParameterValue</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>La conversión definida por el usuario debe realizarse en el tipo envolvente o desde este</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>El miembro de estructura '{0}' de tipo '{1}' crea un ciclo en el diseño de la estructura</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>El tipo de restricción no es conforme a CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>No se puede aplicar la clase de atributo '{0}' porque es abstracta</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>'{0}' debe declarar un cuerpo porque no se marcó como abstracto, externo o parcial</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Se ha detectado código inaccesible</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>El método asincrónico carece de operadores "await" y se ejecutará de forma sincrónica. Puede usar el operador 'await' para esperar llamadas API que no sean de bloqueo o 'await Task.Run(...)' para hacer tareas enlazadas a la CPU en un subproceso en segundo plano.</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>La variable de rango '{0}' no puede tener el mismo nombre que un parámetro de tipo de método</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>El tipo '{0}' no tiene constructores definidos</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>método anónimo</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Se esperaba un script (archivo .csx), pero no se especificó ninguno</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>tipos que aceptan valores NULL</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>Omitiendo la opción /noconfig porque se especificó en un archivo de respuesta</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>El formato de desconstrucción 'var (...)' no permite especificar un tipo determinado para 'var'.</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>Falta el número de línea especificado para la directiva #line o no es válido</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> El archivo XML con formato incorrecto "{0}" no se puede incluir </value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>No se puede cargar el ensamblado del analizador {0}: {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>El operador '{0}' definido por el usuario debe declararse estático y público</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>La declaración no es válida; en su lugar, use 'operador {0} &lt;tipo de destino&gt; (...'</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>'{0}': los tipos estáticos no se pueden usar como tipos de valores devueltos</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>'{0}' no debe tener un parámetro params porque '{1}' tampoco lo tiene</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>No se puede crear el archivo temporal: {0}</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>La mejor sobrecarga para '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>El parámetro de tipo '{0}' tiene el mismo nombre que el tipo contenedor o el método</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>El miembro oculta el miembro heredado. Falta una contraseña nueva</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>Un método parcial debe declararse dentro de una clase parcial o una estructura parcial</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>El tipo '{1}' de '{0}' está en conflicto con el espacio de nombres importado '{3}' de '{2}'. Se usará el tipo definido en '{0}'.</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>El espacio de nombres '{1}' de '{0}' está en conflicto con el tipo importado '{3}' de '{2}'. Se usará el espacio de nombres definido en '{0}'.</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>El mejor método Add sobrecargado '{0}' del inicializador de colecciones tiene algunos argumentos no válidos</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>La creación de matriz debe disponer de un tamaño de matriz o un inicializador de matriz</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>El parámetro de tipo '{0}' no tiene ninguna etiqueta typeparam correspondiente en el comentario XML en '{1}' (pero otros parámetros de tipo sí)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>La asignación en la expresión condicional siempre es constante; ¿quería utilizar == en lugar de = ?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>No se puede aplicar la clase de atributo '{0}' porque es genérica</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>Error al leer el archivo de manifiesto '{0}' de Win32: '{1}'</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>El atributo '{0}' del módulo '{1}' se omitirá a favor de la instancia que aparece en el origen</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>No se puede asignar {0} a una variable de rango</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>Un parámetro params debe ser el último parámetro de una lista de parámetros formales</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>No se permite una instrucción throw sin argumentos en una cláusula finally anidada en la cláusula catch más cercana</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>Una tupla debe contener al menos dos elementos.</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>El tipo '{0}' no se puede usar como argumento de tipo</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>El tipo de interoperabilidad '{0}' no se puede incrustar porque le falta el atributo '{1}' requerido.</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>Una expresión lambda asincrónica convertida en un delegado que devuelve 'Task' no puede devolver un valor. ¿Intentó devolver 'Task&lt;T&gt;'?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>El nombre de idioma '{0}' no es válido.</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>No se puede usar más de un tipo en una instrucción for, using, fixed o de declaración</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>La variable de rango '{0}' no se puede asignar: es de solo lectura</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>'{0}' no contiene un constructor que tome {1} argumentos</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>Las cadenas de referencia cultural de ensamblado no pueden contener caracteres NULL incrustados.</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>No se puede usar el tipo '{0}' que acepta valores NULL en un patrón; utilice el tipo '{1}' subyacente.</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>Ambas declaraciones de métodos parciales deben usar un parámetro params; si no, ninguna podrá usarlo</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>'{0}' en la declaración explícita de la interfaz no es un miembro de interfaz</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>El tipo '{1}' de '{0}' está en conflicto con el tipo importado '{3}' de '{2}'. Se usará el tipo definido en '{0}'.</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>Los elementos de matriz no pueden ser del tipo '{0}'</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>No se pueden colocar modificadores en declaraciones de descriptores de acceso de eventos</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>La clase base '{0}' debe ir antes que cualquier interfaz</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Se especificaron opciones que están en conflicto: archivo de recursos de Win32; manifiesto de Win32</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>Los iteradores no pueden tener parámetros no seguros o tipos yield</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>CallerMemberNameAttribute no se puede aplicar porque no hay conversiones estándar del tipo '{0}' al tipo '{1}'</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>No se puede devolver un miembro del parámetro "{0}" por referencia, porque no es un parámetro out o ref.</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(Ubicación del símbolo relacionado con el error anterior)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>No se puede proporcionar ningún valor en el cuerpo de una cláusula catch</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>Como este es un método asincrónico, la expresión devuelta debe ser de tipo '{0}' en lugar de 'Task&lt;{0}&gt;'</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>Se esperaba { o ;</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>La palabra clave 'this' no es válida en una propiedad, método o inicializador de campo estáticos</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>parámetro opcional</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>Ruta de búsqueda especificada no válida</value>
  </data>
  <data name="ERR_RefReturnThis" xml:space="preserve">
    <value>No se puede devolver "this" por referencia.</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>No se encuentra el tipo de interoperabilidad que coincide con el tipo de interoperabilidad incrustado '{0}'. ¿Falta alguna referencia de ensamblado?</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>Esta advertencia se emite cuando los atributos AssemblyKeyFileAttribute o AssemblyKeyNameAttribute del ensamblador encontrados en el origen entran en conflicto con las opciones de línea de comando /keyfile o /keycontainer o con el nombre del archivo de clave o con el contenedor de claves especificados en las propiedades del proyecto.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>Esta advertencia indica que un atributo, como InternalsVisibleToAttribute, no se especificó correctamente.</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>La declaración de una variable por referencia debe tener un inicializador.</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>'MethodImplOptions.Synchronized' no se puede aplicar a un método asincrónico</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>No se pude devolver por referencia un parámetro '{0}' porque no es de tipo ref o out.</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>Los elementos definidos en un espacio de nombres no se pueden declarar explícitamente como private, protected, protected internal o private protected.</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>La opción /moduleassemblyname únicamente se puede especificar cuando cree un tipo de destino de 'module'</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>El parámetro de tipo '{0}' hereda las restricciones conflictivas '{1}' y '{2}'</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>El identificador de recurso '{0}' ya se ha usado en este ensamblado</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>El valor de parámetro predeterminado para '{0}' debe ser una constante en tiempo de compilación</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>El programa no contiene ningún método 'Main' estático adecuado para un punto de entrada</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>Este error se produce cuando un tipo de sistema predefinido como System.Int32 se encuentra en dos ensamblajes. Una forma de que esto suceda es si hace referencia a mscorlib o System.Runtime.dll desde dos lugares diferentes, como si intentase ejecutar dos versiones de .NET Framework en paralelo.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>No se puede devolver por referencia un miembro de '{0}' porque se inicializó con un valor que no se puede devolver por referencia.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>Los métodos con argumentos de variable no son conformes a CLS</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal para crear tokens literales numéricos.</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>Ambas declaraciones de método parcial deben ser estáticas o ninguna de ellas puede ser estática</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>'{0}' no es el tipo de referencia que requiere la instrucción lock</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>No se puede devolver un campo estático de solo lectura por referencia grabable.</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>Las interfaces conformes a CLS solo pueden contener miembros conformes a CLS</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>Los módulos agregados se deben marcar con el atributo CLSCompliant para que coincidan con el ensamblado</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>'{0}': un parámetro o una variable o función local no pueden tener el mismo nombre que un parámetro de tipo de método</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>El tipo de retorno no es conforme a CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>Error al abrir el archivo de icono {0}: {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>No se encontró SyntaxTree '{0}' para quitarlo</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>No se puede inferir el tipo de variable de desconstrucción con tipo implícito '{0}'.</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>Las restricciones para métodos de invalidación y de implementación de interfaz explícita se heredan del método base; por tanto, no se pueden especificar directamente</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>Se ha especificado un nombre de archivo no válido para la directiva de preprocesador</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>El carácter '{0}' se debe escapar (duplicándose) en las cadenas interpoladas.</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>método de extensión</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>La expresión no tiene un nombre.</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>Error inesperado al escribir la información de depuración: '{0}'</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>Compilación (C#): </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>El tipo no es conforme a CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>No se puede convertir en el tipo estático '{0}'</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>EL tipo no tiene constructores accesibles que solo usen tipos conforme a CLS</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>'{0}' no se puede marcar como conforme a CLS porque es miembro del tipo '{1}' no conforme a CLS</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>tipos anónimos</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>La constante '{0}' no se puede marcar como estática</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>La propiedad o el indizador '{0}' no se puede usar en este contexto porque carece del descriptor de acceso get</value>
  </data>
  <data name="ERR_AutoPropsInRoStruct" xml:space="preserve">
    <value>Las propiedades de instancia implementadas automáticamente en estructuras readonly deben ser readonly.</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>La versión de lenguaje especificada "{0}" no puede tener ceros al principio</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>Error al abrir el archivo de respuesta '{0}'</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>El mejor método Add sobrecargado para el elemento inicializador de la colección está obsoleto</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de valor devuelto '{1}' es menos accesible que el operador '{0}'</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>Alias externo sin usar.</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>No se permite la referencia a una variable out con tipo implícito '{0}' en la misma lista de argumentos.</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>Falta el modificador parcial en la declaración de tipo '{0}'; existe otra declaración parcial de este tipo</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>'{0}': no se puede invalidar porque '{1}' no tiene un descriptor de acceso set invalidable</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>El alias externo '{0}' no se especificó en una opción /reference</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>¿Pretendía utilizar la etiqueta de conmutador predeterminada (`default:`) en lugar de `case default:`? Si de verdad pretendía utilizar el literal predeterminado, considere el uso de `case (default):` u otro literal (`case 0:` o `case null:`) según corresponda.</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>'{0}' no es una ubicación de atributo reconocida. Las ubicaciones de atributo para esta declaración son '{1}'. Todos los atributos de este bloque se omitirán.</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>El parámetro {0} se debe declarar con la palabra clave '{1}'</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>La interfaz '{0}' tiene una interfaz de origen no válida necesaria para incrustar el evento '{1}'.</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>La mejor coincidencia de método sobrecargado '{0}' para el elemento inicializador de la colección no se puede usar. Los métodos 'Add' inicializadores de colección no pueden tener parámetros out ni ref.</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>'{0}': no se encontró ningún miembro adecuado para invalidar</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;lista de rutas de acceso&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>Los miembros de '{0}' no se pueden modificar porque es un '{1}'</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>'{0}': solo los miembros conformes a CLS pueden ser abstractos</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>Directiva Using innecesaria</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>No se puede vincular archivos de recursos al compilar un módulo</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;espacio de nombres global&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>Dependencia de restricción circular que implica '{0}' y '{1}'</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>'{0}' define el operador == o el operador != pero no invalida Object.GetHashCode()</value>
  </data>
  <data name="IDS_LangVersions" xml:space="preserve">
    <value>Versiones de lenguaje admitidas:</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>Uno de los parámetros de un operador binario debe ser el tipo contenedor</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>'{0}' no implementa '{1}'</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>No se puede obtener acceso al miembro protegido '{0}' a través de un calificador del tipo '{1}'; el calificador debe ser del tipo '{2}' (o derivado de este)</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>Falta el miembro '{0}.{1}' que requiere el compilador</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>En este contexto no se permiten atributos de ensamblado y módulo</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>Se esperaba un comentario de una línea o un fin de línea</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>El miembro no oculta un miembro heredado. No se necesita una nueva palabra clave</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>Las estructuras sin constructores explícitos no pueden contener miembros con inicializadores.</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>'{0}': las clases estáticas no se pueden usar como restricciones</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>El tipo de valor devuelto de un método asincrónico debe ser void, Task o Task&lt;T&gt;</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>El comentario XML tiene un atributo cref '{0}' que no se pudo resolver</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>No se encuentra el nombre de tipo '{0}' en el espacio de nombres '{1}'. Este tipo se ha reenviado al ensamblado '{2}'. Puede agregar una referencia a ese ensamblado.</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Foreach no puede funcionar en un '{0}'. ¿Intentó invocar el '{0}'?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>Una referencia a un campo volátil no se tratará como volátil</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>El acceso a un miembro en un campo de una clase de serialización por referencia puede causar una excepción en tiempo de ejecución.</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>El campo no puede tener un tipo void</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>El tipo de base no es conforme a CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>Los métodos de extensión deben definirse en una clase estática de nivel superior; {0} es una clase anidada</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>El módulo '{0}' ya está definido en este ensamblado. Cada módulo debe tener un nombre de archivo único.</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>Los atributos no son válidos en este contexto.</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>búferes de tamaño fijo</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>El punto y coma después del bloque de métodos o de descriptores de acceso no es válido</value>
  </data>
  <data name="ERR_RefReadonlyNotField2" xml:space="preserve">
    <value>Los miembros de {0} "{1}" no se pueden usar como valor out o ref porque es una variable readonly.</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>Si se incrusta el tipo de interoperabilidad '{0}' desde el ensamblado '{1}', se producirá un conflicto de nombre en el ensamblado actual. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>Los métodos con argumentos de variable no son conformes a CLS</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>'{0}': los modificadores de accesibilidad de los descriptores de acceso solo se pueden usar si la propiedad o el indizador tienen un descriptor de acceso get y set</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>No se puede definir una clase o un miembro que use 'dynamic', porque no se encuentra el tipo '{0}' requerido por el compilador. ¿Falta alguna referencia?</value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>El modificador 'abstract' no es válido en los campos. Pruebe a usar una propiedad en su lugar.</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>activar tipo booleano</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>El resultado de la expresión siempre es 'NULL' de tipo '{0}'</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>El atributo CLSCompliant no tiene ningún significado cuando se aplica tipos de retorno</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>No se puede convertir {0} en el tipo delegado indicado porque algunos de los tipos de valores devueltos del bloque no se pueden convertir implícitamente en el tipo de valor devuelto del delegado</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>Falta el comentario XML para el tipo o miembro visible de forma pública '{0}'</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>El miembro '{0}' implementa el miembro de interfaz '{1}' en el tipo '{2}'. Hay varias coincidencias para el miembro de interfaz en tiempo de ejecución. El método que se llamará depende de la implementación.</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>El compilador emite esta advertencia cuando reemplaza un error con una advertencia. Para obtener información sobre el problema, busque el código de error mencionado.</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>variable using</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>La restricción new() debe ser la última restricción especificada</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>'{0}' ya se muestra en la lista de interfaces en el tipo '{2}' con nombres de elementos de tupla diferentes, como '{1}'.</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>El campo '{0}' nunca se asigna y siempre tendrá el valor predeterminado {1}</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>La referencia de ensamblado de confianza '{0}' no es válida. Los ensamblados firmados con nombre seguro deben especificar una clave pública en sus declaraciones InternalsVisibleTo.</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>El tipo no es conforme a CLS porque la interfaz base no es conforme a CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>El tipo '{1}' ya define un miembro denominado '{0}' con los mismos tipos de parámetro</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;!-- El comentario XML con formato incorrecto se ha omitido para el miembro "{0}" --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>No se puede convertir el bloque de método anónimo sin una lista de parámetros en el tipo delegado '{0}' porque tiene uno o varios parámetros out</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>El atributo '{0}' solo es válido en métodos o clases de atributos</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>La palabra clave 'void' no se puede usar en este contexto</value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>El espacio de nombres '{1}' ya contiene una definición para '{0}'</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>elementos: no pueden estar vacíos</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>Se esperaba un identificador o un literal numérico.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>El comentario XML de '{1}' tiene una etiqueta paramref para '{0}', pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>Se esperaba un operador unario sobrecargable</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>El operador "{0}" no se puede aplicar al operando del tipo "{1}"</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>No se pueden buscar miembros en '{0}' porque es un parámetro de tipo</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>El nombre de archivo '{0}' almacenado en '{1}' debe coincidir con su nombre de archivo.</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>Si se utiliza '{0}' como valor out o ref, o se acepta su dirección, se puede producir una excepción en tiempo de ejecución porque es un campo de una clase de serialización por referencia.</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>La cadena de versión especificada no se ajusta al formato recomendado: principal,secundaria,compilación,revisión</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>'{0}': los elementos de matriz no pueden ser de tipo estático</value>
  </data>
  <data name="IDS_SK_CONSTRUCTOR" xml:space="preserve">
    <value>constructor</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>No se puede determinar el tipo de la expresión condicional porque no hay una conversión implícita entre '{0}' y '{1}'</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es '{1}'</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>El evento '{0}' solo puede aparecer a la izquierda de += o -= (excepto cuando se usa desde dentro del tipo '{1}')</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>La propiedad o el indizador '{0}' no se pueden usar en este contexto porque el descriptor de acceso set es inaccesible</value>
  </data>
  <data name="IConversionExpressionIsNotCSharpConversion" xml:space="preserve">
    <value>{0} no es una expresión de conversión de C# válida.</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>El argumento con nombre '{0}' especifica un parámetro para el que ya se ha proporcionado un argumento posicional</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>No se puede convertir el grupo de métodos '{0}' en el tipo no delegado '{1}'. ¿Intentó invocar el método?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>Se omitirá /win32manifest para el módulo porque solo se aplica a ensamblados</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>foreach requiere que el tipo de valor devuelto '{0}' de '{1}' tenga un método MoveNext público y una propiedad Current pública adecuados</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(Ubicación del símbolo relacionado con la advertencia anterior)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>Los inicializadores de matriz solo se pueden utilizar en un inicializador de variable o campo. Pruebe a usar una expresión new en su lugar.</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;NULL&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;texto&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>Referencia no coincidente entre "{0}" y el delegado "{1}"</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>'{0}': no se puede invalidar porque '{1}' no es una función</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>variable local con tipo implícito</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>El tipo '{0}' predefinido debe ser un elemento struct.</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>matriz con tipo implícito</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>Use Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier o Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier para crear tokens de identificador.</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>'{0}': no se pueden tener propiedades de instancia o inicializadores de campo en estructuras</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Las instrucciones yield pueden no aparecer en el nivel superior del código interactivo.</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>'{0}': el tipo usado en una instrucción using debe poder convertirse implícitamente en 'System.IDisposable'</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>Posible comparación de referencias no intencionada; para obtener una comparación de valores, convierta el lado de la izquierda en el tipo '{0}'</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>Especificador de rango no válido: se esperaba ',' o ']'</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>Ya se ha definido el descriptor de acceso de la propiedad</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>Una variable con tipo implícito no se puede inicializar con un inicializador de matriz</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>Nueva línea en constante</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>Un tipo genérico no puede derivar de '{0}' porque es una clase de atributos</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>No se puede crear una instancia de analizador</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>El cuerpo de '{0}' no puede ser un bloque de iteradores porque '{1}' no es un tipo de interfaz de iteradores</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>La expresión que se asigne a '{0}' debe ser constante</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>El tamaño de la matriz no se puede especificar en una declaración de variable (intente inicializar con una expresión 'new')</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>'{0}': un evento abstracto no puede tener inicializador</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>Se han importado varios ensamblados con identidad equivalente: '{0}' y '{1}'. Quite una de las referencias duplicadas.</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>El tipo '{1}' de '{0}' está en conflicto con el espacio de nombres '{3}' de '{2}'</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>El atributo CallerLineNumberAttribute no tendrá efecto porque se aplica a un miembro que se utiliza en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>Se esperaba un tipo</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>La posición debe estar dentro del intervalo del árbol de sintaxis.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un inicializador de matriz multidimensional</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>Las interfaces no pueden incluir campos</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>No se puede devolver '{0}' por referencia porque se inicializó con un valor que no se puede devolver por referencia.</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>Uso inesperado de un nombre con alias</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>Una matriz de parámetros no se puede usar con el modificador 'this' en un método de extensión</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>La llamada al método '{0}' debe enviarse de forma dinámica, pero no se puede porque forma parte de una expresión de acceso base. Puede convertir los argumentos dinámicos o eliminar el acceso base.</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>'{0}': una clase no puede ser estática y sellada</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' deben ser todas clases, todas estructuras o todas interfaces</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>El campo '{0}' conforme a CLS no puede ser volátil</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>Se esperaba la palabra clave contextual 'equals'</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>Ya no se admite la sintaxis 'id#'. En su lugar, use '$id'.</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>El punto de entrada del programa es código de script global. Ignorando punto de entrada</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>Nunca se usa el campo</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>El objeto '{0}' se puede desechar más de una vez.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>"{0}" no implementa el miembro de interfaz "{1}". "{2}" no puede implementar "{1}" porque no tiene un tipo de valor devuelto coincidente por referencia.</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>Solo se puede tener acceso a los búferes de tamaño fijo mediante variables locales o campos</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>El comentario XML de '{1}' tiene una etiqueta typeparamref para '{0}', pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>Entre los atributos cref, los tipos anidados de tipos genéricos deberían ser cualificados</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una especificación de argumento con nombre</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>Tipo de destino no válido para /target: se debe especificar 'exe', 'winexe', 'library' o 'module'</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>No se puede asignar un campo de solo lectura estático (excepto en un constructor estático o inicializador de variable)</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>No se puede obtener acceso al miembro '{0}' con una referencia de instancia; califíquelo con un nombre de tipo en su lugar</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>Posiblemente una asignación incorrecta a local, que es el argumento a una instrucción using o lock</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>El control no puede salir del texto de una cláusula finally</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>El nodo de sintaxis no está dentro del árbol de sintaxis</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>Las devoluciones por referencia solo se pueden usar en métodos que devuelven datos por referencia.</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>El tipo '{0}' no se puede declarar como const</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>Los métodos asincrónicos no pueden tener parámetros ref o out</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>El control no puede quedar fuera del modificador de la etiqueta de caso final ('{0}')</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>La directiva using para '{0}' aparece previamente en este espacio de nombres</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>El idioma no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente al método del descriptor de acceso '{1}'</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>El idioma no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente a los métodos del descriptor de acceso '{1}' o '{2}'</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>'{0}': no se permiten conversiones definidas por el usuario ni a una interfaz ni desde ella</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>No use refout si utiliza refonly.</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>No se pueden usar los parámetros ref ni out '{0}' dentro de un método anónimo, una expresión lambda ni una expresión de consulta</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>El resultado de la expresión siempre es 'null'</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>No se pudo emitir el módulo '{0}'.</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>expresión throw</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>El método '{0}' no puede implementar el descriptor de acceso de la interfaz '{1}' para el tipo '{2}'. Use una implementación de interfaz explícita.</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>El alias '{0}' entra en conflicto con {1} definición</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}'</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>La constante integral es demasiado extensa</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>No se encontró el archivo.</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>No se permite una declaración en este contexto.</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>Un punto de entrada de devolución void o int no puede ser asincrónico</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta typeparamref, pero no hay ningún parámetro de tipo con ese nombre</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>El nombre local es demasiado largo para PDB</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>El atributo Guid se debe especificar con el atributo ComImport</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>No se puede proporcionar un valor en el cuerpo de un bloque try con una cláusula catch</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>La implementación de la interfaz explícita coincide con más de un miembro de la interfaz</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>No se puede especificar /main si se compila un módulo o una biblioteca</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>Este tipo se incluye solo con fines de evaluación y está sujeto a cambios o a que se elimine en próximas actualizaciones.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>No se permiten expresiones de tipo '{0}' en una cláusula from siguiente incluida en una expresión de consulta con el tipo de origen '{1}'. No se pudo realizar la inferencia de tipos en la llamada a '{2}'.</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>operador de propagación nulo</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>Los ensamblados '{0}' y '{1}' hacen referencia a los mismos metadatos, pero solo uno es una referencia vinculada (especificada con la opción /link): puede quitar una de las referencias.</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>covariante</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>Los campos de búfer de tamaño fijo solo pueden ser miembros de estructuras</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una conversión de tupla.</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>No se puede leer el archivo de configuración '{0}': '{1}'</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>Las expresiones lambda asincrónicas no se pueden convertir en árboles de expresión</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>El parámetro de tipo '{1}' tiene la restricción 'struct'; por tanto, '{1}' no se puede usar como restricción para '{0}'</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>El tipo "{0}" predefinido no se ha definido o importado, o bien se declara en varios ensamblados a los que se hace referencia.</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>El argumento de tipo no puede ser NULL</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>La declaración de un alias externo debe preceder a los demás elementos definidos en el espacio de nombres</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>Opción '{0}' no válida para /platform; debe ser anycpu, x86, Itanium o x64</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>El argumento pasado al atributo '{0}' debe ser un identificador válido</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>El CallerMemberNameAttribute aplicado al parámetro '{0}' no tendrá efecto. Lo invalida el CallerFilePathAttribute.</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de valor devuelto '{1}' es menos accesible que el delegado '{0}'</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>El atributo de seguridad '{0}' no se puede aplicar a un método Async.</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>Los atributos de módulo y ensamblado deben ir delante de los demás elementos definidos en un archivo, excepto las cláusulas using y las declaraciones de alias externos</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>Se creó una referencia para el ensamblaje de interoperabilidad incrustado debido a una referencia al ensamblaje indirecta</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>El tipo '{0}' sin administrar solo es válido para los campos.</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>La propiedad '{0}' implementada automáticamente se debe asignar completamente antes de devolver el control al llamador.</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>El operador unario sobrecargado '{0}' toma un parámetro</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>El tipo '{0}' no seguro no se puede usar para crear un objeto</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>Uso del parámetro out sin asignar '{0}'</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>contravariante</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>El atributo Conditional no es válido en miembros de interfaz</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>No se puede modificar el resultado de una conversión unboxing</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>ref y out no son válidos en este contexto</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>La etiqueta final '{0}' no coincide con la etiqueta de inicio '{1}'.</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>El lado derecho de una asignación de instrucción fixed puede no ser una expresión de conversión</value>
  </data>
  <data name="IDS_FeatureRefExtensionMethods" xml:space="preserve">
    <value>métodos de extensión ref</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>Los miembros del campo de solo lectura '{0}' no se pueden modificar (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>Suponiendo que la referencia del ensamblado '{0}' usada por '{1}' coincide con la identidad '{2}' de '{3}', puede que necesite proporcionar la directiva en tiempo de ejecución</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>El valor '{0}' de SecurityAction no es válido para los atributos de seguridad aplicados a un ensamblado</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>La variable de rango '{0}' entra en conflicto con una declaración anterior de '{0}'</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>El nombre del tipo o del espacio de nombres '{0}' no se encontró (¿falta una directiva using o una referencia de ensamblado?)</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>Se esperaba la palabra clave contextual 'on'</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>Se esperaba la palabra clave contextual 'by'</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>La característica '{0}' no está implementada en este compilador.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay conversión boxing de '{3}' a '{1}'.</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>Un método de extensión debe ser estático</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>Tipo de valor devuelto no válido en el atributo cref del comentario XML</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}' está obsoleto: '{1}'</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>El ensamblado {0} no contiene ningún analizador.</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>de forma covariante</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>Se creó una referencia al ensamblado de interoperabilidad '{0}' incrustado debido a una referencia indirecta a ese ensamblado creado por el ensamblado '{1}'. Puede cambiar la propiedad 'Incrustar tipos de interoperabilidad' en cualquiera de los ensamblados.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>El archivo de código fuente ha superado el límite de 16.707.565 líneas representables en el PDB. La información de depuración no será correcta.</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>colección</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>No use 'System.Runtime.CompilerServices.DynamicAttribute'. Use la palabra clave 'dynamic' en su lugar.</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>El nombre de archivo '{0}' está vacío, contiene caracteres no válidos, tiene una especificación de unidad sin ruta de acceso absoluta o es demasiado largo</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>'{0}' no se puede marcar como conforme a CLS porque el ensamblado no tiene ningún atributo CLSCompliant</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>La versión de lenguaje proporcionada no se admite o no es válida: "{0}".</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>'{0}': los miembros de interfaz no pueden tener una definición</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>Se esperaba una instrucción de expresión o de declaración.</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>No se puede asignar a la propiedad o el indizador '{0}' porque es de solo lectura</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>El método o el delegado no pueden devolver el tipo '{0}'</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>Incoherencia de accesibilidad: el tipo de campo '{1}' es menos accesible que el campo '{0}'</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>La opción /pdb requiere que se use también la opción /debug</value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>La expresión dada de la expresión "is" siempre tiene el tipo provisto</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>Los recursos y módulos vinculados deben tener un nombre de archivo único. El nombre de archivo '{0}' se ha especificado más de una vez en este ensamblado</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>Llame a System.IDisposable.Dispose() en una instancia asignada antes de que todas sus referencias estén fuera de ámbito</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>Una expresión lambda de árbol de expresión no puede contener una llamada COM con ref omitido en argumentos</value>
  </data>
  <data name="ERR_ParamsCantBeWithModifier" xml:space="preserve">
    <value>El parámetro params no se puede declarar como {0}.</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>En una instrucción foreach se requieren un tipo y un identificador</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>Argumento {0}: no se puede convertir de '{1}' a '{2}'</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Las especificaciones de argumento con nombre deben aparecer después de haber especificado todos los argumentos fijos. Use la versión {0} del lenguaje, o una posterior, para permitir argumentos con nombre que no sean finales.</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>Las restricciones para el parámetro de tipo '{0} del método '{1} deben coincidir con las restricciones del parámetro de tipo '{2} del método de interfaz '{3}. Si lo prefiere, puede usar una implementación de interfaz explícita.</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>No se puede devolver por referencia la variable de rango '{0}'.</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>No puede aparecer código no seguro en iteradores</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>La construcción __arglist solo es válida dentro de un método de argumento de variable</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>No se puede determinar el tipo de expresión condicional porque '{0}' y '{1}' se convierten implícitamente uno en el otro</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>"new" no se puede usar con un tipo de tupla. Use una expresión literal de tupla en su lugar.</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>Token inesperado '{0}'</value>
  </data>
  <data name="ERR_RefConditionalDifferentTypes" xml:space="preserve">
    <value>La expresión debe ser de tipo "{0}" para que coincida con el valor ref alternativo.</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>'{0}': no puede derivar del tipo sellado '{1}'</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>El punto de entrada de depuración debe ser una definición de un método declarado en la compilación actual.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>No hay un orden específico entre los campos en declaraciones múltiples de la estructura parcial</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>Suponiendo que la referencia del ensamblado '{0}' usada por '{1}' coincide con la identidad '{2}' de '{3}', puede que necesite proporcionar la directiva en tiempo de ejecución</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta typeparam para '{0}', pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Hay que especificar el parámetro de atributo '{0}' o '{1}'.</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Hay que especificar el parámetro de atributo '{0}'.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>método con forma de expresión</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>El CallerFilePathAttribute no tendrá efecto porque se aplica a un miembro que se usa en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>No se pueden compilar módulos al usar /refout o /refonly.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'. Los tipos que aceptan valores NULL no pueden cumplir restricciones de interfaz.</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>Hay XML formado incorrectamente en el archivo de comentarios incluido</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>El espacio de nombres '{1}' contiene una definición que entra en conflicto con el alias '{0}'</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Nombre de ensamblado no válido: {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>Un árbol de expresión no puede contener un descarte.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>Usar "is" para comprobar la compatibilidad con "dynamic" es idéntico a comprobar la compatibilidad con "Object"</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>Las directivas de uso de espacio de nombres solo se pueden aplicar a espacios de nombres. '{0}' es un tipo, no un espacio de nombres. Puede que deba utilizar una directiva de uso de versión estática en su lugar</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>No se pueden usar miembros del campo de solo lectura '{0}' como valores out o ref (excepto en un constructor).</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Error de sintaxis de línea de comandos: formato de GUID '{0}' no válido para la opción '{1}'</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>Dentro de los atributos cref, se deben calificar los tipos anidados de los tipos genéricos.</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerLineNumberAttribute solo se puede aplicar a parámetros con valores predeterminados</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>El resultado de la expresión siempre es '{0}' porque un valor del tipo '{1}' nunca es igual a 'NULL' de tipo '{2}'</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>No se puede devolver un valor a partir de un iterador. Utilice la instrucción yield return para devolver un valor o yield break para terminar la iteración.</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>Se esperaba disable o restore</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>La opción '{0}' debe ser una ruta de acceso absoluta.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Versión {0} no válida para /subsystemversion. La versión debe ser 6.02 o posterior para ARM o AppContainerExe, y 4.00 o posterior en caso contrario</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>Declarador de miembro de inicializador no válido</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>La opción pathmap no tenía el formato correcto.</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>El tipo de búfer de tamaño fijo debe pertenecer a uno de los tipos siguientes: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float o double</value>
  </data>
  <data name="ERR_CallArgMixing" xml:space="preserve">
    <value>No se permite esta combinación de argumentos para "{0}" porque puede exponer variables a las que el parámetro "{1}" hace referencia fuera de su ámbito de declaración.</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}'</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>El argumento {0} no se debe pasar con la palabra clave '{1}'</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>La propiedad o el indizador '{0}' no se pueden usar en este contexto porque el descriptor de acceso get es inaccesible</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>funciones locales</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>tuplas</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>alias externo</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>Elemento de inclusión XML no válido: {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>El valor de alineación tiene una magnitud que puede dar lugar a una cadena con formato grande</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>El tipo detectado o producido debe derivarse de System.Exception</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>No se especificaron archivos de origen</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>El atributo '{0}' se omite cuando se especifica la firma pública.</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>El búfer de tamaño fijo de longitud {0} y tipo '{1}' es demasiado grande</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>'{0}' no puede implementar '{1}' porque el idioma no lo admite</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 2. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 3. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 1. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 6. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 7.0. Use la versión del lenguaje {1} u otra posterior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 4. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>La característica "{0}" no está disponible en C# 5. Use la versión de lenguaje {1} u otra superior.</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>opción /LIB</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>El atributo Conditional no es válido en '{0}' porque su tipo de valor devuelto no es void</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>El atributo DllImport no se puede aplicar a un método que sea genérico o esté contenido en un tipo genérico.</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>Uso de la variable local no asignada '{0}'</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>Una propiedad o un indizador no se puede pasar como parámetro out o ref</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>El miembro invalida los miembros base con varios candidatos de invalidación en el tiempo de ejecución</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>'{0}' no se puede devolver por referencia porque es un '{1}'.</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Omitir la carga de los tipos con errores en el ensamblado de analizador debido a ReflectionTypeLoadException</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>Los parámetros o las variables locales de tipo '{0}' no se pueden declarar en métodos asincrónicos o expresiones lambda.</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>No se encontró ninguna declaración de definición para la declaración de implementación del método parcial '{0}'</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>La referencia al tipo '{0}' confirma que está definida en este ensamblado, pero no lo está ni en el código fuente ni en los módulos agregados</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>No se puede pasar un valor NULL como nombre de ensamblado de confianza</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>El valor por defecto especificado no tendrá efecto porque se aplica a un miembro que se utiliza en contextos que no permiten argumentos opcionales</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>Bloque switch vacío</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>'{0}': una clase abstracta no puede estar sellada ni ser estática</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>Introducir un método 'Finalize' afectar a la invocación del destructor</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>Debe proporcionar un inicializador en una declaración de instrucción fixed o using</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>El tipo de valor devuelto para los operadores ++ o -- debe coincidir con el tipo de parámetro o derivarse de este</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>Varianza no válida: el parámetro de tipo '{1}' debe ser un {3} válido en '{0}'. '{1}' es {2}.</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>'{0}': no se permiten conversiones definidas por el usuario ni al tipo dinámico ni desde él.</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>AppConfigPath debe ser absoluto.</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>El CallerFilePathAttribute aplicado al parámetro '{0}' no tendrá efecto. Lo invalida el CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>Posible instrucción vacía errónea</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay conversión boxing ni conversión de parámetro de tipo de '{3}' a '{1}'.</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>XML con formato incorrecto en el archivo de comentarios de inclusión: '{0}'</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>Las propiedades implementadas automáticamente deben invalidar todos los descriptores de acceso de la propiedad invalidada.</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>La subexpresión no se puede usar en un argumento de nameof.</value>
  </data>
  <data name="ERR_MismatchedRefEscapeInTernary" xml:space="preserve">
    <value>Las ramas de un operador ternario ref no pueden hacer referencia a variables con ámbitos de declaración incompatibles.</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>Un campo de búfer de tamaño fijo debe tener el especificador de tamaño de matriz detrás del nombre de campo</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>Directiva #warning</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>Ninguna sobrecarga para el método '{0}' toma {1} argumentos</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>No se puede aplicar la indización con [] a una expresión del tipo '{0}'</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>'{0}' no es una restricción válida. Un tipo usado como restricción debe ser una interfaz, una clase no sellada o un parámetro de tipo.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>Referencia ambigua en el atributo cref: '{0}'. Se supone '{1}', pero también podría haber coincidido con otras sobrecargas que incluyen '{2}'.</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>La clase '{0}' no puede tener varias clases base: '{1}' y '{2}'</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>'{0}' invalida Object.Equals(object o) pero no invalida Object.GetHashCode()</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>Directiva Using innecesaria.</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>El nombre '{0}' no existe en el contexto actual</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>No hay ningún bucle envolvente desde el que interrumpir o continuar</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>La implementación de interfaz explícita '{0}' coincide con más de un miembro de interfaz. El miembro de interfaz que se elige depende de la implementación. Si quiere, puede usar una implementación no explícita.</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>Referencia a entidad sin definir '{0}'.</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>El comentario XML tiene código XML con formato incorrecto: '{0}'</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Las propiedades que devuelven datos por referencia deben tener un descriptor de acceso get.</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>Incoherencia de accesibilidad: la interfaz base '{1}' es menos accesible que la interfaz '{0}'</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>Un árbol de expresión no puede contener una expresión de método anónimo</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>expresión lambda</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>Se esperaba una definición de tipo o espacio de nombres, o el fin del archivo</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>Literal de cadena no terminado</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>Tipo de restricción no válida. Un tipo utilizado como restricción debe ser una interfaz, una clase no sellada o un parámetro de tipo.</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>La expresión siempre causará una excepción System.NullReferenceException porque el valor por defecto es null</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>Ni 'is' ni 'as' son válidos como tipos de puntero</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>El parámetro de tipo tiene el mismo nombre que el parámetro de tipo de un tipo externo</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>'{0}': las interfaces conformes a CLS solo pueden tener miembros conformes a CLS</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>Una expresión de método anónimo no se puede convertir en un árbol de expresión</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Se ha especificado el archivo de origen más de una vez</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>Se ha usado sintaxis incorrecta en un comentario.</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>No se admite un método Add de extensión para un inicializador de colección en un lambda de expresión.</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>El atributo '{0}' solo es válido en un indizador que no sea una declaración de miembro de interfaz explícita</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>'{0}' no es una clase de atributos</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>No se puede usar un tipo anónimo en una expresión constante</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>Las expresiones y las instrucciones solo pueden aparecer en un cuerpo de método</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>El tipo de '{0}' no es conforme a CLS</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>El operador "{0}" es ambiguo en los operandos "default" y "default"</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>El tipo de argumento '{0}' no es conforme a CLS</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>El parámetro params debe ser una matriz unidimensional</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>El punto de entrada del programa es código de script global: se omite el punto de entrada '{0}'.</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>No se puede llamar a un miembro base abstracto: '{0}'</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>No se puede convertir NULL en el parámetro de tipo '{0}' porque podría ser un tipo de valor que no acepta valores NULL. Use 'default({0})' en su lugar.</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>La funcionalidad no es parte de la especificación de lenguaje C# estandarizada por ISO y puede no estar aceptada en otros compiladores</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>No se puede devolver por referencia un miembro de la variable local '{0}' porque no es una variable local de tipo ref.</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>'{0}' no tiene clase base y no puede llamar a un constructor base</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>La mejor coincidencia de método sobrecargado para '{0}' tiene una firma errónea para el elemento inicializador. El elemento Add inicializable debe ser un método de instancia accesible.</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>Se especificó la firma pública y se requiere una clave pública, pero no se ha especificado ninguna.</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>Se esperaba )</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>No se encontró el archivo de origen '{0}'.</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>propiedad</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>'{0}' no se puede devolver por referencia porque es de solo lectura.</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>Una función anónima convertida en un delegado que devuelve void no puede devolver un valor</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>No se puede utilizar el tipo "dynamic" en un patrón.</value>
  </data>
  <data name="ERR_RefReadonlyNotField" xml:space="preserve">
    <value>No se puede usar {0} "{1}" como valor out o ref porque es una variable readonly.</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>Los destructores y object.Finalize no se pueden llamar directamente. Puede llamar a IDisposable.Dispose si está disponible.</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>Demasiados caracteres en literal de carácter</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>Se han proporcionado diferentes valores de suma de comprobación de #pragma</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>El valor '{0}' de SecurityAction no es válido para el atributo PrincipalPermission</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>Declarador de matriz erróneo. Para declarar una matriz administrada, el especificador de rango precede al identificador de la variable. Para declarar un campo de búfer de tamaño fijo, use la palabra clave fixed delante del tipo de campo.</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>Las declaraciones parciales de '{0}' deben tener los mismos nombres de parámetro de tipo y modificadores de varianza en el mismo orden</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>'{0}' no se puede derivar de la clase especial '{1}'</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>Como '{0}' es un método asincrónico que devuelve 'Task', una palabra clave return no debe ir seguida de una expresión de objeto. ¿Intentó devolver 'Task&lt;T&gt;'?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>No se puede usar '{0}' como valor out o ref porque es de solo lectura.</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>No se encontró ninguna implementación del patrón de consulta para el tipo de origen '{0}'. No se encontró '{1}'.</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerMemberNameAttribute solo se puede aplicar a parámetros con valores predeterminados</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>El tipo entra en conflicto con un espacio de nombres importado</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>El comentario XML tiene una etiqueta param para '{0}', pero no hay ningún parámetro con ese nombre</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>Falta el comentario XML para el tipo o miembro visible públicamente</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>La comparación con la constante integral es inútil. La constante está fuera del intervalo del tipo</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>El tipo define operator == or operator !=, pero no reemplaza a Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>Se ignorará el atributo en beneficio de la instancia que aparece en la fuente</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>No se pudo abrir el archivo de origen '{0}': {1}</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>El atributo '{0}' no es válido en este tipo de declaración. Solo es válido en declaraciones '{1}'.</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>Una variable local o un parámetro denominados '{0}' no se pueden declarar en este ámbito porque ese nombre se está usando en un ámbito local envolvente para definir una variable local o un parámetro</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>'{0}' es de tipo '{1}'. Un valor de parámetro predeterminado de un tipo de referencia que no sea de cadena solo se puede inicializar con NULL</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>No se pueden incrustar tipos de interoperabilidad desde el ensamblado '{0}' porque le falta el atributo '{1}' o '{2}'.</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>El tipo de restricción '{0}' no es conforme a CLS</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>No se puede asignar la propiedad o campo estático '{0}' en un inicializador de objeto</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>Atributo '{0}' duplicado</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>El atributo '{0}' solo es válido en clases derivadas de System.Attribute</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>Comparar con tipos de estructura o nulos siempre produce 'false'</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>No se permite el atributo RequiredAttribute en tipos C#</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>Solo se permiten 65534 variables locales incluyendo las generadas por el compilador</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>Normalmente, no debe usarse un campo volátil como valor ref o out, porque no se tratará como volátil. Pero hay excepciones, como cuando se llama a una API entrelazada.</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>No se puede incrustar el tipo de interoperabilidad '{0}' encontrado en los ensamblados '{1}' y '{2}'. Puede establecer la propiedad 'Incrustar tipos de interoperabilidad' en false.</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>la ruta de acceso es demasiado larga o no es válida</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>'{1} {0}' tiene un tipo de valor devuelto equivocado</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>El tipo no implementa la trama de colección. El miembro tiene la firma incorrecta</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>async main</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>El miembro '{0}' no se encontró en el tipo '{1}' del ensamblado '{2}'.</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>No se esperaba una etiqueta final en esta ubicación.</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>'{1}': no se puede derivar de la clase estática '{0}'</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>El acceso a un miembro en '{0}' podría provocar una excepción en tiempo de ejecución, ya que es un campo de una clase de serialización por referencia.</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>El tipo debe ser 'var'.</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>Se esperaba una expresión</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>'{0}' ha concedido acceso de confianza, pero la clave pública del ensamblado de salida no coincide con la especificada por el atributo en el ensamblado de concesión.</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>El idioma no admite el tipo '{0}'</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>La expresión se debe poder convertir implícitamente en 'Boolean' o su tipo '{0}' debe definir el operador '{1}'.</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>Se puede eliminar el objeto más de una vez</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>El CallerMemberNameAttribute aplicado al parámetro '{0}' no tendrá efecto. Lo invalida el CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>La referencia de ensamblado no es válida y no se puede resolver</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>El tipo de parámetro para el operador ++ o -- debe ser el tipo contenedor</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>No se encontró ningún valor para RuntimeMetadataVersion</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>Se requiere una referencia de objeto para el campo, método o propiedad '{0}' no estáticos</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>'{0}': las interfaces no pueden declarar tipos</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>No se puede marcar al tipo o al miembro como conformes a CLS porque el ensamblador no tiene un atributo CLSCompliant</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>'{0}': el tipo de valor devuelto debe ser '{2}' para que coincida con el miembro invalidado '{1}'</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>El envío puede tener, como máximo, un árbol de sintaxis.</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>Ninguna sobrecarga correspondiente a '{0}' coincide con el delegado '{1}'</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>Tipo no válido para el parámetro en el atributo cref del comentario XML</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>No se puede especificar el atributo DefaultMember en un tipo que contenga un indizador</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>El nivel de advertencia debe estar en el intervalo 0-4</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>indexador con forma de expresión</value>
  </data>
  <data name="ERR_LocalFunctionMissingBody" xml:space="preserve">
    <value>"{0}" es una función local y, por lo tanto, siempre debe tener un cuerpo.</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>'{0}': no se puede derivar del tipo dinámico</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>el árbol no forma parte de la compilación</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>Un elemento lambda de árbol de expresión no puede contener un operador de incorporación con un literal predeterminado o nulo en la parte izquierda</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>Error de sintaxis, se esperaba '{0}'</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>No es una ubicación de atributo reconocida</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>El inicializador de elemento no puede estar vacío</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>El tipo de la expresión de la cláusula {0} es incorrecto. No se pudo realizar la inferencia de tipos en la llamada a '{1}'.</value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>filtro de excepciones</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>Las declaraciones de métodos parciales de '{0}' tienen restricciones de parámetros de tipo incoherentes</value>
  </data>
</root>