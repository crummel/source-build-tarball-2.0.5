<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>Для создания результирующего файла без исходных текстов должен быть задан параметр /out.</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>Деление на константу, равную нулю</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>'{0}" не является допустимым аргументом именованного атрибута, так как он не является допустимым типом параметра атрибута.</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>Комментарий XML содержит неправильно сформированный XML</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Пропуск некоторых типов в сборке анализатора {0} из-за исключения ReflectionTypeLoadException: {1}.</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>Поле назначено, но его значение не используется</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>Дерево выражения не может содержать оператор присваивания.</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>Не удается обнаружить один или несколько типов, необходимых для компиляции динамического выражения. Возможно, отсутствует ссылка.</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}" является устаревшим: '{1}'</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>Атрибут Conditional недопустим для "{0}", так как это конструктор, деструктор, оператор или явная реализация интерфейса.</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Недопустимое имя модуля: {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>'{0}": не разрешено пользовательское преобразование в базовый класс или из базового класса.</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>'{0}": невозможно сослаться на тип через выражение; попытайтесь использовать "{1}".</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>Версия компилятора: "{0}". Версия языка: {1}.</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>итераторы</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>Ключ /win32manifest для модуля пропущен, т. к. используется только для сборок</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>Кодовая страница "{0}" является недопустимой или не установлена.</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>Член с атрибутом "obsolete" "{0}" переопределяет член без атрибута "obsolete" "{1}"</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>Отсутствуют закрывающие кавычки у литерала строки.</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>Компиляция отменена пользователем.</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Ссылки на метаданные не поддерживаются.</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>Тело запроса должно заканчиваться предложением select или предложением group.</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>Предложение Switch содержит несколько случаев со значением метки "{0}".</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>Требуется идентификатор, "{1}" является ключевым словом.</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>Недопустимое значение "{0}": '{1}'.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>Дерево выражения не может содержать небезопасные операции над указателями.</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>В ссылке на сущность используется недопустимый символ.</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>Дерево лямбда-выражения не может содержать метод с изменяющимся числом аргументов.</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>Переключатель командной строки еще не реализован</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>Компилятор неявно расширил переменную с расширением знака, а затем использовал полученное значение в битовой или обычной операции. Это может вызвать непредсказуемое поведение.</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>К указателю должен быть применен оператор * или -&gt;.</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>Недопустимое имя символа предварительной обработки. "{0}" не является допустимым идентификатором.</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>Оператор "{0}" невозможно применить к операнду типа "{1}" и "{2}".</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>Тип невозможно пометить как совместимый с CLS, так как он является членом несовместимого с CLS типа</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>Атрибут CallerMemberNameAttribute не будет работать: он переопределяется атрибутом CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField2" xml:space="preserve">
    <value>Члены {0} "{1}" невозможно вернуть по ссылке для записи, так как это переменная только для чтения</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>"{0}" не может объявить тело, потому что помечен как abstract.</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа события "{1}" ниже доступности события "{0}"</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>Член "{0}" переопределяет устаревший член "{1}". Добавьте к "{0}" атрибут Obsolete.</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Обнаружен недостижимый код</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>Типу или члену не требуется атрибут, совместимый с CLS, так как сборка не содержит атрибут CLSCompliant</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>Не удалось найти реализацию шаблона запроса для исходного типа "{0}".  "{1}" не найден.  Попробуйте явно указать тип переменной диапазона "{2}".</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>"{0}" является недопустимым номером предупреждения.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования неявной ссылки из "{3}" в "{1}".</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>Метод, оператор или метод доступа помечен как внешний и не имеет атрибутов</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>Имя деструктора должно соответствовать имени класса.</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>Невозможно передать переменную диапазона "{0}" как параметр с ключевыми словами out или ref.</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>Цикл foreach должен объявлять собственные переменные итерации.</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>Атрибут DllImport должен быть указан для метода, который помечен как "static" и "extern".</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>разделяемый метод</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>Полю "{0}" присвоено значение, но оно ни разу не использовано.</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>Нельзя использовать оператор yield в теле предложения finally.</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;пространство имен&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>Оператор await можно использовать только в выражении запроса в первом выражении коллекции начального предложения From или в выражении коллекции предложения Join.</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>Значение по умолчанию, указанное для параметра "{0}", не будет действовать, так как оно применяется к члену, используемому в контекстах, не допускающих необязательных аргументов.</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>'{0}": явное объявление интерфейса может содержаться только в классе или в структуре.</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>Нельзя переопределять глобальный внешний псевдоним.</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>Атрибут CLSCompliant не применяется к параметрам. Попробуйте разместить его в методе.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>Это предупреждение возникает, если в блоке catch() не указан тип исключений после блока catch (System.Exception e). В предупреждении рекомендуется, чтобы блок catch() не получал исключения.

В блоке catch(), находящемся после блока catch (System.Exception e), могут возникнуть исключения, не связанные с CLS, если для параметра RuntimeCompatibilityAttribute задано значение false в файле AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Если для этого атрибута не задано явно значение false, все исключения, не связанные с CLS, упаковываются как исключения и их получает блок catch (System.Exception e).</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>Невозможное ожидание в предложении catch.</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>Невозможно деконструировать динамические объекты.</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>Невозможно использовать выражение в этом контексте, так как его невозможно передать или вернуть по ссылке</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>В параметре /reference, объявляющем внешний псевдоним, можно задать только одно имя файла. Чтобы задать несколько псевдонимов или имен файлов, следует использовать несколько параметров /reference.</value>
  </data>
  <data name="ERR_StackAllocConversionNotPossible" xml:space="preserve">
    <value>Невозможно преобразовать выражение stackalloc типа "{0}" в тип "{1}".</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>Отсутствует закрывающий разделитель "}" для интерполированного выражения, начинающегося с "{".</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>Для включения проверки на соответствие CLS следует назначить сборке, а не модулю, атрибут CLSCompliant.</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>Оператор foreach не работает с переменными типа "{0}", так как "{0}" не содержит открытого определения для "{1}".</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Ошибка чтения файла ruleset {0} — {1}.</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Не вызывайте метод Finalize базового класса напрямую. Он вызывается автоматически из деструктора.</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>'{0}": значение перечислителя недопустимо велико для типа, к которому он относится.</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>Недопустимое имя файла в директиве препроцессора. Слишком длинное имя файла, либо оно не является допустимым именем файла.</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>Тип или член устарел</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>Аргументы типа для метода "{0}" не могут определяться по использованию. Попытайтесь явно определить аргументы типа.</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>Отсутствует атрибут file</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>Отсутствует атрибут path</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>Неуправляемый тип "{0}" недопустим для полей.</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Ошибка при подписи выхода открытым ключом из контейнера "{0}" — {1}.</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>Для оператора "{0}" требуется, чтобы был определен соответствующий оператор "{1}".</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>Инициализатор поля не может обращаться к нестатическому полю, методу или свойству "{0}".</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>автоматически реализуемые свойства только для чтения</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>Поля доступного только для чтения статического поля "{0}" можно использовать как значение ref или out только в статическом конструкторе</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>модификаторы доступа в свойствах</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>Недопустимый токен "{0}" в объявлении класса, структуры или члена интерфейса.</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>Не удалось найти файл метаданных "{0}".</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>"{0}" не имеет предопределенного размера, поэтому оператор sizeof может использоваться только в небезопасном (unsafe) контексте (рекомендуется использование System.Runtime.InteropServices.Marshal.SizeOf).</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>Недопустимый путь для поиска "{0}" указан в "{1}" — "{2}"</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>Невозможно вернуть поля "{0}" по ссылке, так как это "{1}"</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>Невозможно преобразовать {0} в тип делегата "{1}", так как типы параметров не совпадают с типами параметров делегата.</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>Только члены, совместимые с CLS, могут быть абстрактными</value>
  </data>
  <data name="IDS_FeaturePrivateProtected" xml:space="preserve">
    <value>частный защищенный</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>Сборка и модуль "{0}" не могут предназначаться для разных процессоров.</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>Невозможное ожидание в теле оператора lock.</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>Доступное только для чтения статическое поле можно использовать как значение ref или out только в статическом конструкторе</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>Атрибут "{0}" нельзя использовать в методах доступа к свойствам или событиям. Он допустим только для объявлений "{1}".</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>Использование массивов как аргументов атрибутов в CLS не разрешено</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>Неиспользованный внешний псевдоним</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>Недопустимое число</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>изменение типа</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>каталог не существует</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>Чтобы применить "{0}" в качестве логического оператора краткой записи, его объявляющий тип "{1}" должен определять оператор True и оператор False.</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>Требуется вложенный инициализатор массива.</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>Деструкторы могут содержаться только в типах классов.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>Предполагается, что ссылка на сборку совпадает с удостоверением</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>Ссылка сборки "{0}" является недопустимой и не может быть разрешена.</value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>Назначению деконструкции требуется выражение с типом справа.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Недопустимое выравнивание разделов файла "{0}"</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Анонимные методы, лямбда-выражения и выражения запроса внутри структуры не имеют доступа к членам экземпляра "this". Возможно, следует скопировать "this" в локальную переменную за пределами анонимного метода, лямбда-выражения или выражения запроса и использовать эту локальную переменную.</value>
  </data>
  <data name="ERR_AssignReadonlyNotField2" xml:space="preserve">
    <value>Не удается присвоить значение члену {0} "{1}", так как это переменная только для чтения</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>Условный член "{0}" не может реализовать член интерфейса "{1}" в типе "{2}".</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>Статический класс "{0}" не может быть производным от типа "{1}". Статические классы должны быть производными от object.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>Поля статического поля "{0}", доступного только для чтения, нельзя вернуть по ссылке для записи</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>Тип "{0}" определен в этой сборке, но для нее указан метод передачи типа.</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>Выражение слишком длинное или сложное для компиляции</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>После директивы #pragma ожидается комментарий длиной в одну строку или комментарий в конце строки</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>'{0}": свойство события должно иметь методы доступа для добавления и удаления.</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>Ожидается "{" или ";" или "=&gt;"</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>Сборка, на которую указывает ссылка, предназначена для другого процессора</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>Не удается найти управляемый класс-оболочку coclass "{0}" для интерфейса "{1}" (возможно, была пропущена ссылка на сборку).</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>"{0}" не реализует шаблон "{1}". "{2}" неоднозначен с "{3}".</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>Недопустимый параметр "{0}" для /langversion. Используйте "/langversion:?" для вывода списка поддерживаемых значений.</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>Полное имя псевдонима не является выражением.</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>Требуется идентификатор.</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>Значение "goto case" невозможно неявно преобразовать в тип "{0}".</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>Назначение в условном выражении всегда является константой</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>Член с атрибутом Conditional "{0}" не может иметь параметр с ключевым словом out.</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>Невозможно ожидание в небезопасном контексте.</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>Внедренный оператор не может быть объявлением или оператором с идентификатором.</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>Конструктор помечен как внешний</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>инциализатор коллекции</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>Предопределенный тип "{0}" не определен или не импортирован</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>автоматически реализованные свойства</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>Вызов метода "{0}" с автоматической диспетчеризацией может привести к ошибке во время выполнения, поскольку одна или несколько применимых перегрузок являются условными методами.</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>Тип или член устарел</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>Конструктор "{0}" помечен как внешний</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>"{0}": реализация интерфейсов статическими классами невозможна.</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>Внедренная структура взаимодействия "{0}" может содержать только открытые экземпляры полей.</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>Невозможно наследовать от "{0}", так как он не является параметром типа.</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>Локальная переменная, объявленная в операторе fixed, должна иметь тип указателя.</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>внешний псевдоним</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>Недопустимый тип возвращаемого значения в атрибуте cref XML-комментария</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>Атрибут CLSCompliant не имеет значения при применении к параметрам</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>Первый операнд оператора as не может быть литералом кортежа без естественного типа.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Недопустимый тип инструментирования: {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>Невозможно объявить пространство имен в коде скрипта</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>Открытая, защищенная или защищенная внутренняя переменная должна иметь тип, совместимый с CLS.</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>Конфликт модификаторов доступа в разделяемых объявлениях "{0}".</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Тип "{3}", допускающий значение Null, не соответствует ограничению "{1}".</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>Возможно, использовано непреднамеренное сравнение ссылок: для правой стороны требуется приведение</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>Не удалось произвести запись в выходной файл "{0}" — "{1}".</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>Требуется ключевое слово "this" или "base".</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>Результат значения всегда одинаковый, так как значение этого типа никогда не равно NULL</value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>Невозможно использовать "yield" в коде скрипта верхнего уровня</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>В асинхронном методе отсутствуют операторы await, будет выполнен синхронный метод</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>Предопределенный тип определяется в нескольких сборках глобального псевдонима</value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>'{0}": аргумент атрибута не может использовать параметры типа.</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>Требуется перегружаемый оператор.</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>Присваивание значений полям доступного только для чтения статического поля "{0}" допускается только в статическом конструкторе и в инициализаторе переменных.</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>Не указаны файлы с исходным кодом.</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>"{0}" имеет неправильную сигнатуру и не может быть точкой входа</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>Конструкции catch не могут использоваться после универсальной конструкции catch оператора try</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>Аргумент отсутствует.</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>Не удается преобразовать лямбда-выражение в дерево выражения, чей аргумент типа "{0}" не является делегатом</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>При указателях на объекты неизвестного типа данная операция не определена.</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>Делегат "{0}" не содержит метода invoke или метода invoke с возвращаемым типом или типами параметров, которые не поддерживаются.</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>оператор nameof</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>Не удается получить адрес, определить размер или объявить указатель на управляемый тип ("{0}").</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>Возможность "{0}" не входит в спецификацию языка C#, стандартизированную ISO, и может не распознаваться другими компиляторами</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>Атрибут "{0}", заданный в исходном файле, конфликтует с параметром "{1}".</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>Невозможно задать аргумент CLSCompliant в модуле, который отличается от атрибута CLSCompliant в сборке.</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>Параметр {0} должен быть объявлен с ключевым словом "{1}".</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>Невозможно ожидание в теле предложения finally.</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>Требуется объект, строка или тип класса.</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>Связанные метаданные netmodule должны обеспечивать полный образ PE: '{0}'.</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>Определение псевдонима с именем global не рекомендуется</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>Объявления исходящих переменных или переменных шаблонов запрещены в инициализаторах конструкторов, полей и свойств.</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred может использоваться только вместе с /t:exe, /t:winexe and /t:appcontainerexe</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>'{0}": класс с атрибутом ComImport не может указывать базовый класс.</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>Поскольку "{1}" имеет атрибут ComImport, "{0}" должен быть внешним или абстрактным.</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>переменная fixed</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>Конфликтующее имя {0}</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>Предыдущее предложение catch уже перехватывает все исключения этого типа или супертипа ("{0}").</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>Использование поля "{0}", которому, возможно, не присвоено значение.</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>Нельзя указывать тела блоков одновременно с телами выражений.</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>System.Void из C# использоваться не может -- для получения объекта типа void используйте typeof(void).</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>Указанный режим документации не поддерживается или недопустим: "{0}".</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>Оператор "{0}" для операнда типа "{1}" является неоднозначным.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>Имя элемента кортежа игнорируется, так как целевым объектом назначения задано другое имя либо имя не задано.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>Сборка, на которую указывает ссылка, не имеет строгого имени</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>Разделяемый метод не может явно реализовывать метод интерфейса.</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>лямбда-выражение</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>Не удается использовать "{0}" для метода Main, так как он импортирован.</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>Тип параметра унарного оператора должен быть вмещающим.</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>Структуры не могут содержать явных конструкторов без параметров.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел. {1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>Длина строковой константы превышает текущий предельный объем памяти. Попробуйте разбить строку на несколько констант.</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>Поле "{0}" должно быть полностью определено до возврата управления в вызывающий метод.</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>Для включения проверки на соответствие CLS следует назначить сборке, а не модулю, атрибут CLSCompliant.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>У сборки "{0}", на которую дается ссылка, нет строгого имени.</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>пространство имен</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>Неоднозначный вызов следующих методов или свойств: '{0}" и "{1}"</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>Константа с плавающей запятой вне допустимого диапазона для типа "{0}".</value>
  </data>
  <data name="ERR_InvalidDebugInfo" xml:space="preserve">
    <value>Не удается считать сведения об отладке метода "{0}" (маркер 0x{1:X8}) из сборки "{2}".</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>Не удается выдать отладочную информацию для исходного текста без кодировки.</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>Недопустимый параметр "{0}"; видимость ресурса должна быть либо "public", либо "private".</value>
  </data>
  <data name="ERR_ExplicitReservedAttr" xml:space="preserve">
    <value>Не используйте "{0}". Этот атрибут зарезервирован для использования компилятором.</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>Невозможно восстановить предупреждение, так как оно было отключено глобально</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>__arglist не разрешается использовать в списке параметров итераторов.</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>Не удается преобразовать асинхронный тип {0} в тип делегата "{1}". Асинхронный тип {0} может возвращать значения Void, Task или Task&lt;T&gt;, ни одно из которых не преобразуется в "{1}".</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>Повторяющийся атрибут "{0}"</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>Требуется конечный тег для элемента "{0}".</value>
  </data>
  <data name="IDS_FeatureLeadingDigitSeparator" xml:space="preserve">
    <value>разделитель начальных цифр</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Аргументы типа недопустимы в операторе nameof.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>Тип или имя пространства имен "{0}" не существует в пространстве имен "{1}" (возможно, отсутствует ссылка на сборку).</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>'{0}": при создании экземпляра типа переменной не удается задать аргументы</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>Ошибка при чтении ресурсов Win32 — {0}.</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Не удалось найти имя типа "{0}" в глобальном пространстве имен. Этот тип был отправлен в сборку "{1}". Попробуйте добавить ссылку на эту сборку.</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>Невозможно вернуть выражение типа void.</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>Параметр ref или out не может иметь значение по умолчанию.</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Не удалось найти имя типа "{0}". Этот тип был перемещен в сборку "{1}". Возможно, стоит добавить ссылку на эту сборку.</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>Итераторы не могут иметь локальных переменных по ссылке</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>Не удалось указать значение по умолчанию для параметра this.</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>Данное выражение никогда не имеет указанный тип ("{0}")</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит тег typeparam, но параметр типа с таким именем не существует</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>Либо оба объявления разделяемого метода должны иметь модификаторы unsafe, либо ни одно из объявлений не должно иметь модификатора unsafe.</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>Второй операнд оператора "is" или "as" не может быть статического типа "{0}".</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>Базовый тип помечен как несовместимый с CLS в сборке, помеченной как совместимая с CLS. Удалите атрибут, указывающий совместимость сборки с CLS, или удалите атрибут, указывающий несовместимость типа с CLS.</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>Метод с vararg не может быть универсальным, иметь универсальный тип или параметр params</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>Для применения оператора "await" у типа "{0}" должен быть подходящий метод GetAwaiter. Возможно отсутствует директива using для "System".</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>Требуется ";" или "=" (невозможно задать аргументы конструктора в объявлении).</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>Тип возвращаемого значения операторов Истина и Ложь должен быть логическим.</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>Ограничение не может быть специальным классом "{0}"</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>Тип "{0}", отправленный в сборку "{1}", конфликтует с типом "{2}", отправленным в сборку "{3}".</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>В этом контексте значения по умолчанию недействительны.</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Делегат "{0}" не имеет параметра с именем "{1}".</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>"{0}" несовместим с CLS, поскольку с ним несовместим базовый интерфейс "{1}".</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>В исходном интерфейсе "{0}" отсутствует метод "{1}", обязательный для внедрения события "{2}".</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>Параметр конструктора атрибута "{0}" необязателен, однако значение параметра по умолчанию указано не было.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Лямбда дерева выражения не может содержать оператор распространения значений NULL.</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>Не удалось найти псевдоним "{0}"</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>Повторная инициализация члена "{0}"</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>Недопустимый параметр "{0}" для /debug; допустимые значения: "portable", "embedded", "full" или "pdbonly"</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>Адрес нефиксированного выражения можно получить только внутри инициализатора оператора fixed.</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>'{0}": класс с атрибутом ComImport не может указывать инициализаторы полей.</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>'{0}": нельзя объявлять индексаторы в статическом классе.</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>'{0}" уже присутствует в списке интерфейсов.</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>Невозможно использовать объект this, пока не будут назначены все его поля.</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>"{0}": для свойства или индексатора должен быть указан по крайней мере один метод доступа.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>Неявно типизированные переменные не могут быть константными</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>Переменная объявлена с тем же именем, что и переменная в базовом классе, однако, не было использовано новое ключевое слово. Это предупреждение сообщает о том, что следует использовать новое ключевое слово: переменная объявлена с учетом использования нового ключевого слова в декларации.</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности метода "{0}"</value>
  </data>
  <data name="ERR_FieldsInRoStruct" xml:space="preserve">
    <value>Поля экземпляров в структурах только для чтения должны быть доступны только для чтения.</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>Чтобы создать токены символьных литералов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>Использование массивов как аргументов атрибутов в CLS не разрешено</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>Величина значения выравнивания {0} больше, чем {1}; это может привести к возникновению большой форматированной строки.</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>объявление переменной с параметром OUT</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>Сравнение с целочисленной константой не имеет смысла; константа находится вне диапазона значений типа "{0}".</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>"экспериментальный"</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>Тип "{0}" из сборки "{1}" не может быть использован за границами сборки, так как имеет аргумент универсального типа, являющийся внедренным типом взаимодействия.</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction" xml:space="preserve">
    <value>Локальная функция "{0}" объявлена, но не используется.</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>Оператор as должен использоваться со ссылочным типом или с типом, допускающим значение Null (тип "{0}" не допускает значение Null).</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>Абстрактный метод {0} "{1}" не может быть помечен как virtual.</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>"{0}": статические классы не могут содержать определяемых пользователем операторов.</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>Метка "{0}" во вложенной области видимости скрывает другую метку с тем же именем.</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>Член "{1}" переопределяет "{0}". Возникает множественное переопределение в ходе выполнения. Реализация зависит от того, какой метод будет вызван.</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>Требуется метод доступа get или set.</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>Не используйте "System.ParamArrayAttribute". Используйте ключевое слово "params".</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>Новый защищенный член объявлен в запечатанном классе</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Отправленный тип "{0}" конфликтует с типом, объявленным в основном модуле этой сборки.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>Две сборки отличаются номером выпуска или версии. Для унификации необходимо указать директивы в CONFIG-файле приложения и предоставить допустимое строгое имя сборки.</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>Конструктор "{0}" не может вызвать сам себя посредством другого конструктора</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>Файл "{0}", на который дается ссылка, не является сборкой.</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>Перегруженный бинарный оператор "{0}" принимает два параметра.</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>Недопустимый атрибут Conditional для "{0}", так как он является методом переопределения.</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>Локаль "{0}" или его члены не могут получить свои адреса и использоваться внутри анонимного метода или лямбда-выражения</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>Ожидается SearchCriteria.</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>Интерфейсы не могут содержать конструкторы.</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>Так как "{0}" возвращает значение void, поэтому после ключевого слова return не должно присутствовать выражение объекта.</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>Определенный пользователем оператор не может получить объект данного включающего типа и выполнить преобразование в объект данного включающего типа.</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>Не удается продолжить, так как оператор edit содержит ссылку на встроенный тип: "{0}".</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Поскольку этот вызов не ожидается, выполнение текущего метода продолжается до завершения вызова. Попробуйте применить оператор await к результату вызова.</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>"{0}" не реализует шаблон "{1}". "{2}" либо статический, либо не открытый.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>Следует вызвать метод System.IDisposable.Dispose() для выделенного экземпляра {0} до того, как все ссылки на него будут находиться вне области действия.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>Выделенный экземпляр {0} не уничтожается во всех путях исключений.  Следует вызвать метод System.IDisposable.Dispose до того, как все ссылки на него будут находиться вне области действия.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>Предполагаемый синтаксический узел не может принадлежать синтаксическому дереву из текущей компиляции.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>Атрибут безопасности "{0}" имеет недопустимое значение SecurityAction "{1}".</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>Для приведения отрицательного значения следует заключить значение в круглые скобки.</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>Слишком длинное локальное имя "{0}" для PDB.  Попробуйте сократить или компилировать без /debug.</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>Требуется определение члена, оператор или признак конца файла</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>Так как этот вызов не ожидается, выполнение существующего метода продолжается до завершения вызова</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>Предложение Using должно предшествовать любым другим элементам пространства имен кроме объявлений внешних псевдонимов.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>Оператор await можно использовать только в методах с модификатором async. Consider marking this method with the 'async' modifier and changing its return type to 'Task&lt;{0}&gt;'.</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>Буфер фиксированного размера может иметь только одно измерение.</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>Результат выражения всегда равен "{0}", поскольку значение типа "{1}" никогда не равно Null типа "{2}"</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>переменная</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>Не удается использовать псевдоним "{0}" с "::" так как псевдоним ссылается на тип. Вместо этого используйте объект ".".</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Встретилась отметка о конфликте слияния</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>Недопустимая дружественная ссылка на сборку "{0}". Объявления InternalsVisibleTo не содержат определения версии, языка и региональных параметров, токена открытого ключа или архитектуры процессора.</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>Пустая символьная константа.</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>'{0}" не может быть добавлен к этой сборке, так как он уже там находится.</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>Общедоступные подписи не поддерживаются для netmodule.</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>Поле или свойство не может иметь тип "{0}".</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>Имена элементов кортежа не разрешены в левой части деконструкции.</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>Дерево лямбда-выражения не может содержать группу методов.</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>Не удается привязать делегат к "{0}", так как он является членом "System.Nullable&lt;T&gt;".</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>метод</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>В разделяемых объявлениях "{0}" имена параметров типов и их порядок должны быть одинаковыми.</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>В этом месте нельзя использовать символы "{0}".</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>Оператор "await" можно использовать только в методах с модификатором async {0}. Попробуйте пометить {0} модификатором "async".</value>
  </data>
  <data name="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne" xml:space="preserve">
    <value>Первый параметр метода расширения "ref" "{0}" должен иметь тип значения или универсальный тип, ограниченный структурой.</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>Построение цепочки наблюдающей семантической модели не поддерживается. Необходимо создать наблюдающую модель из ненаблюдающей ParentModel.</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>Для программы определено несколько точек входа. Компиляция с /main позволит указать тип, содержащий точку входа.</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>Выражение фильтра является константой, попробуйте удалить фильтр.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_2" xml:space="preserve">
    <value>Компонент "{0}" недоступен в C# 7.2. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 7.1. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>Не удалось включить фрагмент XML "{1}" файла "{0}" — {2}.</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>Тип "{0}", экспортированный из модуля "{1}", конфликтует с типом "{2}", экспортированным из модуля "{3}".</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>Точка входа не может быть универсальной или иметь универсальный тип</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>'{0}" не имеет подходящего статического метода Main.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>Слишком длинное полное имя "{0}" для отладочной информации. Компилируйте без параметра "/debug".</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>Необязательные параметры должны быть указаны после всех требуемых параметров.</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>Предупреждение переопределяет ошибку</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>Отсутствует ссылка на эту метку.</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>Переменная "{0}" объявлена, но ни разу не использована.</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>Использование универсального {1} "{0}" требует аргументы типа {2}.</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>Требуется директива #endif.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>Существующий метод вызывает асинхронный метод, который возвращает Task или Task&lt;TResult&gt; и не применяет оператор await к результату. Вызов асинхронного метода запускает асинхронную задачу. Однако, так как оператор await не применяется, программа продолжает работу, не дождавшись выполнения задачи. В большинстве случаев такое поведение не ожидается. Обычно другие аспекты вызова метода зависят от результатов вызова, или предполагается, что вызываемый метод будет завершен как минимум до возврата значения из метода, содержащего вызов.

Не менее важно то, что происходит с исключениями, возникающими в вызываемом асинхронном методе. Исключение, возникающее в методе, который возвращает Task или Task&lt;TResult&gt;, хранится в возвращенной задаче. Если не ждать завершения задачи или не выполнить явную проверку на исключения, исключение теряется. Если подождать завершения задачи, исключение вызывается повторно.

Рекомендуется всегда дожидаться вызова.

Подавление предупреждений следует использовать только в том случае, если вы не хотите ждать завершения асинхронного вызова, а вызванный метод не создаст исключений. В этом случае можно подавить предупреждение, назначив результат задачи вызова для переменной.</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>выражение запроса</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>Недопустимое значение аргумента атрибута "{0}".</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>Безразмерная сборка не может иметь модуль для конкретного процессора "{0}".</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>Спецификатор формата не должен оканчиваться пробелом.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>Переменная назначена, но ее значение не используется</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>Методы доступа add и remove должны иметь тело.</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>'Невозможно реализовать "{0}" через явную реализацию метода "{1}", так как он является методом доступа.</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>Член реализует член интерфейса с несколькими совпадениями во время выполнения</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>Комментарий XML имеет повторяющийся тег param для "{0}".</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>Имя перечислителя "{0}" зарезервировано и не может использоваться.</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>Лямбда дерева выражения не может содержать инициализатор словаря.</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>Член "{0}" не скрывает доступный член. Ключевое слово new не требуется.</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation" xml:space="preserve">
    <value>Спецификации именованных аргументов должны создаваться после всех указанных фиксированных аргументов в динамическом вызове.</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>Номер, переданный в директиву препроцессора предупреждений #pragma, не являлся допустимым номером предупреждения. Убедитесь, что номер соответствует предупреждению, а не ошибке.</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>ожидать в блоках "Catch" и "Finally"</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>"{0}": точка входа не может быть универсальной или находиться в универсальном типе</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>"{0}" не реализует член интерфейса "{1}".</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>'{0}" не содержит определение для "{1}", и наиболее подходящий перегруженный метод расширения "{2}" требует наличия получателя типа "{3}".</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>Использование #r допускается только в скриптах.</value>
  </data>
  <data name="ERR_DynamicLocalFunctionTypeParameter" xml:space="preserve">
    <value>Невозможно передать аргумент с динамическим типом в универсальную локальную функцию "{0}" с выводимыми аргументами типа.</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Синтаксическое дерево уже имеется</value>
  </data>
  <data name="ERR_BadParameterModifiersOrder" xml:space="preserve">
    <value>Модификатор параметра "{0}" не может использоваться после модификатора "{1}"</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Недопустимое имя выходных данных: {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>Класс с атрибутом ComImport не может иметь определенного пользователем конструктора.</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>Выражение return должно иметь тип "{0}", так как этот метод возвращает данные по ссылке</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Автоматически реализованные свойства должны иметь методы доступа get.</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>Идентификатор "{0}" несовместим с CLS.</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Ошибка чтения отладочной информации для "{0}"</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>Статические классы не могут содержать деструкторы.</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>Данное выражение всегда имеет указанный тип ("{0}")</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>Ссылки на исходный файл не поддерживаются.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>Нет определенного порядка полей при нескольких объявлениях разделяемой структуры "{0}". Чтобы определить порядок, все поля экземпляра должны быть в одном объявлении.</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>Несогласованность по доступности: доступность индексатора возвращаемого типа "{1}" ниже доступности индексатора "{0}"</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>Поле, совместимое с CLS, не может иметь модификатор volatile</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности метода "{0}"</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>Дерево должно иметь корневой узел в SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>В качестве оператора могут использоваться только выражения присваивания, вызова, инкремента, декремента и создания нового объекта</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>Применение атрибута CallerFilePathAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>params недопустим в этом контексте.</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>Дерево лямбда-выражения не может содержать параметры с ключевыми словами out и ref.</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>Не удается инициализировать тип "{0}" инициализатором набора, потому что он не реализует интерфейс "System.Collections.IEnumerable".</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>Тип первого операнда переопределенного оператора сдвига должен совпадать с вмещающим типом, а тип второго операнда должен быть int.</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>автоматический инициализатор свойства</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>Ошибка чтения ресурса "{0}" — "{1}".</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>Требуется директива препроцессора.</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>"await" нельзя использовать в выражении, содержащем тип "{0}"</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>Не удается определить модификаторы доступа для обоих методов доступа свойства или индексатора "{0}".</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Имена элементов кортежа должны быть уникальными.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>Имя языка недопустимо</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}": явный вызов оператора или метода доступа невозможен.</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>Параметр "{0}" не может быть внешним и иметь инициализатор конструктора</value>
  </data>
  <data name="IDS_StackAllocExpression" xml:space="preserve">
    <value>stackalloc {0}[{1}]</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>Автоматически реализованные свойства не могут возвращать данные по ссылке</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>Отсутствует требуемый пробел.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Отсутствует ссылка на "{0}" netmodule.</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>Операция вызвала переполнение стека.</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>переменная цикла foreach</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>'{0}": невозможно переопределить, так как "{1}" не является событием.</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>'{0}" повторяющийся TypeForwardedToAttribute</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>Буферы фиксированного размера должны иметь ненулевую длину.</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>Оператор await нельзя использовать в качестве идентификатора в асинхронном методе или лямбда-выражении.</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>Постоянное значение "{0}" не может быть преобразовано в "{1}" (для переопределения используйте синтаксис "unchecked").</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>Идентификатор несовместим с CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>инициализатор словаря</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>интерполированные строки</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>Не все ветви кода возвращают значение в {0} типа "{1}.</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>Возможно, использовано непреднамеренное сравнение ссылок: для левой стороны требуется приведение</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>Не удается разрешить путь файла "{0}", определенный для именованного аргумента "{1}" атрибута PermissionSet.</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>Недопустимое число</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>Сборка "{0}", на которую дается ссылка, использует другой параметр языка и региональных параметров "{1}".</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>Неоднозначная ссылка в атрибуте cref</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>Первый параметр метода расширения не может иметь тип "{0}".</value>
  </data>
  <data name="IDS_FeatureReadOnlyReferences" xml:space="preserve">
    <value>ссылки только для чтения</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>'{0}" является {1}, который недопустим в данном контексте.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>Перегруженный метод "{0}", отличающийся только параметром с ключевым словом ref или out, либо рангом массива, несовместимы с CLS.</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>Параметр имеет недопустимый тип "void".</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>Ограничения не разрешены в объявлениях, не являющихся универсальными.</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>Синтаксически недопустимый атрибут cref в комментарии XML</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>анонимные методы</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>Дерево выражений не может содержать выражение throw.</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>Не удается преобразовать тип "{0}" в "{1}"</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>Нельзя указывать именованный аргумент "{0}" несколько раз.</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>Спецификатор типа массива, [], должен располагаться перед именем параметра.</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>Не удается преобразовать значение NULL в "{0}", поскольку этот тип значений не допускает значение NULL.</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>Модификатор "partial" может использоваться только перед "class", "struct", "interface" или "void".</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>Тип аргумента для атрибута DefaultParameterValue должен соответствовать типу параметра.</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>Недопустимый параметр псевдонима ссылки: "{0}=" — не указано имя файла</value>
  </data>
  <data name="ERR_FieldAutoPropCantBeByRefLike" xml:space="preserve">
    <value>Поле или автоматически реализуемое свойство не может быть типа "{0}", если это не член экземпляра ссылочной структуры.</value>
  </data>
  <data name="ERR_BadNonTrailingNamedArgument" xml:space="preserve">
    <value>Именованный аргумент "{0}" используется не на своем месте, но за ним следует неименованный аргумент</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>Члены поля "{0}", доступного только для чтения, нельзя вернуть по ссылке, доступной для записи</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>Не удается использовать выражение типа "{0}" в качестве аргумента для динамически отправляемой операции.</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>Выражения запросов по источнику типа "dynamic" или с последовательностью объединения типа "dynamic" запрещены.</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>Параметр "{0}" переопределяет атрибут "{1}", заданный в исходном файле или в добавленном модуле.</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>'{0}": имена членов не могут совпадать с именами типов, в которых они содержатся</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>Контекстное ключевое слово "var" может использоваться только в объявлении локальной переменной или в скрипте.</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>Недопустимый номер базы образа "{0}'</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>Событие среды выполнения Windows не может передаваться как параметр out или ref.</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>Экземпляр типа "{0}" нельзя использовать внутри вложенной функции, выражения запроса, блока итератора или асинхронного метода.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>'{0}" не реализует член интерфейса "{1}". '{2}" не может реализовать "{1}", потому что не имеет соответствующего возвращаемого типа "{3}".</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>Тип одного из выражений в предложении {0} неверен.  Ошибка определения типа при вызове в "{1}".</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>Атрибут cref комментария XML ссылается на параметр типа</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>Требуется имя метода.</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>Не удается использовать фиксированную локальную переменную "{0}" внутри анонимного метода, лямбда-выражения или выражения запроса.</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>__arglist недопустим в этом контексте.</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Элементы не могут иметь значение Null.</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>Не символ C# .</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>"{0}": нельзя использовать статические типы в качестве параметров.</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Тип "{0}", экспортированный из модуля "{1}", конфликтует с типом, объявленным в основном модуле этой сборки.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>Указанная строка версии не соответствует требуемому формату — основной номер[.дополнительный номер[.сборка[.редакция]]].</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>Оператор foreach не может использоваться с переменными типа "{0}", так как он реализует несколько экземпляров "{1}"; рекомендуется предварительное приведение к определенной реализации интерфейса.</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит тег param, но параметр с таким именем не существует</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>Возвращаемый тип By-reference "ref {0}" не поддерживается.</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>Требуется идентификатор.</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>сопоставление шаблону</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>Атрибут CallerMemberNameAttribute не будет работать: он переопределяется атрибутом CallerFilePathAttribute</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>Дерево выражения не может иметь доступ к базовым членам.</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>Параметр может иметь только один модификатор "{0}".</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>В области видимости оператора goto отсутствует метка "{0}".</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>Небезопасный код может использоваться только при компиляции с параметром /unsafe.</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>await нельзя использовать в выражении, содержащем вызов "{0}", так как он возвращает данные по ссылке</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>"{0}": виртуальные и абстрактные члены не могут быть закрытыми.</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>Сборка, на которую указывает ссылка, содержит другой параметр языка и региональных параметров</value>
  </data>
  <data name="ERR_InExtensionMustBeValueType" xml:space="preserve">
    <value>Первый параметр метода расширения "in" "{0}" должен иметь тип значения.</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>Значение типа "{0}" нельзя использовать в качестве параметра по умолчанию для допускающего значение Null параметра "{1}", так как "{0}" не является простым типом</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>Использование значения типа "{0}" в качестве параметра по умолчанию недопустимо, так как отсутствуют стандартные методы преобразования в тип "{1}".</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>"{0}" является абстрактным, но содержится в классе "{1}", который не является абстрактным.</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>Модуль "{0}" в сборке "{1}" перенаправляет тип "{2}" в несколько сборок: "{3}" и "{4}".</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>После предупреждения #pragma ожидается отключение или восстановление</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>Значение SecurityAction "{0}" недопустимо для атрибутов безопасности, применяемых к типу или методу.</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>'{0}" является {1}, но используется как {2}.</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>Перед директивами препроцессору могут находиться только пробельные знаки.</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>поле</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>псевдоним using</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>Тип не реализует шаблон коллекции: член является статическим или закрытым</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>цифровые разделители</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>событие</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>Модификатор "{0}" недопустим для этого элемента.</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>В файле ключа "{0}" отсутствует закрытый ключ, необходимый для подписи.</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>надпись</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>Выражение __arglist может появляться только в вызове или в выражении new.</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>Алгоритм "{0}" не поддерживается</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>Метод должен иметь тип возвращаемого значения</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>параметр типа</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>Перечисления не могут содержать явные конструкторы без параметров</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>Недопустимое расположение атрибута для объявления</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Сбой шифрования при создании хэшей.</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>Этот метод можно использовать только для создания токенов — {0} не является видом токена.</value>
  </data>
  <data name="ERR_OverloadRefKind" xml:space="preserve">
    <value>"{0}" не может определять перегруженный {1}, который отличается только модификаторами параметров "{2}" и "{3}"</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>Имя "{0}" не существует в текущем контексте (возможно, отсутствует ссылка на сборку "{1}"?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>Ключевое слово "base" неприменимо в текущем контексте.</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>Невозможно использовать локальную переменную "{0}" перед ее объявлением.</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>Использование строки литерала "]]&gt;" в содержимом элемента не допускается.</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>'{0}": не может реализовывать динамический интерфейс "{1}".</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Недопустимый параметр для указанного неуправляемого типа.</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>Параметр /REFERENCEPATH</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>Дерево выражений не может содержать ссылку на локальную функцию</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>Поле имеет несколько различных константных значений.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} версии {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>© Корпорация Майкрософт (Microsoft Corporation). Все права защищены.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>Атрибут безопасности "{0}" не допускается для этого типа объявления. Атрибуты безопасности допустимы только в сборке, типе и объявлениях метода.</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>using static</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Доступ к члену "{0}", добавленному в ходе текущего сеанса отладки, возможен только из его объявляющей сборки "{1}".</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>Нельзя использовать #load после первого токена в файле</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>Дерево выражений не может содержать объявление переменной аргумента out.</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>Недопустимый тип для параметра {0} в атрибуте cref комментария XML: '{1}'</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа ограничения "{1}" ниже доступности "{0}"</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>"{0}" не может быть одновременно абстрактным и запечатанным.</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>Недопустимый символ "{0}".</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>'{0}" недопустимый именованный аргумент атрибута. Аргументы именованного атрибута должны быть полями без описателей readonly, static и const или открытыми нестатическими свойствами с доступом на чтение и запись.</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>Нераспознанная директива #pragma</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>Не удается объявить переменную статического типа "{0}"</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>Вы добавили ссылку на сборку с помощью /link (для свойства "Внедрять типы взаимодействия" задано значение true). Это сообщает компилятору, что следует внедрять сведения о типе взаимодействия из этой сборки. Однако компилятор не может внедрять сведения о типе взаимодействия из этой сборки, так как сборка, на которую указывает ссылка, также ссылается на сборку, использующую /reference (для свойства "Внедрять типы взаимодействия" задано значение false).

Чтобы внедрить сведения о типах взаимодействия в обе сборки, используйте /link для ссылок на каждую сборку (задайте для свойства "Внедрять типы взаимодействия" значение true).

Чтобы удалить предупреждение, можно использовать /reference (задайте для свойства "Внедрять типы взаимодействия" значение false). В этом случае основная сборка взаимодействия предоставит сведения о типе взаимодействия.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>метод доступа к свойству тела выражения</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>"{0}" определяет оператор "==" или оператор "!=", но не переопределяет Object.Equals(object o).</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Неверное число аргументов типа</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>"{0}" не реализует шаблон "{1}". "{2}" имеет неправильную сигнатуру.</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>Объявление пространства имен не может содержать модификаторы или атрибуты.</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>'{0}": типы полей экземпляров, помеченные StructLayout(LayoutKind.Explicit), должны иметь атрибут FieldOffset.</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>Не удается создать экземпляр абстрактного класса или интерфейса "{0}".</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>Явная реализация интерфейса события должна использовать синтаксис метода доступа к событиям.</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>При оценке постоянного значения для "{0}" используется циклическое определение.</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>"{0}" недопустимое место атрибута для этого объявления. Для этого объявления допускаются следующие места атрибутов: "{1}". Все атрибуты этого блока будут проигнорированы.</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>"{0}" неоднозначен между "{1}" и "{2}"; используйте либо "@{0}", либо "{0}Attribute".</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>Требуется ";".</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>Может произойти сбой динамически отправляемого вызова во время выполнения, так как одна или несколько применимых перегрузок являются условными методами</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>Пространство имен конфликтует с импортированным типом</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>Разделяемый метод не может иметь несколько реализующих объявлений.</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>Невозможно вернуть "{0}" как значение ref или out, так как это "{1}"</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>Дружественный доступ предоставлен "{0}", однако состояние подписи строгого имени выходной сборки не соответствует состоянию предоставляющей сборки.</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>Ограничение не может быть динамическим типом "{0}".</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>Оператор "{0}" невозможно применить к операнду типа "{1}".</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>"{0}": ссылка на временное поле не будет считаться временной.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>Дерево выражения не может содержать динамическую операцию. </value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>Неявно типизированная локальная переменная не может быть фиксированной.</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>Недопустимый импортированный тип "{0}". Он содержит циклическую зависимость базового класса.</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>Обнаружены повторные реализации шаблона запроса для исходного типа "{0}".  Неоднозначный вызов "{1}".</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>Переключатель командной строки "{0}" еще не реализован и был пропущен.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>Метод, оператор или метод доступа "{0}" помечен как внешний и не имеет атрибутов. Для указания на внешнюю реализацию, возможно, следует добавить атрибут DllImport.</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности индексатора "{0}"</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>свойство, воплощающее выражение</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>Для полей static и const атрибут FieldOffset не разрешен.</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>Невозможно использовать локальную переменную ref "{0}" внутри анонимного метода, лямбда-выражения или выражения запроса</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>Оператор "{0}" для операнда типа "{1}" и "{2}" является неоднозначным.</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>Тип возвращаемого значения "{0}" несовместим с CLS.</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>Предполагается, что ссылка на сборку совпадает с удостоверением</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>'{0}" не содержит определения для "{1}", и не удалось найти метод расширения "{1}", принимающий тип "{0}" в качестве первого аргумента (возможно, пропущена директива using для "{2}").</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>Не указан открытый ключ, необходимый для отложенной подписи.</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>Выражение всегда будет вызывать System.NullReferenceException, поскольку значение "{0}" по умолчанию равно Null.</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>Индексаторы должны иметь хотя бы один параметр.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>Использование "{0}" для проверки совместимости с "{1}" равнозначно проверке совместимости с "{2}" и проходит успешно для всех значений, кроме значений Null</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>Требуется значение целочисленного типа.</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>Эта возможность языка ("{0}") еще не реализована.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>Дерево синтаксиса должно быть создано из отправки.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>Полное имя слишком длинное для сведений об отладке</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>Значение для RuntimeMetadataVersion не обнаружено. Не обнаружена также сборка, содержащая System.Object, или значение для RuntimeMetadataVersion не определено параметрами.</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>Интерфейс, помеченный как CoClassAttribute, не помечен как ComImportAttribute</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>Выделенный экземпляр освобождается не во всех путях исключений</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>Требуется "in"</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>Ошибка в связанной сборке "{0}".</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>Имя элемента кортежа "{0}" не допускается ни в одной позиции.</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>Индексирование массива с отрицательным индексом (индексы массива всегда начинаются с нуля)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>Атрибут CLSCompliant не применяется к возвращаемым типам. Попробуйте разместить его в методе.</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>'{0}", определенный для метода Main, должен быть действительным неуниверсальным классом или структурой</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел. {1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>Проверка совместимости с CLS не будет выполнена, так как она не видима за пределами этой сборки</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>Несовместимые ограничения для параметров типа "{1}" в разделяемых объявлениях "{0}".</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>Не удалось найти "{0}", определенного для метода Main.</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>Использование поля класса с маршалингом по ссылке в виде значения ref или out или получение его адреса может вызвать исключение времени выполнения</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>"{0}": невозможно использовать модификаторы доступа в методах доступа в интерфейсе.</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>Отсутствует аргумент, соответствующий требуемому формальному параметру "{0}" из "{1}".</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>Указанный тип исходного кода не поддерживается или недопустим: "{0}"</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>Не удалось указать значение по умолчанию для массива параметров.</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>Назначение выполнено для той же переменной</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>Недопустимое имя символа предварительной обработки. "{0}" не является допустимым идентификатором.</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>"{0}" не в состоянии реализовать ни "{1}", ни "{2}", так как они могут быть идентичными для некоторых подстановок параметров типа.</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>Тип "{0}", отправленный в сборку "{1}", конфликтует с типом "{2}", экспортированным из модуля "{3}".</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть типом значения, не допускающим значения Null.</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>Метод содержит неправильную подпись и не может быть точкой входа</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>Повторяющийся модификатор "{0}"</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>контравариантно</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>После спецификатора verbatim (@) требуется ключевое слово, идентификатор или строка.</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>В явной реализации интерфейса "{0}" отсутствует метод доступа "{1}".</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}" должен быть неабстрактным типом и иметь открытый конструктор без параметров, чтобы использовать его в качестве параметра "{1}" в универсальном типе или методе "{0}".</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>'{0}": вмещающий тип не реализует интерфейс "{1}".</value>
  </data>
  <data name="ERR_RefStructInterfaceImpl" xml:space="preserve">
    <value>"{0}": ссылочные структуры не могут реализовывать интерфейсы</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>Не удалось найти реализацию шаблона запроса для исходного типа "{0}".  "{1}" не найден.  Возможно, не хватает ссылки на "System.Core.dll" или директивы using для "System.Linq".</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>Определяемые пользователем операторы не могут возвращать значения типа void.</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>двоичные литералы</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>Невозможно создать массив с отрицательным размером.</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>статические классы</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>Внутри анонимного метода или лямбда-выражения нельзя использовать оператор yield.</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>Не удается внедрить тип "{0}", так как он имеет универсальный аргумент. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>Файл с исходным текстом программы превысил установленный в PDB-файле предел в 16 707 565 строк; отладочная информация будет неправильной</value>
  </data>
  <data name="IDS_FeatureRefStructs" xml:space="preserve">
    <value>ссылочные структуры</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>Автоматически реализованные в интерфейсах свойства не могут иметь инициализаторы.</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>"{0}" не реализует член интерфейса "{1}". "{2}" не открытый.</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>"{1}" не определяет параметр типа "{0}"</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>Оператор typeof не может использоваться для динамического типа.</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>Операндом оператора инкремента или декремента должна быть переменная, свойство или индексатор.</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>Параметр /embed поддерживается только при создании PDB-файла.</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>"{0}" не может одновременно внешним и абстрактным.</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>Требуется объект с типом, приводимым к "{0}".</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>Не удается создать экземпляр статического класса "{0}".</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>"{0}" скрывает наследуемый член "{1}". Если скрытие было намеренным, используйте ключевое слово new.</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Недопустимый символ Юникода.</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>Лямбда-выражения, возвращающие данные по ссылке, невозможно преобразовать в деревья выражений</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>Невозможно определить класс или элемент, использующий кортежи, так как не удалось найти необходимый тип компилятора ({0}). Отсутствует ссылка?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Ошибка при подписи выхода открытым ключом из файла "{0}" — {1}.</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>"{0}": невозможно одновременно задать класс ограничения и ограничения "class" или "struct".</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>Директива "using static" может применяться только к типам; "{0}" является пространством имен, а не типом. Используйте директиву "using namespace"</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>Не удается использовать лямбда-выражение в качестве аргумента для динамически отправляемой операции без предварительного преобразования его в делегат или тип дерева выражения.</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>Возвращаемые по значению данные можно использовать только в методах, которые возвращают данные по значению</value>
  </data>
  <data name="ERR_EscapeStackAlloc" xml:space="preserve">
    <value>Результат выражения stackalloc типа "{0}" нельзя использовать в этом контексте, так как он может быть доступен вне содержащего метода.</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>В качестве аргумента для атрибута TypeForwardedTo указан недопустимый тип.</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>Не удается создать делегат с "{0}", так как он или метод, который он переопределяет, имеет атрибут Conditional.</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>Использование литерала по умолчанию недопустимо в этом контексте.</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}". Существует явное преобразование (возможно, пропущено приведение типов).</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>Экземпляр анализатора {0} невозможно создать из {1} : {2}"</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>Директива Using уже использовалась в этом пространстве имен</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>Комментарий XML содержит атрибут cref, который не удалось разрешить</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>Невозможно явным образом добавить ссылку на "System.Runtime.CompilerServices.TupleElementNamesAttribute". Используйте синтаксис кортежа для определения имен кортежа.</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>Выражение фильтра является константой</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>Недопустимое число</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>Делегат "{0}" не принимает аргументы {1}.</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>'{0}" скрывает наследуемый абстрактный член "{1}".</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>Повторяющийся параметр типа "{0}"</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>Событие в интерфейсе не может иметь методы доступа add и remove.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>Рекомендуемый перегружаемый метод Add для элемента инициализатора коллекции устарел</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>Для "{0}" даны разные контрольные суммы.</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>'{0}": событие должно иметь тип делегата.</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>Требуется выражение после оператора yield return.</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>Параметр /sourcelink поддерживается только при создании данных формата PDB.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>Первым аргументом атрибута безопасности должен быть допустимый SecurityAction.</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>Контекстное ключевое слово "var" не может быть использовано в объявлении переменной диапазона.</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>Недопустимый внешний псевдоним для /reference; "{0}" является недопустимым идентификатором.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>Член скрывает унаследованный член: отсутствует ключевое слово переопределения</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>Атрибут FieldOffset может назначаться только членам типов, для которых используется StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит повторяющийся тег параметра</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>тип</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>'{0}": нельзя использовать статические типы в качестве аргументов типов.</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>Выражение Throw в данном контексте запрещено.</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>Применение атрибута CallerLineNumberAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>Требуется перегружаемый бинарный оператор.</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>Нет подходящего типа для неявно типизированного массива.</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>В этом месте пробел не допускается.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>За XML-комментарием не следует допустимый элемент языка</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>stackalloc не может использоваться вместе с отрицательным размером.</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>Ошибка в синтаксисе командной строки: Отсутствует "{0}" для параметра "{1}".</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>Указатели и буферы фиксированного размера можно использовать только в небезопасном контексте.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>Перегруженный метод, отличающийся только типами неименованных массивов, несовместим с CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>Ошибка при сборке ресурсов Win32 — {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>В деревьях выражений не могут использоваться разделяемые методы, имеющие только определяющее объявление или только удаленные условные методы.</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>Имя элемента кортежа "{0}" является выведенным. Для обращения к элементу по выведенному имени используйте версию языка {1} или более позднюю.</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>Возможно, непреднамеренное сравнение ссылок; для получения сравнения значений приведите правую часть к типу "{0}".</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит повторяющийся тег параметра типа</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>Сборка "{0}" с удостоверением "{1}" использует "{2}" с более высокой версией, чем у сборки "{3}" с удостоверением "{4}", на которую делается ссылка.</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>Неуниверсальный {1} "{0}" нельзя использовать с аргументами типа.</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>Имя сборки "{0}" зарезервировано и не может использоваться как ссылка в интерактивном сеансе.</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>Тип определяет оператор == или оператор !=, но не переопределяет Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>'{0}": тип должен быть "{2}", чтобы соответствовать переопределенному члену "{1}".</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>Побитовый оператор "ИЛИ" применен к операнду, расширенному знаком; рекомендуется предварительное приведение к меньшему беззнаковому типу</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>Невозможно использовать буферы фиксированного размера в нефиксированных выражениях. Попробуйте использовать оператор fixed.</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>Невозможно получить адрес указанного выражения.</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>Дерево выражения не может содержать "{0}".</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>Не удалось указать значение параметра по умолчанию вместе с DefaultParameterAttribute или OptionalAttribute.</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>Для типа "{0}" не найден подходящий экземпляр деконструкции или метод расширения с типом возвращаемого значения void и следующим числом параметров out: {1}.</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>Метод расширения должен быть определен в неуниверсальном статическом классе.</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>"{0}" является типом "{1}". Константное поле ссылочного типа, отличного от string, может инициализироваться только значением Null.</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>Ограничение "new()" невозможно использовать вместе с ограничением "struct".</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>Недопустимо использовать __arglist в списке параметров асинхронного метода.</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>Не используйте "System.Runtime.CompilerServices.ExtensionAttribute". Используйте вместо этого ключевое слово "this".</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>Требуется функция доступа add или remove.</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>Невозможно передать управление из тела анонимного метода или лямбда-выражения.</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>Устаревший член переопределяет неустаревший член</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>Все другие ограничения должны следовать после ограничения типа класса "{0}".</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>"{0}" должен соответствовать возвращаемому по ссылке типу переопределенного члена "{1}"</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>Атрибут CallerFilePathAttribute не будет работать: он переопределяется атрибутом CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>Группы метода выражения недопустимо использовать в качестве аргумента для nameof.</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>Невозможно инициализировать ссылкой переменную по значению</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>'{0}" не содержит определения для "{1}" и не удалось найти метод расширения "{1}", принимающий тип "{0}" в качестве первого аргумента (возможно, пропущена директива using или ссылка на сборку).</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} "{0}" нельзя использовать с аргументами типа</value>
  </data>
  <data name="ERR_EscapeLocal" xml:space="preserve">
    <value>Локальный "{0}" нельзя использовать в этом контексте, так как из-за этого переменные, на которые имеются ссылки, могут стать доступными за пределами их области объявления.</value>
  </data>
  <data name="ERR_EscapeOther" xml:space="preserve">
    <value>Выражение нельзя использовать в этом контексте, так как из-за этого переменные могут стать косвенно доступными за пределами их области объявления.</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>Разделяемый метод не может иметь несколько определяющих объявлений.</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>Ссылка сборки "{0}" является недопустимой и не может быть разрешена.</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>Статические классы не могут иметь конструкторы экземпляров.</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>Для применения оператора "await" у типа {0} должен быть подходящий метод GetAwaiter.</value>
  </data>
  <data name="ERR_EscapeCall2" xml:space="preserve">
    <value>Элемент результата "{0}" нельзя использовать в этом контексте, так как из-за этого переменные, на которые ссылается параметр "{1}", могут стать доступными за пределами их области объявления.</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>Тип "{1}" уже резервирует член "{0}" с такими же типами параметров.</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>Тип аргумента несовместим с CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>Нераспознанная escape-последовательность</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>Параметр не имеет соответствующий тег параметра в комментарии XML (в отличие от остальных параметров)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>Наследуемый интерфейс "{1}" образует циклическую ссылку в иерархии интерфейсов для "{0}".</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>Не удалось найти тип или имя пространства имен "{0}" в глобальном пространстве имен (возможно, отсутствует ссылка на сборку?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>Невозможное ожидание в выражении фильтра предложения catch.</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>Назначение типов массивов разрешено только через выражения инициализации массивов. Используйте выражение с оператором new.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>Неявно типизированные переменные должны быть инициализированы</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>Объявление параметра-типа должно быть идентификатором, а не типом.</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>"{0}": новый защищенный член объявлен в структуре.</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>"{0}": статические классы не могут содержать защищенные члены.</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>'{0}": нельзя объявлять члены экземпляра в статическом классе.</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Исполняемые файлы не могут быть вспомогательными сборками; язык и региональные параметры должны быть пустыми.</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>Использование ключевого слова "base" в этом контексте не допускается.</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>Тип "{0}" определен в сборке, на которую нет ссылки. Следует добавить ссылку на сборку "{1}".</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>'{0}" добавляет метод доступа, не обнаруженный в члене интерфейса "{1}".</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>Нераспознанный параметр: "{0}"</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>Не допускается использование асинхронных методов в интерфейсе, классе или структуре с атрибутом "SecurityCritical" или "SecuritySafeCritical".</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>Первый операнд операторов "is" или "as" не может быть лямбда-выражением, анонимным методом или группой методов.</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>Возможно, для доступа к массиву отсутствует спецификатор именованного аргумента.</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>Не удается использовать группу методов в качестве аргумента для динамически отправляемой операции. Предполагалось вызывать этот метод?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>Доступное только для чтения поле можно использовать как значение ref или out только в конструкторе</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>Вызван GetDeclarationName для узла объявления, в котором возможно содержится несколько операторов объявления переменных.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>Эта ошибка происходит, если перегруженный метод получает массив массивов, и единственное отличие между подписями методов — тип элементов массива. Чтобы избежать этой ошибки, рассмотрите возможность использования прямоугольного массива вместо массива массивов; используйте дополнительный параметр, чтобы разрешить неоднозначность вызова функции, переименуйте один или несколько перегруженных методов или, если совместимость с CLS не требуется, удалите атрибут CLSCompliantAttribute.</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>Имена элементов кортежа в сигнатуре метода "{0}" должны совпадать с именами элементов кортежа в методе интерфейса "{1}" (включая тип возвращаемого значения).</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>Повторяющийся атрибут "{0}" в "{1}"</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>асинхронная функция</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Недопустимый формат отладочной информации: {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>Предполагалось использовать метку параметра по умолчанию ("default:") вместо "case default:"? Если вы намерены использовать литерал по умолчанию, рекомендуется использовать "case (default):" или другой литерал ("case 0:" или "case null:") соответствующим образом.</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>У асинхронных методов не может быть небезопасных параметров или возвращаемых типов.</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>Член переопределяет устаревший член</value>
  </data>
  <data name="ERR_AssignReadonlyNotField" xml:space="preserve">
    <value>Не удается присвоить значение {0} "{1}", так как это переменная только для чтения</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>Асинхронные методы не могут иметь локальных переменных по ссылке</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>Инициализаторы могут иметь только автоматически реализованные свойства.</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>Невозможно создать короткое имя файла "{0}", если уже существует длинное имя файла, содержащее это короткое имя.</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#warning: "{0}'</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>Статический член "{0}" не может быть помечен как override, virtual или abstract.</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>Левая часть выражения присваивания должна быть переменной, свойством или индексатором.</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>Член "{0}", помеченный как override, не может быть помечен как new или virtual.</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>Оба объявления частичного метода, "{0}" и "{1}", должны использовать одинаковые имена элементов кортежа.</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>Члены структуры не могут возвращать по ссылке члены экземпляра this или другого экземпляра</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>"{0}": не все ветви кода возвращают значение.</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>Метка case оператора switch уже обработана предыдущей меткой case.</value>
  </data>
  <data name="ERR_EscapeCall" xml:space="preserve">
    <value>Результат "{0}" нельзя использовать в этом контексте, так как из-за этого переменные, на которые ссылается параметр "{1}", могут стать доступными за пределами их области объявления.</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>Не удается переадресовать тип "{0}", так как он является вложенным типом "{1}".</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>Требуется однострочный комментарий или признак конца строки.</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>Ограничение не может быть динамическим типом.</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>До передачи управления из текущего метода параметру, помеченному ключевым словом out, "{0}" должно быть присвоено значение.</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>Недопустимое имя символа предварительной обработки; недопустимый идентификатор</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>Суффикс "l" легко спутать с цифрой "1" -- для ясности используйте "L"</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>'{0}" в явном объявлении интерфейса не является интерфейсом.</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>'{0}": невозможно переопределение "{1}", так как такая операция в данном языке не поддерживается.</value>
  </data>
  <data name="ERR_BadParameterModifiers" xml:space="preserve">
    <value> Модификатор параметра "{0}" не может использоваться с "{1}"</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>Невызываемый член "{0}" не может использоваться как метод.</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>Значения ref или out должно быть переменной, которой можно присвоить значение</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>Чтобы выполнить минимальную квалификацию типа, необходимо использовать SyntaxTreeSemanticModel.</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>Тип "{0}" определен в модуле, который еще не был добавлен. Необходимо добавить модуль "{1}".</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>Пространство имен "{1}" в "{0}" конфликтует с типом "{3}" в "{2}".</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>"{0}": статический конструктор не должен иметь параметров.</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>Выходной параметр не может иметь атрибут In.</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>группа методов</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>Поле никогда не назначается и всегда будет иметь значение по умолчанию</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>Метод "{0}" имеет параметр с модификатором "this", не являющийся первым параметром метода.</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>Не допускается использование знаков кавычек в кодировке, отличной от ASCII, до и после литералов строки.</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>Для ссылки "base" требуется базовый класс.</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>Непредвиденная директива препроцессору.</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>Проверка на соответствие CLS не будет выполнена для "{0}", поскольку он не видим за пределами данной сборки.</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>'{0}": невозможно переопределить, так как "{1}" не является свойством.</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>Выражение типа "{0}" не может быть обработано шаблоном типа "{1}" в C# {2}. Используйте версию языка {3} или более позднюю.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>Переменной "{0}" присвоено значение, но оно ни разу не использовано.</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>Имя элемента кортежа "{0}" допускается только в позиции {1}.</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>Несколько модификаторов защиты.</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>В комментарии XML имеется атрибут cref "{0}" с неверным синтаксисом.</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>'{0}' не поддерживается данным языком.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит тег paramref, но параметр с таким именем не существует</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>Оператор await можно использовать только в методах с модификатором async. Попробуйте пометить этот метод модификатором async и изменить тип его возвращаемого значения на Task.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>Невозможно обновить "{0}"; нет атрибута "{1}".</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>"{0}": новый защищенный член объявлен в запечатанном классе</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>Управление не может передаваться вниз от одной метки case ("{0}") к другой.</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>Не удается преобразовать {0} к типу "{1}", так как он не является типом делегата.</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>Лямбда-выражение с телом оператора не может быть преобразовано в дерево выражения.</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Компилятор Microsoft (R) Visual C#</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>Не удается преобразовать тип "{0}" в "{1}" с помощью преобразования ссылок, упаковки-преобразования, распаковки-преобразования, преобразования в оболочку или преобразования типа Null</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>Указатель должен быть проиндексирован только по одному значению.</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>Недопустимый номер предупреждения</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>возвращаемые данные и локальные переменные типа ByRef</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>Нельзя передать аргумент динамического типа в параметр params "{0}" локальной функции "{1}".</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>Внедренный метод взаимодействия "{0}" содержит тело.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод Add "{0}" для элемента инициализатора набора устарел.</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>динамический</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>Невозможно использовать локальную переменную "{0}" перед ее объявлением. Объявление данной локальной переменной скрыто в поле "{1}".</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>Невозможно определить символы препроцессора или отменить их определение где-либо, кроме начала файла.</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>Параметры компиляции "{0}" и "{1}" невозможно использовать одновременно.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Атрибут CallerMemberNameAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>Переполнение при выполнении операции во время компиляции в режиме проверки.</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>квалификатор псевдонима пространства имен</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>Оператор throw без аргументов не может использоваться вне предложения catch.</value>
  </data>
  <data name="ERR_BadSpecialByRefIterator" xml:space="preserve">
    <value>Оператор foreach нельзя использовать с перечислителями типа "{0}" в методах с модификатором Async или Iterator, так как "{0}" является ссылочной структурой.</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>Событие "{0}" никогда не используется.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>За XML-комментарием не следует допустимый элемент языка</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Ошибка при записи в XML-файл документации: {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>универсальные типы</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>"Интерфейс "{0}" помечен с помощью "CoClassAttribute" и не помечен с помощью "ComImportAttribute".</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>Невозможно использовать поля "{0}" как значение ref или out, так как это "{1}"</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>Использование автоматически реализованного свойства "{0}", которому, возможно, не присвоено значение</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>Поле "{0}" никогда не используется.</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>Отсутствует ссылка на эту метку.</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>'{0}" повторяющийся именованный аргумент атрибута</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>Не удается сделать ссылку на переменную типа "{0}".</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>Оператор await можно использовать, только если он содержится в методе или лямбда-выражении, помеченном модификатором async.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>Дерево выражений не может содержать литерал кортежа.</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>Выполнено сравнение с той же переменной</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>Невозможно использовать литерал по умолчанию как аргумент для динамически отправляемой операции.</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>Выражения, инициализирующие коллекцию и объект, не могут быть применены к выражению создания делегата</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>Комментарий XML имеет повторяющийся тег для "{0}".</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>'{0}": не разрешено пользовательское преобразование в производный класс или из производного класса.</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>'{0}" не является допустимым описателем формата.</value>
  </data>
  <data name="ERR_RefConditionalAndAwait" xml:space="preserve">
    <value>await не может использоваться в выражении, содержащем условный оператор ref</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>Сборка с аналогичным простым именем "{0}" уже была импортирована. Попробуйте удалить одну из ссылок (например "{1}") или подпишите их для параллельного использования.</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>Оператор "await" невозможно использовать в инициализаторе статической переменной скрипта.</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>Не удается наследовать интерфейс "{0}" с указанными параметрами типов, так как из-за этого метод "{1}" содержит перегрузки, различающиеся только параметрами ref и out.</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>Имя "{0}" находится вне области левой части конструкции "equals".  Возможно, требуется поменять местами выражения с обеих сторон "equals".</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>Невозможно применить CallerFilePathAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>Идентификатор "{0}", отличающийся только регистром, несовместим с CLS.</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа свойства "{1}" ниже доступности свойства "{0}"</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>Ошибка при открытии файла ресурсов Win32 "{0}" — "{1}"</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>Пустой спецификатор формата.</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>Битовая операция или оператор, использовавшийся в операнде с расширением знака</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>Результат значения всегда одинаковый, так как значение этого типа никогда не равно NULL</value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>Сбой при доступе к прозрачному члену идентификатора для поля "{0}" из "{1}".  Запрашиваемые данные реализуют шаблон запроса?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>Невозможно применить CallerLineNumberAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>"внешний псевдоним" недопустим в этом контексте.</value>
  </data>
  <data name="ERR_RefConditionalNeedsTwoRefs" xml:space="preserve">
    <value>Либо оба значения ссылочного оператора должны быть ссылочными, либо ни одно из них не должно быть ссылочным</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>Не удается внедрить тип "{0}", так как он является вложенным. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>Невозможно задать аргумент CLSCompliant в модуле, который отличается от атрибута CLSCompliant в сборке.</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}. См. также ошибку CS{1}.</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>Недопустимый базовый тип.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>Имя типа "{0}" не существует в типе "{1}".</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value>Не обнаружено элементов, соответствующих тегу include. </value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>Тип переопределяет Object.Equals(object o), но не переопределяет Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>Значение "goto case" не может быть неявно преобразовано в тип switch</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>Указан параметр компилятора /doc, но одна или несколько конструкций не содержат комментарии.</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>'{0}": невозможно переопределить наследуемый член "{1}", так как он не помечен как virtual, abstract или override.</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>Повторяющееся имя параметра "{0}".</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>"{0}": модификаторы доступа для статических конструкторов не разрешены.</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>Неожиданное использование несвязанного универсального имени.</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>Метод доступа "{0}" не может реализовать член интерфейса "{1}" для типа "{2}". Используйте явную реализацию интерфейса.</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>Разделяемый метод должен быть либо оба раза объявлен как метод расширения, либо нигде не объявлен как метод расширения.</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Требуется catch или finally.</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>В выражении new после типа требуется "()", []" или "{}".</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>Переменная объявлена, но не используется</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>Обнаружен признак конца файла, требуется "*/".</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>Не удается создать ссылку на компиляцию типа "{0}" из компиляции {1}.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>"{0}" скрывает наследуемый член "{1}". Чтобы текущий член переопределял эту реализацию, добавьте ключевое слово override. В противном случае добавьте ключевое слово new.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>'{0}" не реализует член интерфейса "{1}". '{2}" не может реализовать член интерфейса, потому что он не является открытым.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>Требуется {0} SemanticModel.</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>оператор по умолчанию</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>Объявления исходящих переменных и переменных шаблонов недопустимы в предложении запроса.</value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>Значение типа void нельзя назначить.</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>литерал по умолчанию</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>Выражение типа "{0}" не может быть обработано шаблоном типа "{1}".</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>Заданы несовместимые параметры: файл ресурсов Win32; значок Win32.</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>Атрибут пропускается при указании общедоступного подписывания.</value>
  </data>
  <data name="ERR_TypeReserved" xml:space="preserve">
    <value>Имя типа "{0}" зарезервировано для использования компилятором.</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>Имя "{0}" находится вне области правой части конструкции "equals".  Возможно, требуется поменять местами выражения с обеих сторон "equals".</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>"{0}": невозможно изменить имена элементов кортежа при переопределении наследуемого элемента "{1}"</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>Общая длина пользовательских строк, используемых программой, превышает допустимый предел. Попробуйте сократить использование строковых литералов.</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>Требуется "{"</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>Суффикс l легко спутать с цифрой 1</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>Непредвиденный символ в этом месте.</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>Ожидался "&gt;" или " /&gt;" для закрытия тега "{0}".</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>Параметр типа не имеет соответствующий тег параметра типа в комментарии XML (в отличие от остальных параметров)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>Определение псевдонима с именем "global" не рекомендуется из-за того, что "global::" всегда указывает на глобальное пространство имен и не является псевдонимом.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>Применение атрибута CallerMemberNameAttribute к параметру "{0}" ни к чему не приводит, поскольку атрибут применяется к члену, который используется в контекстах, запрещающих необязательные аргументы.</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>Параметр конструктора атрибута "{0}" имеет тип "{1}", который является недопустимым типом параметра атрибута.</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>Недопустимый модификатор изменения. В качестве варианта допускается указывать только параметры типа интерфейса и делегата.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>Перегруженный метод, отличающийся только в параметре ref или out или в ранге массива, несовместим с CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>"{0}": изменяемое поле не может быть типа "{1}"</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>В выражении stackalloc после типа требуется [].</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>Неверное определение члена анонимного типа. Члены анонимного типа должны быть объявлены присваиванием члена, простым именем или доступом к члену.</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>Кортеж не может содержать значение типа void.</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>Не удается задать только атрибут Out для параметра ref. Используйте атрибуты In и Out вместе или ни одно из их.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>Исходный файл "{0}" задан несколько раз.</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>Членам свойства "{0}" типа "{1}" не могут быть присвоены значения с помощью инициализатора объекта, так как они имеют тип значения</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>"{0}": структуры не могут вызывать конструкторы базового класса.</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>Тип не реализует шаблон коллекции: члены неоднозначны</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>stackalloc не может использоваться в блоке catch или в блоке finally.</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>Ожидался литерал строки, однако знак открывающих кавычек обнаружен не был.</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>'{0}" не может одновременно быть внешним и объявлять тело.</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>Недопустимое выражение препроцессора.</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>Ключевое слово "this" неприменимо в текущем контексте.</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>SyntaxTree "{0}" получено из директивы #load и не может быть удалено или перемещено непосредственным образом.</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>Нераспознанная директива #pragma</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>Анонимный тип не может иметь несколько свойств с одинаковыми именами.</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>Имя "{0}" превышает максимальную длину, допустимую в метаданных.</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>Невозможно использовать директиву "using static" для объявления псевдонима</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>Проведено присвоение той же переменной; действительно выполнить такое назначение, а не иное?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>Событие не используется</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>Событие "{0}" может находиться только в левой части операции += или -=</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> Недопустимый тег Include </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>Метод передачи типа для типа "{0}" в сборке "{1}" приводит к циклу.</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>Тип "{0}" уже содержит определение для "{1}".</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>Дерево выражения не может содержать вызов, для которого используются необязательные аргументы.</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>Не удалось открыть файл метаданных "{0}" — {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>Операция сравнения со значением Null типа "{0}" всегда возвращает False.</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>модуль как спецификатор конечного объекта атрибута</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>Это предупреждение может быть создано, если два метода интерфейса различаются только по тому, помечен ли конкретный параметр как ref или как out. Рекомендуется изменить код, чтобы избежать этого предупреждения, так как неочевидно, какой метод вызывается во время выполнения, и вызов нужного метода не гарантируется.

Хотя C# разделяет параметры out и ref, спецификация CLR не видит отличий и выбирает случайный метод, реализующий интерфейс.

Предоставьте компилятору способ различения методов. Например, можно дать им разные имена или указать дополнительный параметр в одном из них.</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>Нельзя использовать #r после первой лексемы в файле.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>'{0}" не реализует член интерфейса "{1}". '{2}" не может реализовать член интерфейса, потому что он является статическим.</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>Невозможно инициализировать значением переменную по ссылке</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>именованный аргумент</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>Предопределенный тип "{0}" определен в нескольких сборках в глобальном псевдониме; используется описание из "{1}"</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>Дерево лямбда-выражения не может содержать вызов метода, свойства или индексатора, который возвращает данные по ссылке</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>Разделяемый метод не может иметь модификаторы доступа или модификаторы virtual, abstract, override, new, sealed или extern.</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>Отсутствует знак равенства между атрибутом и его значением.</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>Невозможно деконструировать кортеж элементов "{0}" на переменные "{1}".</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>"{0}" не реализует наследуемый абстрактный член "{1}".</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>Не удается создать экземпляр переменной типа "{0}", так как у нее отсутствуют ограничения new().</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>Не удается получить тип "{0}", так как инициализатор прямо или косвенно ссылается на определение.</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>#load допускается только в скриптах</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>Перегруженный метод "{0}", отличающий только типами массивов без имен, несовместим с CLS.</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>Все другие ограничения должны следовать после ограничения "class" или "struct".</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>Аргументом атрибута должно быть константное выражение, выражение typeof или выражение создания массива того же типа, что и параметр атрибута.</value>
  </data>
  <data name="IDS_FeatureReadOnlyStructs" xml:space="preserve">
    <value>структуры только для чтения</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;выражение throw&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>разделяемые типы</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>Универсальный параметр является определением, а ожидается, что он будет ссылкой {0}.</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>Синтаксис "var (...)" как lvalue зарезервирован.</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>Параметр /noconfig пропущен, т. к. он задан в файле ответов</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>Недопустимый операнд для сопоставления с шаблоном. Требуется значение, но найдено "{0}".</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>"{0}": свойство или индексатор не могут иметь тип void.</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>'{0}": невозможно переопределить наследуемый член "{1}", так как он запечатан.</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>Итераторы не могут иметь параметры с ключевым словом ref или out.</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>У индексированного свойства "{0}" все аргументы должны быть необязательными</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>Несовместимое использование лямбда-параметра; типы параметров должны быть либо все явными, либо все неявными.</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>Не удалось загрузить сборку анализатора</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>Невозможно определить тип неявно типизированной отмены.</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>Тип "{0}" в списке интерфейсов не является интерфейсом.</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>элемент</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>Параметр __arglist должен быть указан последним в списке формальных параметров.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>Дерево выражений не может содержать оператор соответствия шаблону is.</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>Атрибуты запрещены для параметров локальной функции и параметров типа</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>Неоднозначные пользовательские преобразования "{0}" и "{1}" при преобразовании из "{2}" в "{3}".</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>Не удается внедрить тип взаимодействия "{0}". Используйте вместо него доступный интерфейс.</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>Выражение должно иметь тип "{0}", так как ему назначается значение по ссылке</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>Сборка не содержит анализаторов</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>Индексация массива с отрицательным индексом</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>Свойства, возвращающие данные по ссылке, не могут иметь методы доступа set</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>Ошибка в синтаксисе командной строки: Отсутствует ":&lt;номер&gt;" для параметра "{0}".</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>Ссылка на тип "{0}" требует его определения в "{1}", но его не удалось найти.</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>Возможно, неправильное назначение локальной переменной "{0}", которая является аргументом оператора using или lock. Вызов Dispose или разблокирование произойдет на ее оригинальном значении.</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>Кортеж со следующим числом элементов: {0} невозможно преобразовать в тип "{1}".</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>Символ "&lt;" нельзя использовать в значении атрибута.</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>Неверный синтаксис #pragma checksum; должно быть #pragma checksum "имя файла" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>инвариантно</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>"{0}" предназначен только для оценки и может быть изменен или удален в будущих обновлениях.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>Позиция не находится в пределах синтаксического дерева с полным диапазоном {0}.</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>Не удается определить новый метод расширения, так как не найден требуемый компилятором тип "{0}". Возможно, отсутствует ссылка на System.Core.dll</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>Для использования в качестве логического оператора краткой записи пользовательский логический оператор ("{0}") должен иметь такой же возвращаемый тип и типы параметров.</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>Сравнение выполнено с той же переменной. Действительно следует выполнять такое сравнение?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>Идентификатор, отличающийся только регистром, несовместим с CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>Недопустимый реальный литерал.</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>Получить адрес фиксированного выражения с помощью оператора fixed невозможно.</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>"{0}" не имеет доступных конструкторов, которые используют совместимые с CLS типы.</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>Ошибка при вычислении выражения десятичной константы.</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>Повторяющаяся метка "{0}".</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения полю допускается только в конструкторе и в инициализаторе переменных.</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>Псевдоним using "{0}" ранее встречался в этом пространстве имен.</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>Аргумент {0} должен передаваться с ключевым словом "{1}".</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>Недопустимое значение именованного аргумента атрибута "{0}".</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>Повторяющееся ограничение "{0}" для параметра типа "{1}".</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>Членам поля только для чтения "{0}" типа "{1}" не могут быть присвоены значения с помощью инициализатора объекта, так как они имеют тип значения.</value>
  </data>
  <data name="ERR_FieldlikeEventsInRoStruct" xml:space="preserve">
    <value>Подобные полям события не допускаются в структурах только для чтения.</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>Модификатор "async" можно использовать только в методах, имеющих тело.</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>Разделяемые объявления "{0}" не должны указывать различные базовые классы.</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>'{0}" недоступен из-за его уровня защиты.</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>Наследуемые члены "{0}" и "{1}" имеют одинаковую сигнатуру в типе "{2}", поэтому их нельзя переопределить.</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>Не удается выполнить требуемую для доступа к индексатору динамическую отправку, поскольку он является частью базового выражения доступа. Попробуйте привести типы динамических аргументов или исключить доступ к базовым членам.</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>'{0}" не имеет применимого метода с именем "{1}", но, по-видимому, имеет метод расширения с таким именем. Методы расширения не могут отправляться динамически. Попробуйте привести динамические аргументы или вызвать метод расширения без использования синтаксиса метода расширения.</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>"{0}": абстрактные свойства не могут иметь закрытых методов доступа.</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>Выражение, заданное выражению is не может иметь указанный тип</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>Указанная строка версии не соответствует рекомендованному формату — основной номер.дополнительный номер.сборка.редакция</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>Ошибка при открытии файла манифеста Win32 {0} — {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>'{0}" — новый виртуальный член в запечатанном классе "{1}".</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>Дерево выражения не может содержать индексированное свойство.</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>Недопустимый синтаксис контрольной суммы #pragma</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>LookupOptions имеет недопустимую комбинацию параметров.</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>Требуется инициализатор массива длиной "{0}".</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>Поле, доступное только для чтения, невозможно вернуть по ссылке, доступной для записи</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>Выражение switch или метка case должны быть логическим значением, символом, строкой, целым числом, перечислением или соответствующим типом, принимающим значение NULL, в C# 6 и более ранних версиях.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>Чтобы выполнить минимальную квалификацию типа, необходимо указать расположение.</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>Добавленные модули должны быть помечены атрибутом CLSCompliant, чтобы соответствовать этой сборке.</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>Тип "{2}" должен быть ссылочным типом для его использования в качестве параметра "{1}" в универсальном типе или методе "{0}".</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>Отправка может включать только код скрипта.</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>'{0}": переопределение невозможно, так как "{1}" не имеет функции доступа get, доступной для переопределения.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>Предыдущее выражение catch уже получило все исключения</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>Интерфейсы не могут содержать операторы.</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>'{0}" является двоичным файлом, а не текстовым.</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>Выражение оператора switch должно быть значением; найдено "{0}".</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>Невозможно присвоить "{0}" свойству анонимного типа.</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>Не удается открыть "{0}" для записи — "{1}".</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>Возможно, ошибочный пустой оператор</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>Невозможно создать делегат на основе метода "{0}, так как он является разделяемым методом без реализующего объявления.</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>Не следует переопределять object.Finalize. Укажите деструктор.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>конструктор и деструктор тела выражения</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>"{0}": автоматически реализованные свойства не могут быть использованы в типах, помеченных StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>Ожидается имя файла в кавычках, однострочный комментарий или признак конца строки.</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>Комментарий XML для "{0}" имеет атрибут cref, который ссылается на параметр типа.</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>Делегат "{0}" не имеет допустимого конструктора.</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>Деконструкция должна иметь не менее двух переменных.</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>Методы расширения "{0}", определенные на типе значения "{1}", не могут применяться для создания делегатов.</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>Несогласованность по доступности: доступность базового класса "{1}" ниже доступности класса "{0}"</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>Оператор goto case допустим только внутри оператора выбора.</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>Класс System.Object не может иметь базовый класс или реализовывать интерфейс.</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>'{0}": невозможно изменить модификаторы доступа при переопределении "{1}", унаследованном из "{2}".</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>Индексатор не может иметь тип void.</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности оператора "{0}"</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>Требуется указать значение поля const.</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>Не удается восстановить предупреждение "CS{0}", так как оно было глобально отключено.</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>Введение метода Finalize может помешать вызову деструктора. Предполагается объявить деструктор?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>Тело "{0}" не может быть блоком итератора, так как "{0}" возвращает данные по ссылке</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>Неверное число индексов в []; требуется {0}.</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>Не указан открытый ключ, необходимый для отложенной подписи.</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>Разделяемый метод не может иметь параметры out.</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>Недопустимый термин "{0}" в выражении</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>Модификатор доступа метода доступа "{0}" должен быть более ограничивающим, чем у свойства или индексатора "{1}".</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerFilePathAttribute можно применять только к параметрам со значениями по умолчанию.</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>Отсутствует спецификация файла для параметра "{0}"</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>Требуется имя файла в кавычках</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>Повторяющееся определенное пользователем преобразование в типе "{0}".</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>Требуется тип byte, sbyte, short, ushort, int, uint, long или ulong.</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>Неожиданное использование универсального имени.</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>"{0}" не требуется атрибут CLSCompliant, так как сборка не имеет атрибута CLSCompliant.</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>Сигнатура управляемого класса-оболочки coclass "{0}" для интерфейса "{1}" не является допустимой сигнатурой имени класса.</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>Тип "{1}" существует как в "{0}", так и в "{2}".</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>Тип конфликтует с импортированным типом</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>Символ "{0}" можно экранировать только двойными символами "{0}{0}" в интерполированной строке.</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>Недопустимый элемент включения для XML</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>Это предупреждение возникает, когда создается класс с методом, подпись которого является открытым, виртуальным, недействительным методом Finalize.

Если такой класс используется в качестве базового, а производный класс определяет деструктор, то деструктор переопределит метод Finalize базового класса, а не метод Finalize производного класса.</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>Не используйте атрибут "System.Runtime.CompilerServices.FixedBuffer". Вместо него следует применять модификатор "fixed".</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>Использование NULL в этом контексте не допускается.</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>Квалификатор псевдонима пространства имен "::" всегда разрешается в тип или пространство имен, что в данном случае недопустимо. Рассмотрите возможность использования ".".</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>Параметр типа "{0}" не может использоваться с оператором "as", так как он не имеет ни ограничений типа класса, ни ограничения "class".</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>Ключевое слово "base" неприменимо в статическом методе.</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>Не удается инициализировать член "{0}". Это не поле или свойство.</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>Неоднозначность между "{0}" и "{1}"</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction_Title" xml:space="preserve">
    <value>Локальная функция объявлена, но не используется</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Ошибка в синтаксисе командной строки: Отсутствует Guid для параметра "{1}".</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>Сборка, на которую дана ссылка "{0}", направлена на другой процессор.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>Не удается присвоить {0} неявно типизированной переменной.</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Произошла ошибка при записи выходного файла: {0}.</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>"{0}": статический конструктор не может иметь явный вызов конструктора "this" или "base".</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>Переменная окружения LIB</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>'{0}" не может реализовать "{1}", так как "{2}" является событием среды выполнения Windows и "{3}" является регулярным событием .NET.</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>"{0}" является устаревшим.</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>'{0}" является типом "{1}". Тип, заданный в объявлении константы, должен быть sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, типом enum или ссылочным.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>Указанная строка версии не соответствует рекомендованному формату — основной номер.дополнительный номер.сборка.редакция</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>Параметр "{0}" не имеет совпадающего тега param в комментарии XML для "{1}" (в отличие от остальных параметров)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>Индексированное свойство "{0}" содержит необязательные аргументы, которые необходимо указать</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>Чтобы тип "{0}" можно было использовать как AsyncMethodBuilder для типа "{1}", его свойство Task должно возвращать тип "{1}" вместо "{2}".</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>"{0}": поле не может быть одновременно изменяемым и доступным только для чтения</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>Требуется директива #endregion.</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>Имя параметра "{0}" конфликтует с автоматически созданным именем параметра.</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>Параметры типа не разрешены в группе методов в качестве аргумента "nameof".</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа параметра "{1}" ниже доступности делегата "{0}"</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>Предыдущее предложение catch уже перехватывает все исключения. Все возникшие необработанные исключения будут перенесены в System.Runtime.CompilerServices.RuntimeWrappedException.</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value> Сбой при вставке некоторых или всех включенных XML </value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>Ожидание "{0}" невозможно</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>Деконструкция не может содержать объявления и выражения в левой части.</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>Требуется постоянное значение.</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>Имя типа параметра "{0}" совпадает с именем типа параметра внешнего типа "{1}".</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>Литерал с типом double не может быть неявно преобразован к типу "{1}"; используйте суффикс "{0}" для создания литерала этого типа</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Параметры компилятора Visual C#

                        - ВЫХОДНЫЕ ФАЙЛЫ -
 /out:&lt;файл&gt;                   Указывает имя выходного файла (по умолчанию: базовое имя
                               файла с классом main или имя первого файла)
 /target:exe                   По умолчанию выполняет сборку консольного исполняемого файла (краткая
                               форма: /t:exe)
 /target:winexe                Выполняет сборку исполняемого файла Windows (краткая форма:
                               /t:winexe)
 /target:library               Выполняет сборку библиотеки (краткая форма: /t:library)
 /target:module                Выполняет сборку модуля, который может быть добавлен в другую
                               сборку (краткая форма: /t:module)
 /target:appcontainerexe       Выполняет сборку исполняемого файла контейнера приложений (краткая форма:
                               /t:appcontainerexe)
 /target:winmdobj              Выполняет сборку промежуточного файла среды выполнения Windows,
                               используемого в WinMDExp (краткая форма: /t:winmdobj)
 /doc:&lt;файл&gt;                   Создаваемый XML-файл документации
 /refout:&lt;файл&gt;                Создаваемые выходные данные базовой сборки.
 /platform:&lt;строка&gt;            Ограничить платформы, на которых может выполняться этот код: x86,
                               Itanium, x64, arm, anycpu32bitpreferred или
                               anycpu. Значение по умолчанию — anycpu.

                        - ВХОДНЫЕ ФАЙЛЫ -
 /recurse:&lt;подстановочный знак&gt;           Включить все файлы в текущем каталоге и
                               подкаталогах в соответствии с заданным
                               подстановочным знаком
 /reference:&lt;псевдоним&gt;=&lt;файл&gt;     Ссылаться на метаданные из заданного файла
                               сборки с помощью определенного псевдонима (краткая форма: /r)
 /reference:&lt;список файлов&gt;        Ссылаться на метаданные из заданных файлов
                               сборки (краткая форма: /r)
 /addmodule:&lt;список файлов&gt;        Скомпоновать указанные модули вместе с этой сборкой
 /link:&lt;список файлов&gt;             Внедрить метаданные из указанных файлов
                               сборок взаимодействия (краткая форма: /l)
 /analyzer:&lt;список файлов&gt;         Запускать анализаторы из этой сборки
                               (краткая форма: /a)
 /additionalfile:&lt;список файлов&gt;   Дополнительные файлы, которые не оказывают прямого влияния на создание
                               кода, но могут использоваться анализаторами для вывода
                               ошибок или предупреждений.
 /embed                        Внедрить все исходные файлы в PDB.
 /embed:&lt;список файлов&gt;            Внедрить указанные файлы в PDB.

                        - РЕСУРСЫ -
 /win32res:&lt;файл&gt;              Задает файл ресурсов Win32 (RES-файл)
 /win32icon:&lt;файл&gt;             Использовать этот значок для вывода.
 /win32manifest:&lt;файл&gt;         Задает файл манифеста Win32 (XML-файл).
 /nowin32manifest              Не включать манифест Win32 по умолчанию.
 /resource:&lt;ресурс&gt;           Внедрить указанный ресурс (краткая форма: /res)
 /linkresource:&lt;ресурс&gt;       Скомпоновать указанный ресурс вместе с этой сборкой
                               (краткая форма: /linkres), где данные о ресурсах имеют формат
                               &lt;файл&gt;[,&lt;имя строки&gt;[,public|private]]

                        - СОЗДАНИЕ КОДА -
 /debug[+|-]                   Выдать отладочную информацию.
 /debug:{full|pdbonly|portable|embedded}
                               Задать тип отладки (по умолчанию — "full",
                               "portable" — кроссплатформенный формат,
                               "embedded" — кроссплатформенный формат, внедряемый в
                               целевой DLL- или EXE-файл)
 /optimize[+|-]                Включить оптимизацию (краткая форма: /o)
 /deterministic                Создать детерминированную сборку
                               (включая GUID версии модуля и метку времени)
 /refonly                      Создать базовую сборку вместо основных выходных данных.
 /instrument:TestCoverage      Создать сборку, инструментированную для сбора
                               сведений об объеме протестированного кода. 
 /sourcelink:&lt;файл&gt;            Данные о ссылке на исходные файлы для внедрения в PDB.

                        - ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ -
 /warnaserror[+|-]             Записывать все предупреждения как ошибки.
 /warnaserror[+|-]:&lt;предупреждения&gt; Записывать указанные предупреждения как ошибки.
 /warn:&lt;n&gt;                     Задать уровень генерации предупреждений (0–4) (краткая форма: /w)
 /nowarn:&lt;предупреждения&gt;           Отключить указанные предупреждения.
 /ruleset:&lt;файл&gt;               Указать файл набора правил, отключающий определенные
                               диагностические операции.
 /errorlog:&lt;файл&gt;              Указать файл для записи всех диагностических данных
                               компилятора и анализатора.
 /reportanalyzer               Сообщить дополнительные сведения об анализаторе, например
                               время выполнения.

                        - ЯЗЫК -
 /checked[+|-]                 Создать проверки переполнений.
 /unsafe[+|-]                  Допускать "небезопасный" код.
 /define:&lt;список символов&gt;         Определить символы условной компиляции (краткая
                               форма: /d)
 /langversion:?         Указать допустимые значения для версии языка
 /langversion:&lt;строка&gt;         Указать языковую версию, например
                               "default" (последняя основная версия) или
                               "latest" (последняя версия, включая дополнительные),
                               или конкретные версии, например 6 или 7.1.

                        - БЕЗОПАСНОСТЬ -
 /delaysign[+|-]               Использовать отложенную подпись для сборки, применяя только открытую
                               часть ключа строгого имени
 /publicsign[+|-]              Подписать сборку, используя только открытую
                               часть ключа строгого имени
 /keyfile:&lt;файл&gt;               Указать файл ключей строгого имени.
 /keycontainer:&lt;строка&gt;        Указать контейнер ключей строгого имени.
 /highentropyva[+|-]           Включить ASLR с высокой энтропией.

                        - ПРОЧЕЕ -
 @&lt;файл&gt;                       Считать файл ответов с дополнительными параметрами.
 /help                         Отображать это сообщение об использовании (краткая форма: /?)
 /nologo                       Запрещать отображение сообщения компилятора об авторских правах.
 /noconfig                     Не включать файл CSC.RSP автоматически.
 /parallel[+|-]                Параллельная сборка.
 /version                      Отобразить номер версии компилятора и выйти.

                        - ДОПОЛНИТЕЛЬНО -
 /baseaddress:&lt;адрес&gt;        Базовый адрес библиотеки, для которой выполняется сборка.
 /checksumalgorithm:&lt;алгоритм&gt;      Задать алгоритм для расчета контрольной суммы
                               исходного файла, хранимой в формате PDB. Поддерживаемые значения:
                               SHA1 (по умолчанию) или SHA256.
 /codepage:&lt;n&gt;                 Задать кодовую страницу, используемую при открытии исходных
                               файлов.
 /utf8output                   Выводить сообщения компилятора в кодировке UTF-8.
 /main:&lt;тип&gt;                  Указать тип, содержащий точку входа
                               (все другие возможные точки входа игнорируются) (краткая
                               форма: /m)
 /fullpaths                    Компилятор создает полные пути.
 /filealign:&lt;n&gt;                Задать выравнивание для разделов выходных
                               файлов.
 /pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                               Задать сопоставление для выходных данных имен исходного пути по
                               компилятору.
 /pdb:&lt;файл&gt;                   Задать имя файла для отладочной информации (по умолчанию
                               используется имя выходного файла с расширением PDB)
 /errorendlocation             Выводить строку и столбец конечного расположения
                               каждой ошибки.
 /preferreduilang              Указать имя предпочтительного языка вывода.
 /nostdlib[+|-]                Не обращаться к стандартной библиотеке (mscorlib.dll).
 /subsystemversion:&lt;строка&gt;    Задать версию подсистемы этой сборки.
 /lib:&lt;список файлов&gt;              Задать дополнительные каталоги для поиска
                               ссылок.
 /errorreport:&lt;строка&gt;         Указать способ обработки внутренних ошибок компилятора:
                               prompt, send, queue или none. По умолчанию используется
                               queue.
 /appconfig:&lt;файл&gt;             Указать файл конфигурации приложения,
                               содержащий параметры привязки сборки.
 /moduleassemblyname:&lt;строка&gt;  Имя сборки, частью которой будет являться
                               этот модуль.
 /modulename:&lt;строка&gt;          Задать имя исходного модуля.
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>Синтаксическая ошибка; требуется значение.</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>"{0}" не может быть запечатанным, т. к. не содержит модификатора override.</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#error: '{0}'</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>Переменная диапазона "{0}" уже была объявлена.</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>В AssemblySignatureKeyAttribute определен недопустимый открытый ключ подписи.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>Имя элемента кортежа "{0}" игнорируется, так как целевым типом "{1}" задано другое имя либо имя не задано.</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>Это предупреждение возникает при попытке вызвать метод, свойство или индексатор в члене или классе, производном от MarshalByRefObject; при этом член является типом значения. Объекты, наследуемые от MarshalByRefObject, обычно упаковываются по ссылке в домене приложений. Если код пытается получить прямой доступ к члену типа значения такого объекта в домене приложений, возникнет исключение времени выполнения. Чтобы устранить предупреждение, сначала скопируйте член в локальную переменную и вызовите метод в этой переменной.</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>Имена двух индексаторов различаются; для каждого индексатора в пределах типа следует использовать атрибут IndexerName с одним и тем же именем.</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>Для использования оператора "Await" необходимо, чтобы у возвращаемого типа "{0}" метода "{1}.GetAwaiter()" были соответствующие члены IsCompleted, OnCompleted и GetResult и чтобы этот тип реализовывал интерфейс INotifyCompletion или ICriticalNotifyCompletion.</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>'{0}" является неоднозначной ссылкой между "{1}" и "{2}".</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>Параметр переопределяет атрибут, заданный в исходном файле или добавленном модуле</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>Разделяемые методы должны иметь тип возвращаемого значения void.</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>Циклическая зависимость базового класса включает "{0}" и "{1}".</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>Ожидается идентификатор или численный литерал</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}".</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>Не удалось включить фрагмент XML</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>'{0}": событие в интерфейсе не может иметь инициализатор.</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>Конструктор "{0}" не может вызвать сам себя</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>Однострочный комментарий нельзя использовать в качестве интерполированной строки.</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>Локальная переменная или функция с именем "{0}" уже определена в этой области.</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>Две сборки отличаются номером выпуска или версии. Для унификации необходимо указать директивы в CONFIG-файле приложения и предоставить допустимое строгое имя сборки.</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>Не удалось изменить возвращаемое значение "{0}", т. к. оно не является переменной.</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>"{0}": базовый тип "{1}" несовместим с CLS.</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>Невозможно присвоить значение "{0}", так как он доступен только для чтения.</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>Параметр {0} объявлен как тип "{1}{2}" вместо "{3}{4}".</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Ошибка чтения файла "{0}", указанного для именованного аргумента "{1}" для атрибута PermissionSet: '{2}'</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>Для параметра типа "{0}" уже указано предложение ограничения. Все ограничения для параметра типа должны быть объявлены в одном предложении Where.</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>Ожидание "void" невозможно</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>Невозможно вернуть по ссылке локальный "{0}", так как это не локальная переменная ref</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>Не удается выполнить требуемую для вызова конструктора динамическую отправку, поскольку этот вызов является частью инициализатора конструктора. Попробуйте привести динамические аргументы.</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>Невозможно определить тип неявно типизированной переменной "out" "{0}".</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>Не удается внедрить типы взаимодействия из сборки "{0}" из-за отсутствия в ней атрибута "{1}".</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>инициализатор объекта</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>Неявно типизированные переменные не могут быть многократно объявлены.</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField" xml:space="preserve">
    <value>Невозможно вернуть {0} "{1}" по ссылке для записи, так как это переменная только для чтения</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>Пространство имен не может напрямую включать в себя такие члены, как поля или методы.</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>Модификатор члена "{0}" должен указываться перед типом и именем члена.</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>Требуется "}"</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>Пустой блок switch</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>Требуется именованный аргумент атрибута.</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>Параметр имеет несколько различных значений по умолчанию.</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>Аргумент типа "{0}" неприменим для атрибута DefaultParameterValue.</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>Определенное пользователем преобразование должно осуществлять преобразование в данный включающий тип или из данного включающего типа.</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>Член структуры "{0}" типа "{1}" приводит к циклу в этом макете структуры.</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>Тип ограничения несовместим с CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>Не удается использовать класс атрибута "{0}", так как он является абстрактным.</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>'{0}" должен объявлять тело, так как он не помечен модификатором abstract, extern или partial.</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Обнаружен недостижимый код</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>В данном асинхронном методе отсутствуют операторы await, поэтому метод будет выполняться синхронно. Воспользуйтесь оператором await для ожидания неблокирующих вызовов API или оператором await Task.Run(...) для выполнения связанных с ЦП заданий в фоновом потоке.</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>Переменная диапазона "{0}" не может иметь имя, совпадающее с именем параметра типа метода.</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>Для типа "{0}" не определен конструктор.</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>анонимный метод</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Ожидался скрипт (CSX-файл), но ни один не был указан</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>типы, допускающие значение NULL</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>Параметр /noconfig пропущен, т. к. он задан в файле ответов</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>Форма деконструкции "var (...)" не разрешает использовать конкретный тип для "var".</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>Номер строки, указанный для директивы #line, отсутствует или недействителен.</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> Невозможно включить некорректный файл XML "{0}". </value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>Не удается загрузить сборку Analyzer {0}: {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>Определенный пользователем оператор "{0}" должен быть объявлен как статический и открытый.</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>Объявление недействительно; используйте "{0} оператор &lt;результирующий тип&gt; (..." вместо</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>"{0}": нельзя использовать статические типы в качестве возвращаемых типов.</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>'{0}" не должен иметь параметр params, так как у "{1}" его нет.</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>Не удается создать временный файл — {0}.</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" не имеет параметр с именем "{1}".</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>Параметр типа "{0}" совпадает с именем вмещающего типа или метода.</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>Член скрывает унаследованный член: отсутствует новое ключевое слово</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>Разделяемый метод должен быть объявлен в разделяемом классе или разделяемой структуре.</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>Тип "{1}" в "{0}" конфликтует с импортированным пространством имен "{3}" в "{2}". Используется тип, определенный в "{0}".</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>Пространство имен "{1}" в "{0}" конфликтует с импортированным типом "{3}" в "{2}". Используется пространство имен, определенное в "{0}".</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод Add "{0}" для инициализатора набора содержит недопустимые аргументы.</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>При создании массива следует указать размер массива или инициализатор массива.</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>Параметр типа "{0}" не имеет совпадающего тега typeparam в комментарии XML для "{1}" (в отличие от остальных параметров типов)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>В условных выражениях присваивание всегда постоянное. Предполагалось использовать ==, а не = ?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>Класс атрибута "{0}" не может использоваться, так как он является универсальным.</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>Ошибка при чтении файла манифеста Win32 "{0}" — "{1}".</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>Атрибут "{0}" модуля "{1}" будет игнорироваться, вместо него используется экземпляр в источнике.</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>Невозможно присвоить {0} переменной диапазона.</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>Параметр params должен быть указан последним в списке формальных параметров.</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>Недопустимо использовать оператор throw без аргументов в предложении finally, которая находится в ближайшем вложенном предложении catch.</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>Кортеж должен содержать по меньшей мере два элемента.</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>Тип "{0}" не может использоваться в качестве аргумента типа</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>Не удается внедрить тип взаимодействия "{0}", так как у него отсутствует обязательный атрибут "{1}".</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>Асинхронное лямбда-выражение, преобразованное в делегата, возвращающего "Task", не может возвращать значение. Предполагалось возвращать "Task&lt;T&gt;"?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>Недопустимое имя языка "{0}".</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>В операторах for, using, fixed и операторах объявления не может использоваться более одного типа.</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>Невозможно присвоить значение переменной диапазона "{0}", доступной только для чтения.</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>'{0}" не содержит конструктор, который принимает аргументы {1}.</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>Строки языка и региональных параметров сборки могут не содержать встроенных символов NULL.</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>Запрещено использовать тип "{0}", допускающий значение NULL, в шаблоне. Используйте вместо него базовый тип "{1}".</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>Параметр params должен использоваться в обоих объявлениях разделяемого метода или не должен использоваться ни в одном из них.</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>'{0}" в явном объявлении интерфейса не является членом интерфейса.</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>Тип "{1}" в "{0}" конфликтует с импортированным типом "{3}" в "{2}". Используется тип, определенный в "{0}".</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>Элементы массива не могут иметь тип "{0}".</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>Модификаторы нельзя размещать в объявлениях методов доступа к событиям.</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>Перед интерфейсом должен быть указан базовый класс "{0}".</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Заданы несовместимые параметры: файл ресурсов Win32; манифест Win32.</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>Итераторы не могут иметь небезопасные параметры или типы yield.</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>Невозможно применить CallerMemberNameAttribute, так как отсутствуют стандартные преобразования из типа "{0}" в тип "{1}".</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>Невозможно вернуть по ссылке член параметра "{0}", так как это не параметр ref или out</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(Местоположение символа, связанного с предыдущей ошибкой)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>Нельзя использовать оператор yield в теле предложения catch.</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>Поскольку данный метод является асинхронным, возвращаемое выражение должно относиться к типу "{0}", а не типу "Task&lt;{0}&gt;".</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>Требуется "{" или ";".</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>Ключевое слово "this" не может использоваться в инициализаторах статических свойств, методов или полей.</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>необязательный параметр</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>Указан недопустимый путь поиска</value>
  </data>
  <data name="ERR_RefReturnThis" xml:space="preserve">
    <value>Невозможно вернуть this по ссылке.</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>Не удается найти тип взаимодействия, соответствующий внедренному типу взаимодействия "{0}". Возможно, отсутствует ссылка на сборку.</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>Это предупреждение возникает, если атрибуты сборки AssemblyKeyFileAttribute или AssemblyKeyNameAttribute в источнике конфликтуют с параметром командной строки /keyfile или /keycontainer либо с именем файла ключа или контейнером ключа, указанном в свойствах проекта.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>Это предупреждение указывает, что атрибут, например InternalsVisibleToAttribute, был указан неправильно.</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>Объявление переменной по ссылке должно иметь инициализатор</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>Невозможно применить MethodImplOptions.Synchronized к асинхронному методу.</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>Невозможно вернуть параметр "{0}" по ссылке, так как это не параметр ref или out</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>Элементы, определенные в пространстве имен, нельзя объявлять в явном виде как частные, защищенные, защищенные внутренние или частные защищенные.</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>Параметр /moduleassemblyname может использоваться только при сборке модуля.</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>Параметр типа "{0}" наследует конфликтующие ограничения "{1}" и "{2}".</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>Идентификатор ресурса "{0}" в этой сборке уже использован.</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>Значение параметра по умолчанию для "{0}" должно быть константой времени компиляции.</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>Программа не содержит статического метода "Main", подходящего для точки входа.</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>Эта ошибка происходит, когда предопределенный тип системы, например System.Int32, находится в двух сборках. Единственная причина этого — ссылка на mscorlib или System.Runtime.dll из двух разных расположений, например, при попытке запустить две версии .NET Framework одновременно.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>Невозможно вернуть по ссылке член "{0}", так как он был инициализирован значением, которое нельзя вернуть по ссылке</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>Методы с переменным числом аргументов не совместимы с требованиями CLS.</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>Чтобы создать токены цифровых литералов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal.</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>Объявления разделяемого метода либо оба должны иметь модификаторы static, либо ни одно из объявлений не должно иметь модификатора static.</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>'{0}" не является ссылочным типом, как требуется в операторе lock.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>Статическое поле, доступное только для чтения, невозможно вернуть по ссылке для записи</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>Интерфейсы, совместимые с CLS, должны включать только совместимые с CLS члены</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>Добавленные модули должны быть помечены атрибутом CLSCompliant, чтобы соответствовать этой сборке.</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>"{0}": имя параметра, локальной переменной или локальной функции не может совпадать с именем параметра типа метода.</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>Тип возвращаемого значения несовместим с CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>Ошибка при открытии файла значка {0} — {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>SyntaxTree "{0}" не найдено и не будет удалено.</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>Не удается вывести тип переменной неявно типизированных деконструкций "{0}".</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>Ограничения для переопределения и явные методы реализации интерфейса унаследованы от базового метода, поэтому они не могут быть указаны напрямую.</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>Для директивы препроцессора указано недопустимое имя файла</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>Символ "{0}" необходимо экранировать (путем дублирования) в интерполированной строке.</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>метод расширения</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>Выражение не имеет имени.</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>Неожиданная ошибка при записи информации отладки — "{0}".</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>Компиляция (C#): </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>Тип несовместим с CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>Не удается преобразовать в статический тип "{0}".</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>Тип не содержит доступных конструкторов, которые используют только совместимые с CLS типы</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>"{0}" не может быть помечен как совместимый с CLS, поскольку является членом типа "{1}", несовместимого с CLS.</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>анонимные типы</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>Константа "{0}" не может быть помечена модификатором static.</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>Свойство или индексатор "{0}" не может использоваться в этом контексте, так как не имеет метода доступа get.</value>
  </data>
  <data name="ERR_AutoPropsInRoStruct" xml:space="preserve">
    <value>Автоматически реализуемые свойства экземпляра в структурах только для чтения должны быть доступны только для чтения.</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>Указанная версия языка "{0}" не может содержать начальные нули.</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>Ошибка при открытии файла ответа "{0}"</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>Рекомендуемый перегружаемый метод Add для элемента инициализатора коллекции устарел</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности оператора "{0}"</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>Неиспользованный внешний псевдоним.</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>Ссылка на неявно типизированную переменную "{0}" с параметром OUT не разрешена в том же списке аргументов.</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>Отсутствует модификатор partial в объявлении типа "{0}"; существует другое разделяемое объявление этого типа.</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>'{0}": переопределение невозможно, так как "{1}" не имеет функции доступа set, доступной для переопределения.</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>В параметре /reference не указан внешний псевдоним "{0}".</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>Предполагалось использовать метку параметра по умолчанию ("default:") вместо "case default:"? Если вы намерены использовать литерал по умолчанию, рекомендуется использовать "case (default):" или другой литерал ("case 0:" или "case null:") соответствующим образом.</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>"{0}" не распознан как расположение атрибута. Допустимые расположения атрибута для этого объявления: "{1}". Все атрибуты этого блока будут проигнорированы.</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>Параметр {0} должен быть объявлен с ключевым словом "{1}".</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>Интерфейс "{0}" имеет недопустимый исходный интерфейс, который требуется для внедрения события "{1}".</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод, соответствующий "{0}" для элемента инициализации коллекции, не может быть использован. Методы инициализации коллекции "Add" не имеют ссылочных и выходных параметров.</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>"{0}": не найден метод, пригодный для переопределения.</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;список путей&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>Невозможно изменить члены "{0}", так как это "{1}".</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>"{0}': только совместимые с CLS члены могут быть абстрактными.</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>Ненужная директива using</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>Не удается связать файлы ресурсов при сборке модуля.</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;глобальное пространство имен&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>Циклическая зависимость ограничений включает "{0}" и "{1}".</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>"{0}" определяет оператор "==" или оператор "!=", но не переопределяет Object.GetHashCode().</value>
  </data>
  <data name="IDS_LangVersions" xml:space="preserve">
    <value>Поддерживаемые языковые версии:</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>Тип одного из параметров бинарного оператора должен быть вмещающим.</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>'{0}" не реализует "{1}"</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>Доступ к защищенному члену "{0}" через квалификатор типа "{1}" невозможен; квалификатор должен иметь тип "{2}" (или производный от него тип).</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>Отсутствует обязательный для компилятора член "{0}.{1}"</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>В данном контексте нельзя использовать атрибуты сборки и модуля</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>Требуется однострочный комментарий или признак конца строки.</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>Член не скрывает унаследованный член: новое ключевое слово не требуется</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>Структуры без явных конструкторов не могут содержать члены с инициализаторами.</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>'{0}": нельзя использовать статические классы в качестве ограничений.</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>Возвращаемым типом асинхронного метода должен быть void, Task или Task&lt;T&gt;</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>Комментарий XML содержит атрибут cref "{0}", который не удалось разрешить.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>Не удалось найти имя типа "{0}" в пространстве имен "{1}". Этот тип был отправлен в сборку "{2}". Попробуйте добавить ссылку на эту сборку.</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Работа оператора Foreach в "{0}" невозможна. Действительно вызвать "{0}"?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>Ссылка на поле с модификатором volatile не будет использоваться как изменяемая ссылка</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>Доступ к члену в поле класса упаковки по ссылке может вызвать исключение времени выполнения</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>Поле не может иметь тип void.</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>Базовый тип несовместим с CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>Методы расширения должны быть определены в статическом классе верхнего уровня; {0} является вложенным классом.</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>Модуль "{0}" уже определен в этой сборке. Каждый модуль должен иметь уникальное имя.</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>В этом контексте атрибуты недопустимы.</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>буферы фиксированного размера</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>Использование точки с запятой после блока метода или доступа недопустимо.</value>
  </data>
  <data name="ERR_RefReadonlyNotField2" xml:space="preserve">
    <value>Члены {0} "{1}" невозможно использовать как значения ref или out, так как это переменная только для чтения</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>Внедрение типа взаимодействия "{0}" из сборки "{1}" служит причиной конфликта имен в текущей сборке. Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>Методы с переменным числом аргументов не совместимы с требованиями CLS.</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>"{0}": модификаторы доступа для методов доступа могут использоваться, только если свойство или индексатор имеет оба метода доступа, get и set.</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>Не удается определить класс или член, использующий dynamic, так как не удается найти требуемый компилятором тип "{0}". Возможно, отсутствует ссылка.</value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>Для полей модификатор метода "abstract" недопустим. Вместо этого попробуйте использовать свойство.</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>выбор по значению логического типа</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>Результатом этого выражения всегда будет "Null" типа "{0}".</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>Атрибут CLSCompliant не имеет значения при применении к типам возвращаемых значений</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>Не удается преобразовать {0} в требуемый тип делегата, так как некоторые возвращаемые типы блока не могут быть неявно преобразованы в возвращаемый тип делегата.</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>Отсутствует комментарий XML для публично видимого типа или члена "{0}"</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>Член "{0}" реализует интерфейсный член "{1}" в типе "{2}". Во время выполнения возникает множественное соответствие интерфейсных членов. Реализация зависит от того, какой метод будет вызван.</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>Компилятор определяет это предупреждение, когда оно переопределяет ошибку с предупреждением. Для получения дополнительных сведений о проблеме выполните поиск упомянутой ошибки кода.</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>переменная using</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>Ограничение new() должно быть последним указанным ограничением.</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>"{0}" уже указан в списке интерфейсов типа "{2}" с другими именами элементов кортежа: "{1}".</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>Полю "{0}" нигде не присваивается значение, поэтому оно всегда будет иметь значение по умолчанию {1}.</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>Недопустимая дружественная ссылка на сборку "{0}". Сборки, подписанные строгим именем, должны содержать в объявлении InternalsVisibleTo открытый ключ.</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>Тип несовместим с CLS, так как базовый интерфейс несовместим с CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>Тип "{1}" уже определяет член "{0}" с такими же типами параметров.</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;!-- Проигнорирован некорректный комментарий XML для члена "{0}" --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>Невозможно преобразовать блок анонимного метода без списка параметров в тип делегата "{0}", так как он имеет один или несколько выходных параметров.</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>Атрибут "{0}" допустим только для методов или классов атрибутов.</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>Использование ключевого слова "void" в этом контексте недопустимо. </value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>Пространство имен "{1}" уже содержит определение для "{0}".</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>элементы: не должно быть пустым</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>Ожидается идентификатор или численный литерал.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>Комментарий XML в "{1}" имеет тег paramref для "{0}", но параметр для этого имени отсутствует.</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>Требуется перегружаемый унарный оператор.</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>Оператор "{0}" невозможно применить к операнду "{1}".</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>Не удается выполнить поиск члена в "{0}", так как это параметр типа.</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>Имя модуля "{0}", сохраненное в "{1}", должно соответствовать его имени файла.</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>Использование "{0}" в качестве значения ref или out или получение его адреса может вызвать исключение времени выполнения, поскольку это поле класса, который маршалируется по ссылке</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>Указанная строка версии не соответствует рекомендованному формату — основной номер.дополнительный номер.сборка.редакция</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>'{0}": элементы массива не могут быть статического типа.</value>
  </data>
  <data name="IDS_SK_CONSTRUCTOR" xml:space="preserve">
    <value>конструктор</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>Не удается определить тип условного выражения, так как неявного преобразования между "{0}" и "{1}" не существует.</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>Невозможно присвоить "{0}" значение, так как он является "{1}".</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>Событие "{0}" может присутствовать только в левой части операций += и -= (кроме случая использования в типе "{1}").</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, так как метод доступа set недоступен.</value>
  </data>
  <data name="IConversionExpressionIsNotCSharpConversion" xml:space="preserve">
    <value>{0} не является допустимым выражением преобразования C#</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>Именованный аргумент "{0}" задает параметр, для которого уже был установлен позиционный аргумент.</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>Не удается преобразовать группу методов "{0}" в тип, не являющийся делегатом "{1}". Предполагалось вызывать этот метод?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>Ключ /win32manifest для модуля пропущен, т. к. используется только для сборок</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>Оператор foreach требует, чтобы возвращаемый тип "{0}" для "{1}" имел соответствующий открытый метод MoveNext и открытое свойство Current.</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(Местоположение символа, связанного с предыдущим предупреждением)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>Инициализаторы массивов могут использоваться только в инициализаторах переменных или полей. Используйте выражение с оператором new.</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;NULL&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;текст&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>Несоответствие ссылок между методом "{0}" и делегатом "{1}"</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>'{0}": невозможно переопределить, так как "{1}" не является функцией.</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>неявно типизированная локальная переменная</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>Предопределенный тип "{0}" должен быть структурой.</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>неявно типизированный массив</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>Чтобы создать токены идентификаторов, используйте Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier или Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier.</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>"{0}": в структуре не могут содержаться инициализаторы свойств или полей экземпляров.</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Операторы yield не могут использоваться на верхнем уровне интерактивного кода.</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>'{0}": тип, использованный в операторе using, должен иметь неявное преобразование в System.IDisposable.</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>Возможно, непреднамеренное сравнение ссылок; для получения сравнения значений приведите левую часть к типу "{0}".</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>Недопустимый спецификатор ранга: требуется "," или "]".</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>Метод доступа к свойству уже определен.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>Невозможно инициализировать неявно типизированную переменную инициализатором массива.</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>Символ новой строки в константе.</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>Универсальный тип не может быть производным от "{0}", так как это класс атрибута.</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>Невозможно создать экземпляр анализатора</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>Тело "{0}" не может быть блоком итератора, так как "{1}" не является типом интерфейса итератора.</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>Назначаемое для "{0}" выражение должно быть константным.</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>Размер массива не может быть указан в объявлении переменной (попытайтесь инициализировать его с помощью оператора new).</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>"{0}": абстрактное событие не может иметь инициализатор.</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>Импортировано несколько сборок с одинаковыми удостоверениями: '{0}" и "{1}". Удалите одну из повторяющихся ссылок.</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>Тип "{1}" в "{0}" конфликтует с пространством имен "{3}" в "{2}".</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Атрибут CallerLineNumberAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>Требуется тип.</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>Позиция должна находиться в диапазоне синтаксического дерева.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>Дерево выражения не может содержать инициализатор многомерного массива.</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>Интерфейсы не могут содержать поля.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>Невозможно вернуть по ссылке "{0}", так как он был инициализирован значением, которое нельзя вернуть по ссылке</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>Неожиданное использование псевдонима.</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>Массив параметров не может быть использован с модификатором "this" в методе расширения.</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>Не удается выполнить требуемую для вызова метода "{0}" динамическую подготовку к отправке в связи с тем, что этот метод является частью базового выражения доступа. Попробуйте привести типы динамических аргументов или исключить доступ к базовым членам.</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>"{0}": класс не может быть одновременно статическим и запечатанным.</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>Разделяемые объявления "{0}" должны быть все классами, все структурами или все интерфейсами.</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>Поле "{0}", совместимое с CLS, не может быть временным.</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>Требуется контекстное ключевое слово "equals".</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>Синтаксис "id#" больше не поддерживается. Вместо этого используйте "$id".</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>Точка входа в программе является глобальным кодом скрипта; выполняется пропуск точки входа</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>Поле не используется</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>Объект "{0}" нельзя удалить более одного раза.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>"{0}" не реализует член интерфейса "{1}". "{2}" не может реализовать "{1}", так как он не имеет соответствующего возвращаемого по ссылке типа.</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>Доступ к буферам фиксированного размера разрешен только через локальные переменные или поля.</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>Комментарий XML в "{1}" имеет тег typeparam для "{0}", но тип параметра для этого имени отсутствует.</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>Вложенные типы универсальных типов должны соответствовать в атрибутах cref</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>Дерево выражения не может содержать спецификацию именованного аргумента.</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>Недопустимый тип результата для /target: необходимо указать "exe", "winexe", "library" или "module"</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения статическому полю допускается только в статическом конструкторе и в инициализаторе переменных.</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>Доступ к члену "{0}" через ссылку на экземпляр невозможен; вместо этого уточните его, указав имя типа.</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>Возможно, используется недопустимое назначение для локального параметра, который является аргументом оператора using или lock</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>Управление не может быть передано из тела предложения finally.</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>Синтаксический узел не находится в синтаксическом дереве.</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>Возвращаемые по ссылке данные можно использовать только в методах, которые возвращают данные по ссылке</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>Тип "{0}" не может быть объявлен как const.</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>У асинхронных методов не может быть параметров ref и out.</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>Управление не может выйти за пределы переключателя с окончательной меткой case ("{0}")</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>Директива using для "{0}" ранее встречалась в этом пространстве имен</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попытайтесь вызвать метод доступа "{1}" напрямую.</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попытайтесь вызвать методы доступа "{1}" или "{2}" напрямую.</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>'{0}": не разрешено пользовательское преобразование в интерфейс или из интерфейса.</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>Не используйте refout при использовании refonly.</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>Нельзя использовать параметр "{0}" с ключевым словом ref или out внутри анонимного метода, лямбда-выражения или выражения запроса.</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>Результат выражения — всегда NULL</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>Не удалось выдать модуль "{0}".</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>выражение Throw</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>Метод "{0}" не может реализовать метод доступа интерфейса "{1}" для типа "{2}". Используйте явную реализацию интерфейса.</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>Псевдоним "{0}" конфликтует с определением {1}.</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>"{0}" не содержит определение для "{1}".</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>Значение целочисленной константы слишком велико.</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>Не удалось найти файл.</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>Объявление недопустимо в этом контексте.</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>Функция void or int, возвращающая точку входа, не может быть асинхронной</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>Комментарий XML содержит тег typeparamref, но параметр типа с таким именем не существует</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>Локальное имя слишком длинное для PDB-файла</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>Вместе с атрибутом ComImport следует задать атрибут Guid.</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>Нельзя использовать оператор yield в теле блока try, имеющего предложение catch.</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>Реализация явного интерфейса совпадает больше чем с одним членом интерфейса</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>Не допускается указывать /main при сборке модуля или библиотеки.</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>Тип предназначен только для оценки и может быть изменен или удален в будущих обновлениях.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>Выражение типа "{0}" недопустимо в последующем предложении from в выражении запроса с исходным типом "{1}".  Ошибка определения типа при вызове в "{2}".</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>оператор, распространяющий значения Null</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>Сборки "{0}" и "{1}" ссылаются на одни метаданные, но только одна из них является связанной ссылкой (указан параметр using /link); попробуйте удалить одну из ссылок.</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>ковариантный</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>Поля буферов фиксированного размера могут быть только членами структур.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>Дерево выражений не может содержать преобразование кортежа.</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>Не удается выполнить чтение файла конфигурации "{0}" — "{1}".</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>Асинхронные лямбда-выражения невозможно преобразовывать в деревья выражений.</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>Параметр типа "{1}" имеет ограничение "struct", поэтому "{1}" не может использоваться в качестве ограничения для "{0}".</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>Предопределенный тип "{0}" не определен и не импортирован или объявлен в нескольких сборках, на которые имеются ссылки.</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>Аргумент типа не может иметь значение Null</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>Объявление внешнего псевдонима должно предшествовать всем другим элементам, определенным в пространстве имен.</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>Недопустимый параметр "{0}" для /platform; должен быть anycpu, x86, Itanium или x64.</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>Аргумент для атрибута "{0}" должен быть допустимым идентификатором.</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>Применение CallerMemberNameAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerFilePathAttribute.</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>Несогласованность по доступности: доступность возвращаемого типа "{1}" ниже доступности делегата "{0}"</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>Атрибут безопасности "{0}" нельзя применить к асинхронному методу.</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>Атрибуты сборки и модуля должны находиться перед всеми остальными элементами в файле, кроме предложений using и описаний внешних псевдонимов.</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>Создана ссылка на внедренную сборку взаимодействия из-за непрямой ссылки на сборку</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>Неуправляемый тип "{0}" допустим только для полей.</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>Автоматически реализованное свойство "{0}" должно быть полностью определено до возврата управления в вызывающий метод.</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>Перегруженный унарный оператор "{0}" принимает один параметр.</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>Небезопасный тип "{0}" не может применяться при создании объекта.</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>Использование выходного параметра "{0}", которому не присвоено значение.</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>контравариантный</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>Атрибут Conditional недопустим для членов интерфейса.</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>Невозможно изменить результат преобразования при распаковке.</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>Ключевые слова ref и out недопустимы в этом контексте.</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>Конечный тег "{0}" не соответствует начальному тегу "{1}".</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>Правая часть присваивания оператора fixed не может быть выражением приведения типа.</value>
  </data>
  <data name="IDS_FeatureRefExtensionMethods" xml:space="preserve">
    <value>ссылочные методы расширения</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>Члены поля "{0}", предназначенного только для чтения, могут быть изменены только в конструкторе или инициализаторе переменных.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>При предположении, что ссылка на сборку "{0}", используемая "{1}", совпадает с удостоверением "{2}"для "{3}", возможно, потребуется задать политику среды выполнения</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>Значение SecurityAction "{0}" недопустимо для атрибутов безопасности, применяемых к сборке</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>Переменная диапазона "{0}" конфликтует с предыдущим объявлением "{0}".</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>Не удалось найти тип или имя пространства имен "{0}" (возможно, отсутствует директива using или ссылка на сборку).</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>Требуется контекстное ключевое слово "on".</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>Требуется контекстное ключевое слово "by".</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>Функция "{0}" не реализована в этом компиляторе.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки из "{3}" в "{1}".</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>Метод расширения должен быть статическим.</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>Недопустимый тип возвращаемого значения в атрибуте cref XML-комментария</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>'{0}" является устаревшим: '{1}'</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>Сборка {0} не содержит анализаторов.</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>ковариантно</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>Была создана ссылка на внедренную сборку взаимодействия "{0}", поскольку существует косвенная ссылка на эту сборку, созданная сборкой "{1}". Рассмотрите возможность изменения свойства "Внедрять типы взаимодействия" в любой сборке.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>Файл с исходным текстом программы превысил установленный в PDB-файле предел в 16 707 565 строк; отладочная информация будет неправильной</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>коллекция</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>Не используйте "System.Runtime.CompilerServices.DynamicAttribute". Используйте вместо этого ключевое слово "dynamic".</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>Имя файла "{0}" пустое, содержит недопустимые символы, имеет имя диска без абсолютного пути или слишком длинное.</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>"{0}" не может быть помечен как совместимый с CLS, поскольку сборка не имеет атрибута CLSCompliant.</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>Указанная версия языка не поддерживается или недопустима: "{0}".</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>'{0}": члены интерфейса не могут иметь определение.</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>Ожидался оператор выражения или оператор объявления.</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>Невозможно присвоить значение свойству или индексатору "{0}" — доступ только для чтения.</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>Метод или делегат не могут возвращать тип "{0}".</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>Несогласованность по доступности: доступность типа поля "{1}" ниже доступности поля "{0}"</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>Параметр /pdb требует использования параметра /debug.</value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>Выражение, заданное выражению is всегда имеет указанный тип</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>Каждый связанный ресурс и модуль должны иметь уникальное имя файла. Имя файла "{0}" определено более одного раза в этой сборке.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>Вызов System.IDisposable.Dispose() в выделенном экземпляре до того, как все ссылки, указывающие на него, окажутся за пределами диапазона</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>Дерево лямбда-выражения не может содержать вызов COM с пропущенным аргументом ref.</value>
  </data>
  <data name="ERR_ParamsCantBeWithModifier" xml:space="preserve">
    <value>Параметр params не может объявляться с ключевым словом {0}</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>В операторе foreach требуется указать и тип, и идентификатор.</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>Аргумент {0}: не удается преобразовать из "{1}" в "{2}".</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Спецификации именованных аргументов должны создаваться после указания всех фиксированных аргументов. Используйте версию языка {0} или более позднюю, чтобы разрешить неконечные именованные аргументы.</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>Ограничения для параметра типа "{0}" метода "{1}" должны соответствовать ограничениям параметра типа "{2}" метода интерфейса "{3}". Рассмотрите возможность явной реализации интерфейса.</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>Невозможно вернуть переменную диапазона "{0}" по ссылке</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>Небезопасный код не может использоваться в итераторах.</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>Конструкция __arglist допускается только в методе с переменным числом аргументов.</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>Невозможно определить тип условного выражения, так как "{0}" и "{1}" неявно преобразовываются друг в друга.</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>"new" невозможно использовать с типом кортежа. Вместо этого используйте литеральное выражение кортежа.</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>Непредвиденный токен "{0}"</value>
  </data>
  <data name="ERR_RefConditionalDifferentTypes" xml:space="preserve">
    <value>Для соответствия альтернативному ссылочному значению выражение должно иметь тип "{0}"</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>'{0}": не может быть производным от запечатанного типа "{1}".</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>Точкой входа отладки должно быть определение метода, объявленное в текущей компиляции.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>Не определен порядок полей в нескольких декларациях разделяемой структуры</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>При предположении, что ссылка на сборку "{0}", используемая "{1}", совпадает с удостоверением "{2}"для "{3}", возможно, потребуется задать политику среды выполнения</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>Комментарий XML для "{0}" имеет тег typeparam, но тип параметра для этого имени отсутствует.</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Должен быть указан параметр атрибута "{0}" или "{1}".</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Должен быть указан параметр атрибута "{0}".</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>метод, воплощающий выражение</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Атрибут CallerFilePathAttribute не будет работать, так как он применяется к члену, который используется в контекстах, не допускающих необязательные аргументы.</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>Не удается скомпилировать сетевые модули при использовании /refout или /refonly.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Тип "{3}", допускающий значение Null, не соответствует ограничению "{1}". Типы, допускающие значение Null, не соответствуют никаким ограничениям интерфейсов.</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>Неправильно сформированный XML во включенном файле комментариев</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>Пространство имен "{1}" содержит определение, конфликтующее с псевдонимом "{0}".</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Недопустимое имя сборки: {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>Дерево выражений не может содержать отмену.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>Использование is для проверки совместимости с типом dynamic равнозначно проверке совместимости с типом Object</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>Директива "using namespace" может применяться только к пространствам имен; "{0}" является типом, а не пространством имен. Используйте директиву "using static"</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>Члены доступного только для чтения поля "{0}" можно использовать как значение ref или out только в конструкторе</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Ошибка в синтаксисе командной строки: Недопустимый формат Guid "{0}" для параметра "{1}".</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>В атрибутах cref вложенные типы универсальных типов должны быть полными.</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerLineNumberAttribute можно применять только к параметрам со значениями по умолчанию.</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>Результат выражения всегда равен "{0}", поскольку значение типа "{1}" никогда не равно Null типа "{2}"</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>Невозможно вернуть значение итератора. Используйте оператор yield return для возвращения значения или оператор yield break для окончания итерации.</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>Требуется disable или restore</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>Параметр "{0}" должен быть абсолютным путем.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Недопустимое значение версии {0} для /subsystemversion. Для ARM или AppContainerExe должна быть указана версия 6.02, в остальных случаях - версия 4.00 или выше</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>Неверное объявление инициализатора члена.</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>Неправильный формат параметра pathmap.</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>Тип буфера фиксированного размера должен входить в следующий список: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float или double.</value>
  </data>
  <data name="ERR_CallArgMixing" xml:space="preserve">
    <value>Это сочетание аргументов для "{0}" запрещено, так как оно может делать переменные, на которые ссылается параметр "{1}", доступными за пределами их области объявления</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>Значение константы "{0}" не может быть преобразовано в "{1}".</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>Аргумент "{0}" не должен передаваться с ключевым словом "{1}".</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, так как метод доступа get недоступен.</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>локальные функции</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>кортежи</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>внешний псевдоним</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>Недопустимый элемент включения для XML — {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>Величина значения выравнивания может привести к возникновению большой форматированной строки</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>Тип в операторах caught или thrown должен быть производным от System.Exception.</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>Не указаны исходные файлы</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>Атрибут "{0}" пропускается при указании общедоступного подписывания.</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>Буфер фиксированного размера с длиной {0} и типом "{1}" слишком велик.</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>'{0}" не удается реализовать "{1}", так как он не поддерживается в данном языке.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 2. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 3. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 1. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 6. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 7.0. Используйте версию языка {1} или более позднюю.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 4. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>Возможность "{0}" недоступна в C# 5. Используйте версию языка {1} или выше.</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>параметр /LIB</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>Атрибут Conditional для "{0}" недопустим, так как возвращаемый тип не является недействительным.</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>Атрибут DllImport не может применяться для универсального метода или метода в универсальном типе.</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>Использование локальной переменной "{0}", которой не присвоено значение.</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>Свойство или индексатор не могут передаваться как параметр out или ref.</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>Член переопределяет базовый член с помощью нескольких кандидатов переопределения во время выполнения</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>Невозможно вернуть "{0}" по ссылке, так как это "{1}"</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Пропуск загрузки типов в сборке анализатора, завершившихся сбоем из-за ReflectionTypeLoadException</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>Параметры или локальные переменные типа "{0}" не могут объявляться в асинхронных методах или лямбда-выражениях.</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>Отсутствует определяющее объявление для реализующего объявления разделяемого метода "{0}".</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>Ссылка на тип "{0}" требует его определения в данной сборке, однако он не определен в исходном тексте программы или добавленных модулях.</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>Невозможно передать значение NULL в качестве имени дружественной сборки.</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>Указанное значение по умолчанию не будет работать, так как оно применяется к члену, который используется в контекстах, не допускающих дополнительные аргументы</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>Пустой блок switch</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>"{0}": абстрактный класс не может быть запечатанным или статическим.</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>Введение метода Finalize может помешать вызову деструктора</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>Требуется указать инициализатор в объявлении оператора fixed или using.</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>Возвращаемый тип оператора ++ или -- должен соответствовать типу параметра или быть производным от типа параметра.</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>Недопустимое отклонение: Параметр типа "{1}" должен быть {3}, допустимым на "{0}". "{1}" является {2}.</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>'{0}": пользовательские преобразования в динамические типы или из них не разрешены.</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>AppConfigPath должен быть абсолютным.</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>Применение CallerFilePathAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>Возможно, ошибочный пустой оператор</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>Тип "{3}" не может быть использован как параметр типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки или преобразования параметра типа из "{3}" в "{1}".</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>Некорректный XML во включенном файле комментариев — "{0}".</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>Автоматически реализуемые свойства должны переопределять все методы доступа переопределенного свойства.</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>Невозможно использовать подвыражение в аргументе nameof.</value>
  </data>
  <data name="ERR_MismatchedRefEscapeInTernary" xml:space="preserve">
    <value>Ветви ссылочного тернарного оператора не могут ссылаться на переменные с несовместимыми областями объявления.</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>Поле буфера фиксированного размера должно иметь спецификатор размера массива после имени поля.</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>Директива #warning</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>Ни одна из перегрузок метода "{0}" не принимает {1} аргументов.</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>Не удается применить индексирование через [] к выражению типа "{0}".</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>'{0}" не является допустимым ограничением. Тип, использованный в качестве ограничения, должен быть интерфейсом, незапечатанным классом или параметром-типом.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>Неоднозначная ссылка в атрибуте cref: "{0}". Предполагается "{1}", но может также соответствовать другим перегрузкам, включая "{2}".</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>Класс "{0}" не может иметь несколько базовых классов: '{1}" и "{2}"</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>"{0}" переопределяет Object.Equals(object o), но не переопределяет Object.GetHashCode().</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>Ненужная директива using.</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>Имя "{0}" не существует в текущем контексте.</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>Отсутствует внешний цикл для прерывания или продолжения.</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>Явная реализация интерфейса '{0}' соответствует более чем одному члену интерфейса. Выбор члена интерфейса зависит от реализации. Возможно, требуется использовать неявную реализацию.</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>Ссылка на неопределенную сущность "{0}".</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>Комментарий XML содержит некорректный XML — "{0}".</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Свойства, возвращающие данные по ссылке, должны иметь метод доступа get</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>Несогласованность по доступности: доступность базового интерфейса "{1}" ниже доступности интерфейса "{0}"</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>Дерево выражения не может содержать выражение анонимного метода.</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>лямбда-выражение</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>Требуется определение типа или пространства имен, либо признак конца файла.</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>Строковая константа без признака завершения</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>Недопустимый тип ограничения. Тип, использованный в качестве ограничения, должен быть интерфейсом, незапечатанным классом или параметром-типом.</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>Выражение будет всегда вызывать исключение System.NullReferenceException, так как значение по умолчанию для типа равно NULL</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>Ни "is", ни "as" недопустимы в типах указателей.</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>Параметр типа имеет то же имя, что и параметр, указанный во внешнем типе</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>"{0}": совместимые с CLS интерфейсы должны иметь только совместимые с CLS члены.</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>Выражение анонимного метода не может быть преобразовано в дерево выражения.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Исходный файл указан несколько раз</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>Неверный синтаксис комментария.</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>Расширение "Добавление метода" не поддерживается для инициализатора коллекции в лямбда-выражении.</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>Атрибут "{0}" применим только для индексатора, который не является явным объявлением члена интерфейса.</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>"{0}" не является классом атрибута.</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>Невозможно использовать анонимный тип в константном выражении.</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>Выражения и операторы можно использовать только в теле метода.</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>Тип ограничения "{0}" несовместим с CLS.</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>Оператор "{0}" для операндов "по умолчанию" и "по умолчанию" является неоднозначным.</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>Аргумент типа "{0}" несовместим с CLS.</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>Параметр params должен быть одномерным массивом.</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>Точкой входа программы является глобальный код скрипта; игнорируйте точку входа "{0}".</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>Не удается вызвать абстрактный член базового класса: '{0}'</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>Невозможно преобразовать Null к параметру типа "{0}", так как он может быть типом значения, не допускающим значения Null. Используйте вместо этого "default({0})".</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>Компонент не является частью стандартизированной спецификации ISO языка C# и может не приниматься другими компиляторами</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>Невозможно вернуть по ссылке член локального элемента "{0}", так как это не локальная переменная ref</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>"{0}" не имеет базового класса и не может вызвать базовый конструктор.</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" имеет неправильную сигнатуру элемента инициализатора. Инициализируемый метод Add должен быть доступным методом экземпляра.</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>Указано общедоступное подписывание, для которого требуется открытый ключ, но он не указан.</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>Требуется ")"</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>Не удалось найти исходный файл "{0}".</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>свойство</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>Невозможно вернуть "{0}" по ссылке, так как он доступен только для чтения</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>Анонимная функция, преобразованная в делегата, возвращающего void, не может возвращать значение.</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>Запрещено использовать тип dynamic в шаблоне.</value>
  </data>
  <data name="ERR_RefReadonlyNotField" xml:space="preserve">
    <value>Невозможно использовать {0} "{1}" как значение ref или out, так как это переменная только для чтения</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>Непосредственный вызов деструкторов и функций object.Finalize запрещен. Рекомендуется вызов функции IDisposable.Dispose, если она доступна.</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>Превышение допустимого числа символов в символьной константе.</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>Заданы разные значения контрольной суммы #pragma</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>Значение SecurityAction "{0}" недопустимо для атрибута PrincipalPermission.</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>Неверный оператор объявления массива. Для объявления управляемого массива спецификатор ранга должен предшествовать идентификатору переменной. Чтобы объявить поле буфера фиксированного размера, перед типом поля используйте ключевое слово fixed.</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>В разделяемых объявлениях "{0}" должны быть одинаковыми имена параметров типов, модификаторы изменений и их порядок.</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>'{0}" не может наследовать от специального класса "{1}".</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>Поскольку "{0}" является асинхронным методом, возвращающим Task, после ключевого слова return не может стоять выражение объекта. Предполагалось возвращать "Task&lt;T&gt;"?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>Невозможно использовать "{0}" как значение ref или out, так как он доступен только для чтения</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>Не удалось найти реализацию шаблона запроса для исходного типа "{0}".  "{1}" не найден.</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerMemberNameAttribute можно применять только к параметрам со значениями по умолчанию.</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>Тип конфликтует с импортированным пространством имен</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>Комментарий XML имеет тег param для "{0}", но параметр с таким именем отсутствует.</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>Отсутствует комментарий XML для открытого видимого типа или члена</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>Сравнение с константой интеграции бесполезно: константа находится за пределами диапазона типа</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>Тип определяет оператор == или оператор !=, но не переопределяет Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>Вместо атрибута будет использоваться экземпляр, отображающийся в источнике</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>Не удалось открыть исходный файл "{0}" — {1}.</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>Атрибут "{0}" не допускается для этого типа объявления. Он допустим только для объявлений "{1}".</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>Локальная переменная или параметр с именем "{0}" нельзя объявить в данной области, так как это имя используется во включающей локальной области для определения локальной переменной или параметра</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>"{0}" является типом "{1}". Значение по умолчанию для параметра, имеющее ссылочный тип, который отличается от string, может инициализироваться только значением Null.</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>Внедрение типов взаимодействия из сборки "{0}" невозможно, так как у нее отсутствует атрибут "{1}" или атрибут "{2}".</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>Тип ограничения "{0}" несовместим с CLS.</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>Статическому полю или свойству "{0}" не может быть присвоено значение внутри инициализатора объекта.</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>Повторяющийся атрибут "{0}"</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>Атрибут "{0}" допустим только для классов, наследуемых из System.Attribute.</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>Сравнение со значением NULL или типом структуры всегда вызывает false</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>Атрибут RequiredAttribute не разрешен для типов C#.</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>Допускается использование только 65 534 локальных переменных с учетом тех, которые были созданы компилятором.</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>Непостоянное поле обычно не должно использоваться в качестве значения ref или out, так как оно не будет считаться непостоянным. Существуют исключения, например при вызове заблокированного API.</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>Не удается внедрить тип взаимодействия "{0}", находящийся в обеих сборках "{1}" и "{2}". Попробуйте задать свойству "Внедрить типы взаимодействия" значение False.</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>слишком длинный или недопустимый путь.</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>'{1} {0}" имеет неправильный возвращаемый тип.</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>Тип не реализует шаблон коллекции: член содержит неправильную подпись</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>async main</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>Член "{0}" не найден в типе "{1}" из сборки "{2}".</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>Конечный тег в этом месте не ожидался.</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>"{1}": не может быть производным от статического класса "{0}"</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>Доступ к члену в "{0}" может вызвать исключение времени исполнения, поскольку он является полем класса, который маршалируется по ссылке.</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>Тип должен быть "var".</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>Требуется выражение.</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>Дружественный доступ предоставлен "{0}", однако открытый ключ выходной сборки не соответствует ключу, определенному атрибутом предоставляющей сборки.</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>'{0}" является типом, который не поддерживается в данном языке.</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>Выражение должно быть неявно преобразуемым в логическое значение, или его тип "{0}" должен определять оператор "{1}".</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>Объект может быть освобожден несколько раз</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>Применение CallerMemberNameAttribute к параметру "{0}" ни к чему не приведет. Он переопределяется с помощью CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>Ссылка на сборку недопустима и не может быть разрешена</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>Параметр для операторов ++ и -- должен иметь вмещающий тип.</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>Не удалось найти значение RuntimeMetadataVersion</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>Для нестатического поля, метода или свойства "{0}" требуется ссылка на объект.</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>'{0}": в интерфейсах невозможно объявлять типы</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>Тип или член не может быть помечен как совместимый с CLS, так как сборка не содержит атрибут CLSCompliant</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>'{0}": возвращаемый тип должен быть "{2}", чтобы соответствовать переопределенному члену "{1}".</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>Отправка может иметь максимум одно синтаксическое дерево.</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>Нет перегруженного метода для "{0}", который соответствует делегату "{1}".</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>Недопустимый тип параметра в атрибуте cref комментария XML</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>Невозможно указать атрибут DefaultMember для типа, содержащего индексатор.</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>Уровень предупреждений должен быть в диапазоне 0–4.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>индексатор, воплощающий выражение</value>
  </data>
  <data name="ERR_LocalFunctionMissingBody" xml:space="preserve">
    <value>"{0}" — это локальная функция, и поэтому всегда должна иметь тело.</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>'{0}": не может наследовать от динамического типа.</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>дерево не является частью компиляции</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>Лямбда-выражение дерева выражений не может содержать объединяющий оператор с литералом NULL или литералом по умолчанию в качестве левого операнда.</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>Синтаксическая ошибка, требуется "{0}"</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>Нераспознанное расположение атрибута</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>Инициализатор элемента не может быть пустым.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>Тип выражения в предложении {0} неверен.  Ошибка определения типа при вызове в "{1}".</value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>фильтр исключений</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>Объявления разделяемого метода "{0}" имеют несовместимые ограничения параметров типов.</value>
  </data>
</root>