<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>Dla wyjść bez źródła trzeba określić opcję /out.</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>Dzielenie przez wartość stałą wynoszącą zero</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>„{0}” nie jest prawidłowym argumentem nazwanego atrybutu, ponieważ nie jest to prawidłowy typ parametru atrybutu</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>Komentarz XML ma nieprawidłowo sformułowany kod XML</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Niektóre typy zestawu analizatora {0} zostaną pominięte z powodu wyjątku ReflectionTypeLoadException: {1}.</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>Pole jest przypisane, ale jego wartość nie jest nigdy używana</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać operatora przypisania.</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>Nie można odnaleźć przynajmniej jednego typu wymaganego do skompilowania wyrażenia dynamicznego. Czy nie brakuje odwołania?</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>Element „{0}” jest przestarzały: „{1}”</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jest to konstruktor, destruktor, operator lub jawna implementacja interfejsu</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Nieprawidłowa nazwa modułu: {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>„{0}”: zdefiniowane przez użytkownika konwersje na lub z klasy bazowej nie są dozwolone</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>„{0}”: nie można odwołać się do typu przy użyciu wyrażenia. Spróbuj użyć „{1}”</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>Wersja kompilatora: „{0}”. Wersja języka: {1}.</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>iteratory</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>Strona kodowa „{0}” jest nieprawidłowa lub niezainstalowana</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>Przestarzały element członkowski „{0}” przesłania nieprzestarzały element członkowski „{1}”.</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>Brak zamykającego znaku cudzysłowu dla literału ciągu.</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>Kompilacja anulowana przez użytkownika</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Odwołania do metadanych nie są obsługiwane.</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>Treść zapytania musi kończyć się klauzulą „select” lub „group”.</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>Instrukcja switch zawiera wiele etykiet case o wartości „{0}”</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>Oczekiwano identyfikatora; „{1}” jest słowem kluczowym</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>Nieprawidłowa wartość „{0}”: „{1}”.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać niebezpiecznej operacji wskaźnika</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>Znaleziono nieprawidłowy znak wewnątrz odwołania do jednostki.</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać metody z argumentami zmiennych</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>Przełącznik wiersza polecenia nie jest jeszcze zaimplementowany</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>Kompilator niejawnie poszerzył zmienną i rozszerzył jej znak, a następnie użył wartości wynikowej w operacji bitowej OR. Może to powodować nieoczekiwane działanie.</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>Do wskaźnika należy zastosować operator * lub -&gt;</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>Nie można zastosować operatora „{0}” do argumentów operacji typu „{1}” lub „{2}”.</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>Nie można oznaczyć typu jako zgodnego ze specyfikacją CLS, ponieważ jest to element członkowski typu niezgodnego ze specyfikacją CLS</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField2" xml:space="preserve">
    <value>Elementy członkowskie elementu {0} „{1}” nie mogą być zwracane przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>W elemencie „{0}” nie może wystąpić deklaracja treści, ponieważ jest on oznaczony jako abstrakcyjny</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>Niespójność dostępności: typ zdarzenia „{1}” jest mniej dostępny niż zdarzenie „{0}”</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>Element członkowski „{0}” przesłania przestarzały element członkowski „{1}”. Dodaj atrybut Obsolete do elementu członkowskiego „{0}”.</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Wykryto nieosiągalny kod</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>Typ lub element członkowski nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Rozważ jawne określenie typu zmiennej zakresu „{2}”.</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>„{0}” to nie jest prawidłowy numer ostrzeżenia</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak niejawnej konwersji odwołania z typu „{3}” na „{1}”.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>Metoda, operator lub metoda dostępu są oznaczone jako zewnętrzne i nie zawierają atrybutów</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>Nazwa destruktora musi być zgodna z nazwą klasy</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>Nie można przekazać zmiennej zakresu „{0}” jako parametru ze specyfikatorem out lub ref</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>Pętla foreach musi deklarować swoje zmienne iteracji.</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>Dla metody oznaczonej przy użyciu słów kluczowych „static” i „extern” musi zostać określony atrybut DllImport</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>metoda częściowa</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>Pole „{0}” jest przypisane, lecz jego wartość nie jest nigdy używana</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>Nie można użyć instrukcji yield w treści klauzuli finally.</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;przestrzeń nazw&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>Operatora „await” można użyć tylko w wyrażeniu zapytania w pierwszym wyrażeniu kolekcji początkowej klauzuli „from” albo w wyrażeniu kolekcji klauzuli „join”.</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>Domyślna wartość określona dla parametru „{0}” nie odniesie żadnego skutku, ponieważ jest zastosowana dla elementu członkowskiego używanego w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>„{0}”: jawna deklaracja interfejsu może występować tylko w klasie lub strukturze</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>Nie można ponownie zdefiniować globalnego aliasu zewnętrznego</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do parametrów. Zamiast tego spróbuj umieścić go w metodzie.</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>To ostrzeżenie występuje, gdy blok catch() nie ma określonego typu wyjątku po bloku catch (System.Exception e). Ostrzeżenie zawiera zalecenie, aby blok catch() nie przechwytywało żadnych wyjątków.

Blok catch() po bloku catch (System.Exception e) może przechwytywać wyjątki niezgodne ze specyfikacją CLS, jeśli element RuntimeCompatibilityAttribute ma ustawioną wartość false w pliku AssemblyInfo.cs: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. Jeśli ten atrybut nie ma jawnie ustawionej wartości false, wszystkie zgłaszane wyjątki niezgodne ze specyfikacją CLS są opakowywane jako wyjątki przez blok catch (System.Exception e).</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania wewnątrz klauzuli „catch”</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>Nie można dekonstruować obiektów dynamicznych.</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>Nie można użyć wyrażenia w tym kontekście, ponieważ może ono nie zostać przekazane lub zwrócone przez odwołanie</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>Opcja /reference, która deklaruje alias zewnętrzny, może mieć tylko jedną nazwę pliku. Aby określić wiele aliasów lub nazw plików, użyj wielu opcji /reference.</value>
  </data>
  <data name="ERR_StackAllocConversionNotPossible" xml:space="preserve">
    <value>Konwersja wyrażenia stackalloc typu „{0}” na typ „{1}” nie jest możliwa.</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>Brak zamykającego znaku ograniczającego „}” dla interpolowanego wyrażenia rozpoczynającego się od znaku „{”.</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>Instrukcja foreach nie może operować na zmiennych typu „{0}”, ponieważ „{0}” nie zawiera definicji publicznej elementu „{1}”</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Błąd podczas odczytywania pliku zestawu reguł {0} — {1}</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Nie wywołuj bezpośrednio metody Finalize klasy podstawowej. Metoda jest wywoływana automatycznie z destruktora.</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>„{0}”: wartość, która wystąpiła w module wyliczającym, jest zbyt duża, aby można było ją stosować przy użyciu typu tego modułu</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora. Nazwa pliku jest za długa lub nieprawidłowa.</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>Typ lub element członkowski jest przestarzały</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>Nie można wywnioskować argumentów typu dla metody „{0}” na podstawie użytkowania. Spróbuj jawnie określić argumenty typu.</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>Brak atrybutu pliku</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>Brak atrybutu ścieżki</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>Niezarządzany typ „{0}” jest nieprawidłowy dla pól.</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z kontenera „{0}” — {1}</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>Operator „{0}” wymaga zdefiniowanego zgodnego operatora „{1}”</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>Inicjator pola nie może odwoływać się do niestatycznego pola, metody lub właściwości „{0}”.</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>automatycznie implementowane właściwości tylko do odczytu</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>Pól pola statycznego tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze statycznym)</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>modyfikatory dostępu we właściwościach</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>Nieprawidłowy token „{0}” w deklaracji elementu członkowskiego klasy, struktury lub interfejsu</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>Nie można znaleźć pliku metadanych „{0}”</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>„{0}” nie ma wstępnie zdefiniowanego rozmiaru, dlatego elementu sizeof można użyć tylko w kontekście słowa kluczowego „unsafe” (użyj elementu System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>Określono nieprawidłową ścieżkę wyszukiwania „{0}” w elemencie „{1}” — „{2}”</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>Nie można zwrócić pól elementu „{0}” przez odwołanie, ponieważ to jest element „{1}”</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>Nie można przekonwertować {0} na typ delegowany „{1}”, ponieważ typy parametrów nie pasują do typów parametru delegowanego</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>Tylko elementy członkowskie zgodne ze specyfikacją CLS mogą być abstrakcyjne</value>
  </data>
  <data name="IDS_FeaturePrivateProtected" xml:space="preserve">
    <value>prywatny chroniony</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>Zestaw i moduł „{0}” nie mogą wskazywać różnych procesorów.</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania w treści instrukcji „lock”</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>Statycznego pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze statycznym)</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>Atrybut „{0}” nie jest prawidłowy w metodach dostępu do właściwości lub zdarzeń. Jest on prawidłowy tylko w deklaracjach „{1}”.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>Nieużywany alias zewnętrzny</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>Nieprawidłowy numer</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>typ wariancji</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>katalog nie istnieje</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>Aby element „{0}” można było zastosować jako operator „short circuit”, jego typ deklarujący „{1}” musi definiować operatory true i false</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>Oczekiwano zagnieżdżonego inicjatora tablicy</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>Tylko typy klasy mogą zawierać destruktory</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>Przydział dekonstrukcji wymaga wyrażenia o typie podanym po prawej stronie.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Nieprawidłowe wyrównanie sekcji pliku „{0}”</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Anonimowe metody, wyrażenia lambda i wyrażenia zapytania wewnątrz struktur nie mogą uzyskiwać dostępu do elementów członkowskich wystąpień elementu „this”. Rozważ możliwość skopiowania elementu „this” do zmiennej lokalnej poza metodą anonimową, wyrażeniem lambda lub wyrażeniem zapytania i użycie zamiast niego elementu lokalnego.</value>
  </data>
  <data name="ERR_AssignReadonlyNotField2" xml:space="preserve">
    <value>Nie można przypisać do elementu członkowskiego {0} „{1}”, ponieważ jest to zmienna tylko do odczytu</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>Warunkowy element członkowski „{0}” nie może implementować elementu członkowskiego interfejsu „{1}” w typie „{2}”</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>Klasa statyczna „{0}” nie może pochodzić od typu „{1}”. Klasy statyczne muszą pochodzić od obiektu.</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>Pól statycznego pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>Typ „{0}” jest zdefiniowany w tym zestawie, ale zdefiniowano dla niego funkcję przesyłania typu dalej</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>Wyrażenie jest zbyt długie lub zbyt złożone do skompilowania</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza po dyrektywie #pragma</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>'{0}': dla właściwości zdarzenia muszą istnieć metody dostępu Add i Remove</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>Oczekiwano symbolu { lub ; lub =&gt;</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>Celem przywołanego zestawu jest inny procesor</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>Nie można znaleźć zarządzanej klasy otoki coclass „{0}” interfejsu „{1}” (brak odwołania do zestawu?)</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>Element „{0}” nie implementuje wzorca „{1}”. Elementy „{2}” i „{3}” są wzajemnie niejednoznaczne.</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>Nieprawidłowa opcja „{0}” dla /langversion. Użyj opcji „/langversion:?”, aby wyświetlić listę obsługiwanych wartości.</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>Nazwa kwalifikowana za pomocą aliasu nie jest wyrażeniem.</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>Oczekiwano identyfikatora.</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>Wartości „goto case” nie można jawnie przekonwertować na typ „{0}”</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>Przypisanie w wyrażeniu warunkowym jest zawsze stałe</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>Warunkowy element członkowski „{0}” nie może mieć parametru wyjściowego</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania w kontekście słowa kluczowego „unsafe”.</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>Osadzona instrukcja nie może być instrukcją deklaracji ani instrukcją etykiety.</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>Konstruktor jest oznaczony jako zewnętrzny</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>inicjator kolekcji</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany.</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>automatycznie zaimplementowane właściwości</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>Dynamicznie wysłane wywołanie metody „{0}” może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa.</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>Typ lub element członkowski jest przestarzały</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>Konstruktor „{0}” jest oznaczony jako zewnętrzny</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>„{0}”: klasy statyczne nie mogą implementować interfejsów</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>Osadzona struktura międzyoperacyjna „{0}” może zawierać tylko publiczne pola wystąpień.</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>Nie może pochodzić od „{0}”, ponieważ jest to parametr typu</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>Typ zmiennej lokalnej zadeklarowanej w instrukcji fixed musi być typem wskaźnika</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>alias zewnętrzny</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do parametrów</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>Pierwszy operand operatora „as” nie może być literałem krotki bez typu naturalnego.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Nieprawidłowy rodzaj instrumentacji: {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>Nie można zadeklarować przestrzeni nazw w kodzie skryptu</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>Typ zmiennej publicznej, chronionej zmiennej lub chronionej zmiennej wewnętrznej musi być zgodny ze specyfikacją CLS (Common Language Specification).</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>Modyfikatory dostępu częściowych deklaracji elementu „{0}” powodują konflikt</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”.</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>Możliwe niezamierzone porównanie odwołań; prawa strona wymaga rzutowania</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>Nie można zapisać do pliku wyjściowego „{0}” — „{1}”</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>Oczekiwano słowa kluczowego „this” lub „base”</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>Nie można użyć instrukcji „yield” w kodzie skryptu najwyższego poziomu</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>Metoda asynchroniczna nie zawiera operatorów „await” i zostanie uruchomiona synchronicznie</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ występuje w wielu zestawach w aliasie globalnym</value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>„{0}”: argument atrybutu nie może używać parametrów typu</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>Oczekiwano operatora z możliwością przeciążenia</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>Polom statycznego pola tylko do odczytu „{0}” nie można przypisać wartości (z wyjątkiem pól w konstruktorze statycznym lub inicjatorze zmiennych).</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>Nie określono plików źródłowych.</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>Element „{0}” ma nieprawidłową sygnaturę i nie może być punktem wejścia</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>Klauzule catch nie mogą następować po ogólnej klauzuli catch instrukcji try.</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>Brak argumentu</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>Nie można skonwertować wyrażenia lambda na drzewo wyrażenia, którego argument typu „{0}” nie jest typem delegowanym</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>Rozpatrywana operacja jest niezdefiniowana we wskaźnikach void</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>Delegat „{0}” nie ma metody wywołania lub ma metodę wywołania z typem zwracanym lub typami parametrów, które nie są obsługiwane.</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>operator nameof</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>Nie można przyjąć adresu, pobrać rozmiaru lub zadeklarować wskaźnika typu zarządzanego („{0}”)</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>Funkcja „{0}” nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>Atrybut „{0}” podany w pliku źródłowym jest w konflikcie z opcją „{1}”.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>Parametr {0} nie powinien być deklarowany za pomocą słowa kluczowego „{1}”</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania w treści klauzuli „finally”.</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>Oczekiwano typu object, string lub class</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>Połączone metadane modułu netmodule muszą określać pełny obraz PE: „{0}”.</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>Nie zaleca się definiowania aliasu o nazwie „global”</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>W inicjatorach konstruktora, pola i właściwości nie można używać deklaracji zmiennej „out” ani zmiennej wzorca.</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred można używać tylko z /t:exe, /t:winexe i /t:appcontainerexe</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>„{0}”: klasa o atrybucie ComImport nie może określać klasy podstawowej</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>Ponieważ element „{1}” ma atrybut ComImport, element „{0}” musi być zewnętrzny lub abstrakcyjny</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>zmienna ustalona</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>Nazwa {0} powoduje konflikt nazw</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>Poprzednia klauzula catch przechwytuje już wszystkie wyjątki tego typu lub jego nadtypu („{0}”)</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>Użycie prawdopodobnie nieprzypisanego pola „{0}”</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>Treści bloku i treści wyrażenia nie mogą być jednocześnie udostępnione.</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>W języku C# nie można użyć elementu System.Void. Aby uzyskać obiekt typu void, użyj elementu typeof(void).</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>Podany tryb dokumentacji jest nieobsługiwany lub nieprawidłowy: „{0}”.</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>Dla argumentu operacji typu „{0}” operator „{1}” jest niejednoznaczny.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>Nazwa elementu krotki została zignorowana, ponieważ element docelowy przypisania określa inną nazwę lub nie określa żadnej nazwy.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>Przywoływany zestaw nie ma silnej nazwy</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>Metoda częściowa nie może jawnie implementować metody interfejsu.</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>wyrażenie lambda</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” dla metody Main, ponieważ jest on zaimportowany</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>Parametr operatora jednoargumentowego musi być typem zawierającym</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>Struktury nie mogą zawierać jawnych konstruktorów bez parametrów</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>Długość stałej typu String przekracza bieżący limit pamięci. Spróbuj podzielić ciąg na wiele stałych.</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>Pole „{0}” musi być całkowicie przypisane przed zwróceniem sterowania do elementu wywołującego</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>Aby włączyć sprawdzanie zgodności ze specyfikacją CLS, należy określić atrybut CLSCompliant dla zestawu, a nie dla modułu</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>Przywoływany zestaw „{0}” nie ma silnej nazwy.</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>przestrzeń nazw</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>Wystąpiło niejednoznaczne wywołanie między następującymi dwiema metodami lub właściwościami: „{0}” i „{1}”</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>Wartość stałej zmiennoprzecinkowej jest spoza zakresu typu „{0}”</value>
  </data>
  <data name="ERR_InvalidDebugInfo" xml:space="preserve">
    <value>Nie można odczytać informacji debugowania metody „{0}” (token 0x{1:X8}) z zestawu „{2}”</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>Nie można wyemitować informacji debugowania dla tekstu źródłowego bez kodowania.</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>Nieprawidłowa opcja „{0}”; widoczność zasobu musi mieć wartość „public” lub „private”</value>
  </data>
  <data name="ERR_ExplicitReservedAttr" xml:space="preserve">
    <value>Nie używaj elementu „{0}”. Jest on zarezerwowany do użycia przez kompilator.</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>Nie można przywrócić ostrzeżenia, ponieważ zostało globalnie wyłączone</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>Element „__arglist” jest niedozwolony w liście parametrów iteratorów.</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>Nie można przekonwertować elementu async {0} na typ delegowany „{1}”. Element async {0} może zwrócić wartość void, Task lub Task&lt;T&gt;, a żadne z tych typów nie mogą być przekonwertowane na „{1}”.</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>Zduplikowany atrybut „{0}”</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>Oczekiwano tagu końcowego dla elementu „{0}”.</value>
  </data>
  <data name="IDS_FeatureLeadingDigitSeparator" xml:space="preserve">
    <value>wiodący separator cyfr</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Argumenty typu nie są dozwolone w operatorze nameof.</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>Typ lub przestrzeń nazw „{0}” nie występuje w przestrzeni nazw „{1}” (czy nie brakuje odwołania do zestawu?)</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>„{0}”: nie można udostępnić argumentów podczas tworzenia wystąpienia typu zmiennej</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>Błąd odczytu zasobów Win32 — {0}</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Nie można odnaleźć nazwy typu „{0}” w globalnej przestrzeni nazw. Ten typ został przesłany dalej do zestawu „{1}”. Rozważ możliwość dodania odwołania do tego zestawu.</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>Nie można zwrócić wyrażenia typu „void”.</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>Parametr ref lub out nie może mieć wartości domyślnej</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>Nie można znaleźć nazwy typu „{0}”. Ten typ został przekazany do zestawu „{1}”. Rozważ dodanie odwołania do tego zestawu.</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>Iteratory nie mogą mieć zmiennych lokalnych dostępnych przez odwołanie</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>Nie można określić wartości domyślnej dla parametru „this”</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>Podane wyrażenie nigdy nie jest określonego typu („{0}”)</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>Komentarz XML ma tag typeparam, ale nie ma parametru typu o takiej nazwie</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>Obie deklaracje metody częściowej muszą być niezabezpieczone albo żadna z nich nie może być niezabezpieczona.</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>Drugi operand operatora „is” lub „as” nie może być typem statycznym „{0}”</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>Typ podstawowy został oznaczony jako element, który nie musi być zgodny ze specyfikacją CLS (Common Language Specification), w zestawie oznaczonym jako zgodny ze specyfikacją CLS. Usuń atrybut określający, że zestaw jest zgodny ze specyfikacją CLS, lub usuń atrybut określający, że typ nie jest zgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>Metoda z atrybutem vararg nie może być ogólna, znajdować się w typie ogólnym ani mieć parametru params</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>Operator „await” wymaga, aby typ {0} miał przypisaną odpowiednią metodę GetAwaiter. Czy brakuje dyrektywy użytkowania dla „Systemu”?</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>Oczekiwano znaku ; lub = (w deklaracji nie można określić argumentów konstruktora).</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>Typ zwracany operatora True lub False musi być typem logicznym</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>Ograniczenie nie może być specjalną klasą „{0}”</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” przesłanym do zestawu „{3}”.</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>Wartości domyślne w tym kontekście są nieprawidłowe.</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Delegat „{0}” nie ma parametru o nazwie „{1}”</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>Element „{0}” nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>Interfejs źródłowy „{0}” nie zawiera metody „{1}” wymaganej do osadzenia zdarzenia „{2}”.</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>Parametr „{0}” konstruktora atrybutu jest opcjonalny, ale nie została podana wartość domyślna parametru.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać operatora propagowania wartości null.</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>Nie znaleziono aliasu „{0}”</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>Zduplikowana inicjacja elementu członkowskiego „{0}”</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>Nieprawidłowa opcja „{0}” dla opcji /debug; wymagana wartość to „portable”, „embedded”, „full” lub „pdbonly”</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>Wewnątrz inicjatora instrukcji fixed można pobrać jedynie adres nieustalonego wyrażenia</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>„{0}”: klasa o atrybucie ComImport nie może określać inicjatorów pola.</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>„{0}”: nie można zadeklarować indeksatorów w klasie statycznej</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>Interfejs „{0}” już wyszczególniono na liście interfejsów</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>Obiekt „this” nie może być używany przed przypisaniem wszystkich jego pól</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>„{0}”: właściwość lub indeksator musi mieć co najmniej jedna metodę dostępu</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>Zmienne o typie określonym niejawnie nie mogą być stałymi</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>Zmienna została zadeklarowana przy użyciu tej samej nazwy co zmienna w klasie podstawowej. Jednak nie użyto słowa kluczowego new. To ostrzeżenie informuje o konieczności użycia słowa kluczowego new. Zmienna została zadeklarowana tak, jakby użyto słowa kluczowego new w deklaracji.</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż metoda „{0}”</value>
  </data>
  <data name="ERR_FieldsInRoStruct" xml:space="preserve">
    <value>Wystąpienia pól struktur tylko do odczytu muszą być tylko do odczytu.</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów znakowych.</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>Użycie tablic jako argumentów atrybutów jest niezgodne ze specyfikacją CLS</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>Wartość wyrównania {0} jest większa niż {1} i może powodować powstanie ciągu w dużym formacie.</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>deklaracja zmiennej wyjściowej</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>Porównanie ze stałą całkowitoliczbową jest bezcelowe. Stała jest poza zakresem typu „{0}”.</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>„eksperymentalna”</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>Typ „{0}” z zestawu „{1}” nie może być używany między granicami zestawów, ponieważ ma argument typu ogólnego, który jest osadzonym typem międzyoperacyjnym.</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction" xml:space="preserve">
    <value>Funkcja lokalna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>Operatora „as” należy używać z typem referencyjnym lub typem dopuszczającym wartość null („{0}” jest typem niedopuszczającym wartości null)</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>Abstrakcyjny element {0} „{1}” nie może być oznaczona jako wirtualny</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>„{0}”: klasy statyczne nie mogą zawierać operatorów zdefiniowanych przez użytkownika</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>Etykieta „{0}” zasłania inną etykietę o takiej samej nazwie w zawartym zakresie</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>Element członkowski „{1}” przesłania element „{0}”. W czasie wykonywania jest możliwych wiele różnych przesłonięć. Od implementacji zależy, która metoda zostanie wywołana.</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>Oczekiwano metody dostępu get lub set.</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>Nie używaj atrybutu „System.ParamArrayAttribute”. Zamiast niego użyj słowa kluczowego „params”.</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>W klasie zapieczętowanej zadeklarowano nowy chroniony element członkowski</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Typ przesłany „{0}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>Konstruktor „{0}” nie może wywołać się za pośrednictwem innego konstruktora</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>Przywoływany plik „{0}” nie jest zestawem</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>Przeciążony operator binarny „{0}” przyjmuje dwa parametry</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jest to metoda przesłonięcia</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>Adresu elementu lokalnego „{0}” lub jego elementów członkowskich nie można pobrać i użyć wewnątrz metody anonimowej lub wyrażenia lambda.</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>Oczekiwano elementu SearchCriteria.</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać konstruktorów</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>Ponieważ element „{0}” zwraca wartość typu void, po słowie kluczowym nie może występować wyrażenie obiektu</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>Zdefiniowany przez użytkownika operator nie może pobrać obiektu typu otaczającego i dokonać konwersji na obiekt typu otaczającego</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>Nie można kontynuować, ponieważ edycja zawiera odwołanie do typu osadzonego: „{0}”</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Ponieważ to wywołanie nie jest oczekiwane, wykonywanie bieżącej metody będzie kontynuowane bez oczekiwania na ukończenie wywołania. Rozważ możliwość zastosowania operatora „await” do wyniku wywołania.</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” jest statyczny lub nie jest publiczny.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>Wywołaj metodę Call System.IDisposable.Dispose() dla alokowanego wystąpienia elementu {0}, zanim wszystkie odwołania do niego znajdą się poza zakresem.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>Alokowane wystąpienie elementu {0} nie jest usuwane we wszystkich ścieżkach wyjątku. Wywołaj metodę System.IDisposable.Dispose(), zanim wszystkie odwołania do niego znajdą się poza zakresem.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>Drzewo składni do przeanalizowania nie może należeć do drzewa składni bieżącej kompilacji.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>Atrybut zabezpieczeń „{0}” ma nieprawidłową wartość SecurityAction „{1}”</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>Aby rzutować wartość ujemną, musisz ją ująć w nawias.</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>Lokalna nazwa „{0}” jest za długa dla pliku PDB. Rozważ skrócenie jej lub skompilowanie bez opcji /debug.</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>Oczekiwano definicji elementu członkowskiego, instrukcji albo znacznika końca pliku</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>To wywołanie nie jest oczekiwane, dlatego wykonywanie bieżącej metody będzie kontynuowane do czasu ukończenia wywołania</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>Klauzula „using” musi występować przed wszystkimi innymi elementami zdefiniowanymi w przestrzeni nazw poza deklaracjami aliasów zewnętrznych.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>Operatora „await” można używać tylko w metodzie asynchronicznej. Rozważ oznaczenie tej metody za pomocą modyfikatora „async” i zmianę jej typu zwracanego na „Task&lt;{0}&gt;”.</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>Ustalony bufor może mieć tylko jeden wymiar.</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>zmienna</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>Nie można użyć aliasu „{0}” ze znakami „::”, ponieważ alias odwołuje się do typu. Użyj znaku „.”.</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Napotkano znacznik konfliktu scalania</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Deklaracje InternalsVisibleTo nie mogą mieć określonej wersji, kultury, tokena klucza publicznego ani architektury procesora.</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>Pusty literał znakowy</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>Nie można dodać elementu „{0}” do tego zestawu, ponieważ jest to już zestaw</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>Publiczne podpisywanie nie jest obsługiwane w przypadku modułów sieciowych.</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>Pole ani właściwość nie może mieć typu „{0}”</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>Nazwy elementów krotek nie są dozwolone po lewej stronie dekonstrukcji.</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać grupy metod</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>Nie można powiązać obiektu delegowanego z elementem „{0}”, ponieważ jest to członek typu „System.Nullable&lt;T&gt;”.</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>metoda</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu w takiej samej kolejności</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>Znaków „{0}” nie można użyć w tej lokalizacji.</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>Operatora „await” można używać tylko w elemencie asynchronicznym {0}. Rozważ oznaczenie elementu {0} za pomocą modyfikatora „async”.</value>
  </data>
  <data name="ERR_RefExtensionMustBeValueTypeOrConstrainedToOne" xml:space="preserve">
    <value>Pierwszy parametr metody rozszerzenia „ref” „{0}” musi być typem wartości lub typem ogólnym ograniczonym do struktury.</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>Tworzenie łańcuchów spekulacyjnego modelu semantycznego nie jest obsługiwane. Należy utworzyć model spekulacyjny z nadrzędnego modelu niespekulacyjnego.</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>W programie zdefiniowano więcej niż jeden punkt wejścia. Skompiluj z opcją /main, aby określić typ zawierający punkt wejścia.</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>Wyrażenie filtru jest stałą, rozważ usunięcie filtru</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_2" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 7.2. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 7.1. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML „{1}” pliku „{0}” — {2}</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>Punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>Element „{0}” nie ma odpowiedniej statycznej metody Main</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>W pełni kwalifikowana nazwa elementu „{0}” jest za długa dla informacji debugowania. Skompiluj bez opcji „/debug”.</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>Parametry opcjonalne muszą występować po wszystkich parametrach wymaganych</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>Ostrzeżenie przesłania błąd</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>Brak odwołania do tej etykiety</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>Zmienna „{0}” jest zadeklarowana, lecz nie jest nigdy używana</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>Użycie ogólnego elementu {1} „{0}” wymaga argumentów typu „{2}”</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>Oczekiwano dyrektywy #endif.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>Bieżąca metoda wywołuje metodę asynchroniczną, która zwraca zadanie lub wynik Task&lt;TResult&gt; i która nie stosuje operatora await do wyniku. Wywołanie metody asynchronicznej rozpoczyna zadanie asynchroniczne. Jednak ze względu na niezastosowanie operatora await działanie programu będzie kontynuowane bez oczekiwania na zakończenie zadania. W większości przypadków jest to nieoczekiwane zachowanie. Przeważnie inne aspekty metody wywołującej zależą do wyników wywołania lub przynajmniej działanie wywołanej metody powinno zakończyć się przed powrotem z metody zawierającej wywołanie.

Równie ważnym problemem jest to, co dzieje się z wyjątkami zgłoszonymi przez wywołaną metodę asynchroniczną. Wyjątek zgłoszony w ramach metody zwracającej zadanie lub wynik Task&lt;TResult&gt; jest przechowywany w zwróconym zadaniu. Jeśli nie wykonasz operacji await dla zadania ani jawnie nie wyszukasz wyjątków, wyjątek zostanie utracony. Jeśli wykonasz operację await dla zadania, wyjątek zostanie ponownie zgłoszony.

Najlepsze rozwiązanie to wykonywanie operacji await dla zadania za każdym razem.

Pominięcie ostrzeżenia należy wziąć pod uwagę tylko w sytuacji, gdy na pewno nie chcesz czekać na zakończenie wywołania asynchronicznego oraz gdy wywołana metoda nie zgłosi żadnych wyjątków. W tym przypadku można pominąć ostrzeżenie, przydzielając wynik zadania wywołania do zmiennej.</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>wyrażenie zapytania</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>Nieprawidłowa wartość argumentu dla atrybutu „{0}”</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>Zestaw agnostyczny nie może mieć modułu specyficznego dla procesora „{0}”.</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>Specyfikator formatu nie może kończyć się białym znakiem.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>Zmienna jest przypisana, ale jej wartość nie jest nigdy używana</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>Metoda dostępu add lub remove musi mieć treść</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>Jawna implementacja metody „{0}” nie może implementować elementu „{1}”, ponieważ jest to metoda dostępu</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>Element członkowski implementuje element członkowski za pomocą wielu dopasowań w czasie wykonywania</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>Komentarz XML zawiera zduplikowany tag param dla elementu „{0}”</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>Nazwa typu wyliczeniowego „{0}” jest zarezerwowana i nie można jej użyć</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać inicjatora słownika.</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>Element członkowski „{0}” nie ukrywa elementu członkowskiego z możliwością dostępu. Słowo kluczowe new nie jest wymagane.</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgumentInDynamicInvocation" xml:space="preserve">
    <value>Specyfikacje argumentu nazwanego muszą występować po wszystkich stałych argumentach, które zostały określone w dynamicznym wywołaniu.</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>Numer przekazany do dyrektywy preprocesora ostrzeżenia #pragma nie jest prawidłowym numerem ostrzeżenia. Upewnij się, że numer reprezentuje ostrzeżenie, a nie błąd.</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>Instrukcja await w blokach catch i finally</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>„{0}”: punkt wejścia nie może być elementem ogólnym ani być typu ogólnego</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>„{0}” nie zawiera definicji dla „{1}”, a najlepsze przeciążenie metody rozszerzenia „{2}” wymaga odbiorcy typu „{3}”</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>Dyrektywa #r jest dozwolona tylko w skryptach</value>
  </data>
  <data name="ERR_DynamicLocalFunctionTypeParameter" xml:space="preserve">
    <value>Nie można przekazać argumentu o typie dynamicznym do ogólnej funkcji lokalnej „{0}” z argumentami typu wywnioskowanego.</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Drzewo składni już istnieje</value>
  </data>
  <data name="ERR_BadParameterModifiersOrder" xml:space="preserve">
    <value>Modyfikator parametru „{0}” nie może być używany po modyfikatorze „{1}”</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Nieprawidłowa nazwa wyjścia: {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>W klasie z atrybutem ComImport nie może występować konstruktor zdefiniowany przez użytkownika.</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>Zwracane wyrażenie musi być typu „{0}”, ponieważ ta metoda zwraca wartość przez odwołanie</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Właściwości zaimplementowane automatycznie w interfejsach muszą mieć metody dostępu get.</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>Identyfikator „{0}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Błąd podczas odczytywania informacji dotyczących debugowania elementu „{0}”</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>Klasy statyczne nie mogą zawierać destruktorów</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>Podane wyrażenie jest zawsze określonego typu („{0}”)</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>Odwołania do plików źródłowych nie są obsługiwane.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>Nie ma zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury „{0}”. Aby określić kolejność, wszystkie pola wystąpienia muszą znajdować się w tej samej deklaracji.</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>Niespójność dostępności: typ zwracany indeksatora „{1}” jest mniej dostępny niż indeksator „{0}”</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>Pole zgodne ze specyfikacją CLS nie może być nietrwałe</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż metoda „{0}”</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>drzewo musi zawierać węzeł główny z elementem SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>Jako instrukcji można używać tylko wyrażeń przypisania, wywołania, zwiększenia, zmniejszenia oraz utworzenia nowego obiektu.</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>Atrybut CallerFilePathAttribute zastosowany do parametru „{0}” nie będzie mieć efektu, ponieważ jest stosowany do elementu członkowskiego używanego w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>Element params jest nieprawidłowy w tym kontekście.</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać parametru out ani ref</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>Nie można zainicjować typu „{0}” za pomocą inicjatora kolekcji, ponieważ nie implementuje on interfejsu „System.Collections.IEnumerable”</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>Pierwszy argument operacji przeciążonego operatora przesunięcia musi mieć taki sam typ co typ zawierający, a typ drugiego argumentu operacji musi być typem int</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>inicjator właściwości automatycznej</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>Błąd podczas odczytywania zasobu „{0}” — „{1}”</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>Oczekiwano dyrektywy preprocesora</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>Operatora „await” nie można użyć w wyrażeniu zawierającym typ „{0}”</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>Nie można określić modyfikatorów dostępności dla obu metod dostępu właściwości lub indeksatora „{0}”</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Nazwy elementów krotek muszą być unikatowe.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>Nazwa języka jest nieprawidłowa</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>„{0}”: nie można jawnie wywołać operatora lub metody dostępu.</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>Element „{0}” nie może być zewnętrzny ani zawierać inicjatora konstruktora</value>
  </data>
  <data name="IDS_StackAllocExpression" xml:space="preserve">
    <value>stackalloc {0}[{1}]</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>Właściwości zaimplementowane automatycznie nie mogą zwracać wartości przez odwołanie</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>Brak wymaganego białego znaku.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Brak odwołania do modułu netmodule „{0}”.</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>Operacja spowodowała przepełnienie stosu.</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>zmienna iteracji foreach</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>„{0}”: nie można przesłonić. Element „{1}” nie jest zdarzeniem</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>„{0}” zduplikowany atrybut TypeForwardedToAttribute</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>Bufory o ustalonym rozmiarze muszą mieć długość większą niż zero.</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>Operatora „await” nie można użyć jako identyfikatora w metodzie asynchronicznej ani wyrażeniu lambda.</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>Nie można przekonwertować wartości stałej „{0}” na „{1}” (w celu przesłonięcia należy użyć składni instrukcji „unchecked”).</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>Identyfikator nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>inicjator słownika</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>ciągi interpolowane</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>Nie dla wszystkich ścieżek kodu jest zwracana wartość w {0} typu „{1}”</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>Możliwe niezamierzone porównanie odwołań; lewa strona wymaga rzutowania</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>Nie można rozpoznać ścieżki pliku „{0}” określonej dla argumentu nazwanego „{1}” atrybutu PermissionSet</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>Nieprawidłowy numer</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>Przywoływany zestaw „{0}” ma inne ustawienie kultury — „{1}”.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>Niejednoznaczne odwołanie w atrybucie cref</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>Pierwszy parametr metody rozszerzenia nie może być parametrem typu „{0}”</value>
  </data>
  <data name="IDS_FeatureReadOnlyReferences" xml:space="preserve">
    <value>odwołania tylko do odczytu</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>Element „{0}” to element „{1}”, który jest nieprawidłowy w podanym kontekście</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>Przeciążona metoda „{0}” różniąca się tylko specyfikacją ref lub out parametru lub rangą tablicy nie jest zgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>Nieprawidłowy typ parametru (void)</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>Ograniczenia są niedozwolone w deklaracjach innych niż ogólne</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>Komentarz XML zawiera składniowo niepoprawny atrybut cref</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>metody anonimowe</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>Drzewo wyrażeń nie może zawierać wyrażenia throw.</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>Nie można przekonwertować typu „{0}” na „{1}”.</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>Nazwanego argumentu „{0}” nie można wprowadzać wiele razy.</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>Specyfikator typu tablicy — [] — musi wystąpić przed nazwą parametru.</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>Nie można przekonwertować wartości null na „{0}”, ponieważ nie jest to możliwa wartość null typu.</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>Modyfikator „partial” może się pojawić tylko bezpośrednio przed typem „class”, „struct”, „interface” lub „void”</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>Typ argumentu atrybutu DefaultParameterValue musi być zgodny z typem parametru</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>Nieprawidłowa opcja aliasu odwołania: „{0}=” — brak nazwy pliku</value>
  </data>
  <data name="ERR_FieldAutoPropCantBeByRefLike" xml:space="preserve">
    <value>Pole lub automatycznie implementowana właściwość nie może być typu „{0}”, chyba że jest to element członkowski struktury ref.</value>
  </data>
  <data name="ERR_BadNonTrailingNamedArgument" xml:space="preserve">
    <value>Nazwany argument „{0}” jest używany poza pozycją, ale następuje po nim nienazwany argument</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>Elementów członkowskich pola tylko do odczytu „{0}” nie można zwrócić przez zapisywalne odwołanie</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>Nie można użyć wyrażenia typu „{0}” jako argumentu do operacji wiązanej dynamicznie.</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>Wyrażenia zapytań w odniesieniu do typu źródła „dynamic” lub z sekwencją złączenia typu „dynamic” nie są dozwolone.</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>Opcja „{0}” przesłania atrybut „{1}” podany w pliku źródłowym lub dodanym module</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>„{0}”: nazwy elementów członkowskich nie mogą być takie same jak nazwa zawierającego je typu</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>Kontekstowe słowo kluczowe „var” może występować tylko w deklaracji zmiennej lokalnej lub kodzie skryptu</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>Nieprawidłowy numer podstawowy obrazu „{0}”</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>Zdarzenia środowiska wykonawczego systemu Windows nie można przekazać jako parametru ze specyfikatorem out lub ref.</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>Wystąpienia typu „{0}” nie można użyć wewnątrz funkcji zagnieżdżonej, wyrażenia zapytania, bloku iteratora ani metody asynchronicznej</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ brak pasującego zwracanego typu „{3}”.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>Typ jednego z wyrażeń w klauzuli {0} jest nieprawidłowy. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”.</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>Komentarz XML zawiera atrybut cref przywołujący parametr typu</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>Oczekiwano nazwy metody</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>Ustalonego, lokalnego elementu „{0}” nie można używać w metodzie anonimowej, wyrażeniu lambda ani wyrażeniu zapytania</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>Element „__arglist” jest nieprawidłowy w tym kontekście.</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Elementy nie mogą mieć wartości null.</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>To nie symbol języka C#.</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>„{0}”: typów statycznych nie można użyć jako parametrów</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>Określony ciąg wersji jest niezgodny z wymaganym formatem — główna[.pomocnicza[.kompilacja[.poprawka]]]</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>Instrukcja foreach nie może używać zmiennych typu „{0}”, ponieważ implementuje wiele utworzeń wystąpienia elementu „{1}”. Spróbuj rzutowania na konkretne utworzenie wystąpienia interfejsu</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>Komentarz XML ma tag param, ale nie ma parametru o takiej nazwie</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>Typ zwracany przez referencję „ref {0}” nie jest obsługiwany.</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>Oczekiwano identyfikatora</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>dopasowanie wzorca</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerFilePathAttribute</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać dostępu bazowego.</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>Parametr może mieć tylko jeden modyfikator „{0}”</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>Brak etykiety „{0}” w zakresie instrukcji goto</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>Niebezpieczny kod może się pojawić tylko w przypadku kompilowania przy użyciu opcji /unsafe</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>Elementu „await” nie można użyć w wyrażeniu zawierającym wywołanie elementu „{0}”, ponieważ zwraca ono wartość przez odwołanie</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>„{0}”: wirtualne ani abstrakcyjne elementy członkowskie nie mogą być prywatne</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>Przywoływany zestaw ma inne ustawienie kultury</value>
  </data>
  <data name="ERR_InExtensionMustBeValueType" xml:space="preserve">
    <value>Pierwszy parametr metody „{0}” rozszerzenia „in” musi być typem wartości.</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>Wartości typu „{0}” nie można użyć jako domyślnego parametru dla parametru dopuszczającego wartość null „{1}”, ponieważ typ „{0}” nie jest typem prostym</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>Wartości typu „{0}” nie można użyć jako domyślnego parametru, ponieważ nie ma standardowych konwersji do typu „{1}”</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>Element „{0}” jest abstrakcyjny, ale jest zawarty w nieabstrakcyjnej klasie „{1}”</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>Moduł „{0}” w zestawie „{1}” przekazuje typ „{2}” do wielu zestawów: „{3}” i „{4}”.</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>Oczekiwano wyłączenia lub przywrócenia po ostrzeżeniu #pragma</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla typu lub metody</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>Element „{0}” to element {1}, ale jest używany jak element {2}</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>Dyrektywy preprocesora muszą wystąpić w wierszu jako pierwsze znaki inne niż spacja.</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>pole</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>alias użycia</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>Typ nie zawiera implementacji wzorca kolekcji; element członkowski jest statyczny lub niepubliczny</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>separatory cyfr</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>zdarzenie</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>Modyfikator „{0}” jest nieprawidłowy dla tego elementu</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>W pliku klucza „{0}” brakuje klucza prywatnego potrzebnego do podpisania</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>etykieta</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>Wyrażenie __arglist może się pojawić tylko wewnątrz wywołania lub nowego wyrażenia</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>Algorytm „{0}” nie jest obsługiwany</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>Metoda musi mieć typ zwracany.</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>parametr typu</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>Wyliczenia nie mogą zawierać jawnych konstruktorów bez parametrów</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>Nieprawidłowa lokalizacja atrybutu tej deklaracji</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Wystąpił błąd kryptograficzny w czasie tworzenia mieszań.</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>Tej metody można użyć tylko do tworzenia tokenów — element {0} nie jest rodzajem tokenu.</value>
  </data>
  <data name="ERR_OverloadRefKind" xml:space="preserve">
    <value>Element „{0}” nie może definiować przeciążonego elementu {1}, który różni się tylko modyfikatorami parametru „{2}” i „{3}”</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>Nazwa „{0}” nie istnieje w bieżącym kontekście (brak odwołania do zestawu „{1}”?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>W bieżącym kontekście słowo kluczowe „base” jest niedostępne</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>Ciąg literału „]]&gt;” jest niedozwolony w zawartości elementu.</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>„{0}”: nie może implementować interfejsu „{1}”</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Parametr jest nieprawidłowy dla określonego niezarządzanego typu.</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>/REFERENCEPATH opcja</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać odwołania do funkcji lokalnej</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>Pole ma wiele unikatowych wartości stałych.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} w wersji {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>Atrybut zabezpieczeń „{0}” jest nieprawidłowy w tym typie deklaracji. Atrybuty zabezpieczeń są prawidłowe tylko dla deklaracji zestawu, typu i metody.</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>using static</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Dostęp do elementu członkowskiego „{0}” dodanego podczas bieżącej sesji debugowania można uzyskać tylko w deklarowanym zestawie „{1}”.</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>Nie można używać elementu #load po pierwszym tokenie w pliku</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać deklaracji zmiennej argumentu wyjściowego.</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>Nieprawidłowy typ parametru {0} w atrybucie cref komentarza XML: „{1}”</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>Niespójność dostępności: typ ograniczony „{1}” jest mniej dostępny niż „{0}”</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>Element „{0}” nie może być zewnętrzny i zapieczętowany</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>Nieoczekiwany znak „{0}”</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>„{0}” nie jest prawidłowym argumentem nazwanego atrybutu. Argumentami nazwanego atrybutu muszą być pola, które nie są tylko do odczytu i nie są statyczne ani stałe, lub właściwości do odczytu/zapisu, które są publiczne, ale nie statyczne.</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>Nierozpoznana dyrektywa #pragma</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>Nie można zadeklarować zmiennej typu statycznego „{0}”</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>Dodano odwołanie do zestawu przy użyciu opcji /link (ustawienie wartości True dla właściwości Osadź typy międzyoperacyjne). Nakazuje to kompilatorowi osadzenie informacji o typie międzyoperacyjnym z tego zestawu. Jednak kompilator nie może osadzić informacji o typie międzyoperacyjnym z tego zestawu, ponieważ inny przywoływany zestaw odwołuje się do tego zestawu przy użyciu opcji /reference (ustawienie wartości False dla właściwości Osadź typy międzyoperacyjne).

Aby osadzić informacje o typie międzyoperacyjnym dla obu zestawów, użyj opcji /link dla odwołań do każdego zestawu (ustaw wartość True dla właściwości Osadź typy międzyoperacyjne).

Aby usunąć ostrzeżenie, możesz zamiast tego użyć opcji /reference (ustaw wartość False dla właściwości Osadź typy międzyoperacyjne). W takiej sytuacji informacje o typie międzyoperacyjnym udostępnia podstawowy zestaw międzyoperacyjny.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>metoda dostępu właściwości treści wyrażenia</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.Equals(object o)</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Nieprawidłowa liczba argumentów typu</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>Element „{0}” nie implementuje wzorca „{1}”. Element „{2}” ma nieprawidłową sygnaturę.</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>Deklaracja przestrzeni nazw nie może mieć modyfikatorów ani atrybutów.</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>„{0}”: typy pól wystąpienia oznaczone elementem StructLayout(LayoutKind.Explicit) muszą mieć atrybut FieldOffset</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>Nie można utworzyć wystąpienia klasy lub interfejsu abstrakcyjnego „{0}”</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>Jawna implementacja interfejsu zdarzenia musi używać składni metody dostępu zdarzenia</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>Obliczanie wartości stałej dla elementu „{0}” obejmuje definicję cykliczną</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>„{0}” to nie jest prawidłowa lokalizacja atrybutu tej deklaracji. Prawidłowe lokalizacje atrybutu tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>„{0}” jest niejednoznaczne między „{1}” i „{2}”; użyj „@{0}” lub „{0}Attribute”</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>Oczekiwano średnika (;)</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>Dynamicznie wysłane wywołanie może nie powieść się w czasie wykonywania, ponieważ co najmniej jedno z przeciążeń, które można zastosować, to metoda warunkowa</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>Przestrzeń nazw powoduje konflikt z zaimportowanym typem</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>Metoda częściowa nie może mieć wielu deklaracji implementujących.</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”.</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale silna nazwa stanu podpisywania zestawu wyjściowego nie jest zgodna z nazwą określoną przez atrybut w zestawie udzielającym dostępu.</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>Ograniczenie nie może być typu dynamicznego „{0}”</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>Nie można zastosować operatora „{0}” do argumentu operacji typu „{1}”.</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>„{0}”: odwołanie do pola nietrwałego nie będzie traktowane jako nietrwałe</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać operacji dynamicznej</value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>Zmienne lokalne o typie określonym niejawnie nie mogą być ustalone.</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>Importowany typ „{0}” jest nieprawidłowy. Zawiera on cykliczną zależność klasy podstawowej.</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>Znaleziono wiele implementacji wzorca zapytania dla typu źródłowego „{0}”. Niejednoznaczne wywołanie elementu „{1}”.</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>Przełącznik wiersza polecenia „{0}” nie został jeszcze wdrożony i został zignorowany.</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>Metoda, operator lub metoda dostępu „{0}” jest oznaczona jako zewnętrzna i nie ma atrybutów. Rozważ dodanie atrybutu DllImport w celu określenia implementacji zewnętrznej.</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż indeksator „{0}”</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>właściwość z wyrażeniem w treści</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>Atrybut FieldOffset jest niedozwolony w polach typu static lub const</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>Nie można użyć zmiennej lokalnej typu ref „{0}” wewnątrz metody anonimowej, wyrażenia lambda ani wyrażenia zapytania</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>Operator „{0}” jest niejednoznaczny dla operandów typu „{1}” i „{2}”</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>Zwracany typ „{0}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>Przyjęto, że odwołanie do zestawu jest zgodne z tożsamością</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>Element „{0}” nie zawiera definicji elementu „{1}” i nie można znaleźć metody rozszerzenia „{1}” przyjmującej pierwszy argument typu „{0}” (brak dyrektywy using dla elementu „{2}”?)</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>Wyrażenie zawsze spowoduje wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość elementu „{0}” to null</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>Dla indeksatora trzeba zdefiniować co najmniej jeden parametr.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>Użycie elementu „{0}” do testowania zgodności z elementem „{1}” jest w zasadzie identyczne z testowaniem zgodności z elementem „{2}” i powiedzie się dla wszystkich wartości innych niż null</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>Oczekiwano wartości typu całkowitoliczbowego</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>Ta funkcja językowa („{0}”) nie jest jeszcze zaimplementowana.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>Drzewo składni powinno zostać utworzone na podstawie przesłanych danych.</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>W pełni kwalifikowana nazwa jest za długa dla informacji debugowania</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>Nie znaleziono wartości elementu RuntimeMetadataVersion. Nie znaleziono żadnego zestawu zawierającego element System.Object ani nie określono wartości elementu RuntimeMetadataVersion za pomocą opcji.</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>Interfejs z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>Nie usunięto alokowanego wystąpienia ze wszystkich ścieżek wyjątków</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>Oczekiwano słowa kluczowego „in”</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>Wystąpił błąd w przywoływanym zestawie „{0}”.</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}“ nie jest dozwolona na żadnej pozycji.</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>Indeksowanie tablicy z ujemnym indeksem (indeksy tablicy zawsze rozpoczynają się od zera)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>Atrybut CLSCompliant nie ma znaczenia, gdy jest stosowany do zwracanych typów. Zamiast tego spróbuj umieścić go w metodzie.</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>Element „{0}” określony dla metody Main musi być prawidłową nieogólną klasą lub strukturą</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała. {1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane, ponieważ nie jest on widoczny spoza tego zestawu</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>Częściowe deklaracje elementu „{0}” mają niezgodne ograniczenia parametru typu „{1}”</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>Nie można znaleźć elementu „{0}” określonego dla metody Main</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>Użycie pola klasy marshal-by-reference jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>„{0}”: modyfikatorów dostępu nie można użyć dla metod dostępu interfejsu</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>Nie podano argumentu odpowiadającego wymaganemu parametrowi formalnemu „{0}” elementu „{1}”</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>Podany rodzaj kodu źródłowego jest nieobsługiwany lub nieprawidłowy: „{0}”</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>Nie można określić wartości domyślnej dla tablicy parametrów</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>Ustawiono przypisanie do tej samej zmiennej</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>Nieprawidłowa nazwa symbolu przetwarzania wstępnego; „{0}” nie jest prawidłowym identyfikatorem</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>Element „{0}” nie może implementować jednocześnie elementu „{1}” i „{2}”, ponieważ mogą się one łączyć przy niektórych podstawieniach parametrów typu.</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>Typ „{2}” musi być niezerowalnym typem wartości, aby można było użyć go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>Metoda ma nieprawidłową sygnaturę i nie może być punktem wejścia</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>Zduplikowany modyfikator „{0}”</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>kontrawariantnie</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>Słowo kluczowe, identyfikator lub ciąg oczekiwany po specyfikatorze kalki: @.</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>W jawnej implementacji interfejsu „{0}” brakuje metody dostępu „{1}”</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>Element „{2}” musi być typem nieabstrakcyjnym z publicznym konstruktorem bez parametrów, aby można go było użyć jako parametru „{1}” w typie ogólnym lub metodzie „{0}”.</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>„{0}”: typ zawierający nie implementuje interfejsu „{1}”</value>
  </data>
  <data name="ERR_RefStructInterfaceImpl" xml:space="preserve">
    <value>„{0}”: Struktury ref nie mogą implementować interfejsów</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”. Być może brakuje odwołania do biblioteki „System.Core.dll” lub użycia dyrektywy dla przestrzeni nazw „System.Linq”.</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>Zdefiniowane przez użytkownika operatory nie mogą zwracać wartości void</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>literały binarne</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>Nie można utworzyć tablicy z ujemnym rozmiarem</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>klasy statyczne</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>Nie można używać instrukcji yield wewnątrz metody anonimowej lub wyrażenia lambda.</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>Typ „{0}” nie może być osadzony, ponieważ ma on argument ogólny. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</value>
  </data>
  <data name="IDS_FeatureRefStructs" xml:space="preserve">
    <value>struktury ref</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>Właściwości zaimplementowane automatycznie w interfejsach nie mogą mieć inicjatorów.</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”. Element „{2}” nie jest publiczny.</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>Element „{1}” nie definiuje parametru typu „{0}”</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>Operator typeof nie może zostać użyty dla typu dynamicznego</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>Argument operatora zwiększania lub zmniejszania musi być zmienną, właściwością lub indeksatorem.</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>Przełącznik /embed jest obsługiwany tylko w przypadku emitowania pliku PDB.</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>Element „{0}” nie może być zewnętrzny i abstrakcyjny</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>Wymagany jest obiekt, który można przekonwertować na typ „{0}”</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>Nie można utworzyć wystąpienia klasy statycznej „{0}”</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>Element „{0}” ukrywa odziedziczony element członkowski „{1}”. Użyj słowa kluczowego new, jeśli ukrycie jest zamierzone.</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Nieprawidłowy znak Unicode.</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>Wyrażeń lambda, które zwracają wartość przez odwołanie, nie można przekonwertować na drzewa wyrażeń</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>Nie można zdefiniować klasy lub elementu członkowskiego, który wykorzystuje krotki, ponieważ nie można znaleźć wymaganego typu kompilatora „{0}”. Czy brakuje odwołania?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Błąd podczas podpisywania danych wyjściowych za pomocą klucza publicznego z pliku „{0}” — {1}</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>„{0}”: nie można jednocześnie określić klasy ograniczenia i ograniczenia „class” lub „struct”</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>Dyrektywa „using static” może być stosowana tylko do typów. Element „{0}” to przestrzeń nazw, a nie typ. Zamiast tego rozważ użycie dyrektywy „using namespace”</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>Nie można użyć wyrażenia lambda jako argumentu do operacji wiązanej dynamicznie bez uprzedniego rzutowania go na delegata lub typ drzewa wyrażenia.</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>Wartości zwracanych przez wartość można użyć tylko w metodach zwracających wartość</value>
  </data>
  <data name="ERR_EscapeStackAlloc" xml:space="preserve">
    <value>Nie można używać wyniku wyrażenia stackalloc typu „{0}” w tym kontekście, ponieważ może zostać ujawniony poza metodą zawierającą</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>Określono nieprawidłowy typ jako argument dla atrybutu TypeForwardedTo.</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>Nie można utworzyć delegata z „{0}”, ponieważ on albo metoda, którą przesłania, ma atrybut „Conditional”</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>Użycie domyślnego literału nie jest prawidłowe w tym kontekście</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>Nie można niejawnie przekonwertować typu „{0}” na „{1}”. Istnieje konwersja jawna (czy nie brakuje rzutu?).</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>Wystąpienia analizatora {0} nie można utworzyć z elementu {1}: {2}.</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>Dyrektywa using występowała wcześniej w tej przestrzeni nazw</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>Komentarz XML zawiera atrybut cref, którego nie można rozpoznać</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>Nie można odwołać się do atrybutu „System.Runtime.CompilerServices.TupleElementNamesAttribute” jawnie. Użyj składni krotek, aby zdefiniować nazwy krotek.</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>Wyrażenie filtru jest stałą</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>Nieprawidłowy numer</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>Delegat „{0}” nie przyjmuje argumentów {1}</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>Element „{0}” ukrywa dziedziczony, abstrakcyjny element członkowski „{1}”</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>Zduplikowany parametr typu „{0}”</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>Zdarzenie w interfejsie nie może mieć metody dostępu add ani remove</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>Podano różne sumy kontrolne dla elementu „{0}”</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>„{0}”: typ zdarzenia musi być zgodny z typem delegowanym</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>Oczekiwano wyrażenia po instrukcji yield return</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>Przełącznik /sourcelink jest obsługiwany tylko w przypadku emitowania pliku PDB.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>Pierwszy argument atrybutu zabezpieczeń musi być prawidłową wartością SecurityAction</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>Nie można używać kontekstowego słowa kluczowego „var” w deklaracji zmiennej zakresu</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>Nieprawidłowy alias zewnętrzny dla opcji „/reference”; wartość „{0}” nie jest prawidłowym identyfikatorem</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>Element członkowski ukrywa dziedziczony element członkowski; brak słowa kluczowego override</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>Atrybut FieldOffset można umieścić tylko w elementach członkowskich o typie oznaczonym przy użyciu atrybutu StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>Komentarz XML zawiera zduplikowany tag param</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>typ</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>„{0}”: typów statycznych nie można używać jako argumentów typu.</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>Wyrażenie throw jest niedozwolone w tym kontekście.</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>Zastosowanie elementu CallerLineNumberAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy elementu członkowskiego, który jest używany w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>Oczekiwano operatora binarnego z możliwością przeciążenia</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>Nie odnaleziono najlepszego typu dla tablicy o typie określonym niejawnie.</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>Białe znaki są niedozwolone w tej lokalizacji.</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>Komentarz XML nie został umieszczony w prawidłowym elemencie języka</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>Nie można użyć ujemnego rozmiaru w przypadku słowa kluczowego stackalloc</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: brak elementu „{0}” dla opcji „{1}”</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>Wskaźniki i bufory o ustalonym rozmiarze mogą zostać użyte tylko w kontekście słowa kluczowego „unsafe”</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>Przeciążona metoda różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>Błąd kompilacji zasobów Win32 — {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>W drzewach wyrażeń nie można używać metod częściowych zawierających tylko deklarację definiującą ani usuniętych metod warunkowych.</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}” została wywnioskowana. Użyj wersji języka {1} lub nowszej, aby uzyskać dostęp do elementu według jego wywnioskowanej nazwy.</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie prawej strony na typ „{0}”</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>Komentarz XML zawiera zduplikowany tag typeparam</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>Zestaw „{0}” z tożsamością „{1}” używa elementu „{2}”, który ma wyższą wersję niż przywoływany zestaw „{3}” z tożsamością „{4}”</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>Nieogólnego elementu {1} „{0}” nie można używać z argumentami typu.</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>Nazwa zestawu „{0}” jest zarezerwowana i nie można jej użyć jako odwołania w sesji interaktywnej</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>Typ definiuje operator == lub !=, ale nie przesłania metody Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>„{0}”: typ musi być „{2}”, aby być zgodnym z przesłoniętym elementem członkowskim „{1}”</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>Operator LUB działający na bitach został użyty względem argumentu ze znakiem. Rozważ możliwość wcześniejszego rzutowania na mniejszy typ bez znaku.</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>Nie można użyć buforów o ustalonym rozmiarze zawartych w wyrażeniach unfixed. Spróbuj użyć instrukcji fixed.</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>Nie można pobrać adresu podanego wyrażenia</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać „{0}”</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>Nie można określić wartości domyślnej parametru w połączeniu z klasami DefaultParameterAttribute lub OptionalAttribute</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>Nie znaleziono odpowiedniego wystąpienia dekonstrukcji lub metody rozszerzenia dla typu „{0}” z {1} parametrami out i typem zwrotnym void.</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>Metoda rozszerzenia musi być zdefiniowana w nieogólnej klasie statycznej.</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>Typ elementu „{0}” to „{1}”. Pole stałe typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null.</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>Ograniczenie „new()” nie może być używane z ograniczeniem „struct”</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>Element „__arglist” jest niedozwolony na liście parametrów metod asynchronicznych.</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>Nie używaj „System.Runtime.CompilerServices.ExtensionAttribute”. Zamiast niego użyj słowa kluczowego „this”.</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>Oczekiwano metody dostępu Add lub Remove</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>Kontrolka nie może opuścić tekstu metody anonimowej lub wyrażenia lambda.</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>Przestarzały element członkowski przesłania nieprzestarzały element członkowski</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>Ograniczenie typu klasy „{0}” musi występować przed wszystkimi innymi ograniczeniami</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>Element „{0}” musi odpowiadać zwracanemu przez odwołanie przesłoniętemu elementowi członkowskiemu „{1}”</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>Zastosowanie elementu CallerFilePathAttribute nie odniesie żadnego skutku; zostanie on przesłonięty przez element CallerLineNumberAttribute</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>Grupy metod rozszerzeń nie są dozwolone jako argument elementu „nameof”.</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>Nie można zainicjować zmiennej dostępnej przez wartość za pomocą odwołania</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>Element „{0}” nie zawiera definicji „{1}”, a nie odnaleziono metody rozszerzenia „{1}”, która przyjmuje pierwszy argument typu „{0}” (czy nie brakuje dyrektywy using lub odwołania do zestawu?).</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>Elementu {1} „{0}” nie można używać z argumentami typu.</value>
  </data>
  <data name="ERR_EscapeLocal" xml:space="preserve">
    <value>Nie można używać lokalnego elementu „{0}” w tym kontekście, ponieważ może uwidaczniać przywoływane zmienne poza ich zakresem deklaracji</value>
  </data>
  <data name="ERR_EscapeOther" xml:space="preserve">
    <value>Nie można używać wyrażenia w tym kontekście, ponieważ pośrednio może ujawniać zmienne poza ich zakresem deklaracji</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>Metoda częściowa nie może mieć wielu deklaracji definiujących.</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>Klasy statyczne nie mogą mieć konstruktorów wystąpienia.</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>Operator „await” wymaga, aby typ {0} miał przypisaną odpowiednią metodę GetAwaiter</value>
  </data>
  <data name="ERR_EscapeCall2" xml:space="preserve">
    <value>Nie można używać elementu członkowskiego wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>Typ „{1}” już rezerwuje element członkowski o nazwie „{0}” z tymi samymi typami parametrów</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>Typ argumentu nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>Nierozpoznana sekwencja ucieczki</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>Parametr nie ma zgodnego tagu param w komentarzu XML (ale inne parametry mają ten tag)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>Dziedziczony interfejs „{1}” jest przyczyną wystąpienia cyklu w hierarchii interfejsów „{0}”</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>Nie można odnaleźć nazwy typu lub przestrzeni nazw „{0}” w globalnej przestrzeni nazw (czy nie brakuje odwołania do zestawu?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania w wyrażeniu filtru klauzuli „catch”</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>Wyrażenia inicjatora tablicy mogą być używane tylko w celu przypisania wartości do typów tablicowych. Zamiast tego spróbuj użyć wyrażenia „new”.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>Zmienne o typie określonym niejawnie muszą być inicjowane</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>Deklaracja parametru typu musi być identyfikatorem, a nie typem</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>„{0}”: nowy chroniony element członkowski zadeklarowany w strukturze</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>„{0}”: klasy statyczne nie mogą zawierać chronionych elementów członkowskich</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>„{0}”: nie można zadeklarować elementów członkowskich wystąpienia w klasie statycznej</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Pliki wykonywalne nie mogą być zestawami satelity, element Culture powinien zawsze być pusty</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>Użycie słowa kluczowego „base” jest nieprawidłowe w tym kontekście</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>Typ „{0}” jest zdefiniowany w nieprzywoływanym zestawie. Musisz dodać odwołanie do zestawu „{1}”.</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>Element „{0}” dodaje metodę dostępu, której nie znaleziono w elemencie członkowskim interfejsu „{1}”</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>Nierozpoznana opcja: „{0}”</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>Metody asynchroniczne są niedozwolone w interfejsach, klasach lub strukturach z atrybutem „SecurityCritical” lub „SecuritySafeCritical”.</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>Pierwszy argument operacji operatora „is” lub „as” nie może być wyrażeniem lambda, metodą anonimową ani grupą metod.</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>Dostęp do tablicy nie może mieć specyfikatora argumentu nazwanego</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>Nie można użyć grupy metod jako argumentu do operacji wiązanej dynamicznie. Czy zamierzane było wywołanie metody?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>Pola tylko do odczytu nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajduje się w konstruktorze)</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>Wywołano metodę GetDeclarationName dla węzła deklaracji, który może zawierać wiele deklaratorów zmiennych.</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>Ten błąd występuje, gdy przeciążona metoda korzysta z tablicy nieregularnej i jedyną różnicą między sygnaturami metod jest typ elementu tablicy. Aby uniknąć tego błędu, rozważ użycie tablicy regularnej zamiast tablicy nieregularnej, użyj dodatkowego parametru w celu odróżnienia wywołania funkcji, zmień nazwy przeciążonych metod lub usuń atrybut CLSCompliantAttribute, jeśli zgodność ze specyfikacją CLS nie jest wymagana.</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>Nazwy elementów krotki w podpisie metody „{0}” muszą być zgodne z nazwami elementów krotki metody interfejsu „{1}” (w tym w zwracanym typie).</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>Zduplikowany atrybut „{0}” w elemencie „{1}”</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>funkcja async</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Nieprawidłowy format informacji debugowania: {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>Czy chodziło Ci o użycie domyślnej etykiety switch („default:”) zamiast „case default:”? Jeśli rzeczywiście chcesz użyć domyślnego literału, rozważ użycie literału „case (default):” lub innego literału („case 0:” bądź „case null:”).</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>Metody asynchroniczne nie mogą zawierać niezabezpieczonych parametrów ani zwracanych typów.</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>Element członkowski przesłania przestarzały element członkowski</value>
  </data>
  <data name="ERR_AssignReadonlyNotField" xml:space="preserve">
    <value>Nie można przypisać do elementu {0} „{1}”, ponieważ jest to zmienna tylko do odczytu.</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>Metody asynchroniczne nie mogą mieć zmiennych lokalnych dostępnych przez odwołanie</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>Tylko właściwości zaimplementowane automatycznie mogą mieć inicjatory.</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>Nie można utworzyć krótkiej nazwy pliku „{0}”, jeśli już istnieje długa nazwa pliku, której krótka wersja jest taka sama</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#warning: „{0}”</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>Statycznego elementu członkowskiego „{0}” nie można oznaczyć specyfikatorem override, virtual ani abstract</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>Lewa strona przypisania musi być zmienną, właściwością lub indeksatorem</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>Dla elementu członkowskiego „{0}” ze specyfikatorem override nie można określić specyfikatora new ani virtual</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>Obydwie częściowe deklaracje metody, „{0}” i „{1}”, muszą korzystać z tych samych nazw elementów krotki.</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>Elementy członkowskie struktury nie mogą zwracać obiektu „this” ani innych elementów członkowskich wystąpienia przez odwołanie</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>„{0}”: nie wszystkie ścieżki kodu zwracają wartość</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>Etykieta case wyrażenia switch została już obsłużona przez poprzednią etykietę case.</value>
  </data>
  <data name="ERR_EscapeCall" xml:space="preserve">
    <value>Nie można używać wyniku elementu „{0}” w tym kontekście, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>Nie można przesłać typu „{0}”, ponieważ jest to zagnieżdżony typ „{1}”</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>Ograniczenie nie może być typu dynamicznego</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>Wartość parametru ze specyfikatorem out „{0}” musi być przypisana zanim sterowanie wyjdzie z bieżącej metody</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>Nieprawidłowa nazwa symbolu przetwarzania wstępnego; nie jest prawidłowym identyfikatorem</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>Sufiks „l” z łatwością można pomylić z cyfrą „1” — w celu zachowania jednoznaczności użyj sufiksu „L”</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>Element „{0}” w jawnej deklaracji interfejsu nie jest interfejsem</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>„{0}” nie może przesłonić „{1}”, ponieważ nie jest to obsługiwane przez język</value>
  </data>
  <data name="ERR_BadParameterModifiers" xml:space="preserve">
    <value>Modyfikator parametru „{0}” nie może być używany z elementem „{1}”</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>Członka „{0}”, którego nie można wywoływać, nie można używać jak metody.</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>Wartość ref lub out musi być zmienną umożliwiającą przypisanie</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>Klasa SyntaxTreeSemanticModel musi być dostępna, aby zapewnić minimalną kwalifikację typu.</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>Typ „{0}” jest zdefiniowany w module, który nie został dodany. Musisz dodać moduł „{1}”.</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z typem „{3}” w elemencie „{2}”</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>„{0}”: konstruktor statyczny nie może mieć parametrów</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>W parametrze wyjściowym nie może występować atrybut wejściowy.</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>grupa metod</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>Do pola nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>Metoda „{0}” zawiera modyfikator parametru „this”, który nie znajduje się w pierwszym parametrze</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>Nie można używać znaków cudzysłowu spoza zestawu znaków ASCII wokół literałów ciągu.</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>Klasa podstawowa jest wymagana dla odwołania „base”</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>Nieoczekiwana dyrektywa preprocesora</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>Sprawdzanie zgodności ze specyfikacja CLS nie zostanie wykonane dla elementu „{0}”, ponieważ nie jest on widoczny spoza tego zestawu</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest właściwością</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}” w języku C# {2}. Użyj języka w wersji {3} lub nowszej.</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>Zmienna „{0}” jest przypisana, lecz jej wartość nie jest nigdy używana</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}“ jest dozwolona tylko na pozycji {1}.</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>Więcej niż jeden modyfikator ochrony</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>Komentarz XML zawiera składniowo niepoprawny atrybut cref „{0}”</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>Element „{0}” nie jest obsługiwany przez język.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>Komentarz XML ma tag paramref, ale nie ma parametru o takiej nazwie</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>Operatora „await” można używać tylko wewnątrz metody asynchronicznej. Rozważ możliwość oznaczenia tej metody za pomocą modyfikatora „async” i zmiany zwracanego przez nią typu na „Task”.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>Nie można zaktualizować elementu „{0}”. Brak atrybutu „{1}”.</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>„{0}”: w klasie zapieczętowanej został zadeklarowany nowy chroniony element członkowski</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>Nie można przejść z jednej etykiety instrukcji case („{0}”) do innej</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>Nie można przekonwertować elementu {0} na typ „{1}”, ponieważ nie jest to typ delegowany</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>Wyrażenia lambda z treścią instrukcji nie można skonwertować na drzewo wyrażenia.</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Kompilator Microsoft (R) Visual C#</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>Nie można przekonwertować typu „{0}” na „{1}” za pomocą konwersji odwołania, konwersji pakującej, konwersji rozpakowującej, konwersji tworzenia otoki ani konwersji na typ zerowy</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>Wskaźnik musi być indeksowany tylko przez jedną wartość</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>Nieprawidłowy numer ostrzeżenia</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>zmienne lokalne i wartości zwracane byref</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>Nie można przekazać argumentu z dynamicznym typem do parametru params „{0}” lokalnej funkcji „{1}”.</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>Osadzona metoda międzyoperacyjna „{0}” zawiera treść.</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>Najlepsza przeciążona metoda Add „{0}” dla elementu inicjatora kolekcji jest przestarzała.</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>dynamiczny</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>Nie można użyć zmiennej lokalnej „{0}” przed jej zadeklarowaniem. Deklaracja zmiennej lokalnej powoduje ukrycie pola „{1}”.</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>Nie można zdefiniować/usunąć definicji symboli preprocesora po pierwszym tokenie w pliku.</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>Nie można równocześnie określić opcji kompilacji „{0}” i „{1}”.</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute nie odniesie żadnego skutku, ponieważ dotyczy on elementu członkowskiego, który jest używany w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>Operacja przepełnia się w czasie kompilowania w trybie sprawdzonym</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>kwalifikator aliasu przestrzeni nazw</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>Instrukcja throw bez żadnych argumentów jest niedozwolona poza klauzulą catch</value>
  </data>
  <data name="ERR_BadSpecialByRefIterator" xml:space="preserve">
    <value>Instrukcja foreach nie może działać na modułach wyliczających typu „{0}” w metodach asynchronicznych lub iteratora, ponieważ element „{0}” jest strukturą ref.</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>Zdarzenie „{0}” nie jest nigdy używane</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>Komentarz XML nie został umieszczony w prawidłowym elemencie języka</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Błąd zapisu w pliku dokumentacji XML: {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>ogólne</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>Interfejs „{0}” z oznaczeniem „CoClassAttribute” nie ma oznaczenia „ComImportAttribute”</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>Nie można użyć pól elementu „{0}” jako wartości ref ani out, ponieważ jest to element „{1}”</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>Użycie prawdopodobnie nieprzypisanej automatycznie implementowanej właściwości „{0}”</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>Pole „{0}” nie jest nigdy używane</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>Brak odwołania do tej etykiety</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>„{0}” zduplikowany nazwany argument atrybutu</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>Nie można przywołać zmiennej typu „{0}”</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>Operatora „await” można używać tylko wtedy, gdy zawierająca go metoda lub wyrażenie lambda zostaną oznaczone modyfikatorem „async”.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać literału krotki.</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>Wykonano porównanie z tą samą zmienną</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>Nie można użyć domyślnego literału jako argumentu operacji wysyłanej dynamicznie.</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>Nie można zastosować wyrażeń inicjatora obiektu i kolekcji do wyrażenia tworzenia delegata</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>Komentarz XML zawiera zduplikowany tag typeparam dla elementu „{0}”</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>„{0}”: zdefiniowane przez użytkownika konwersje na lub z klasy pochodnej nie są dozwolone</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>„{0}” nie jest prawidłowym specyfikatorem formatu</value>
  </data>
  <data name="ERR_RefConditionalAndAwait" xml:space="preserve">
    <value>Element „await” nie może być używany w wyrażeniu zawierającym operator warunkowy ref</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>Zestaw o tej samej prostej nazwie „{0}” został już zaimportowany. Spróbuj usunąć jedno z odwołań (np. „{1}”) lub podpisz je, aby umożliwić działanie obok siebie.</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>Operatora „await” nie można użyć w inicjalizatorze statycznej zmiennej skryptu.</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>Nie można dziedziczyć interfejsu „{0}” z określonymi typami parametrów, ponieważ spowoduje to, że metoda „{1}” będzie zawierać przeciążenia, które będą się różnić tylko parametrami ref i out</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>Nazwa „{0}” jest poza zakresem lewej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>Klasy CallerFilePathAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>Identyfikator „{0}” różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>Niespójność dostępności: typ właściwości „{1}” jest mniej dostępny niż właściwość „{0}”</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>Błąd podczas otwierania pliku zasobów Win32 „{0}” — „{1}”</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>Pusty specyfikator formatu.</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>Użyto operatora bitowego OR w argumencie operacji z rozszerzonym znakiem</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>Wynik wyrażenia jest zawsze taki sam, ponieważ wartość tego typu nigdy nie jest równa wartości „null”</value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>Dostęp do elementu członkowskiego z użyciem przezroczystego identyfikatora dla pola „{0}” typu „{1}” nie powiódł się. Czy odpytywane dane implementują wzorzec zapytania?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>Klasy CallerLineNumberAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>Alias zewnętrzny w tym kontekście jest nieprawidłowy</value>
  </data>
  <data name="ERR_RefConditionalNeedsTwoRefs" xml:space="preserve">
    <value>Obie wartości operatora warunkowego muszą być wartościami ref lub żadna z nich nie może być wartością ref</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>Typu „{0}” nie można osadzić, ponieważ to jest typ zagnieżdżony. Rozważ ustawienie właściwości „Osadź typy międzyoperacyjne” na wartość false.</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>Nie można określić atrybutu CLSCompliant w module, który różni się od atrybutu CLSCompliant w zestawie</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}. Patrz także błąd CS{1}.</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>Nieprawidłowy typ podstawowy</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>Nazwa typu „{0}” nie istnieje w typie „{1}”</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value> Dla następującego tagu Include nie znaleziono żadnych zgodnych elementów </value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>Typ przesłania metodę Object.Equals(object o), ale nie przesłania metody Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>Nie można niejawnie przekonwertować wartości „goto case” na typ przełącznika</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>Określono opcję kompilatora /doc, ale co najmniej jedna konstrukcja nie ma komentarzy.</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>„{0}”: nie można przesłonić odziedziczonego elementu członkowskiego „{1}”, ponieważ nie został on oznaczony przy użyciu słowa kluczowego „virtual”, „abstract” ani „override”</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>Nazwa parametru „{0}” jest duplikatem</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>„{0}”: modyfikatory dostępu są niedozwolone dla konstruktorów statycznych</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>Nieoczekiwane użycie niepowiązanej nazwy ogólnej</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>Metoda dostępu „{0}” nie może implementować elementu członkowskiego interfejsu „{1}” dla typu „{2}”. Należy użyć implementacji interfejsu jawnego.</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>Obie deklaracje metody częściowej muszą być metodami rozszerzenia albo żadna z nich nie może być metodą rozszerzenia.</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Oczekiwano instrukcji „catch” lub „finally”.</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>Wyrażenie new wymaga znaków (), [] lub {} po typie.</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>Zmienna jest zadeklarowana, ale nie jest nigdy używana</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>Napotkano znacznik końca pliku. Oczekiwano znaków "*/".</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>Nie można odwołać się do kompilacji typu „{0}” z kompilacji {1}.</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>Element „{0}” ukrywa odziedziczony element członkowski „{1}”. Aby przesłonić tę implementację bieżącym elementem członkowskim, dodaj słowo kluczowe override. W przeciwnym razie dodaj słowo kluczowe new.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”. Element „{2}” nie może implementować elementu członkowskiego interfejsu, ponieważ jest niepubliczny.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>Oczekiwano elementu SemanticModel {0}.</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>operator domyślny</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>Deklaracje zmiennej wychodzącej i zmiennej wzorca nie są dozwolone w obrębie klauzuli zapytania.</value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>Nie można przypisać wyrażenia typu „void”.</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>domyślny literał</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>Wyrażenie typu „{0}” nie może być obsługiwane przez wzorzec typu „{1}”.</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>Określono opcje powodujące konflikt: plik zasobów Win32; ikona Win32.</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>Atrybut jest ignorowany w przypadku określenia podpisywania publicznego.</value>
  </data>
  <data name="ERR_TypeReserved" xml:space="preserve">
    <value>Nazwa typu „{0}” jest zarezerwowana do użycia przez kompilator.</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>Nazwa „{0}” jest poza zakresem prawej strony operatora równości. Rozważ zamianę wyrażeń po obu stronach operatora równości.</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>„{0}”: nie można zmienić nazw elementów krotki w przypadku przesłaniania dziedziczonego elementu członkowskiego „{1}”</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>Całkowita długość ciągów użytkownika używanych przez program przekracza dozwolony limit. Spróbuj ograniczyć użycie literałów ciągów.</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>Oczekiwano znaku {</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>Sufiks „l” można łatwo pomylić z cyfrą „1”</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>Nieoczekiwany znak w tej lokalizacji.</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>Oczekiwano ciągu „&gt;” lub „/&gt;” zamykającego tag „{0}”.</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>Parametr typu nie ma zgodnego tagu typeparam w komentarzu XML (ale inne parametry mają ten tag)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>Definiowanie aliasu o nazwie „global” jest niezalecane, ponieważ łańcuch „global::” zawsze odwołuje się do globalnej przestrzeni nazw, a nie do aliasu</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku, ponieważ dotyczy elementu członkowskiego, który jest używany w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>Parametr „{0}” konstruktora atrybutu jest typu „{1}”, który nie jest prawidłowym typem parametru atrybutu</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>Nieprawidłowy modyfikator wariancji. Jako wariant można określić tylko parametry typu interface i delegate.</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>Przeciążona metoda różniąca się tylko parametrem ref lub out albo rangą tablicy nie jest zgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>„{0}”: pole nietrwałe nie może być typu „{1}”</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>W wyrażeniu stackalloc po nazwie typu wymagane jest użycie specyfikatora [].</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>Nieprawidłowy deklarator elementu członkowskiego typu anonimowego. Elementy członkowskie typu anonimowego muszą być deklarowane przy użyciu przypisania elementu członkowskiego, nazwy prostej lub dostępu elementu członkowskiego.</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>Spójna kolekcja nie może zawierać wartości typu „void”.</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>Nie można określić tylko atrybutu Out w parametrze ze specyfikatorem ref. Użyj obu atrybutów In i Out lub nie używaj żadnego z nich.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>Plik źródłowy „{0}” jest określony wiele razy</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>Elementów członkowskich właściwości „{0}” typu „{1}” nie można przypisać za pomocą inicjatora obiektu, ponieważ jest on typu wartości</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>„{0}”: struktury nie mogą wywoływać konstruktorów klasy podstawowej</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>Typ nie zawiera implementacji wzorca kolekcji; elementy członkowskie są niejednoznaczne</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>Słowo kluczowe stackalloc nie może być używane w bloku catch lub finally</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>Oczekiwano literału ciągu, lecz nie znaleziono otwierającego znaku cudzysłowu.</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>Element „{0}” nie może być zewnętrzny ani deklarować treści</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>Nieprawidłowe wyrażenie preprocesora</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>W bieżącym kontekście słowo kluczowe „this” jest niedostępne</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>Drzewo SyntaxTree „{0}” jest wynikiem dyrektywy #load i nie można go bezpośrednio usunąć ani zastąpić.</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>Nierozpoznana dyrektywa #pragma</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>Typ anonimowy nie może mieć wielu właściwości o tej samej nazwie.</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>Długość nazwy „{0}” przekracza maksymalną długość dozwoloną w metadanych.</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>Za pomocą dyrektywy „using static” nie można deklarować aliasu</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>Wykonano przypisanie do tej samej zmiennej. Czy chcesz przypisać coś innego?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>Zdarzenie nie jest nigdy używane</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>Zdarzenie „{0}” może pojawić się tylko po lewej stronie wyrażenia += lub -=.</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> Tag Include jest nieprawidłowy </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>Funkcja przesyłania dalej dla typu „{0}” w zestawie „{1}” powoduje wystąpienie cyklu</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>Typ „{0}” już zawiera definicję dla „{1}”</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać połączenia lub wywołania, które używa argumentów opcjonalnych</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>Nie można otworzyć pliku metadanych „{0}” — {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>Porównanie z wartością null typu „{0}” zawsze daje wartość „false”</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>moduł jako specyfikator elementu docelowego atrybutu</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>To ostrzeżenie może zostać wygenerowane, gdy dwie metody interfejsu różnią się tylko oznaczeniem określonego parametru specyfikatorem ref lub out. Aby zapobiec występowaniu tego ostrzeżenia, zmień kod, ponieważ nie można jednoznacznie określić ani zagwarantować, która metoda zostanie wywołana w czasie wykonywania.

Język C# rozróżnia specyfikatory out i ref, jednak dla środowiska CLR są one takie same. Wybiera ono dowolny z nich podczas określania, która metoda zawiera implementację interfejsu.

Musisz umożliwić kompilatorowi rozróżnienie metod. Możesz na przykład nadać im różne nazwy lub określić dla jednej z nich dodatkowy parametr.</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>Nie można użyć dyrektywy #r po pierwszym tokenie w pliku</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”. Element „{2}” nie może implementować elementu członkowskiego interfejsu, ponieważ jest statyczny.</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>Nie można zainicjować zmiennej dostępnej przez odwołanie za pomocą wartości</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>argument nazwany</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” jest zdefiniowany w wielu zestawach aliasu globalnego. Zostanie użyta definicja z elementu „{1}”.</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać wywołania metody, właściwości ani indeksatora, który zwraca wartość przez odwołanie</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>Metoda częściowa nie może mieć modyfikatorów dostępu ani modyfikatorów virtual, abstract, override, new, sealed lub extern.</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>Brak znaku równości między atrybutem i wartością atrybutu.</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>Nie można dekonstruować krotki „{0}” elementów do „{1}” zmiennych.</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>Element „{0}” nie implementuje odziedziczonego abstrakcyjnego elementu członkowskiego „{1}”</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>Nie można utworzyć wystąpienia typu zmiennej „{0}”, ponieważ nie ma ograniczenia new()</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>Typu elementu „{0}” nie można wywnioskować, ponieważ jego inicjator bezpośrednio lub pośrednio przywołuje definicję.</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>element #load jest dozwolony tylko w skryptach</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>Przeciążona metoda „{0}” różniąca się tylko nienazwanymi typami tablicy nie jest zgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>Ograniczenie „class” lub „struct” musi występować przed wszystkimi innymi ograniczeniami</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>Argument atrybutu musi być wyrażeniem stałej, wyrażeniem TypeOf lub wyrażeniem tworzenia tablicy typu parametru atrybutu</value>
  </data>
  <data name="IDS_FeatureReadOnlyStructs" xml:space="preserve">
    <value>struktury tylko do odczytu</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;wyrażenie throw&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>typy częściowe</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>Ogólny parametr jest definicją, a oczekiwano odwołania {0}</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>Składnia „var (...)“ jako wartość lvalue jest zastrzeżona.</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>Nieprawidłowy operand dla dopasowania wzorca; wymagana jest wartość, a znaleziono „{0}”.</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>„{0}”: właściwość ani indeksator nie mogą być typu void</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>„{0}”: nie można przesłonić odziedziczonego elementu członkowskiego „{1}”, ponieważ jest on zapieczętowany</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>Iteratory nie mogą mieć parametrów „ref” ani „out”.</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>Właściwość indeksowana „{0}” musi mieć wszystkie argumenty opcjonalne</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>Niespójne użycie parametrów lambda. Wszystkie typy parametrów muszą być albo jawne, albo niejawne.</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>Nie można załadować zestawu analizatora</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>Nie można wywnioskować typu odrzucenia o typie określonym niejawnie.</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>Typ „{0}” na liście interfejsów nie jest interfejsem</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>element</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>Parametr __arglist musi być ostatnim parametrem formalnej listy parametrów</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać operatora zgodnego z wzorcem „is”.</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>Atrybuty nie są dozwolone w przypadku lokalnych parametrów funkcji lub parametrów typu</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>Niejednoznaczne zdefiniowane przez użytkownika konwersje „{0}” i „{1}” podczas konwertowania z „{2}” na „{3}”.</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>Nie można osadzić typu międzyoperacyjnego „{0}”. Użyj zamiast tego odpowiedniego interfejsu.</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>Wyrażenie musi być typu „{0}”, ponieważ jest przypisywane przez odwołanie</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>Zestaw nie zawiera analizatorów</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>Indeksowanie tablicy z ujemnym indeksem</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>Właściwości zwracające wartość dostępną przez odwołanie nie mogą mieć metod dostępu set</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: brak elementu „:&lt;liczba&gt;” dla opcji „{0}”</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>Odwołanie do typu „{0}” określa, że jest zdefiniowane w elemencie „{1}”, lecz nie można go znaleźć</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>Prawdopodobnie niepoprawne przypisanie do elementu lokalnego „{0}”, który jest argumentem instrukcji using lub lock. Wywołanie metody Dispose lub odblokowanie nastąpi dla oryginalnej wartości elementu lokalnego.</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>Nie można przekonwertować krotki z {0} elementami na typ „{1}”.</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>Znaku „&lt;” nie można użyć w wartości atrybutu.</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>Nieprawidłowa składnia sumy kontrolnej #pragma checksum; powinna być następująca: #pragma checksum "nazwa_pliku" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>niezmiennie</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>Element „{0}” jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>Pozycja nie znajduje się w drzewie składni o pełnym zasięgu {0}</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>Nie można zdefiniować nowej metody rozszerzenia, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania do System.Core.dll?</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>Aby istniała możliwość zastosowania zdefiniowanego przez użytkownika operatora logicznego („{0}”) jako operatora „short circuit”, musi on mieć taki sam typ zwracany i typy parametrów</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>Wykonano porównanie z tą samą zmienną. Czy chcesz porównać coś innego?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>Identyfikator różniący się tylko wielkością liter nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>Nieprawidłowy literał liczby rzeczywistej.</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>Nie można użyć instrukcji fixed do pobrania adresu już ustalonego wyrażenia</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>Element „{0}” nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>Obliczenie wyrażenia ze stałą dziesiętną nie powiodło się</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>Etykieta „{0}” jest duplikatem</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>Nie można przypisać pola tylko do odczytu (z wyjątkiem konstruktora lub inicjatora zmiennej)</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>Alias użycia „{0}” pojawił się poprzednio w tej przestrzeni nazw</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>Argument „{0}” musi być przekazywany ze słowem kluczowym „{1}”</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>Nieprawidłowa wartość nazwanego argumentu atrybutu „{0}”</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>Zduplikowane ograniczenie „{0}” dla parametru typu „{1}”</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>Do elementów członkowskich pola tylko do odczytu „{0}” typu „{1}” nie można przypisać inicjatora obiektu, ponieważ jest ono typu wartości</value>
  </data>
  <data name="ERR_FieldlikeEventsInRoStruct" xml:space="preserve">
    <value>Zdarzenia podobne do pól nie są dozwolone w strukturach tylko do odczytu.</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>Modyfikatora „async” można używać tylko w metodach mających treść.</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>Częściowe deklaracje elementu „{0}” nie mogą określać różnych klas podstawowych</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>Element „{0}” jest niedostępny z powodu swojego poziomu ochrony.</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>Dziedziczone elementy członkowskie „{0}” i „{1}” mają tę samą sygnaturę w typie „{2}”, dlatego nie mogą być przesłaniane</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>Dostęp indeksatora musi być wysyłany dynamicznie, ale jest to niemożliwe, ponieważ jest częścią wyrażenia dostępu bazowego. Rozważ możliwość rzutowania argumentów dynamicznych lub wykluczenia dostępu bazowego.</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>„{0}” nie ma odpowiedniej metody o nazwie „{1}”, ale wygląda na to, że ma metodę rozszerzenia o tej nazwie. Metody rozszerzenia nie mogą być wiązane dynamicznie. Rozważ rzutowanie dynamicznych argumentów lub wywołanie metody rozszerzenia bez składni metody rozszerzenia.</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>„{0}”: właściwości abstrakcyjne nie mogą mieć prywatnych metod dostępu</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>Podane wyrażenie wyrażenia „is” nigdy nie ma podanego typu</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>Określony ciąg wersji jest niezgodny z wymaganym formatem — główna.pomocnicza.kompilacja.poprawka</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>Błąd podczas otwierania pliku manifestu Win32 {0} — {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>„{0}” to nowy wirtualny element członkowski klasy zapieczętowanej „{1}”</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać właściwości indeksowanej</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>Nieprawidłowa składnia sumy kontrolnej #pragma</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>Kombinacja opcji elementu LookupOptions jest nieprawidłowa</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>Oczekiwano inicjatora tablicy o długości „{0}”</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>Nie można zwrócić pola tylko do odczytu przez zapisywalne odwołanie</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>Wyrażenie switch lub etykieta case musi być wartością logiczną, znakiem, ciągiem, liczbą całkowitą, wyliczeniem lub odpowiadającym typem dopuszczającym wartość null w języku C# 6 i wcześniejszych wersjach.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>Lokalizacja musi być określona, aby zapewnić minimalną kwalifikację typu.</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>Typ „{2}” musi być typem referencyjnym, aby można było używać go jako parametru „{1}” w typie ogólnym lub metodzie ogólnej „{0}”.</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>Przesłanie może zawierać tylko kod skryptu.</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu get, którą można przesłonić</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>Poprzednia klauzula catch przechwytuje już wszystkie wyjątki</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać operatorów</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>Plik „{0}” jest plikiem binarnym, a nie plikiem tekstowym</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>Wyrażenie switch musi być wartością; znaleziono element „{0}”.</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>Nie można przypisać elementu {0} do właściwości typu anonimowego</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>Nie można otworzyć „{0}” do zapisu — „{1}”</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>Nie można utworzyć delegata z metody „{0}”, ponieważ jest to metoda częściowa bez deklaracji implementującej.</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>Nie przesłaniaj metody object.Finalize. Zamiast tego udostępnij destruktor.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>konstruktor i destruktor treści wyrażenia</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>„{0}”: automatycznie implementowanych właściwości nie można używać wewnątrz typu oznaczonego jako StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>Oczekiwano nazwy pliku w cudzysłowie, jednowierszowego komentarza lub końca wiersza</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>Komentarz XML zawiera atrybut cref „{0}” przywołujący parametr typu</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>W delegacie „{0}” brak prawidłowego konstruktora.</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>Dekonstrukcja musi zawierać co najmniej dwie zmienne.</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>Metody rozszerzenia „{0}” zdefiniowanej dla typu wartości „{1}” nie można użyć do tworzenia delegatów</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>Niespójność dostępności: klasa podstawowa „{1}” jest mniej dostępna niż klasa „{0}”</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>Instrukcja goto case jest prawidłowa tylko wewnątrz instrukcji switch</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>Klasa System.Object nie może mieć klasy podstawowej ani implementować interfejsu</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>„{0}”: nie można zmienić modyfikatorów dostępu podczas przesłaniania elementu „{1}” dziedziczonym elementem członkowskim „{2}”</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>Indeksowanie nie może być typu void</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż operator „{0}”</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>Pole stałej wymaga podania wartości</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>Nie można przywrócić ostrzeżenia „CS{0}”, ponieważ zostało wyłączone globalnie</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora. Czy zamierzane było zadeklarowanie destruktora?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>Treść elementu „{0}” nie może być blokiem iteratora, ponieważ element „{0}” zwraca wartość przez odwołanie</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>Wewnątrz konstrukcji [] występuje niewłaściwa liczba indeksów. Oczekiwana liczba: {0}</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>Metoda częściowa nie może mieć parametrów wyjściowych.</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>W wyrażeniu występuje nieprawidłowe określenie „{0}”</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>Modyfikator dostępności dla metody dostępu „{0}” musi być bardziej restrykcyjny niż właściwość lub indeksator „{1}”</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>Atrybut CallerFilePathAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>Brak specyfikacji pliku dla opcji „{0}”</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>Oczekiwano nazwy pliku w cudzysłowach</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>Zduplikowana konwersja zdefiniowana przez użytkownika w typie „{0}”</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>Oczekiwano typu byte, sbyte, short, ushort, int, uint, long lub ulong.</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>Nieoczekiwane użycie nazwy ogólnej</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>Element „{0}” nie wymaga atrybutu CLSCompliant, ponieważ zestaw nie ma atrybutu CLSCompliant</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>Sygnatura „{0}” zarządzanej klasy otoki coclass dla interfejsu „{1}” nie jest prawidłową sygnaturą nazwy klasy.</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>Typ „{1}” istnieje zarówno w elemencie „{0}”, jak i „{2}”</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>Typ powoduje konflikt z zaimportowanym typem</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>W przypadku znaku „{0}” ucieczkę można zastosować tylko przez wpisanie dwóch znaków „{0}{0}” w ciągu interpolowanym.</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>Nieprawidłowy element include w kodzie XML</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>To ostrzeżenie występuje w przypadku utworzenia klasy przy użyciu metody, której sygnatura to publiczny wirtualny element void Finalize.

Jeśli taka klasa zostanie użyta jako klasa podstawowa i klasa pochodna definiuje destruktor, ten destruktor przesłoni metodę Finalize klasy podstawowej, a nie element Finalize.</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>Nie używaj atrybutu „System.Runtime.CompilerServices.FixedBuffer”. Zamiast niego użyj modyfikatora pola „fixed”.</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>Użycie wartości null jest nieprawidłowe w tym kontekście</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>Kwalifikator aliasu przestrzeni nazw „::” jest zawsze rozpoznawany jako typ lub przestrzeń nazw, dlatego jest tutaj niedozwolony. Zamiast niego rozważ możliwość użycia kwalifikatora „.”.</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>Parametru typu „{0}” nie można użyć z operatorem „as”, ponieważ nie ma ograniczenia typu klasy ani ograniczenia „class”</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>W metodzie statycznej słowo kluczowe „base” jest niedostępne.</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>Nie można zainicjować elementu członkowskiego „{0}”. To nie jest pole ani właściwość.</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>Niejednoznaczność pomiędzy „{0}” i „{1}”</value>
  </data>
  <data name="WRN_UnreferencedLocalFunction_Title" xml:space="preserve">
    <value>Funkcja lokalna jest zadeklarowana, ale nie jest nigdy używana</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: brak identyfikatora Guid dla opcji „{1}”</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>Celem przywołanego zestawu „{0}” jest inny procesor.</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>Nie można przypisać elementu {0} do zmiennej o typie określonym niejawnie</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Wystąpił błąd podczas zapisywania pliku wyjściowego: {0}.</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>„{0}”: konstruktor statyczny nie może zawierać jawnego wywołania konstruktora „this” lub „base”</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>zmienna środowiskowa LIB</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>Element „{0}” nie może implementować elementu „{1}”, ponieważ „{2}” to zdarzenie środowiska wykonawczego systemu Windows, a „{3}” to zwykłe zdarzenie środowiska .NET.</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>Element „{0}” jest przestarzały</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>Element „{0}” jest typu „{1}”. W deklaracji stałej należy określić typ sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, typ wyliczeniowy lub typ odwołania.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>Parametr „{0}” nie ma zgodnego tagu param w komentarzu XML elementu „{1}” (lecz inne parametry mają)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>Właściwość indeksowana „{0}” ma nieopcjonalne argumenty, które muszą być określone</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>Aby typ „{0}” mógł zostać użyty jako element AsyncMethodBuilder dla typu „{1}”, jego właściwość zadania powinna zwracać typ „{1}” zamiast typu „{2}”.</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>„{0}”: pole nie może być jednocześnie nietrwałe i tylko do odczytu</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>Oczekiwano dyrektywy #endregion.</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>Nazwa parametru „{0}” powoduje konflikt z nazwą parametru generowaną automatycznie</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>Parametry typu nie są dozwolone w grupie metod jako argument operatora „nameof”.</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>Niespójność dostępności: typ parametru „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>Poprzednia klauzula catch przechwytuje już wszystkie wyjątki. Wszystkie wywołane elementy niebędące wyjątkami zostaną opakowane w elemencie System.Runtime.CompilerServices.RuntimeWrappedException.</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value> Nie można wstawić części lub całości dołączonego kodu XML </value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania na „{0}”</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>Dekonstrukcja nie może mieszać deklaracji i wyrażeń po lewej stronie.</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>Oczekiwano wartości stałej</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>Parametr typu „{0}” ma tę samą nazwę co parametr typu zewnętrznego „{1}”</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>Nie można niejawnie przekonwertować literału typu double na typ „{1}”. W celu utworzenia literału tego typu należy użyć sufiksu „{0}”.</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Opcje kompilatora Visual C#

                        - PLIKI WYJŚCIOWE -
 /out:&lt;plik&gt;                   Określ nazwę pliku wyjściowego (domyślnie: nazwa podstawowa
                               pliku z klasą główną lub pierwszym plikiem)
 /target:exe                   Kompiluj plik wykonywalny konsoli (domyślnie) (krótka 
                               wersja: /t:exe)
 /target:winexe                Kompiluj plik wykonywalny systemu Windows (krótka wersja: 
                               /t:winexe)
 /target:library               Kompiluj bibliotekę (krótka wersja: /t:library)
 /target:module                Kompiluj moduł, który można dodać do innego 
                               zestawu (krótka wersja: /t:module)
 /target:appcontainerexe       Kompiluj plik wykonywalny kontenera aplikacji (krótka wersja: 
                               /t:appcontainerexe)
 /target:winmdobj              Kompiluj plik pośredni środowiska uruchomieniowego systemu Windows 
                               przeznaczony dla narzędzia WinMDExp (krótka wersja: /t:winmdobj)
 /doc:&lt;plik&gt;                   Plik dokumentacji XML do wygenerowania
 /refout:&lt;plik&gt;                Dane wyjściowe zestawu odwołania do wygenerowania
  /platform:&lt;ciąg&gt;              Ogranicz platformy, na których można uruchamiać ten kod: x86,
                               Itanium, x64, arm, anycpu32bitpreferred lub 
                               anycpu. Wartość domyślna to anycpu.

                        - PLIKI WEJŚCIOWE -
 /recurse:&lt;symbol wieloznaczny&gt; Dołącz wszystkie pliki zawarte w bieżącym katalogu i 
                               jego podkatalogach zgodnie ze specyfikacją określoną przy użyciu 
                               symboli wieloznacznych
 /reference:&lt;alias&gt;=&lt;plik&gt;     Odwołuj się do metadanych z określonego pliku 
                               zestawu przy użyciu podanego aliasu (krótka wersja: /r)
 /reference:&lt;lista plików&gt;     Odwołuj się do metadanych z określonych 
                               plików zestawów (krótka wersja: /r)
 /addmodule:&lt;lista plików&gt;     Połącz określone moduły z tym zestawem
 /link:&lt;lista plików&gt;          Osadź metadane z określonych plików 
                               zestawów międzyoperacyjnych (krótka wersja: /l)
 /analyzer:&lt;lista plików&gt;      Uruchom analizatory z tego zestawu
                               (krótka wersja: /a)
 /additionalfile:&lt;lista plików&gt; Dodatkowe pliki, które nie mają bezpośredniego wpływu na generowanie
                               kodu, ale mogą być używane przez analizatory w celu tworzenia
                               komunikatów o błędach lub ostrzeżeń.
 /embed                        Osadź wszystkie pliki źródłowe w pliku PDB.
 /embed:&lt;lista plików&gt;            Osadź określone pliki w pliku PDB

                        - ZASOBY -
 /win32res:&lt;plik&gt;              Określ plik zasobu Win32 (res)
 /win32icon:&lt;plik&gt;             Użyj tej ikony dla pliku wyjściowego
 /win32manifest:&lt;plik&gt;         Określ plik manifestu środowiska Win32 (xml)
 /nowin32manifest              Nie dołączaj domyślnego manifestu środowiska Win32
 /resource:&lt;informacje o zasobie&gt; Osadź określony zasób (krótka wersja: /res)
 /linkresource:&lt;informacje o zasobie&gt; Połącz określony zasób z tym zestawem 
                               (krótka wersja: /linkres), gdzie format informacji o zasobie 
                               to &lt;plik&gt;[,&lt;nazwa ciągu&gt;[,public|private]]

                        - GENEROWANIE KODU -
 /debug[+|-]                   Emituj informacje o debugowaniu
 /debug:{full|pdbonly|portable|embedded}
                               Określ typ debugowania (wartość domyślna to „full”, 
                               wartość „portable” to format międzyplatformowy,
                               a wartość „embedded” to format międzyplatformowy wbudowany w 
                               docelowym pliku DLL lub EXE)
 /optimize[+|-]                Włącz optymalizacje (krótka wersja: /o)
 /deterministic                Utwórz zestaw deterministyczny
                               (w tym sygnaturę czasową i identyfikator GUID wersji modułu)
 /refonly                      Utwórz zestaw odwołania zamiast głównych danych wyjściowych
  /instrument:TestCoverage      Utwórz zestaw instrumentowany w celu gromadzenia
                               informacji o pokryciu
 /sourcelink:&lt;plik&gt;            Informacje o linku źródłowym na potrzeby osadzenia w pliku PDB.

                        - BŁĘDY I OSTRZEŻENIA -
 /warnaserror[+|-]             Zgłaszaj wszystkie ostrzeżenia jako błędy
 /warnaserror[+|-]:&lt;lista ostrzeżeń&gt; Zgłaszaj określone ostrzeżenia jako błędy
 /warn:&lt;n&gt;                     Ustaw poziom ostrzeżenia (0–4) (krótka wersja: /w)
 /nowarn:&lt;lista ostrzeżeń&gt;     Wyłącz określone komunikaty ostrzeżeń
 /ruleset:&lt;plik&gt;               Określ plik zestawu reguł wyłączający określone
                               funkcje diagnostyczne.
 /errorlog:&lt;plik&gt;              Określ plik, w którym mają zostać zarejestrowane dane diagnostyczne
                               wszystkich kompilatorów i analizatorów.
 /reportanalyzer               Zgłaszaj dodatkowe informacje analizatora, takie jak
                               czas wykonywania.
 
                        -JĘZYK -
 /checked[+|-]                 Generuj operacje sprawdzenia przepełnienia
 /unsafe[+|-]                  Zezwalaj na niebezpieczny kod
 /define:&lt;lista symboli&gt;       Definiuj symbole kompilacji warunkowej (krótka 
                               wersja: /d) 
 /langversion:?                Wyświetl dozwolone wartości dla wersji języka
 /langversion:&lt;ciąg&gt;         Określ wersję języka, taką jak
                               default (najnowsza wersja główna) lub
                               latest (najnowsza wersja, z uwzględnieniem wersji pomocniczych)
                               lub konkretna wersja, na przykład „6” lub „7.1”

                        - ZABEZPIECZENIA -
 /delaysign[+|-]               Podpisz z opóźnieniem zestaw, używając tylko 
                               części publicznej klucza o silnej nazwie
 /publicsign[+|-]              Podpisz publicznie zestaw, używając tylko
                               części publicznej klucza o silnej nazwie
 /keyfile:&lt;plik&gt;               Określ plik klucza o silnej nazwie
 /keycontainer:&lt;ciąg&gt;          Określ kontener klucza o silnej nazwie
 /highentropyva[+|-]           Włącz losowe generowanie układu przestrzeni adresowej o wysokiej entropii

                        - RÓŻNE -
 @&lt;plik&gt;                       Odczytaj plik odpowiedzi w celu uzyskania dodatkowych opcji
 /help                         Wyświetl ten komunikat dotyczący użycia (krótka wersja: /?)
 /nologo                       Pomiń komunikat kompilatora o prawach autorskich
 /noconfig                     Nie dołączaj automatycznie pliku CSC.RSP
 /parallel[+|-]                Współbieżna kompilacja.
 /version                      Wyświetl numer wersji kompilatora i wyjdź.

                        - ZAAWANSOWANE -
 /baseaddress:&lt;adres&gt;          Adres podstawowy dla biblioteki do skompilowania
 /checksumalgorithm:&lt;algorytm&gt; Określ algorytm do obliczania sumy kontrolnej
                               pliku źródłowego przechowywanej w pliku PDB. Obsługiwane są następujące wartości:
                               SHA1 (domyślnie) lub SHA256.
 /codepage:&lt;n&gt;                 Określ stronę kodową do użycia podczas otwierania 
                               plików źródłowych
 /utf8output                   Wyprowadź komunikaty kompilatora przy użyciu kodowania UTF-8
 /main:&lt;typ&gt;                   Określ typ zawierający punkt wejścia 
                               (wszystkie pozostałe możliwe punkty wejścia zostaną zignorowane) (krótka 
                               wersja: /m)
 /fullpaths                    Kompilator generuje w pełni kwalifikowane ścieżki
 /filealign:&lt;n&gt;                Określ wyrównanie stosowane dla sekcji 
                               plików wyjściowych
 /pathmap:&lt;K1&gt;=&lt;W1&gt;,&lt;K2&gt;=&lt;W2&gt;,... 
                               Określ mapowanie dla nazw ścieżek źródłowych wyprowadzanych przez 
                               kompilator.
 /pdb:&lt;plik&gt;                   Określ nazwę pliku z informacjami o debugowaniu (domyślnie: 
                               nazwa pliku wyjściowego z rozszerzeniem pdb)
 /errorendlocation             Wyprowadź wiersz i kolumnę lokalizacji końcowej dla 
                               każdego błędu
 /preferreduilang              Określ nazwę preferowanego języka wyjściowego.
 /nostdlib[+|-]                Nie odwołuj się do biblioteki standardowej (mscorlib.dll)
 /subsystemversion:&lt;ciąg&gt;      Określ wersję podsystemu tego zestawu
 /lib:&lt;lista plików&gt;           Określ dodatkowe katalogi do przeszukania pod kątem 
                               odwołań
 /errorreport:&lt;ciąg&gt;           Określ, w jaki sposób obsługiwać wewnętrzne błędy kompilatora: 
                               prompt, send, queue lub none. Wartość domyślna to 
                               queue.
 /appconfig:&lt;plik&gt;             Określ plik konfiguracji aplikacji 
                               zawierający ustawienia powiązania zestawu
 /moduleassemblyname:&lt;ciąg&gt;    Nazwa zestawu, którego częścią 
                               ma być ten moduł
 /modulename:&lt;ciąg&gt;            Określ nazwę modułu źródłowego
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>Błąd składni; oczekiwano wartości</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>Elementu „{0}” nie można zapieczętować, ponieważ nie jest przesłonięciem</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#błąd: „{0}”</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>Zmienna zakresu „{0}” jest już zadeklarowana</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>W atrybucie AssemblySignatureKeyAttribute określono nieprawidłowy klucz publiczny sygnatury.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}” została zignorowana, ponieważ typ elementu docelowego „{1}” określa inną nazwę lub nie określa żadnej nazwy.</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>To ostrzeżenie występuje, gdy w przypadku próby wywołania metody, właściwości lub indeksatora w elemencie członkowskim klasy pochodnej elementu MarshalByRefObject element członkowski jest typem wartości. Obiekty dziedziczące po elemencie MarshalByRefObject zwykle powinny być kierowane przez odwołanie w domenie aplikacji. Jeśli kod spróbuje bezpośrednio uzyskać dostęp do elementu członkowskiego typu wartości takiego obiektu w domenie aplikacji, wystąpi wyjątek czasu wykonywania. Aby rozwiązać problem podany w ostrzeżeniu, skopiuj element członkowski do zmiennej lokalnej i wywołaj metodę w tej zmiennej.</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>Istnieją dwa indeksatory o różnych nazwach. Dla każdego indeksatora w określonym typie należy użyć atrybutu IndexerName o takiej samej nazwie.</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>Operator „await” wymaga, aby zwracany typ „{0}” metody „|{1}.GetAwaiter()” zawierał odpowiednie elementy członkowskie IsCompleted, OnCompleted i GetResult oraz implementował element INotifyCompletion lub ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>Element „{0}” to niejednoznaczne odwołanie między elementem „{1}” i „{2}”</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>Opcja przesłania atrybut podany w pliku źródłowym lub dodanym module</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>Metody częściowe muszą zwracać typ void.</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>Cykliczna zależność klasy podstawowej obejmująca element „{0}” i „{1}”</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>Oczekiwano identyfikatora lub literału liczbowego</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>Nie można niejawnie przekonwertować typu „{0}” na „{1}”.</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>„{0}”: nie może istnieć inicjator zdarzenia interfejsu</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>Konstruktor „{0}” nie może wywołać sam siebie</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>W ciągu interpolowanym nie można użyć jednowierszowego komentarza.</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>Lokalna zmienna lub funkcja o nazwie „{0}” została już zdefiniowana w tym zakresie</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>Te dwa zestawy różnią się numerem wydania i/lub wersji. Aby można było wykonać ujednolicenie, musisz określić dyrektywy w pliku config aplikacji i podać poprawną silną nazwę zestawu.</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>Nie można zmodyfikować zwracanej wartości „{0}”, ponieważ nie jest to zmienna.</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>„{0}”: typ podstawowy „{1}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>Nie można przypisać wartości do elementu „{0}” ponieważ jest on tylko do odczytu</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>Parametr {0} jest deklarowany jako typ „{1}{2}”, a powinien być „{3}{4}”</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Błąd podczas odczytu pliku „{0}” określonego przez argument nazwany „{1}” atrybutu PermissionSet: „{2}”</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>Klauzula ograniczenia została już określona dla parametru typu „{0}”. Wszystkie ograniczenia dla parametru typu muszą być określone w jednej klauzuli where.</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania na „void”</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>Nie można zwrócić zmiennej lokalnej „{0}” przez odwołanie, ponieważ to nie jest zmienna lokalna ref</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>Wywołanie konstruktora musi być wysyłane dynamicznie, ale jest to niemożliwe, ponieważ jest częścią inicjatora konstruktora. Rozważ możliwość rzutowania argumentów dynamicznych.</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>Nie można wywnioskować typu zmiennej wyjściowej z niejawnym typem „{0}”.</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}”.</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>inicjator obiektu</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>Zmienne o typie określonym niejawnie nie mogą mieć wiele deklaratorów</value>
  </data>
  <data name="ERR_RefReturnReadonlyNotField" xml:space="preserve">
    <value>Nie można zwrócić elementu {0} „{1}” przez zapisywalne odwołanie, ponieważ jest to zmienna tylko do odczytu</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>Przestrzeń nazw nie może bezpośrednio zawierać elementów członkowskich, takich jak pola lub metody</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>Modyfikator elementu członkowskiego „{0}” musi wystąpić przed definicją typu i nazwy elementu członkowskiego</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>Oczekiwano znaku }</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>Pusty blok „switch”</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>Oczekiwano argumentu atrybutu nazwanego</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>Parametr ma wiele różnych domyślnych wartości.</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>Argumentu typu „{0}” nie można stosować do atrybutu DefaultParameterValue</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>Zdefiniowana przez użytkownika konwersja musi dokonywać konwersji na typ otaczający lub z niego</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>Element członkowski „{0}” typu „{1}” powoduje wystąpienie cyklu w układzie struktury</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>Typ ograniczenia nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>Nie można zastosować klasy atrybutów „{0}”, ponieważ jest ona abstrakcyjna</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>Element „{0}” musi zadeklarować treść, ponieważ nie jest oznaczony jako abstrakcyjny, zewnętrzny ani częściowy</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Wykryto nieosiągalny kod</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>W tej metodzie asynchronicznej brakuje operatorów „await”, dlatego będzie wykonywana synchronicznie. Rozważ możliwość użycia operatora „await” w celu zdefiniowania oczekiwania na nieblokujące wywołania interfejsów API albo wyrażenia „await Task.Run(...)” w celu przeniesienia wykonywania zadań intensywnie angażujących procesor do wątku w tle.</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>Zmienna zakresu „{0}” nie może mieć takiej samej nazwy jak parametr typu metody</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>Typ „{0}” nie ma zdefiniowanego konstruktora.</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>metoda anonimowa</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Oczekiwano skryptu (plik CSX), ale go nie określono</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>typy dopuszczające wartość null</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>Forma „var (...)” dekonstrukcji nie zezwala na specyficzny typ wartości „var”.</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>Nie określono numeru wiersza dla dyrektywy #line lub określony numer jest nieprawidłowy.</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> Nie można dołączyć nieprawidłowo sformułowanego pliku XML „{0}”</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>Nie można załadować zestawu analizatora {0}: {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>Operator zdefiniowany przez użytkownika „{0}” musi być zadeklarowany ze specyfikatorami static i public</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>Nieprawidłowa deklaracja; zamiast niej użyj konstrukcji „{0} operator &lt;typ_docelowy&gt; (...”</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>„{0}”: typów statycznych nie można użyć jako typów w instrukcji return</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>Element „{0}” nie powinien mieć parametru params, ponieważ nie ma go element „{1}”</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>Nie można utworzyć pliku tymczasowego — {0}</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>Najlepsza metoda przeładowania dla elementu „{0}” nie ma parametru o nazwie „{1}”.</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>Parametr typu „{0}” ma tę samą nazwę co zawierający typ lub metoda</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>Element członkowski ukrywa dziedziczony element członkowski; brak słowa kluczowego new</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>Metoda częściowa musi być zadeklarowana w klasie lub strukturze częściowej.</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowaną przestrzenią nazw „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>Przestrzeń nazw „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyta przestrzeń nazw zdefiniowana w elemencie „{0}”.</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>Niektóre argumenty najlepiej dopasowanej przeciążonej metody Add „{0}”dla inicjatora kolekcji są nieprawidłowe.</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>Do utworzenia tablicy wymagane jest określenie rozmiaru tablicy lub inicjatora tablicy.</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>Parametr typu „{0}” nie ma zgodnego tagu typeparam w komentarzu XML elementu „{1}” (lecz inne parametry typu mają)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>Przypisanie w wyrażeniu warunkowym jest zawsze stałe. Czy zamiast operatora = miał zostać użyty operator == ?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>Nie można zastosować klasy atrybutów „{0}”, ponieważ jest ona typu ogólnego</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>Błąd podczas odczytywania pliku manifestu Win32 „{0}” — „{1}”</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>Atrybut „{0}” z modułu „{1}” zostanie zignorowany na korzyść wystąpienia w źródle</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>Nie można przypisać elementu „{0}” do zmiennej zakresu</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>Parametr params musi być ostatnim parametrem na liście parametrów formalnych</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>Instrukcja throw bez argumentów jest niedozwolona w klauzuli finally zagnieżdżonej w najbliższej otaczającej klauzuli catch.</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>Krotka musi zawierać co najmniej dwa elementy.</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>Typu „{0}” nie można użyć jako argumentu typu.</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>Nie można osadzić typu międzyoperacyjnego „{0}”, ponieważ brakuje w nim wymaganego atrybutu „{1}”.</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>Asynchroniczne wyrażenie lambda przekonwertowane na delegata zwracającego typ „Task” nie może zwracać wartości. Czy zamierzony zwracany typ to „Task&lt;T&gt;”?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>Nazwa języka „{0}” jest nieprawidłowa.</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>W instrukcjach deklaracji „for”, „using”, „fixed”, „or” nie można użyć większej liczby typów niż jeden.</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>Nie można wykonać przypisania do zmiennej zakresu „{0}” — można ją tylko odczytać</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>Element „{0}” nie zawiera konstruktora przyjmującego następującą liczbę argumentów: {1}</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>Ciągi kultury zestawu nie mogą zawierać osadzonych znaków NUL.</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>Użycie typu dopuszczającego wartość null „{0}” jest niedozwolone we wzorcu. Użyj zamiast tego bazowego typu „{1}”.</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>Obie częściowe deklaracje metody muszą używać parametru params lub żadna nie może go używać</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>Element „{0}” w jawnej deklaracji interfejsu nie jest elementem członkowskim interfejsu</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>Typ „{1}” w elemencie „{0}” powoduje konflikt z zaimportowanym typem „{3}” w elemencie „{2}”. Zostanie użyty typ zdefiniowany w elemencie „{0}”.</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>W tablicy nie mogą występować elementy typu „{0}”</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>Nie można używać modyfikatorów w deklaracjach metod dostępu do zdarzeń.</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>Przed interfejsami musi występować klasa podstawowa „{0}”</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Określono opcje powodujące konflikt: plik zasobów Win32; manifest Win32</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>Iteratory nie mogą mieć niebezpiecznych parametrów ani typów przekazywania.</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>Klasy CallerMemberNameAttribute nie można zastosować, ponieważ nie ma standardowych konwersji z typu „{0}” do typu „{1}”</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>Nie można zwrócić elementu członkowskiego parametru „{0}” przez odwołanie, ponieważ to nie jest parametr ref ani out</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(Lokalizacja symbolu związanego z poprzednim błędem)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>Nie można użyć instrukcji yield z wartością w treści klauzuli catch.</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>Ponieważ jest to metoda asynchroniczna, zwracane wyrażenie musi być typu „{0}”, a nie „Task&lt;{0}&gt;”</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>Oczekiwano znaku { lub ;</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>W przypadku statycznej właściwości, statycznej metody lub statycznego inicjatora pola użycie słowa kluczowego „this” jest nieprawidłowe</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>parametr opcjonalny</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>Określono nieprawidłową ścieżkę wyszukiwania</value>
  </data>
  <data name="ERR_RefReturnThis" xml:space="preserve">
    <value>Nie można zwrócić elementu „this” przez odwołanie.</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>Nie można znaleźć typu międzyoperacyjnego zgodnego z osadzonym typem międzyoperacyjnym „{0}”. Czy brakuje odwołania do zestawu?</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>To ostrzeżenie występuje, jeśli atrybut zestawu AssemblyKeyFileAttribute lub AssemblyKeyNameAttribute w źródle powoduje konflikt z opcją wiersza polecenia /keyfile lub /keycontainer albo z nazwą pliku klucza lub kontenerem określonymi we właściwościach projektu.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>To ostrzeżenie oznacza, że nie określono poprawnie atrybutu, takiego jak InternalsVisibleToAttribute.</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>Deklaracja zmiennej dostępnej przez odwołanie musi mieć inicjator</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>Atrybutu „MethodImplOptions.Synchronized” nie można stosować do metody asynchronicznej.</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>Nie można zwrócić parametru „{0}” przez odwołanie, ponieważ to nie jest parametr ref ani out</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>Elementów definiowanych w przestrzeni nazw nie można jawnie deklarować jako prywatnych, chronionych, chronionych wewnętrznych lub prywatnych chronionych</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>Opcję /moduleassemblyname można określić tylko w przypadku kompilowania elementu docelowego typu „module”.</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>Parametr typu „{0}” dziedziczy powodujące konflikt ograniczenia „{1}” i „{2}”.</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>Identyfikator zasobu „{0}” został już użyty w tym zestawie</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>Wartość domyślna parametru „{0}” musi być stałą czasu kompilacji</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>Program nie zawiera statycznej metody „Main” odpowiedniej jako punkt wejścia</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>Ten błąd występuje w przypadku odnalezienia wstępnie zdefiniowanego typu, takiego jak System.Int32, w dwóch zestawach. Może się tak dziać, gdy utworzono odwołanie do elementu mscorlib lub biblioteki System.Runtime.dll w dwóch różnych miejscach, na przykład podczas próby uruchomienia dwóch wersji programu .NET Framework obok siebie.</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>Nie można zwrócić przez odwołanie elementu członkowskiego elementu „{0}”, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez odwołanie</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal do utworzenia tokenów literałów liczbowych.</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>Obie deklaracje metody częściowej muszą być statyczne albo żadna z nich nie może być statyczna.</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>„{0}” to nie jest typ referencyjny wymagany przez instrukcję lock</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>Statycznego pola tylko do odczytu nie można zwrócić przez zapisywalne odwołanie</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>Interfejsy zgodne ze specyfikacją CLS muszą mieć tylko elementy członkowskie zgodne ze specyfikacją CLS</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>Dodane moduły muszą być oznaczone atrybutem CLSCompliant, aby były zgodne z zestawem</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>„{0}”: parametr, zmienna lokalna lub funkcja lokalna nie może mieć tej samej nazwy co parametr typu metody</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>Typ zwracany nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>Błąd podczas otwierania pliku ikony {0} — {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>Nie znaleziono elementu SyntaxTree „{0}” do usunięcia</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>Nie można wnioskować typu wprowadzonej niejawnie zmiennej dekonstrukcji „{0}“.</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>Ograniczenia dla przesłoniętych i jawnych metod implementacji interfejsu są dziedziczone z metody podstawowej, dlatego nie mogą być określone bezpośrednio</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>Określono nieprawidłową nazwę pliku dla dyrektywy preprocesora</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>W przypadku znaku „{0}” należy zastosować ucieczkę (przez wpisanie dwóch takich znaków) w ciągu interpolowanym.</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>metoda rozszerzenia</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>Wyrażenie nie ma nazwy.</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>Wystąpił nieoczekiwany błąd podczas zapisywania informacji debugowania — „{0}”</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>Kompilacja (C#): </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>Typ nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>Nie można przekonwertować na typ statyczny „{0}”.</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>Typ nie ma dostępnych konstruktorów używających tylko typów zgodnych ze specyfikacją CLS</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ jest to element członkowski typu „{1}” niezgodnego ze specyfikacją CLS</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>typy anonimowe</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>Stałej „{0}” nie można oznaczyć jako statycznej</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>W tym kontekście nie można użyć właściwości lub indeksatora „{0}”, ponieważ brakuje dla niej metody dostępu Get.</value>
  </data>
  <data name="ERR_AutoPropsInRoStruct" xml:space="preserve">
    <value>Automatycznie implementowane właściwości wystąpienia w strukturach tylko do odczytu muszą być tylko do odczytu.</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>Określona wersja „{0}” języka nie może mieć zer wiodących</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>Błąd podczas otwierania pliku odpowiedzi „{0}”</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>Najlepsza przeciążona metoda Add dla elementu inicjatora kolekcji jest przestarzała</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż operator „{0}”</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>Nieużywany alias zewnętrzny.</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>Odwołanie do zmiennej wyjściowej z niejawnym typem „{0}” jest niedozwolone na tej samej liście argumentów.</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>Brak częściowego modyfikatora w deklaracji typu „{0}”. Istnieje inna częściowa deklaracja tego typu</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>„{0}”: nie można przesłonić, ponieważ element „{1}” nie ma metody dostępu set, którą można przesłonić</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>Alias zewnętrzny „{0}” nie został określony w opcji /reference.</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>Czy chodziło Ci o użycie domyślnej etykiety switch („default:”) zamiast „case default:”? Jeśli rzeczywiście chcesz użyć domyślnego literału, rozważ użycie literału „case (default):” lub innego literału („case 0:” bądź „case null:”).</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>„{0}” nie jest rozpoznawaną lokalizacją atrybutu. Prawidłowe lokalizacje atrybutu dla tej deklaracji to „{1}”. Wszystkie atrybuty w tym bloku zostaną zignorowane.</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>Parametr „{0}” musi być deklarowany za pomocą słowa kluczowego „{1}”</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>Interfejs „{0}” zawiera nieprawidłowy interfejs źródłowy wymagany do osadzenia zdarzenia „{1}”.</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>Nie można użyć najlepiej dopasowanej przeciążonej metody Match „{0}” dla elementu inicjatora kolekcji. Metody „Add” inicjatora kolekcji nie mogą mieć parametrów ref ani out.</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>„{0}”: nie znaleziono odpowiedniej metody do przesłonięcia</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;lista ścieżek&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>Nie można zmodyfikować elementów członkowskich „{0}”, ponieważ jest to „{1}”</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>„{0}”: tylko elementy członkowskie zgodne ze specyfikacją CLS mogą być abstrakcyjne</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>Niepotrzebna dyrektywa using</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>Nie można połączyć plików zasobów podczas kompilowania modułu</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;globalna przestrzeń nazw&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>Cykliczna zależność ograniczenia obejmująca elementy „{0}” i „{1}”.</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>Element „{0}” definiuje operator == lub !=, lecz nie przesłania metody Object.GetHashCode()</value>
  </data>
  <data name="IDS_LangVersions" xml:space="preserve">
    <value>Obsługiwane wersje językowe:</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>Jeden z parametrów operatora binarnego musi być typem zawierającym</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>„{0}” nie implementuje „{1}”</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>Nie można uzyskać dostępu do członka chronionego „{0}” za pośrednictwem kwalifikatora typu „{1}”. Wymagany jest kwalifikator typu „{2}” (lub typu pochodzącego od tego typu).</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>Brak wymaganego przez kompilator członka „{0}.{1}”.</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>Atrybuty zestawów i modułów nie są dozwolone w tym kontekście</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>Oczekiwano jednowierszowego komentarza lub znacznika końca wiersza.</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>Element członkowski nie ukrywa dziedziczonego elementu członkowskiego; słowo kluczowe new nie jest wymagane</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>Struktury bez jawnych konstruktorów nie mogą zawierać elementów członkowskich z inicjatorami.</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>„{0}”: klas statycznych nie można używać jako ograniczeń</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>Zwracany typ metody asynchronicznej musi mieć wartość „void”, „Task” lub „Task&lt;T&gt;”.</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>Komentarz XML ma atrybut cref „{0}”, którego nie można rozpoznać</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>Nie można odnaleźć nazwy typu „{0}” w przestrzeni nazw „{1}”. Ten typ został przesłany dalej do zestawu „{2}”. Rozważ możliwość dodania odwołania do tego zestawu.</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Instrukcja foreach nie może działać względem elementu „{0}”. Czy element „{0}” miał być wywołany?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>Odwołanie do pola nietrwałego nie będzie traktowane jak nietrwałe</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>Dostęp do elementu członkowskiego pola w klasie marshal-by-reference może spowodować wystąpienie wyjątku czasu wykonywania</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>Typ pola nie może być typem void</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>Typ podstawowy nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>Metody rozszerzenia muszą być zdefiniowane w statycznych klasach najwyższego poziomu. „{0}” to klasa zagnieżdżona</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>Moduł „{0}” jest już zdefiniowany w tym zestawie. Nazwa pliku każdego modułu musi być unikatowa.</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>Atrybuty w tym kontekście są nieprawidłowe.</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>bufory o ustalonym rozmiarze</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>Użycie średnika po bloku metody lub metody dostępu jest nieprawidłowe.</value>
  </data>
  <data name="ERR_RefReadonlyNotField2" xml:space="preserve">
    <value>Elementy członkowskie elementu {0} „{1}” nie mogą być używane jako wartość ref ani out, ponieważ jest to zmienna tylko do odczytu</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>Osadzenie typu międzyoperacyjnego „{0}” z zestawu „{1}” powoduje konflikt nazw w bieżącym zestawie. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>Metody ze zmiennymi argumentami nie są zgodne ze specyfikacją CLS</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>„{0}”: modyfikatorów dostępności można używać tylko wtedy, gdy właściwość lub indeksator mają metody dostępu Get i Set</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>Nie można zdefiniować klasy ani elementu członkowskiego korzystającego z typu „dynamic”, ponieważ nie można odnaleźć wymaganego przez kompilator typu „{0}”. Czy brakuje odwołania?</value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>Modyfikator „abstract” w polach jest nieprawidłowy. Spróbuj zamiast niego użyć właściwości.</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>włącz typ wartości logicznej</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>Wynikiem wyrażenia jest zawsze element „null” typu „{0}”</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>Atrybut CLSCompliant nie ma znaczenia w przypadku zastosowania go do typów zwracanych</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>Nie można przekonwertować bloku „{0}” na zamierzony typ delegowany, ponieważ niektóre typy zwracane występujące w bloku nie umożliwiają niejawnej konwersji na zwracany typ delegowany</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>Brak komentarza XML dla widocznego publicznie typu lub elementu członkowskiego „{0}”</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>Element członkowski „{0}” implementuje element członkowski interfejsu „{1}” w typie „{2}”. W czasie wykonywania element członkowski interfejsu jest zgodny z wieloma metodami. Od implementacji zależy, która metoda zostanie wywołana.</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>Kompilator emituje to ostrzeżenie w przypadku przesłonięcia błędu z ostrzeżeniem. Aby uzyskać informacje dotyczące tego problemu, wyszukaj podany kod błędu.</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>zmienna użycia</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>Ograniczenie new() musi być ostatnim określonym ograniczeniem</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>Element „{0}” znajduje się już na liście interfejsów w typie „{2}” z różnymi nazwami elementów krotki jako „{1}”.</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>Do pola „{0}” nigdy nie jest przypisywana wartość i będzie ono mieć zawsze wartość domyślną {1}</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Zestawy podpisane silnymi nazwami muszą określać klucz publiczny w swoich deklaracjach InternalsVisibleTo.</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>Typ nie jest zgodny ze specyfikacją CLS, ponieważ interfejs podstawowy nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>Typ „{1}” już definiuje element członkowski o nazwie „{0}” z tymi samymi typami parametrów</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;!-- Zignorowano nieprawidłowo sformułowany komentarz XML elementu członkowskiego „{0}” --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>Nie można przekonwertować bloku metody anonimowej bez listy parametrów na typ delegowany „{0}”, ponieważ ma on jeden lub kilka parametrów out</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>Atrybut „{0}” jest prawidłowy tylko w przypadku metod lub klas atrybutów</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>W tym kontekście nie można użyć słowa kluczowego „void”.</value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>Przestrzeń nazw „{0}” już zawiera definicję dla „{1}”</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>Element items: nie może być pusty</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>Oczekiwano identyfikatora lub literału liczbowego.</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>Komentarz XML elementu „{1}” ma tag paramref dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>Oczekiwano operatora jednoargumentowego z możliwością przeciążenia.</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>Nie można zastosować operatora „{0}” do operandu „{1}”</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>Nie można wyszukać elementu członkowskiego w elemencie „{0}”, ponieważ to jest parametr typu</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>Nazwa modułu „{0}” przechowywana w elemencie „{1}” musi być zgodna z nazwą jego pliku.</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>Użycie elementu „{0}” jako wartości ref lub out albo pobranie jego adresu może spowodować wyjątek czasu wykonywania, ponieważ to jest pole klasy marshal-by-reference</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>„{0}”: elementy tablicy nie mogą być typu statycznego</value>
  </data>
  <data name="IDS_SK_CONSTRUCTOR" xml:space="preserve">
    <value>konstruktor</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>Nie można określić typu wyrażenia warunkowego, ponieważ nie istnieje niejawna konwersja między elementem „{0}” i „{1}”</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>Nie można przypisać wartości do elementu „{0}”, ponieważ jest to „{1}”.</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>Zdarzenie „{0}” może występować tylko po lewej stronie symboli += lub -= (z wyjątkiem sytuacji, w której używane jest z wnętrza typu „{1}”)</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Set jest niedostępna.</value>
  </data>
  <data name="IConversionExpressionIsNotCSharpConversion" xml:space="preserve">
    <value>{0} nie jest prawidłowym wyrażeniem konwersji języka C#.</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>Nazwany argument „{0}” określa parametr, dla którego argument pozycyjny został już wskazany.</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>Nie można przekonwertować grupy metod „{0}” na typ niedelegowany „{1}”. Czy zamierzasz wywołać metodę?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>Opcja /win32manifest dla modułu zostanie zignorowana, ponieważ dotyczy tylko zestawów</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>Instrukcja foreach wymaga, aby typ zwracany „{0}” dla elementu „{1}” miał odpowiednią metodę publiczną MoveNext i właściwość publiczną Current</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(Lokalizacja symbolu związanego z poprzednim ostrzeżeniem)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>Inicjatora tablicy można użyć tylko w inicjatorze zmiennej lub pola. Zamiast tego spróbuj użyć wyrażenia „new”.</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;null&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;tekst&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>Niezgodność odwołań między metodą „{0}” a delegatem „{1}”</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>„{0}”: nie można przesłonić, ponieważ element „{1}” nie jest funkcją</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>niejawnie typizowana zmienna lokalna</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” musi być strukturą.</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>niejawnie typizowana tablica</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>Użyj metody Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier lub Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier do utworzenia tokenów identyfikatorów.</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>„{0}”: nie można umieścić inicjatorów właściwości lub pola wystąpienia w strukturach</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Instrukcje yield nie mogą pojawiać się na najwyższym poziomie kodu interaktywnego.</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>„{0}”: musi istnieć możliwość niejawnego przekonwertowania typu użytego w instrukcji using na interfejs „System.IDisposable”</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>Możliwe niezamierzone porównanie odwołań. Aby porównać wartości, wykonaj rzutowanie lewej strony na typ „{0}”</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>Nieprawidłowy specyfikator rangi: oczekiwano „,” lub „]”</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>Metoda dostępu do właściwości jest już zdefiniowana</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>Nie można zainicjować zmiennej o typie określonym niejawnie za pomocą inicjatora tablicy</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>W stałej występuje symbol przejścia do następnego wiersza</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>Typ ogólny nie może pochodzić od „{0}”, ponieważ jest klasą atrybutów</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>Nie można utworzyć wystąpienia analizatora</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>Treść „{0}” nie może być blokiem iteratora, ponieważ „{1}” nie jest typem interfejsu iteratora</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>Wyrażenie przypisane do elementu „{0}” musi być stałą</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>Rozmiaru tablicy nie można określić w deklaracji zmiennej (spróbuj przeprowadzić inicjowanie przy użyciu wyrażenia „new”)</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>„{0}”: nie może istnieć inicjator zdarzenia abstrakcyjnego</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>Zostało zaimportowanych wiele zestawów o równoważnej tożsamości: „{0}” i „{1}”. Usuń jedno ze zduplikowanych odwołań.</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>Typ „{1}” w elemencie „{0}” powoduje konflikt z przestrzenią nazw „{3}” w elemencie „{2}”</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Zastosowanie elementu CallerLineNumberAttribute nie odniesie żadnego skutku, ponieważ dotyczy on elementu członkowskiego, który jest używany w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>Oczekiwano typu</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>Pozycja musi znajdować się w zasięgu drzewa składni.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać inicjatora tablicy wielowymiarowej.</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>Interfejsy nie mogą zawierać pól</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>Nie można zwrócić elementu „{0}” przez odwołanie, ponieważ został on zainicjowany przy użyciu wartości, której nie można zwrócić przez odwołanie</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>Nieoczekiwane użycie nazwy z aliasem</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>Tablicy parametrów nie można używać z modyfikatorem „this” w metodzie rozszerzenia.</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>Wywołanie metody „{0}” musi być wysłane dynamicznie, lecz to nie jest możliwe, ponieważ jest ona częścią wyrażenia dostępu bazowego. Rozważ rzutowanie argumentów dynamicznych lub wyeliminowanie dostępu bazowego.</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>„{0}”: klasa nie może być jednocześnie statyczna i zapieczętowana</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>Wszystkie częściowe deklaracje elementu „{0}” muszą być klasami, strukturami lub interfejsami</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>Pole zgodne ze specyfikacją CLS „{0}” nie może mieć specyfikatora volatile</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>Oczekiwano kontekstowego słowa kluczowego „equals”</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>Składnia „id#” nie jest już używana. Zamiast niej użyj składni „$id”.</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia został zignorowany</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>Pole nie jest nigdy używane</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>Obiektu „{0}” nie można usunąć więcej niż raz.</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>Element „{0}” nie implementuje elementu członkowskiego interfejsu „{1}”. Element „{2}” nie może implementować elementu „{1}”, ponieważ nie ma pasującej wartości zwracanej przez odwołanie.</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>Do buforów o ustalonym rozmiarze można uzyskać dostęp tylko przez elementy lokalne lub pola</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>Komentarz XML elementu „{1}” ma tag typeparamref dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać specyfikacji argumentu nazwanego</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>Nieprawidłowy typ elementu docelowego dla opcji /target: musisz podać typ „exe”, „winexe”, „library” lub „module”</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>Nie można przypisać wartości do statycznego pola tylko do odczytu (jest to możliwe tylko w konstruktorze statycznym lub w inicjatorze zmiennej).</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>Nie można uzyskać dostępu do członka „{0}” przy użyciu odwołania do wystąpienia. Należy użyć nazwy typu jako kwalifikatora.</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>Możliwe niepoprawne przypisanie do zmiennej lokalnej będącej argumentem instrukcji using lub lock</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>Sterowanie nie może opuścić treści klauzuli finally</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>Węzeł składni znajduje się poza drzewem składni</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>Wartości zwracane przez odwołanie mogą być używane tylko w metodach zwracających wartość przez odwołanie</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>Typu „{0}” nie można zadeklarować jako const</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>Metody asynchroniczne nie mogą zawierać parametrów „ref” ani „out”.</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>Kontrolka nie może wykraczać poza przełącznik z końcowej etykiety case („{0}”)</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>Dyrektywa using dla elementu „{0}” już wystąpiła w tej przestrzeni nazw</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metodę dostępu „{1}”.</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>Właściwość, indeksator lub zdarzenie „{0}” nie jest obsługiwane przez język. Spróbuj bezpośrednio wywołać metody dostępu „{1}” lub „{2}”.</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>„{0}”: zdefiniowane przez użytkownika konwersje na lub z interfejsu nie są dozwolone</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>Nie używaj opcji refout, gdy używana jest opcja refonly.</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>Nie można użyć parametru ref ani out „{0}” wewnątrz metody anonimowej, wyrażenia lambda lub wyrażenia zapytania</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>Wynikiem wyrażenia jest zawsze wartość „null”</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>Wyemitowanie modułu „{0}” nie powiodło się.</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>wyrażenie throw</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>Metoda „{0}” nie może implementować metody dostępu interfejsu „{1}” dla typu „{2}”. Użyj jawnej implementacji interfejsu.</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>Alias „{0}” jest w konflikcie z definicją {1}</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>Element „{0}” nie zawiera definicji „{1}”.</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>Za duża wartość stałej całkowitej</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>Nie można znaleźć pliku.</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>Deklaracja jest niedozwolona w tym kontekście.</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>Punkt wejścia zwracający wartości void lub int nie może być asynchroniczny</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>Komentarz XML ma tag typeparamref, ale nie ma parametru typu o takiej nazwie</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>Nazwa lokalna jest za długa dla pliku PDB</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>Atrybut Guid musi być określony z atrybutem ComImport</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>Nie można użyć instrukcji yield z wartością w treści bloku try z klauzulą catch.</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>Implementacja interfejsu jawnego jest zgodna z więcej niż jednym elementem członkowskim interfejsu</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>W czasie kompilowania modułu lub biblioteki nie można określić opcji /main</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>Typ jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>Wyrażenie typu „{0}” jest niedozwolone w kolejnej klauzuli from w wyrażeniu zapytania z typem źródłowym „{1}”. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{2}”.</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>operator propagowania wartości null</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>Zestawy „{0}” i „{1}” odwołują się do tych samych metadanych, ale tylko jeden z nich jest odwołaniem połączonym (określonym za pomocą opcji /link); rozważ usunięcie jednego z odwołań.</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>kowariantny</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>Pola buforu o ustalonym rozmiarze mogą być tylko elementami członkowskimi struktur.</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać konwersji krotki.</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>Nie można odczytać pliku konfiguracyjnego „{0}” — „{1}”</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>Asynchronicznych wyrażeń lambda nie można konwertować na drzewa wyrażeń.</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>Parametr typu „{1}” ma ograniczenie „struct”, dlatego elementu „{1}” nie można użyć jako ograniczenia dla „{0}”.</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” nie został zdefiniowany ani zaimportowany, lub jest zadeklarowany w wielu przywoływanych zestawach</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>Argument typu nie może mieć wartości null</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>Deklaracja aliasu zewnętrznego musi poprzedzać wszystkie inne elementy zdefiniowane w przestrzeni nazw</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>Nieprawidłowa opcja „{0}” dla opcji /platform; wymagana wartość anycpu, x86, Itanium lub x64</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>Argument atrybutu „{0}” musi być prawidłowym identyfikatorem</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerFilePathAttribute.</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>Niespójność dostępności: typ zwracany „{1}” jest mniej dostępny niż obiekt delegowany „{0}”</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>Atrybutu zabezpieczeń „{0}” nie można zastosować dla metody asynchronicznej.</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>Atrybuty zestawu i modułu muszą występować przed wszystkimi innymi elementami zdefiniowanymi w pliku poza klauzulami using i deklaracjami aliasów zewnętrznych</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego z powodu pośredniego odwołania do tego zestawu</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>Niezarządzany typ „{0}” jest prawidłowy tylko dla pól.</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>Automatycznie implementowana właściwość „{0}” musi być całkowicie przypisana przed zwróceniem sterowania do elementu wywołującego.</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>Przeciążony operator jednoargumentowy „{0}” przyjmuje jeden parametr</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>Nie można użyć niezabezpieczonego typu „{0}” do tworzenia obiektów</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>Użycie nieprzypisanego parametru ze specyfikatorem out „{0}”</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>kontrawariantny</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>Atrybut Conditional jest nieprawidłowy w elementach członkowskich interfejsu</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>Nie można zmodyfikować wyniku konwersji rozpakowującej</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>Parametry „ref” i „out” są nieprawidłowe w tym kontekście</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>Tag końcowy „{0}” nie jest zgodny z tagiem początkowym „{1}”.</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>Prawa strona przypisania instrukcji fixed nie może być wyrażeniem rzutowania</value>
  </data>
  <data name="IDS_FeatureRefExtensionMethods" xml:space="preserve">
    <value>metody rozszerzenia ref</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>Nie można modyfikować członków pola tylko do odczytu „{0}” (z wyjątkiem członków w konstruktorze lub inicjatorze zmiennych).</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutów zabezpieczeń zastosowanych dla zestawu</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>Zmienna zakresu „{0}” powoduje konflikt z poprzednią deklaracją zmiennej „{0}”</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>Nie można znaleźć nazwy typu lub przestrzeni nazw „{0}” (brak dyrektywy using lub odwołania do zestawu?)</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>Oczekiwano kontekstowego słowa kluczowego „on”</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>Oczekiwano kontekstowego słowa kluczowego „by”</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>Funkcja „{0}” nie jest zaimplementowana w tym kompilatorze.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej z „{3}” na „{1}”.</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>Metoda rozszerzenia musi być statyczna.</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>Nieprawidłowy zwracany typ w atrybucie cref komentarza XML</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>Element „{0}” jest przestarzały: „{1}”</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>Zestaw {0} nie zawiera żadnych analizatorów.</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>kowariantnie</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego „{0}” z powodu pośredniego odwołania do tego zestawu utworzonego przez zestaw „{1}”. Rozważ zmianę właściwości „Osadź typy międzyoperacyjne” w jednym z zestawów.</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>Plik źródłowy przekroczył limit 16 707 565 wierszy reprezentowanych w pliku PDB; informacje o debugowaniu będą niepoprawne</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>kolekcja</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>Nie używaj „System.Runtime.CompilerServices.DynamicAttribute”. Zamiast niego użyj słowa kluczowego „dynamic”.</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>Nazwa pliku „{0}” jest pusta, zawiera nieprawidłowe znaki, zawiera specyfikację dysku bez bezwzględnej ścieżki lub jest za długa</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>Elementu „{0}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>Podana wersja języka jest nieobsługiwana lub nieprawidłowa: „{0}”.</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>„{0}”: nie mogą istnieć definicje elementów członkowskich interfejsu</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>Oczekiwano wyrażenia lub instrukcji deklaracji.</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>Nie można przypisać wartości do właściwości lub indeksatora „{0}” – jest on tylko do odczytu</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>Metoda ani delegat nie może zwracać typu „{0}”</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>Niespójność dostępności: typ pola „{1}” jest mniej dostępny niż pole „{0}”</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>Opcja /pdb wymaga również użycia opcji /debug </value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>Podane wyrażenie wyrażenia „is” zawsze ma podany typ</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>Nazwa pliku każdego połączonego zasobu i modułu musi być unikatowa. Nazwę pliku „{0}” określono więcej niż raz w tym zestawie.</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>Wywołaj metodę System.IDisposable.Dispose() dla alokowanego wystąpienia zanim wszystkie odwołania do niego znajdą się poza zakresem</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać wywołania modelu COM z pominiętym parametrem ref przy argumentach</value>
  </data>
  <data name="ERR_ParamsCantBeWithModifier" xml:space="preserve">
    <value>Parametr params nie może zostać zadeklarowany jako {0}</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>W instrukcji foreach wymagany jest typ i identyfikator</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>Argument „{0}”: nie można przekonwertować z „{1}” na „{2}”</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Specyfikacje argumentów nazwanych muszą występować po wszystkich stałych argumentach, które zostały określone. Użyj wersji języka {0} lub nowszej, aby zezwalać na argumenty nazwane inne niż końcowe.</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>Ograniczenia parametrów typu „{0}” metody „{1}” muszą być zgodne z ograniczeniami parametrów typu „{2}” metody interfejsu „{3}”. Rozważ użycie jawnej implementacji interfejsu.</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>Nie można zwrócić zmiennej zakresu „{0}” przez odwołanie</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>Niebezpieczny kod nie może występować w iteratorach.</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>Konstrukcja __arglist jest prawidłowa tylko wewnątrz metody argumentu zmiennej</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>Nie można określić typu wyrażenia warunkowego, ponieważ elementy „{0}” i „{1}” są wzajemnie niejawnie konwertowane</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>Atrybutu „new” nie można użyć z typem krotki. Użyj wyrażenia literału krotki.</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>Nieoczekiwany token „{0}”</value>
  </data>
  <data name="ERR_RefConditionalDifferentTypes" xml:space="preserve">
    <value>Wyrażenie musi być typu „{0}”, aby było zgodne z alternatywną wartością ref</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>„{0}”: pochodzenie od zapieczętowanego typu „{1}” jest niemożliwe</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>Punkt wejściowy debugowania musi być definicją metody zadeklarowanej w bieżącej kompilacji.</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>Brak zdefiniowanej kolejności pól w wielu deklaracjach częściowej struktury</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>Przyjęto, że odwołanie do zestawu „{0}” używane przez element „{1}” jest zgodne z tożsamością „{2}” elementu „{3}” — może być konieczne określenie zasad wykonywania</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>Komentarz XML ma tag typeparam dla elementu „{0}”, lecz nie ma parametru typu o takiej nazwie</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Należy podać parametr atrybutu „{0}” lub „{1}”.</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Należy podać parametr atrybutu „{0}”.</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>metoda z wyrażeniem w treści</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>Atrybut CallerFilePathAttribute nie będzie mieć efektu, ponieważ jest stosowany do elementu członkowskiego używanego w kontekście, który nie zezwala na korzystanie z argumentów opcjonalnych</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>Nie można skompilować modułów sieciowych, gdy używana jest opcja /refout lub /refonly.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Typ zerowalny „{3}” nie spełnia ograniczenia elementu „{1}”. Typy zerowalne nie mogą spełniać żadnych ograniczeń interfejsów.</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>Nieprawidłowo sformułowany kod XML w pliku komentarzy</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>Przestrzeń nazw „{1}” zawiera definicję powodującą konflikt z aliasem „{0}”</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Nieprawidłowa nazwa zestawu: {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>Drzewo wyrażeń nie może zawierać odrzucenia.</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>Testowanie zgodności z typem „dynamic” za pomocą operatora „is” jest zasadniczo identyczne z testowaniem zgodności z typem „Object”</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>Dyrektywa „using namespace” może być stosowana tylko do przestrzeni nazw. Element „{0}” to typ, a nie przestrzeń nazw. Zamiast tego rozważ użycie dyrektywy „using static”</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>Elementów członkowskich pola tylko do odczytu „{0}” nie można użyć jako wartości ref ani out (z wyjątkiem sytuacji, gdy znajdują się w konstruktorze)</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: nieprawidłowy format identyfikatora GUID „{0}” dla opcji „{1}”</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>W ramach atrybutów cref zagnieżdżone typy typów ogólnych powinny być kwalifikowane.</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>Atrybut CallerLineNumberAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>Wynik wyrażenia to zawsze „{0}”, ponieważ wartość typu „{1}” nigdy nie jest równa wartości „null” typu „{2}”</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>Nie można zwrócić wartości z iteratora. Użyj instrukcji yield return, aby zwrócić wartość, lub yield break, aby zakończyć iterację.</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>Oczekiwano typu disable lub restore</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>Opcja „{0}” musi być ścieżką bezwzględną.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Nieprawidłowa wersja „{0}” dla opcji /subsystemversion. Wymagana jest 6.02 lub nowsza dla ARM lub AppContainerExe oraz wersja 4.00 lub nowsza w pozostałych przypadkach</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>Nieprawidłowy deklarator inicjującego elementu członkowskiego</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>Opcja pathmap jest nieprawidłowo sformatowana.</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>Typ buforu o ustalonym rozmiarze musi być jednym z następujących typów: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float lub double.</value>
  </data>
  <data name="ERR_CallArgMixing" xml:space="preserve">
    <value>Ta kombinacja argumentów dla elementu „{0}” jest niedozwolona, ponieważ może uwidaczniać zmienne przywoływane przez parametr „{1}” poza ich zakresem deklaracji</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>Nie można przekonwertować wartości stałej „{0}” na „{1}”.</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>Argumentu „{0}” nie można przekazać ze słowem kluczowym „{1}”</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>Właściwości lub indeksatora „{0}” nie można użyć w tym kontekście, ponieważ metoda dostępu Get jest niedostępna.</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>funkcje lokalne</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>krotki</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>alias zewnętrzny</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>Nieprawidłowy element include w kodzie XML — {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>Wartość wyrównania może powodować powstanie ciągu w dużym formacie</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>Przechwycony lub zgłoszony typ musi pochodzić od klasy System.Exception</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>Nie określono plików źródłowych</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>Atrybut „{0}” jest ignorowany w przypadku określenia podpisywania publicznego.</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>Bufor o ustalonym rozmiarze o długości {0} i typie „{1}” jest za duży</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>„{0}” nie może implementować „{1}”, ponieważ nie jest to obsługiwane przez język</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 2. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 3. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 1. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 6. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 7.0. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 4. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>Funkcja „{0}” nie jest dostępna w języku C# 5. Użyj języka w wersji {1} lub nowszej.</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>opcja /LIB</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>Atrybut Conditional jest nieprawidłowy w elemencie „{0}”, ponieważ jego typem zwracanym nie jest void</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>Atrybut DllImport nie może być zastosowany do metody, która jest ogólna lub zawarta w typie ogólnym.</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>Użyto nieprzypisanej zmiennej lokalnej „{0}”</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>Nie można przekazać właściwości lub indeksatora jako parametru „out” lub „ref”.</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>Element członkowski przesłania podstawowy element członkowski za pomocą wielu możliwych przesłonięć w czasie wykonywania</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>Nie można zwrócić elementu „{0}” przez odwołanie, ponieważ to jest element „{1}”</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Pomiń ładowanie typów w zestawie analizatora zakończonych niepowodzeniem z powodu wyjątku ReflectionTypeLoadException</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>Parametrów ani elementów lokalnych typu „{0}” nie można deklarować w metodach asynchronicznych ani wyrażeniach lambda.</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>Nie znaleziono deklaracji definiującej na potrzeby implementowania częściowej metody „{0}”</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>Odwołanie do typu „{0}” określa, że jest zdefiniowane w tym zestawie, lecz nie jest zdefiniowane w module źródłowym ani w żadnym z dodanych modułów</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>Nie można przekazać wartości null dla nazwy przyjaznego zestawu</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>Zastosowanie określonej wartości domyślnej nie odniesie żadnego skutku, ponieważ dotyczy ona elementu członkowskiego, który jest używany w kontekstach niezezwalających na argumenty opcjonalne</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>Pusty blok „switch”</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>„{0}”: klasa abstrakcyjna nie może być zapieczętowana ani statyczna</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>Wprowadzenie metody „Finalize” może zakłócać wywołanie destruktora</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>Inicjator musi zostać udostępniony w deklaracji instrukcji fixed lub using</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>Typ zwracany przez operator ++ lub -- musi odpowiadać typowi parametru lub pochodzić od typu parametru</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>Nieprawidłowa wariancja: parametr typu „{1}” musi być elementem {3} prawidłowym dla elementu „{0}”. Element „{1}” to „{2}”.</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>„{0}”: zdefiniowane przez użytkownika konwersje na lub z typu dynamicznego nie są dozwolone</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>Ścieżka AppConfigPath musi być bezwzględna.</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>Zastosowanie elementu CallerFilePathAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>Prawdopodobnie omyłkowo wystąpiła pusta instrukcja</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>Nie można użyć typu „{3}” jako parametru typu „{2}” w typie ogólnym lub metodzie „{0}”. Brak konwersji pakującej lub konwersji parametru typu z „{3}” na „{1}”.</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>Nieprawidłowo sformułowany kod XML znajduje się w pliku komentarzy — „{0}”</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>Automatycznie implementowane właściwości muszą przesłaniać wszystkie metody dostępu przesłanianej właściwości.</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>Podwyrażenie nie może być używane w argumencie operatora „nameof”.</value>
  </data>
  <data name="ERR_MismatchedRefEscapeInTernary" xml:space="preserve">
    <value>Gałęzie trzyelementowego operatora ref nie mogą odwoływać się do zmiennych z niezgodnymi zakresami deklaracji</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>Pole buforu o ustalonym rozmiarze musi mieć specyfikator rozmiaru tablicy po nazwie pola.</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>Dyrektywa #warning</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>Żadne przeładowanie metody „{0}” nie pobiera następującej liczby argumentów: „{1}”</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>Do wyrażenia typu „{0}” nie można zastosować indeksowania przy użyciu konstrukcji [].</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>„{0}” to nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>Niejednoznaczne odwołanie w atrybucie cref: „{0}”. Przyjęto element „{1}”, lecz inne elementy przeciążające także są zgodne, w tym „{2}”.</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>Klasa „{0}” nie może zawierać wielu klas podstawowych: „{1}” i „{2}”</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>Element „{0}” przesłania metodę Object.Equals(object o), lecz nie przesłania metody Object.GetHashCode()</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>Niepotrzebna dyrektywa using.</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>Nazwa „{0}” nie istnieje w bieżącym kontekście</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>Brak pętli otaczającej, w której ma nastąpić przerwanie lub kontynuowanie</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>Jawna implementacja interfejsu „{0}” jest zgodna z więcej niż jednym elementem członkowskim interfejsu. Wybór interfejsu do użycia zależy od implementacji. Rozważ użycie zamiast niej implementacji niejawnej.</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>Odwołanie do niezdefiniowanej jednostki „{0}”.</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>Komentarz XML ma nieprawidłowo sformułowany kod XML — „{0}”</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>Właściwości zwracające wartość dostępną przez odwołanie muszą mieć metodę dostępu get</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>Niespójność dostępności: interfejs podstawowy „{1}” jest mniej dostępny niż interfejs „{0}”</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać wyrażenia metody anonimowej</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>wyrażenie lambda</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>Oczekiwano definicji typu lub przestrzeni nazw albo znacznika końca pliku.</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>Niezakończony literał ciągu znaków</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>Nieprawidłowy typ ograniczenia. Typ używany jako ograniczenie musi być interfejsem, klasą niezapieczętowaną lub parametrem typu.</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>Wyrażenie będzie zawsze powodować wystąpienie wyjątku System.NullReferenceException, ponieważ domyślna wartość typu to null</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>W typach wskaźnika nie można używać operatorów „is” ani „as”</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>Parametr typu ma tę samą nazwę co parametr typu zewnętrznego</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>„{0}”: interfejsy zgodne ze specyfikacją CLS muszą mieć tylko elementy członkowskie zgodne ze specyfikacją CLS</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>Nie można przekonwertować wyrażenia metody anonimowej na drzewo wyrażenia</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Plik źródłowy został określony wiele razy</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>Użyto nieprawidłowej składni w komentarzu.</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>Metoda Add rozszerzenia nie jest obsługiwana w przypadku inicjatora kolekcji w operatorze lambda wyrażenia.</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>Atrybut „{0}” jest prawidłowy tylko w indeksatorze, który nie jest jawną deklaracją elementu członkowskiego interfejsu</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>„{0}” to nie jest klasa atrybutu</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>W wyrażeniu stałym nie można użyć typu anonimowego.</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>Wyrażenia i instrukcje mogą znajdować się tylko w treści metody</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>Typ elementu „{0}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>Operator „{0}” jest niejednoznaczny dla operandów „default” i „default”</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>Typ argumentu „{0}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>Parametr params musi być tablicą jednowymiarową</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia „{0}” został zignorowany.</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>Nie można wywołać abstrakcyjnego podstawowego elementu członkowskiego: „{0}”</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>Nie można przekonwertować zera na parametr typu „{0}”, ponieważ może on być niezerowalnym typem wartości. Zamiast tego rozważ użycie elementu „default({0}!)”.</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>Funkcja nie jest częścią specyfikacji standardu ISO języka C# i może nie być akceptowana przez inne kompilatory</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>Nie można zwrócić elementu członkowskiego zmiennej lokalnej „{0}” przez odwołanie, ponieważ to nie jest zmienna lokalna ref</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>Element „{0}” nie ma klasy podstawowej i nie można wywołać konstruktora podstawowego</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>Najlepiej dopasowana metoda przeciążona elementu „{0}” zawiera niewłaściwą sygnaturę dla elementu inicjatora. Możliwa do zainicjowania metoda Add musi być dostępną metodą wystąpienia.</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>Określono publiczne podpisywanie, które wymaga klucza publicznego, lecz nie podano klucza publicznego.</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>Oczekiwano znaku )</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>Nie można znaleźć pliku źródłowego „{0}”.</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>właściwość</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>Elementu „{0}” nie można zwrócić przez odwołanie, ponieważ jest tylko do odczytu</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>Funkcja anonimowa przekonwertowana na delegata zwracającego typ void nie może zwracać wartości</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>Używanie typu „dynamic” we wzorcu nie jest dozwolone.</value>
  </data>
  <data name="ERR_RefReadonlyNotField" xml:space="preserve">
    <value>Nie można użyć elementu {0} „{1}” jako wartości ref ani out, ponieważ jest to zmienna tylko do odczytu</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>Destruktory i metoda object.Finalize nie mogą być bezpośrednio wywoływane. Rozważ wywołanie metody IDisposable.Dispose, jeżeli jest dostępna.</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>Za wiele znaków w literale znakowym</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>Podano różne wartości sumy kontrolnej #pragma</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest nieprawidłowa dla atrybutu PrincipalPermission</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>Niewłaściwy deklarator tablicy. Aby zadeklarować tablicę zarządzaną, przed identyfikatorem zmiennej umieść specyfikator rangi tablicy. Aby zadeklarować pole buforu o ustalonym rozmiarze, przed typem pola użyj słowa kluczowego „fixed”.</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>Częściowe deklaracje elementu „{0}” muszą mieć takie same nazwy parametrów typu i modyfikatory wariancji w takiej samej kolejności</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>„{0}” nie może pochodzić od klasy specjalnej „{1}”</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>Ponieważ „{0}” to metoda asynchroniczna zwracająca typ „Task”, po słowie kluczowym return nie może następować wyrażenie obiektu. Czy zamierzony zwracany typ to „Task&lt;T&gt;”?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako wartości ref ani out, ponieważ jest to element tylko do odczytu</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>Nie można znaleźć implementacji wzorca zapytania dla typu źródłowego „{0}”. Nie znaleziono elementu „{1}”.</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>Atrybut CallerMemberNameAttribute można stosować wyłącznie do parametrów mających wartości domyślne.</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>Typ powoduje konflikt z zaimportowaną przestrzenią nazw</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>Komentarz XML ma tag param dla elementu „{0}”, lecz nie ma parametru o takiej nazwie</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>Brak komentarza XML dla widocznego publicznie typu lub elementu członkowskiego</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>Porównanie ze stałą całkowitoliczbową jest bezcelowe; stała jest poza zakresem typu</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>Typ definiuje operator == lub !=, ale nie przesłania metody Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>Atrybut zostanie zignorowany na rzecz wystąpienia w źródle</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>Nie można otworzyć pliku źródłowego „{0}” — {1}</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>W tej deklaracji typu atrybut „{0}” jest nieprawidłowy. Jest on prawidłowy tylko w deklaracjach „{1}”.</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>Element lokalny lub parametr o nazwie „{0}” nie może zostać zadeklarowany w tym zakresie, ponieważ ta nazwa jest już użyta w otaczającym zakresie lokalnym do zdefiniowania elementu lokalnego lub parametru</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>Typ elementu „{0}” to „{1}”. Wartość domyślnego parametru typu referencyjnego innego niż string można zainicjować tylko przy użyciu wartości null</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}” lub „{2}”.</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>Typ ograniczenia „{0}” nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>Statycznego pola lub właściwości „{0}” nie można przypisać w inicjatorze obiektu</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>Zduplikowany atrybut „{0}”</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>Atrybut „{0}” jest prawidłowy tylko w klasach pochodzących od klasy System.Attribute</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>Porównanie z wartością null typu struktury zawsze zwraca wartość „false”</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>Atrybut RequiredAttribute jest niedozwolony dla typów C#</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>Dozwolonych jest tylko 65534 elementów lokalnych, włącznie z wygenerowanymi przez kompilator</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>Pole nietrwałe nie powinno być zwykle używane jako wartość ref ani out, ponieważ nie będzie traktowane jak pole nietrwałe. Istnieją wyjątki od tej reguły, takie jak wywołanie blokowanego interfejsu API.</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>Nie można osadzić typu międzyoperacyjnego „{0}” znajdującego się jednocześnie w zestawach „{1}” i „{2}”. Rozważ ustawienie wartości false dla właściwości „Osadź typy międzyoperacyjne”.</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>ścieżka jest za długa lub nieprawidłowa</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>„{1} {0}” ma nieprawidłowy zwracany typ.</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>Typ nie zawiera implementacji wzorca kolekcji; element członkowski ma niewłaściwą sygnaturę</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>asynchroniczna funkcja main</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>Nie znaleziono elementu członkowskiego „{0}” dla typu „{1}” z zestawu „{2}”.</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>Tag końcowy jest nieoczekiwany w tej lokalizacji.</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>„{1}”: nie można utworzyć na podstawie klasy statycznej „{0}”</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>Dostęp do elementu członkowskiego elementu „{0}” może spowodować wystąpienie wyjątku czasu wykonywania, ponieważ to jest pole w klasie marshal-by-reference</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>Typem musi być „var”.</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>Oczekiwano wyrażenia</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale klucz publiczny zestawu wyjściowego nie jest zgodny z kluczem określonym przez atrybut w zestawie udzielającym dostępu.</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>Element „{0}” jest typem obsługiwanym przez język.</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>Wyrażenie musi umożliwiać niejawną konwersję na typ Boolean lub jego typ „{0}” musi definiować operator „{1}”.</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>Nie można usunąć obiektu więcej niż raz</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>Zastosowanie elementu CallerMemberNameAttribute do parametru „{0}” nie odniesie żadnego skutku. Jest on przesłaniany przez element CallerLineNumberAttribute.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>Odwołanie do zestawu jest nieprawidłowe i nie można go rozpoznać</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>Typ parametru dla operatora ++ lub -- musi być typem zawierającym</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>Nie odnaleziono wartości elementu RuntimeMetadataVersion</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>Dla niestatycznego pola, metody lub właściwości „{0}” wymagane jest odwołanie do obiektu.</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>„{0}”: w interfejsach nie mogą występować deklaracje typów</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>Nie można oznaczyć typu lub elementu członkowskiego jako zgodnego ze specyfikacją CLS, ponieważ zestaw nie ma atrybutu CLSCompliant</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>„{0}”: typem zwracanym musi być „{2}”, aby być zgodnym z przesłoniętym elementem członkowskim „{1}”</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>Przesłanie może mieć co najwyżej jedno drzewo składni.</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>Żadne z przeciążeń dla elementu „{0}” nie pasuje do delegata „{1}”.</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>Nieprawidłowy typ parametru w atrybucie cref komentarza XML</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>Dla typu zawierającego indeksator nie można określić atrybutu DefaultMember.</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>Poziom ostrzeżeń musi być wartością z zakresu od 0 do 4</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>indeksator z wyrażeniem w treści</value>
  </data>
  <data name="ERR_LocalFunctionMissingBody" xml:space="preserve">
    <value>„{0}” jest funkcją lokalną i w związku z tym musi zawsze mieć treść.</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>„{0}”: nie może pochodzić od typu dynamicznego</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>drzewo nie jest częścią kompilacji</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>Drzewo wyrażenia lambda nie może zawierać operatora łączącego z literałem domyślnym lub o wartości null po lewej stronie</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>Błąd składni, oczekiwano elementu „{0}”</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>Nie jest to rozpoznawana lokalizacja atrybutu</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>Inicjator elementu nie może być pusty</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>Typ wyrażenia w klauzuli {0} jest niepoprawny. Wnioskowanie typu nie powiodło się w wywołaniu elementu „{1}”. </value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>filtr wyjątków</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>Częściowe deklaracje metody „{0}” mają niespójne ograniczenia parametrów typu</value>
  </data>
</root>