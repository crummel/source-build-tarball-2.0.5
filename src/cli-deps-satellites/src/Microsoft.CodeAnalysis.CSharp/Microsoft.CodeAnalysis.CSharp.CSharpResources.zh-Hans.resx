<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OutputNeedsName" xml:space="preserve">
    <value>必须为没有源的输出指定 /out 选项</value>
  </data>
  <data name="ERR_IntDivByZero" xml:space="preserve">
    <value>被常数零除</value>
  </data>
  <data name="ERR_BadNamedAttributeArgumentType" xml:space="preserve">
    <value>“{0}”不是有效的特性参数类型，因此不是有效的命名特性参数</value>
  </data>
  <data name="WRN_XMLParseError_Title" xml:space="preserve">
    <value>XML 注释出现 XML 格式错误</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>正在跳过分析器程序集 {0} 中的某些类型，因为出现 ReflectionTypeLoadException: {1}。</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg_Title" xml:space="preserve">
    <value>字段已被赋值，但从未使用过它的值</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAssignment" xml:space="preserve">
    <value>表达式树不能包含赋值运算符</value>
  </data>
  <data name="ERR_DynamicRequiredTypesMissing" xml:space="preserve">
    <value>找不到编译动态表达式所需的一个或多个类型。是否缺少引用?</value>
  </data>
  <data name="ERR_DeprecatedSymbolStr" xml:space="preserve">
    <value>“{0}”已过时:“{1}”</value>
  </data>
  <data name="ERR_ConditionalOnSpecialMethod" xml:space="preserve">
    <value>Conditional 特性在“{0}”上无效，因为它是构造函数、析构函数、运算符或显式接口实现</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>无效的模块名称: {0}</value>
  </data>
  <data name="ERR_ConversionWithBase" xml:space="preserve">
    <value>“{0}”: 不允许进行以基类为转换源或目标的用户定义转换</value>
  </data>
  <data name="ERR_BadTypeReference" xml:space="preserve">
    <value>“{0}”: 无法通过表达式引用类型；请尝试“{1}”</value>
  </data>
  <data name="ERR_CompilerAndLanguageVersion" xml:space="preserve">
    <value>编译器版本:“{0}”。语言版本: {1}。</value>
  </data>
  <data name="IDS_FeatureIterators" xml:space="preserve">
    <value>迭代器</value>
  </data>
  <data name="WRN_CantHaveManifestForModule" xml:space="preserve">
    <value>对模块忽略 /win32manifest，因为它仅应用于程序集</value>
  </data>
  <data name="FTL_BadCodepage" xml:space="preserve">
    <value>代码页“{0}”无效或未安装</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete" xml:space="preserve">
    <value>过时成员“{0}”重写未过时成员“{1}”</value>
  </data>
  <data name="XML_StringLiteralNoEndQuote" xml:space="preserve">
    <value>字符串缺少右引号。</value>
  </data>
  <data name="ERR_CompileCancelled" xml:space="preserve">
    <value>编译被用户取消</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>不支持元数据引用。</value>
  </data>
  <data name="ERR_ExpectedSelectOrGroup" xml:space="preserve">
    <value>查询正文必须以 select 或 group 子句结尾</value>
  </data>
  <data name="ERR_DuplicateCaseLabel" xml:space="preserve">
    <value>switch 语句包含多个具有标签值“{0}”的情况</value>
  </data>
  <data name="ERR_IdentifierExpectedKW" xml:space="preserve">
    <value>应为标识符；“{1}”是关键字</value>
  </data>
  <data name="ERR_BadCompilationOptionValue" xml:space="preserve">
    <value>“{0}”值无效:“{1}”。</value>
  </data>
  <data name="ERR_ExpressionTreeContainsPointerOp" xml:space="preserve">
    <value>表达式树不能包含不安全的指针操作</value>
  </data>
  <data name="XML_InvalidCharEntity" xml:space="preserve">
    <value>实体引用中发现无效字符。</value>
  </data>
  <data name="ERR_VarArgsInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含具有变量参数的方法</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>命令行开关尚未实现</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Description" xml:space="preserve">
    <value>编译器对某个变量进行了隐式拓展和带符号扩展，然后在按位或操作中使用生成的值。这可能会导致意外行为。</value>
  </data>
  <data name="ERR_PtrExpected" xml:space="preserve">
    <value>* 或 -&gt; 运算符只能应用于指针</value>
  </data>
  <data name="WRN_DefineIdentifierRequired" xml:space="preserve">
    <value>预处理符号的名称无效；“{0}”不是有效的标识符</value>
  </data>
  <data name="ERR_BadBinaryOps" xml:space="preserve">
    <value>运算符“{0}”无法应用于“{1}”和“{2}”类型的操作数</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse_Title" xml:space="preserve">
    <value>类型是不符合 CLS 的类型的成员，因此不能将其标记为符合 CLS</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用；它由 CallerLineNumberAttribute 重写</value>
  </data>
  <data name="ERR_AbstractHasBody" xml:space="preserve">
    <value>“{0}”无法声明主体，因为它标记为 abstract</value>
  </data>
  <data name="ERR_BadVisEventType" xml:space="preserve">
    <value>可访问性不一致: 事件类型“{1}”的可访问性低于事件“{0}”</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete" xml:space="preserve">
    <value>成员“{0}”将重写过时的成员“{1}”。请向“{0}”中添加 Obsolete 特性。</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>检测到无法访问的代码</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2_Title" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此类型或成员不需要 CLSCompliant 特性</value>
  </data>
  <data name="ERR_QueryNoProviderCastable" xml:space="preserve">
    <value>未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。请考虑显式指定范围变量“{2}”的类型。</value>
  </data>
  <data name="WRN_BadWarningNumber" xml:space="preserve">
    <value>“{0}”不是有效的警告编号</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的隐式引用转换。</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation_Title" xml:space="preserve">
    <value>方法、运算符或访问器标记为外部对象并且上面没有任何特性</value>
  </data>
  <data name="ERR_BadDestructorName" xml:space="preserve">
    <value>析构函数的名称必须与类的名称匹配</value>
  </data>
  <data name="ERR_QueryOutRefRangeVariable" xml:space="preserve">
    <value>无法作为 out 或 ref 参数传递范围变量“{0}”</value>
  </data>
  <data name="ERR_MustDeclareForeachIteration" xml:space="preserve">
    <value>foreach 循环必须声明其迭代变量。</value>
  </data>
  <data name="ERR_DllImportOnInvalidMethod" xml:space="preserve">
    <value>必须在标记为 "static" 和 "extern" 的方法上指定 DllImport 特性</value>
  </data>
  <data name="IDS_FeaturePartialMethod" xml:space="preserve">
    <value>分部方法</value>
  </data>
  <data name="WRN_UnreferencedFieldAssg" xml:space="preserve">
    <value>字段“{0}”已被赋值，但从未使用过它的值</value>
  </data>
  <data name="ERR_BadYieldInFinally" xml:space="preserve">
    <value>无法在 finally 子句体中生成</value>
  </data>
  <data name="IDS_Namespace1" xml:space="preserve">
    <value>&lt;命名空间&gt;</value>
  </data>
  <data name="ERR_BadAwaitInQuery" xml:space="preserve">
    <value>"await" 运算符只能用在初始 "from" 子句的第一个集合表达式或 "join" 子句的集合表达式内的查询表达式中</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation" xml:space="preserve">
    <value>为形参“{0}”指定的默认值将不起任何作用，因为它适用于在不允许指定可选实参的上下文中使用的成员</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationInNonClassOrStruct" xml:space="preserve">
    <value>“{0}”: 显式接口声明只能在类或结构中声明</value>
  </data>
  <data name="ERR_GlobalExternAlias" xml:space="preserve">
    <value>不能重新定义全局外部别名</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam" xml:space="preserve">
    <value>CLSCompliant 特性在应用于参数时无意义。请尝试将该特性应用于方法。</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Description" xml:space="preserve">
    <value>当 catch() 块未在 catch (System.Exception e) 块之后指定异常类型时，会出现此警告。该警告建议 catch() 块不捕获任何异常。

如果 RuntimeCompatibilityAttribute 在 AssemblyInfo.cs 文件中设置为 false，则 catch (System.Exception e) 块之后的 catch() 块可以捕获非 CLS 异常: [程序集: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]。如果此特性未显式设置为 false，则所有引发的非 CLS 异常都包装为“异常”，catch (System.Exception e) 块可以捕获它们。</value>
  </data>
  <data name="ERR_BadAwaitInCatch" xml:space="preserve">
    <value>无法在 catch 子句中等待</value>
  </data>
  <data name="ERR_CannotDeconstructDynamic" xml:space="preserve">
    <value>无法析构动态对象。</value>
  </data>
  <data name="ERR_RefReturnLvalueExpected" xml:space="preserve">
    <value>不能在此上下文中使用表达式，因为表达式无法按引用返回</value>
  </data>
  <data name="ERR_OneAliasPerReference" xml:space="preserve">
    <value>一个声明外部别名的 /reference 选项只能有一个文件名。要指定多个别名或文件名，请使用多个 /reference 选项。</value>
  </data>
  <data name="ERR_UnclosedExpressionHole" xml:space="preserve">
    <value>以“{”开头的插补的表达式缺少结束分隔符“}”。</value>
  </data>
  <data name="WRN_CLS_NotOnModules" xml:space="preserve">
    <value>必须在程序集而不是模块上指定 CLSCompliant 特性，以便启用 CLS 遵从性检查</value>
  </data>
  <data name="ERR_ForEachMissingMember" xml:space="preserve">
    <value>“{0}”不包含“{1}”的公共定义，因此 foreach 语句不能作用于“{0}”类型的变量</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>读取规则集文件 {0} 时出错 - {1}</value>
  </data>
  <data name="ERR_CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>不要直接调用基类 Finalize 方法。它将从析构函数中自动调用。</value>
  </data>
  <data name="ERR_EnumeratorOverflow" xml:space="preserve">
    <value>“{0}”: 枚举器值太大，不能适应它的类型</value>
  </data>
  <data name="WRN_FileNameTooLong" xml:space="preserve">
    <value>为预处理器指令指定的文件名无效。文件名太长或者是无效的文件名。</value>
  </data>
  <data name="WRN_DeprecatedSymbol_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="ERR_CantInferMethTypeArgs" xml:space="preserve">
    <value>无法从用法中推断出方法“{0}”的类型参数。请尝试显式指定类型参数。</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEFILE" xml:space="preserve">
    <value>缺少文件特性</value>
  </data>
  <data name="IDS_XMLMISSINGINCLUDEPATH" xml:space="preserve">
    <value>缺少路径特性</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>非托管类型“{0}”对于字段无效。</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>使用来自容器“{0}”的公钥对输出签名时出错 -- {1}</value>
  </data>
  <data name="ERR_OperatorNeedsMatch" xml:space="preserve">
    <value>运算符“{0}”要求也要定义匹配的运算符“{1}”</value>
  </data>
  <data name="ERR_FieldInitRefNonstatic" xml:space="preserve">
    <value>字段初始值设定项无法引用非静态字段、方法或属性“{0}”</value>
  </data>
  <data name="IDS_FeatureReadonlyAutoImplementedProperties" xml:space="preserve">
    <value>自动实现 readonly 的属性</value>
  </data>
  <data name="ERR_RefReadonlyStatic2" xml:space="preserve">
    <value>无法将静态只读字段“{0}”的字段用作 ref 或 out 值(静态构造函数中除外)</value>
  </data>
  <data name="IDS_FeaturePropertyAccessorMods" xml:space="preserve">
    <value>属性的访问修饰符</value>
  </data>
  <data name="ERR_InvalidMemberDecl" xml:space="preserve">
    <value>类、结构或接口成员声明中的标记“{0}”无效</value>
  </data>
  <data name="ERR_NoMetadataFile" xml:space="preserve">
    <value>未能找到元数据文件“{0}”</value>
  </data>
  <data name="ERR_SizeofUnsafe" xml:space="preserve">
    <value>“{0}”没有预定义的大小，因此 sizeof 只能在不安全的上下文中使用(请考虑使用 System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="WRN_InvalidSearchPathDir" xml:space="preserve">
    <value>“{1}”中指定的搜索路径“{0}”无效 --“{2}”</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal2Cause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，无法按引用返回其字段</value>
  </data>
  <data name="ERR_CantConvAnonMethParams" xml:space="preserve">
    <value>无法将 {0} 转换为委托类型“{1}”，原因是参数类型与委托参数类型不匹配</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers_Title" xml:space="preserve">
    <value>只有符合 CLS 的成员才能是抽象的</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>程序集和模块“{0}”不能以不同处理器为目标。</value>
  </data>
  <data name="ERR_BadAwaitInLock" xml:space="preserve">
    <value>无法在 lock 语句体中等待</value>
  </data>
  <data name="ERR_RefReadonlyStatic" xml:space="preserve">
    <value>无法将静态只读字段用作 ref 或 out 值(静态构造函数中除外)</value>
  </data>
  <data name="ERR_AttributeNotOnAccessor" xml:space="preserve">
    <value>特性“{0}”对属性或事件访问器无效。它仅对“{1}”声明有效。</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute" xml:space="preserve">
    <value>作为特性参数的数组不符合 CLS</value>
  </data>
  <data name="HDN_UnusedExternAlias_Title" xml:space="preserve">
    <value>未使用的外部别名</value>
  </data>
  <data name="WRN_InvalidNumber_Title" xml:space="preserve">
    <value>无效数字</value>
  </data>
  <data name="IDS_FeatureTypeVariance" xml:space="preserve">
    <value>类型方差</value>
  </data>
  <data name="IDS_DirectoryDoesNotExist" xml:space="preserve">
    <value>目录不存在</value>
  </data>
  <data name="ERR_MustHaveOpTF" xml:space="preserve">
    <value>为了使“{0}”可以像短路运算符一样应用，其声明类型“{1}”必须定义运算符 true 和运算符 false</value>
  </data>
  <data name="ERR_ArrayInitializerExpected" xml:space="preserve">
    <value>应输入嵌套数组初始值设定项</value>
  </data>
  <data name="ERR_OnlyClassesCanContainDestructors" xml:space="preserve">
    <value>只有类类型才能包含析构函数</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Title" xml:space="preserve">
    <value>假定程序集引用与标识匹配</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>程序集引用“{0}”无效，无法解析</value>
  </data>
  <data name="ERR_BadOutWithThis" xml:space="preserve">
    <value> 参数修饰符“out”不能与“this”一起使用 </value>
  </data>
  <data name="ERR_DeconstructRequiresExpression" xml:space="preserve">
    <value>析构任务要求表达式属于右侧的某个类型。</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>无效的文件节对齐方式“{0}”</value>
  </data>
  <data name="ERR_ThisStructNotInAnonMeth" xml:space="preserve">
    <value>结构内部的匿名方法、lambda 表达式和查询表达式无法访问 "this" 的实例成员。请考虑将 "this" 复制到匿名方法、lambda 表达式或查询表达式外部的某个局部变量并改用该局部变量。</value>
  </data>
  <data name="ERR_InterfaceImplementedByConditional" xml:space="preserve">
    <value>条件成员“{0}”无法实现类型“{2}”中的接口成员“{1}”</value>
  </data>
  <data name="ERR_StaticDerivedFromNonObject" xml:space="preserve">
    <value>静态类“{0}”不能从类型“{1}”派生。静态类必须从对象派生。</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic2" xml:space="preserve">
    <value>静态只读字段“{0}”的字段无法按引用返回</value>
  </data>
  <data name="ERR_ForwardedTypeInThisAssembly" xml:space="preserve">
    <value>类型“{0}”是在此程序集中定义的，但又为它指定了一个类型转发器</value>
  </data>
  <data name="ERR_InsufficientStack" xml:space="preserve">
    <value>表达式太长或者过于复杂，无法编译</value>
  </data>
  <data name="WRN_EndOfPPLineExpected_Title" xml:space="preserve">
    <value>#pragma 指令之后应是单行注释或行尾</value>
  </data>
  <data name="ERR_EventNeedsBothAccessors" xml:space="preserve">
    <value>“{0}”: 事件属性必须同时具有 add 和 remove 访问器</value>
  </data>
  <data name="ERR_SemiOrLBraceOrArrowExpected" xml:space="preserve">
    <value>{ or ; or =&gt; 预期的</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>引用程序集面向的是另一个处理器</value>
  </data>
  <data name="ERR_MissingCoClass" xml:space="preserve">
    <value>无法找到接口“{1}”的托管组件类包装器类“{0}”(是否缺少程序集引用?)</value>
  </data>
  <data name="WRN_PatternIsAmbiguous" xml:space="preserve">
    <value>“{0}”不实现“{1}”模式。“{2}”与“{3}”一起使用时目的不明确。</value>
  </data>
  <data name="ERR_BadCompatMode" xml:space="preserve">
    <value>选项“{0}”对于 /langversion 无效；必须是 ISO-1、ISO-2、默认版本、最新版本或 1 到 7.1 范围内的有效版本。</value>
  </data>
  <data name="ERR_AliasQualifiedNameNotAnExpression" xml:space="preserve">
    <value>别名限定名称不是表达式。</value>
  </data>
  <data name="XML_ExpectedIdentifier" xml:space="preserve">
    <value>应为标识符。</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert" xml:space="preserve">
    <value>“goto case”值不可隐式转换为类型“{0}”</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg_Title" xml:space="preserve">
    <value>条件表达式中的赋值总是常量</value>
  </data>
  <data name="ERR_ConditionalWithOutParam" xml:space="preserve">
    <value>条件成员“{0}”不能有 out 参数</value>
  </data>
  <data name="ERR_AwaitInUnsafeContext" xml:space="preserve">
    <value>无法在不安全的上下文中等待</value>
  </data>
  <data name="ERR_BadEmbeddedStmt" xml:space="preserve">
    <value>嵌入的语句不能是声明或标记语句</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation_Title" xml:space="preserve">
    <value>构造函数标记为外部对象</value>
  </data>
  <data name="IDS_FeatureCollectionInitializer" xml:space="preserve">
    <value>集合初始值设定项</value>
  </data>
  <data name="ERR_PredefinedTypeNotFound" xml:space="preserve">
    <value>预定义类型“{0}”未定义或导入</value>
  </data>
  <data name="IDS_FeatureAutoImplementedProperties" xml:space="preserve">
    <value>自动实现的属性</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod" xml:space="preserve">
    <value>动态调度的方法“{0}”调用可能会在运行时失败，因为一个或多个适用的重载为条件方法。</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="WRN_ExternCtorNoImplementation" xml:space="preserve">
    <value>构造函数“{0}”标记为外部对象</value>
  </data>
  <data name="ERR_StaticClassInterfaceImpl" xml:space="preserve">
    <value>“{0}”: 静态类不能实现接口</value>
  </data>
  <data name="ERR_InteropStructContainsMethods" xml:space="preserve">
    <value>嵌入互操作结构“{0}”只能包含公共实例字段。</value>
  </data>
  <data name="ERR_DerivingFromATyVar" xml:space="preserve">
    <value>“{0}”是一个类型参数，无法从它进行派生</value>
  </data>
  <data name="ERR_BadFixedInitType" xml:space="preserve">
    <value>fixed 语句中声明的局部变量类型必须是指针类型</value>
  </data>
  <data name="IDS_FeatureExternAlias" xml:space="preserve">
    <value>外部别名</value>
  </data>
  <data name="WRN_BadXMLRefReturnType_Title" xml:space="preserve">
    <value>XML 注释的 cref 特性中的返回类型无效</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnParam_Title" xml:space="preserve">
    <value>CLSCompliant 特性在应用于参数时无意义</value>
  </data>
  <data name="ERR_TypelessTupleInAs" xml:space="preserve">
    <value>"as" 运算符的第一个操作数在没有自然类型的情况下可能不是元组文本。</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>无效的检测类型: {0}</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>无法在脚本代码中声明命名空间</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Description" xml:space="preserve">
    <value>public、protected 或 protected internal 变量必须属于符合公共语言规范(CLS)的类型。</value>
  </data>
  <data name="ERR_PartialModifierConflict" xml:space="preserve">
    <value>“{0}”的分部声明包含冲突的可访问性修饰符</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。</value>
  </data>
  <data name="WRN_BadRefCompareRight_Title" xml:space="preserve">
    <value>可能非有意的引用比较；右侧需要强制转换</value>
  </data>
  <data name="ERR_OutputWriteFailed" xml:space="preserve">
    <value>未能写入输出文件“{0}”--“{1}”</value>
  </data>
  <data name="ERR_ThisOrBaseExpected" xml:space="preserve">
    <value>应为关键字 "this" 或 "base"</value>
  </data>
  <data name="WRN_NubExprIsConstBool2_Title" xml:space="preserve">
    <value>由于此类型的值永不等于 "null"，该表达式的结果始终相同</value>
  </data>
  <data name="ERR_YieldNotAllowedInScript" xml:space="preserve">
    <value>无法在顶级脚本代码中使用“yield”</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>异步方法缺少 "await" 运算符，将以同步方式运行</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Title" xml:space="preserve">
    <value>预定义类型是在全局别名的多个程序集中定义的</value>
  </data>
  <data name="ERR_AttrArgWithTypeVars" xml:space="preserve">
    <value>“{0}”: 特性参数不能使用类型参数</value>
  </data>
  <data name="ERR_OvlOperatorExpected" xml:space="preserve">
    <value>应输入可重载运算符</value>
  </data>
  <data name="ERR_AssgReadonlyStatic2" xml:space="preserve">
    <value>无法为静态只读字段“{0}”的字段赋值(在静态构造函数或变量初始值设定项中除外)</value>
  </data>
  <data name="WRN_NoSources" xml:space="preserve">
    <value>未指定源文件。</value>
  </data>
  <data name="WRN_InvalidMainSig" xml:space="preserve">
    <value>“{0}”的签名错误，不能作为入口点</value>
  </data>
  <data name="ERR_TooManyCatches" xml:space="preserve">
    <value>catch 子句不能跟在 try 语句的常规 catch 子句之后</value>
  </data>
  <data name="ERR_MissingArgument" xml:space="preserve">
    <value>缺少参数</value>
  </data>
  <data name="ERR_ExpressionTreeMustHaveDelegate" xml:space="preserve">
    <value>不能将 lambda 转换为类型参数“{0}”不是委托类型的表达式树</value>
  </data>
  <data name="ERR_VoidError" xml:space="preserve">
    <value>相关操作在 void 指针上未定义</value>
  </data>
  <data name="ERR_InvalidDelegateType" xml:space="preserve">
    <value>委托“{0}”没有调用方法，或调用方法有不受支持的返回类型或参数类型。</value>
  </data>
  <data name="IDS_FeatureNameof" xml:space="preserve">
    <value>nameof 运算符</value>
  </data>
  <data name="ERR_ManagedAddr" xml:space="preserve">
    <value>无法获取托管类型(“{0}”)的地址和大小，或者声明指向它的指针</value>
  </data>
  <data name="WRN_NonECMAFeature" xml:space="preserve">
    <value>功能“{0}”不是标准化 ISO C# 语言规范的一部分，其他编译器可能不接受它</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>源文件中提供的特定“{0}”与选项“{1}”冲突。</value>
  </data>
  <data name="WRN_CLS_NotOnModules2_Title" xml:space="preserve">
    <value>不能在模块上指定与程序集的 CLSCompliant 特性不同的 CLSCompliant 特性</value>
  </data>
  <data name="ERR_BadParamExtraRef" xml:space="preserve">
    <value>参数 {0} 不应使用“{1}”关键字进行声明</value>
  </data>
  <data name="ERR_BadAwaitInFinally" xml:space="preserve">
    <value>无法在 finally 子句体中等待</value>
  </data>
  <data name="ERR_ClassTypeExpected" xml:space="preserve">
    <value>应是对象、字符串或类类型</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>链接 netmodule 元数据必须提供完整 PE 映像:“{0}”。</value>
  </data>
  <data name="WRN_GlobalAliasDefn_Title" xml:space="preserve">
    <value>定义名为 "global" 的别名是欠妥的</value>
  </data>
  <data name="ERR_ExpressionVariableInConstructorOrFieldInitializer" xml:space="preserve">
    <value>不允许在构造函数、字段、属性初始值设定项中进行 out 变量和 pattern 变量声明。</value>
  </data>
  <data name="ERR_BadPrefer32OnLib" xml:space="preserve">
    <value>/platform:anycpu32bitpreferred 只能与 /t:exe、/t:winexe 和 /t:appcontainerexe 一起使用</value>
  </data>
  <data name="ERR_ComImportWithBase" xml:space="preserve">
    <value>“{0}”: 具有 ComImport 特性的类不能指定基类</value>
  </data>
  <data name="ERR_ComImportWithImpl" xml:space="preserve">
    <value>由于“{1}”具有 ComImport 特性，因此“{0}”必须是外部的或抽象的</value>
  </data>
  <data name="IDS_FIXEDLOCAL" xml:space="preserve">
    <value>固定变量</value>
  </data>
  <data name="NameConflictForName" xml:space="preserve">
    <value>名称 {0} 出现名称冲突</value>
  </data>
  <data name="ERR_UnreachableCatch" xml:space="preserve">
    <value>上一个 catch 子句已经捕获了此类型或超类型(“{0}”)的所有异常</value>
  </data>
  <data name="ERR_UseDefViolationField" xml:space="preserve">
    <value>使用了可能未赋值的字段“{0}”</value>
  </data>
  <data name="ERR_BlockBodyAndExpressionBody" xml:space="preserve">
    <value>不能同时提供程序块主体与表达式主体。</value>
  </data>
  <data name="ERR_SystemVoid" xml:space="preserve">
    <value>在 C# 中无法使用 System.Void -- 使用 typeof(void)获取 void 类型对象</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>提供的文档模式不受支持或无效:“{0}”。</value>
  </data>
  <data name="ERR_AmbigUnaryOp" xml:space="preserve">
    <value>运算符“{0}”对于“{1}”类型的操作数具有二义性</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>由于分配目标指定了其他名称或未指定名称，因此元组元素名称被忽略。</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>引用程序集没有强名称</value>
  </data>
  <data name="ERR_PartialMethodNotExplicit" xml:space="preserve">
    <value>分部方法不能显式实现接口方法</value>
  </data>
  <data name="IDS_FeatureLambda" xml:space="preserve">
    <value>lambda 表达式</value>
  </data>
  <data name="ERR_MainClassIsImport" xml:space="preserve">
    <value>无法对 Main 方法使用“{0}”，因为它是被导入的</value>
  </data>
  <data name="ERR_BadUnaryOperatorSignature" xml:space="preserve">
    <value>一元运算符的参数必须是包含类型</value>
  </data>
  <data name="ERR_StructsCantContainDefaultConstructor" xml:space="preserve">
    <value>结构不能包含显式的无参数构造函数</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法“{0}”已过时。{1}</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>字符串常量的长度超出了当前内存限制。请尝试将字符串拆分成多个常量。</value>
  </data>
  <data name="ERR_UnassignedThis" xml:space="preserve">
    <value>在控制返回调用方之前，字段“{0}”必须完全赋值</value>
  </data>
  <data name="WRN_CLS_NotOnModules_Title" xml:space="preserve">
    <value>必须在程序集而不是模块上指定 CLSCompliant 特性，以便启用 CLS 遵从性检查</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>引用程序集“{0}”没有强名称。</value>
  </data>
  <data name="IDS_SK_NAMESPACE" xml:space="preserve">
    <value>命名空间</value>
  </data>
  <data name="ERR_AmbigCall" xml:space="preserve">
    <value>以下方法或属性之间的调用具有二义性:“{0}”和“{1}”</value>
  </data>
  <data name="ERR_FloatOverflow" xml:space="preserve">
    <value>浮点常量超出“{0}”类型的范围</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>无法在不进行编码的情况下发出源文本的调试信息。</value>
  </data>
  <data name="ERR_BadResourceVis" xml:space="preserve">
    <value>选项“{0}”无效；资源可见性必须是“public”或“private”</value>
  </data>
  <data name="WRN_BadRestoreNumber_Title" xml:space="preserve">
    <value>警告已全局禁用，无法还原</value>
  </data>
  <data name="ERR_VarargsIterator" xml:space="preserve">
    <value>迭代器的参数列表中不允许有 __arglist</value>
  </data>
  <data name="ERR_CantConvAsyncAnonFuncReturns" xml:space="preserve">
    <value>无法将异步 {0} 转换为委托类型“{1}”。异步 {0} 可能会返回 void、Task 或 Task&lt;T&gt;，这些都不可转换为“{1}”。</value>
  </data>
  <data name="XML_DuplicateAttribute" xml:space="preserve">
    <value>“{0}”特性重复</value>
  </data>
  <data name="XML_EndTagExpected" xml:space="preserve">
    <value>元素“{0}”需要结束标记。</value>
  </data>
  <data name="ERR_UnexpectedBoundGenericName" xml:space="preserve">
    <value>Nameof 运算符中不允许使用类型参数。</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNS" xml:space="preserve">
    <value>命名空间“{1}”中不存在类型或命名空间名“{0}”(是否缺少程序集引用?)</value>
  </data>
  <data name="ERR_NewTyvarWithArgs" xml:space="preserve">
    <value>“{0}”: 创建变量类型的实例时无法提供参数</value>
  </data>
  <data name="ERR_BadWin32Res" xml:space="preserve">
    <value>读取 Win32 资源时出错 -- {0}</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>未能在全局命名空间中找到类型名“{0}”。此类型已转发到程序集“{1}”。请考虑添加对该程序集的引用。</value>
  </data>
  <data name="ERR_CantReturnVoid" xml:space="preserve">
    <value>无法返回 "void" 类型的表达式</value>
  </data>
  <data name="ERR_RefOutDefaultValue" xml:space="preserve">
    <value>ref 或 out 参数不能有默认值</value>
  </data>
  <data name="ERR_SingleTypeNameNotFoundFwd" xml:space="preserve">
    <value>未能找到类型名“{0}”。此类型已转发到程序集“{1}”。请考虑添加对该程序集的引用。</value>
  </data>
  <data name="ERR_BadIteratorLocalType" xml:space="preserve">
    <value>迭代器不能有按引用局部变量</value>
  </data>
  <data name="ERR_DefaultValueForExtensionParameter" xml:space="preserve">
    <value>不能为 "this" 参数指定默认值</value>
  </data>
  <data name="WRN_IsAlwaysFalse" xml:space="preserve">
    <value>给定表达式始终不是所提供的(“{0}”)类型</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag_Title" xml:space="preserve">
    <value>XML 注释中有 typeparam 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="ERR_PartialMethodUnsafeDifference" xml:space="preserve">
    <value>两个分部方法声明必须都是不安全声明，或者两者都不能是不安全声明</value>
  </data>
  <data name="ERR_StaticInAsOrIs" xml:space="preserve">
    <value>“is”或“as”运算符的第二个操作数不能是静态类型“{0}”</value>
  </data>
  <data name="WRN_CLS_BadBase_Description" xml:space="preserve">
    <value>基类型在标记为符合公共语言规范(CLS)的程序集中标记为不必符合 CLS。移除指定程序集符合 CLS 的特性或移除指示类型不符合 CLS 的特性。</value>
  </data>
  <data name="ERR_BadVarargs" xml:space="preserve">
    <value>带有 vararg 的方法不能是泛型，不能属于泛型类型，也不能具有 params 参数</value>
  </data>
  <data name="ERR_BadAwaitArg_NeedSystem" xml:space="preserve">
    <value>“await”要求类型“{0}”包含适当的 GetAwaiter 方法。是否缺少针对“System”的 using 指令?</value>
  </data>
  <data name="ERR_BadVarDecl" xml:space="preserve">
    <value>应输入 ";" 或 "="(无法在声明中指定构造函数参数)</value>
  </data>
  <data name="ERR_OpTFRetType" xml:space="preserve">
    <value>运算符 True 或 False 的返回类型必须是 bool</value>
  </data>
  <data name="ERR_SpecialTypeAsBound" xml:space="preserve">
    <value>约束不能是特殊类“{0}”</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>转发到程序集“{1}”的类型“{0}”与转发到程序集“{3}”的类型“{2}”冲突。</value>
  </data>
  <data name="ERR_DefaultValueNotAllowed" xml:space="preserve">
    <value>默认值在此上下文中无效。</value>
  </data>
  <data name="ERR_BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>委托“{0}”没有名为“{1}”的参数</value>
  </data>
  <data name="WRN_CLS_BadInterface" xml:space="preserve">
    <value>“{0}”不符合 CLS，因为基接口“{1}”不符合 CLS</value>
  </data>
  <data name="ERR_MissingMethodOnSourceInterface" xml:space="preserve">
    <value>源接口“{0}”缺少方法“{1}”，此方法对嵌入事件“{2}”是必需的。</value>
  </data>
  <data name="ERR_BadAttributeParamDefaultArgument" xml:space="preserve">
    <value>特性构造函数参数“{0}”是可选的，但是未指定默认参数值。</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>表达式树 Lambda 不能包含空传播运算符。</value>
  </data>
  <data name="ERR_AliasNotFound" xml:space="preserve">
    <value>找不到别名“{0}”</value>
  </data>
  <data name="ERR_MemberAlreadyInitialized" xml:space="preserve">
    <value>成员“{0}”的初始化重复</value>
  </data>
  <data name="ERR_BadDebugType" xml:space="preserve">
    <value>用于 /debug 的选项“{0}”无效；选项必须是 "portable"、"embedded"、"full" 或 "pdbonly"</value>
  </data>
  <data name="ERR_FixedNeeded" xml:space="preserve">
    <value>只能获取 fixed 语句初始值设定项内的未固定表达式的地址</value>
  </data>
  <data name="ERR_ComImportWithInitializers" xml:space="preserve">
    <value>“{0}”: 具有 ComImport 特性的类不能指定字段初始值设定项。</value>
  </data>
  <data name="ERR_IndexerInStaticClass" xml:space="preserve">
    <value>“{0}”: 不能在静态类中声明索引器</value>
  </data>
  <data name="ERR_DuplicateInterfaceInBaseList" xml:space="preserve">
    <value>“{0}”已经在接口列表中列出</value>
  </data>
  <data name="ERR_UseDefViolationThis" xml:space="preserve">
    <value>在给 "this" 对象的所有字段赋值之前，无法使用该对象</value>
  </data>
  <data name="ERR_PropertyWithNoAccessors" xml:space="preserve">
    <value>“{0}”: 属性或索引器必须至少有一个访问器</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableCannotBeConst" xml:space="preserve">
    <value>隐式类型化的变量不能是常量</value>
  </data>
  <data name="WRN_NewRequired_Description" xml:space="preserve">
    <value>使用与基类中的变量相同的名称声明了变量。但是，未使用关键字 new。此警告通知应使用 new；变量如同在声明中使用了 new 一样进行声明。</value>
  </data>
  <data name="ERR_BadVisReturnType" xml:space="preserve">
    <value>可访问性不一致: 返回类型“{1}”的可访问性低于方法“{0}”</value>
  </data>
  <data name="UseLiteralForTokens" xml:space="preserve">
    <value>使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 可创建字符文本标记。</value>
  </data>
  <data name="WRN_CLS_ArrayArgumentToAttribute_Title" xml:space="preserve">
    <value>作为特性参数的数组不符合 CLS</value>
  </data>
  <data name="WRN_AlignmentMagnitude" xml:space="preserve">
    <value>对齐值 {0} 具有大于 {1} 的度量值，可能产生较大的格式化字符串。</value>
  </data>
  <data name="IDS_FeatureOutVar" xml:space="preserve">
    <value>化出变量声明</value>
  </data>
  <data name="WRN_VacuousIntegralComp" xml:space="preserve">
    <value>与整数常量比较无意义；该常量不在“{0}”类型的范围之内</value>
  </data>
  <data name="IDS_VersionExperimental" xml:space="preserve">
    <value>“实验”</value>
  </data>
  <data name="ERR_GenericsUsedAcrossAssemblies" xml:space="preserve">
    <value>无法跨程序集边界使用程序集“{1}”中的类型“{0}”，因为它有身为嵌入的互操作类型的泛型类型参数。</value>
  </data>
  <data name="ERR_AsMustHaveReferenceType" xml:space="preserve">
    <value>as 运算符必须与引用类型或可以为 null 的类型一起使用(“{0}”是不可以为 null 值的类型)</value>
  </data>
  <data name="ERR_AbstractNotVirtual" xml:space="preserve">
    <value>抽象方法“{0}”不能标记为 virtual</value>
  </data>
  <data name="ERR_OperatorInStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类不能包含用户定义的运算符</value>
  </data>
  <data name="ERR_LabelShadow" xml:space="preserve">
    <value>在包含的范围中标签“{0}”遮盖了具有同样名称的另一个标签</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches" xml:space="preserve">
    <value>成员“{1}”重写“{0}”。在运行时有多个重写候选项。此实现取决于将要调用的方法。</value>
  </data>
  <data name="ERR_GetOrSetExpected" xml:space="preserve">
    <value>应为 get 或 set 访问器</value>
  </data>
  <data name="ERR_ExplicitParamArray" xml:space="preserve">
    <value>不要使用 "System.ParamArrayAttribute"，而是使用 "params" 关键字。</value>
  </data>
  <data name="WRN_ProtectedInSealed_Title" xml:space="preserve">
    <value>在密封类中声明了新的保护成员</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>转发的类型“{0}”与此程序集主模块中声明的类型冲突。</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev_Description" xml:space="preserve">
    <value>两个程序集的版本和/或版本号不同。为进行统一，必须在应用程序的 .config 文件中指定指令，并且必须提供程序集的正确强名称。</value>
  </data>
  <data name="ERR_IndirectRecursiveConstructorCall" xml:space="preserve">
    <value>构造函数“{0}”无法通过另一构造函数调用自身</value>
  </data>
  <data name="ERR_ImportNonAssembly" xml:space="preserve">
    <value>引用的文件“{0}”不是程序集</value>
  </data>
  <data name="ERR_BadBinOpArgs" xml:space="preserve">
    <value>重载的二元运算符“{0}”采用两个参数</value>
  </data>
  <data name="ERR_ConditionalOnOverride" xml:space="preserve">
    <value>Conditional 特性在“{0}”上无效，因为该特性是重写方法</value>
  </data>
  <data name="ERR_LocalCantBeFixedAndHoisted" xml:space="preserve">
    <value>局部变量“{0}”或其成员的地址不能用作匿名方法的参数，也不能在匿名方法或 lambda 表达式内部使用</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>需要 SearchCriteria。</value>
  </data>
  <data name="ERR_InterfacesCantContainConstructors" xml:space="preserve">
    <value>接口不能包含构造函数</value>
  </data>
  <data name="ERR_RetNoObjectRequired" xml:space="preserve">
    <value>由于“{0}”返回 void，返回关键字后面不得有对象表达式</value>
  </data>
  <data name="ERR_IdentityConversion" xml:space="preserve">
    <value>用户定义的运算符不能采用封闭类型的对象，也不能转换成封闭类型的对象</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>无法继续，因为编辑包括对嵌入类型的引用:“{0}”。</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>由于此调用不会等待，因此在此调用完成之前将会继续执行当前方法。请考虑将 "await" 运算符应用于调用结果。</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible" xml:space="preserve">
    <value>“{0}”不实现“{1}”模式。“{2}”是静态的或非公共的。</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1" xml:space="preserve">
    <value>请在对 {0} 的所有引用超出范围之前，对它的分配实例调用 Call System.IDisposable.Dispose()。</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2" xml:space="preserve">
    <value>{0} 的分配实例未按所有异常路径释放。请在对它的所有引用超出范围之前，调用 Call System.IDisposable.Dispose()。</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>要推断的语法节点不能属于来自当前编译的语法树。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>安全特性“{0}”具有无效 SecurityAction 值“{1}”</value>
  </data>
  <data name="ERR_PossibleBadNegCast" xml:space="preserve">
    <value>若要强制转换负值，必须将该值放在括号内。</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>本地名称“{0}”对于 PDB 太长。请考虑缩短或在不使用 /debug 的情况下编译。</value>
  </data>
  <data name="ERR_GlobalDefinitionOrStatementExpected" xml:space="preserve">
    <value>应是成员定义、语句或文件尾</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>由于此调用不会等待，因此在调用完成前将继续执行当前方法</value>
  </data>
  <data name="ERR_UsingAfterElements" xml:space="preserve">
    <value>using 子句必须位于命名空间中定义的所有其他元素之前(外部别名声明除外)</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncMethod" xml:space="preserve">
    <value>“await”运算符只能在异步方法中使用。请考虑使用“async”修饰符标记此方法，并将其返回类型更改为“Task&lt;{0}&gt;”。</value>
  </data>
  <data name="ERR_FixedBufferTooManyDimensions" xml:space="preserve">
    <value>固定缓冲区只能有一个维度。</value>
  </data>
  <data name="WRN_NubExprIsConstBool" xml:space="preserve">
    <value>由于“{1}”类型的值永不等于“{2}”类型的 "null"，该表达式的结果始终为“{0}”</value>
  </data>
  <data name="IDS_SK_VARIABLE" xml:space="preserve">
    <value>变量</value>
  </data>
  <data name="ERR_ColColWithTypeAlias" xml:space="preserve">
    <value>无法将别名“{0}”与“::”一起使用，因为该别名引用了类型。请改用“.”。</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>遇到合并冲突标记</value>
  </data>
  <data name="ERR_FriendAssemblyBadArgs" xml:space="preserve">
    <value>友元程序集引用“{0}”无效。不能在 InternalsVisibleTo 声明中指定版本、区域性、公钥标记或处理器架构。</value>
  </data>
  <data name="ERR_EmptyCharConst" xml:space="preserve">
    <value>空字符</value>
  </data>
  <data name="ERR_AddModuleAssembly" xml:space="preserve">
    <value>“{0}”无法添加到此程序集，因为它已是程序集</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>netmodule 不支持公共签名。</value>
  </data>
  <data name="ERR_FieldCantBeRefAny" xml:space="preserve">
    <value>字段或属性不能是“{0}”类型</value>
  </data>
  <data name="ERR_TupleElementNamesInDeconstruction" xml:space="preserve">
    <value>析构左侧不允许使用元组元素名称。</value>
  </data>
  <data name="ERR_MemGroupInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含方法组</value>
  </data>
  <data name="ERR_DelegateOnNullable" xml:space="preserve">
    <value>无法将委托绑定到作为 "System.Nullable&lt;T&gt;" 成员的“{0}”</value>
  </data>
  <data name="IDS_SK_METHOD" xml:space="preserve">
    <value>方法</value>
  </data>
  <data name="ERR_PartialWrongTypeParams" xml:space="preserve">
    <value>“{0}”的分部声明必须具有顺序相同的相同类型参数名</value>
  </data>
  <data name="XML_InvalidToken" xml:space="preserve">
    <value>此位置无法使用字符“{0}”。</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsyncLambda" xml:space="preserve">
    <value>“await”运算符只能在异步 {0} 中使用。请考虑使用“async”修饰符标记此 {0}。</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>不支持链接推理语义模型。应从非推理 ParentModel 创建推理模型。</value>
  </data>
  <data name="ERR_MultipleEntryPoints" xml:space="preserve">
    <value>程序定义了多个入口点。使用 /main (指定包含入口点的类型)进行编译。</value>
  </data>
  <data name="WRN_FilterIsConstant" xml:space="preserve">
    <value>筛选器表达式是常量，请考虑删除筛选器</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7_1" xml:space="preserve">
    <value>功能“{0}”在 C# 7.1 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="WRN_FailedInclude" xml:space="preserve">
    <value>无法包括文件“{0}”的 XML 段落“{1}”-- {2}</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>从模块“{1}”导出的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</value>
  </data>
  <data name="WRN_MainCantBeGeneric_Title" xml:space="preserve">
    <value>入口点不能是泛型的或属于泛型类型</value>
  </data>
  <data name="ERR_NoMainInClass" xml:space="preserve">
    <value>“{0}”没有合适的静态 Main 方法</value>
  </data>
  <data name="WRN_DebugFullNameTooLong" xml:space="preserve">
    <value>“{0}”的完全限定名对于调试信息太长。请在不使用“/debug”选项的情况下编译。</value>
  </data>
  <data name="ERR_DefaultValueBeforeRequiredValue" xml:space="preserve">
    <value>可选参数必须出现在所有必需参数之后</value>
  </data>
  <data name="WRN_ErrorOverride_Title" xml:space="preserve">
    <value>警告正在重写错误</value>
  </data>
  <data name="WRN_UnreferencedLabel_Title" xml:space="preserve">
    <value>这个标签尚未被引用</value>
  </data>
  <data name="WRN_UnreferencedVar" xml:space="preserve">
    <value>声明了变量“{0}”，但从未使用过</value>
  </data>
  <data name="ERR_BadArity" xml:space="preserve">
    <value>使用泛型 {1}“{0}”需要 {2} 个类型参数</value>
  </data>
  <data name="ERR_EndifDirectiveExpected" xml:space="preserve">
    <value>应输入 #endif 指令</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Description" xml:space="preserve">
    <value>当前的方法调用返回一个 Task 或 Task&lt;TResult&gt; 的 async 方法，并且不会将 await 操作符应用到结果中。对 async 方法的调用将启动异步任务。但是，由于未应用 await 操作符，程序将继续运行而不会等待任务完成。在多数情况下，这种行为并不是你想要的。通常，调用方法的其他部分依赖调用结果，或者至少从包含此调用的方法中返回前需要完成此被调用的方法。

一个同样重要的问题是在调用的 async 方法中产生的异常将发生什么情况。在返回 Task 或 Task&lt;TResult&gt; 的方法中产生的异常存储在返回的任务中。如果你不等待任务完成或显式检查异常，则异常将丢失。如果你等待任务完成，则此异常将重新抛出。

最佳的做法是你应始终等待此调用完成。

仅当你确定不需要等待异步调用完成，并且调用的方法不会产生任何异常时，你可以考虑取消警告。为此，你可以通过将调用的任务结果分配给一个变量来取消警告。</value>
  </data>
  <data name="IDS_FeatureQueryExpression" xml:space="preserve">
    <value>查询表达式</value>
  </data>
  <data name="ERR_InvalidAttributeArgument" xml:space="preserve">
    <value>“{0}”特性的参数值无效</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>不可知的程序集不能具有特定于处理器的模块“{0}”。</value>
  </data>
  <data name="ERR_TrailingWhitespaceInFormatSpecifier" xml:space="preserve">
    <value>格式说明符不能包含尾随空格。</value>
  </data>
  <data name="WRN_UnreferencedVarAssg_Title" xml:space="preserve">
    <value>变量已被赋值，但从未使用过它的值</value>
  </data>
  <data name="ERR_AddRemoveMustHaveBody" xml:space="preserve">
    <value>add 访问器或 remove 访问器必须有一个主体</value>
  </data>
  <data name="ERR_ExplicitMethodImplAccessor" xml:space="preserve">
    <value>“{0}”显式方法实现无法实现“{1}”，因为它是一个访问器</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Title" xml:space="preserve">
    <value>成员在运行时使用多个匹配项实现接口成员</value>
  </data>
  <data name="WRN_DuplicateParamTag" xml:space="preserve">
    <value>XML 注释中对“{0}”有重复的 param 标记</value>
  </data>
  <data name="ERR_ReservedEnumerator" xml:space="preserve">
    <value>枚举器名“{0}”是保留名称，不能使用</value>
  </data>
  <data name="ERR_DictionaryInitializerInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含一个字典初始值设定项。</value>
  </data>
  <data name="WRN_NewNotRequired" xml:space="preserve">
    <value>成员“{0}”不会隐藏可访问成员。不需要关键字 new。</value>
  </data>
  <data name="WRN_BadWarningNumber_Description" xml:space="preserve">
    <value>传递到 #pragma 警告预处理器指令的编号不是有效的警告编号。验证该编号是否表示警告而不是错误。</value>
  </data>
  <data name="IDS_AwaitInCatchAndFinally" xml:space="preserve">
    <value>在 catch 块和 finally 块中等待</value>
  </data>
  <data name="WRN_MainCantBeGeneric" xml:space="preserve">
    <value>“{0}”: 入口点不能是泛型的或属于泛型类型</value>
  </data>
  <data name="ERR_UnimplementedInterfaceMember" xml:space="preserve">
    <value>“{0}”不实现接口成员“{1}”</value>
  </data>
  <data name="ERR_BadInstanceArgType" xml:space="preserve">
    <value>“{0}”不包含“{1}”的定义，并且最佳扩展方法重载“{2}”需要类型为“{3}”的接收器</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>仅脚本中允许使用 #r</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>语法树已存在</value>
  </data>
  <data name="ERR_BadRefWithThis" xml:space="preserve">
    <value> 参数修饰符“ref”不能与“this”一起使用 </value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>无效输出名: {0}</value>
  </data>
  <data name="ERR_ComImportWithUserCtor" xml:space="preserve">
    <value>具有 ComImport 特性的类不能有用户定义的构造函数</value>
  </data>
  <data name="ERR_RefReturnMustHaveIdentityConversion" xml:space="preserve">
    <value>返回表达式必须为“{0}”类型，因为此方法按引用返回</value>
  </data>
  <data name="ERR_AutoPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>自动实现的属性必须具有 get 访问器。</value>
  </data>
  <data name="WRN_CLS_BadIdentifier" xml:space="preserve">
    <value>标识符“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>读取“{0}”的调试信息时出错</value>
  </data>
  <data name="ERR_DestructorInStaticClass" xml:space="preserve">
    <value>静态类不能包含析构函数</value>
  </data>
  <data name="WRN_IsAlwaysTrue" xml:space="preserve">
    <value>给定表达式始终为所提供的(“{0}”)类型</value>
  </data>
  <data name="ERR_SourceFileReferencesNotSupported" xml:space="preserve">
    <value>不支持源文件引用。</value>
  </data>
  <data name="WRN_SequentialOnPartialClass" xml:space="preserve">
    <value>在分部结构“{0}”的多个声明中的字段之间没有已定义的排序方式。要指定排序方式，所有实例字段必须位于同一声明中。</value>
  </data>
  <data name="ERR_BadVisIndexerReturn" xml:space="preserve">
    <value>可访问性不一致: 索引器返回类型“{1}”的可访问性低于索引器“{0}”</value>
  </data>
  <data name="WRN_CLS_VolatileField_Title" xml:space="preserve">
    <value>符合 CLS 的字段不能是可变字段</value>
  </data>
  <data name="ERR_BadVisParamType" xml:space="preserve">
    <value>可访问性不一致: 参数类型“{1}”的可访问性低于方法“{0}”</value>
  </data>
  <data name="TreeMustHaveARootNodeWith" xml:space="preserve">
    <value>树必须具有带 SyntaxKind.CompilationUnit 的根节点</value>
  </data>
  <data name="ERR_IllegalStatement" xml:space="preserve">
    <value>只有 assignment、call、increment、decrement 和 new 对象表达式可用作语句</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation" xml:space="preserve">
    <value>应用到参数“{0}”的 CallerFilePathAttribute 将不起作用，因为它应用到的成员在不允许使用可选参数的上下文中使用</value>
  </data>
  <data name="ERR_IllegalParams" xml:space="preserve">
    <value>params 在此上下文中无效</value>
  </data>
  <data name="ERR_ByRefParameterInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含 out 或 ref 参数</value>
  </data>
  <data name="ERR_CollectionInitRequiresIEnumerable" xml:space="preserve">
    <value>无法使用集合初始值设定项初始化类型“{0}”，原因是它不实现“System.Collections.IEnumerable”</value>
  </data>
  <data name="ERR_BadShiftOperatorSignature" xml:space="preserve">
    <value>重载移位运算符的第一个操作数的类型必须与包含类型相同，第二个操作数的类型必须是 int 类型</value>
  </data>
  <data name="IDS_FeatureAutoPropertyInitializer" xml:space="preserve">
    <value>自动属性初始值设定项</value>
  </data>
  <data name="ERR_CantReadResource" xml:space="preserve">
    <value>读取资源“{0}”时出错 --“{1}”</value>
  </data>
  <data name="ERR_PPDirectiveExpected" xml:space="preserve">
    <value>应输入预处理器指令</value>
  </data>
  <data name="ERR_ByRefTypeAndAwait" xml:space="preserve">
    <value>“等待”不能在包含“{0}”类型的表达式中使用</value>
  </data>
  <data name="ERR_DuplicatePropertyAccessMods" xml:space="preserve">
    <value>不能为属性或索引器“{0}”的两个访问器同时指定可访问性修饰符</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>元组元素名称必须是唯一的。</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>语言名无效</value>
  </data>
  <data name="ERR_CantCallSpecialMethod" xml:space="preserve">
    <value>“{0}”: 无法显式调用运算符或访问器</value>
  </data>
  <data name="ERR_ExternHasConstructorInitializer" xml:space="preserve">
    <value>“{0}”不能是外部的，也不能具有构造函数初始值设定项</value>
  </data>
  <data name="ERR_AutoPropertyCannotBeRefReturning" xml:space="preserve">
    <value>自动实现的属性无法按引用返回</value>
  </data>
  <data name="XML_WhitespaceMissing" xml:space="preserve">
    <value>缺少所需空格。</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>缺少对“{0}”netmodule 的引用。</value>
  </data>
  <data name="IDS_OperationCausedStackOverflow" xml:space="preserve">
    <value>操作导致堆栈溢出。</value>
  </data>
  <data name="IDS_FOREACHLOCAL" xml:space="preserve">
    <value>foreach 迭代变量</value>
  </data>
  <data name="ERR_CantOverrideNonEvent" xml:space="preserve">
    <value>“{0}”: 无法重写；“{1}”不是事件</value>
  </data>
  <data name="ERR_DuplicateTypeForwarder" xml:space="preserve">
    <value>“{0}”与 TypeForwardedToAttribute 重复</value>
  </data>
  <data name="ERR_InvalidFixedArraySize" xml:space="preserve">
    <value>固定大小缓冲区的长度必须大于零</value>
  </data>
  <data name="ERR_BadAwaitAsIdentifier" xml:space="preserve">
    <value>“await”不能用作异步方法或 lambda 表达式中的标识符</value>
  </data>
  <data name="ERR_ConstOutOfRangeChecked" xml:space="preserve">
    <value>常量值“{0}”无法转换为“{1}”(使用 "unchecked" 语法重写)</value>
  </data>
  <data name="WRN_CLS_BadIdentifier_Title" xml:space="preserve">
    <value>标识符不符合 CLS</value>
  </data>
  <data name="IDS_FeatureDictionaryInitializer" xml:space="preserve">
    <value>字典初始值设定项</value>
  </data>
  <data name="IDS_FeatureInterpolatedStrings" xml:space="preserve">
    <value>插补的字符串</value>
  </data>
  <data name="ERR_AnonymousReturnExpected" xml:space="preserve">
    <value>在类型“{1}”的“{0}”中，并不是所有代码路径都返回值</value>
  </data>
  <data name="WRN_BadRefCompareLeft_Title" xml:space="preserve">
    <value>可能非有意的引用比较；左侧需要强制转换</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>无法解析为 PermissionSet 特性的命名参数“{1}”指定的文件路径“{0}”</value>
  </data>
  <data name="ERR_InvalidNumber" xml:space="preserve">
    <value>无效数字</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>引用程序集“{0}”具有不同区域性设置“{1}”。</value>
  </data>
  <data name="WRN_AmbiguousXMLReference_Title" xml:space="preserve">
    <value>cref 特性中有不明确的引用</value>
  </data>
  <data name="ERR_BadTypeforThis" xml:space="preserve">
    <value>扩展方法的第一个参数的类型不能是“{0}”</value>
  </data>
  <data name="ERR_BadSKunknown" xml:space="preserve">
    <value>“{0}”是一个 {1}，这在给定的上下文中无效</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut" xml:space="preserve">
    <value>仅 ref 或 out 有区别，或者仅数组秩不同的重载方法“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_NoVoidParameter" xml:space="preserve">
    <value>参数类型 "void" 无效</value>
  </data>
  <data name="ERR_ConstraintOnlyAllowedOnGenericDecl" xml:space="preserve">
    <value>在非泛型声明上不允许使用约束</value>
  </data>
  <data name="WRN_BadXMLRefSyntax_Title" xml:space="preserve">
    <value>XML 注释中有语法错误的 cref 特性</value>
  </data>
  <data name="IDS_FeatureAnonDelegates" xml:space="preserve">
    <value>匿名方法</value>
  </data>
  <data name="ERR_ExpressionTreeContainsThrowExpression" xml:space="preserve">
    <value>表达式树不能包含 throw 表达式</value>
  </data>
  <data name="ERR_NoExplicitConv" xml:space="preserve">
    <value>无法将类型“{0}”转换为“{1}”</value>
  </data>
  <data name="ERR_DuplicateNamedArgument" xml:space="preserve">
    <value>不能多次指定所命名的参数“{0}”。</value>
  </data>
  <data name="ERR_BadArraySyntax" xml:space="preserve">
    <value>数组类型说明符 [] 必须出现在参数名之前</value>
  </data>
  <data name="ERR_ValueCantBeNull" xml:space="preserve">
    <value>无法将 null 转换为“{0}”，因为后者是不可以为 null 的值类型</value>
  </data>
  <data name="ERR_PartialMisplaced" xml:space="preserve">
    <value>"partial" 修饰符的后面只能紧跟 "class"、"struct"、"interface" 或 "void"</value>
  </data>
  <data name="ERR_DefaultValueTypeMustMatch" xml:space="preserve">
    <value>DefaultParameterValue 特性的实参类型必须与形参类型匹配</value>
  </data>
  <data name="ERR_AliasMissingFile" xml:space="preserve">
    <value>无效的引用别名选项:“{0}=”-- 缺少文件名</value>
  </data>
  <data name="ERR_RefReturnReadonly2" xml:space="preserve">
    <value>只读字段“{0}”的成员无法按引用返回</value>
  </data>
  <data name="ERR_BadDynamicMethodArg" xml:space="preserve">
    <value>无法将类型为“{0}”的表达式用作动态调度的操作的参数。</value>
  </data>
  <data name="ERR_BadDynamicQuery" xml:space="preserve">
    <value>不允许源类型 "dynamic" 上或具有类型 "dynamic" 的连接序列的查询表达式</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource" xml:space="preserve">
    <value>选项“{0}”重写源文件或添加的模块中给出的特性“{1}”</value>
  </data>
  <data name="ERR_MemberNameSameAsType" xml:space="preserve">
    <value>“{0}”: 成员名不能与它们的封闭类型相同</value>
  </data>
  <data name="ERR_TypeVarNotFound" xml:space="preserve">
    <value>上下文关键字“var”只能出现在局部变量声明或脚本代码中</value>
  </data>
  <data name="ERR_BadBaseNumber" xml:space="preserve">
    <value>图像基数“{0}”无效</value>
  </data>
  <data name="ERR_WinRtEventPassedByRef" xml:space="preserve">
    <value>无法作为 out 或 ref 参数传递 Windows 运行时事件。</value>
  </data>
  <data name="ERR_SpecialByRefInLambda" xml:space="preserve">
    <value>“{0}”类型的实例不能在匿名函数、查询表达式、迭代器块或异步方法中使用</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongReturnType" xml:space="preserve">
    <value>“{0}”不实现接口成员“{1}”。“{2}”无法实现“{1}”，因为它没有“{3}”的匹配返回类型。</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedMulti" xml:space="preserve">
    <value>{0} 子句中其中一个表达式的类型不正确。在对“{1}”的调用中，类型推理失败。</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar_Title" xml:space="preserve">
    <value>XML 注释中有引用类型参数的 cref 特性</value>
  </data>
  <data name="ERR_MethodNameExpected" xml:space="preserve">
    <value>应输入方法名称</value>
  </data>
  <data name="ERR_FixedLocalInLambda" xml:space="preserve">
    <value>在匿名方法、lambda 表达式或查询表达式中不能使用固定的局部变量“{0}”</value>
  </data>
  <data name="ERR_IllegalVarArgs" xml:space="preserve">
    <value>__arglist 在此上下文中无效</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>元素不能为 Null。</value>
  </data>
  <data name="NotACSharpSymbol" xml:space="preserve">
    <value>不是 C# 符号。</value>
  </data>
  <data name="ERR_ParameterIsStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类型不能用作参数</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>从模块“{1}”导出的类型“{0}”与此程序集主模块中声明的类型冲突。</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>指定版本字符串不符合所需格式 - major[.minor[.build[.revision]]]</value>
  </data>
  <data name="ERR_MultipleIEnumOfT" xml:space="preserve">
    <value>foreach 语句实现“{1}”的多个实例化，因此不能在“{0}”类型的变量上运行；请尝试强制转换到特定的接口实例化</value>
  </data>
  <data name="WRN_UnmatchedParamTag_Title" xml:space="preserve">
    <value>XML 注释中有 param 标记，但是没有该名称的参数</value>
  </data>
  <data name="ERR_ByRefReturnUnsupported" xml:space="preserve">
    <value>不支持按引用返回类型“ref {0}”。</value>
  </data>
  <data name="ERR_IdentifierExpected" xml:space="preserve">
    <value>应输入标识符</value>
  </data>
  <data name="IDS_FeaturePatternMatching" xml:space="preserve">
    <value>模式匹配</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用；它由 CallerFilePathAttribute 重写</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBaseAccess" xml:space="preserve">
    <value>表达式树不能包含基访问</value>
  </data>
  <data name="ERR_DupParamMod" xml:space="preserve">
    <value>参数只能有一个“{0}”修饰符</value>
  </data>
  <data name="ERR_LabelNotFound" xml:space="preserve">
    <value>goto 语句范围内没有“{0}”这样的标签</value>
  </data>
  <data name="ERR_IllegalUnsafe" xml:space="preserve">
    <value>不安全代码只会在使用 /unsafe 编译的情况下出现</value>
  </data>
  <data name="ERR_RefReturningCallAndAwait" xml:space="preserve">
    <value>不能在包含对“{0}”的调用的表达式中使用 "await"，因为它按引用返回</value>
  </data>
  <data name="ERR_VirtualPrivate" xml:space="preserve">
    <value>“{0}”: 虚拟成员或抽象成员不能是私有的</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>引用程序集具有不同区域性设置</value>
  </data>
  <data name="ERR_NoConversionForNubDefaultParam" xml:space="preserve">
    <value>无法将类型为“{0}”的值用作可以为 null 的参数“{1}”的默认参数，因为“{0}”不是简单类型</value>
  </data>
  <data name="ERR_NoConversionForDefaultParam" xml:space="preserve">
    <value>不能将“{0}”类型的值用作默认参数，因为没有到类型“{1}”的标准转换</value>
  </data>
  <data name="ERR_AbstractInConcreteClass" xml:space="preserve">
    <value>“{0}”是抽象的，但它包含在非抽象类“{1}”中</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>程序集“{1}”中的模块“{0}”将类型“{2}”转发到多个程序集: “{3}”和“{4}”。</value>
  </data>
  <data name="WRN_IllegalPPWarning_Title" xml:space="preserve">
    <value>#pragma 警告后应为 disable 或 restore</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>SecurityAction 值“{0}”对于应用于类型或方法的安全特性无效</value>
  </data>
  <data name="ERR_BadSKknown" xml:space="preserve">
    <value>“{0}”是 {1}，但此处被当做 {2} 来使用</value>
  </data>
  <data name="ERR_BadDirectivePlacement" xml:space="preserve">
    <value>预处理器指令必须作为一行的第一个非空白字符出现</value>
  </data>
  <data name="IDS_SK_FIELD" xml:space="preserve">
    <value>字段</value>
  </data>
  <data name="IDS_SK_ALIAS" xml:space="preserve">
    <value>using 别名</value>
  </data>
  <data name="WRN_PatternStaticOrInaccessible_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员静态的或非公共的</value>
  </data>
  <data name="IDS_FeatureDigitSeparator" xml:space="preserve">
    <value>数字分隔符</value>
  </data>
  <data name="IDS_SK_EVENT" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="ERR_BadMemberFlag" xml:space="preserve">
    <value>修饰符“{0}”对该项无效</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>密钥文件“{0}”缺少签名所需的私钥</value>
  </data>
  <data name="IDS_SK_LABEL" xml:space="preserve">
    <value>标签</value>
  </data>
  <data name="ERR_IllegalArglist" xml:space="preserve">
    <value>__arglist 表达式只能出现在调用或 new 表达式内部</value>
  </data>
  <data name="FTL_BadChecksumAlgorithm" xml:space="preserve">
    <value>不支持算法“{0}”</value>
  </data>
  <data name="ERR_MemberNeedsType" xml:space="preserve">
    <value>方法必须具有返回类型</value>
  </data>
  <data name="IDS_SK_TYVAR" xml:space="preserve">
    <value>类型形参</value>
  </data>
  <data name="ERR_EnumsCantContainDefaultConstructor" xml:space="preserve">
    <value>枚举不能包含显式无参数构造函数</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration_Title" xml:space="preserve">
    <value>不是此声明的有效特性位置</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>创建哈希时加密失败。</value>
  </data>
  <data name="ThisMethodCanOnlyBeUsedToCreateTokens" xml:space="preserve">
    <value>此方法只能用于创建标记 - {0} 不出标记类型。</value>
  </data>
  <data name="ERR_NameNotInContextPossibleMissingReference" xml:space="preserve">
    <value>当前上下文中不存在名称“{0}”(是否缺少对程序集“{1}”的引用?)</value>
  </data>
  <data name="ERR_BaseInBadContext" xml:space="preserve">
    <value>关键字“base”在当前上下文中不可用</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclaration" xml:space="preserve">
    <value>本地变量“{0}”在声明之前无法使用</value>
  </data>
  <data name="XML_CDataEndTagNotAllowed" xml:space="preserve">
    <value>元素内容中不允许使用字符串“]]&gt;”。</value>
  </data>
  <data name="ERR_DeriveFromConstructedDynamic" xml:space="preserve">
    <value>“{0}”: 无法实现动态接口“{1}”</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>参数对于指定非托管类型无效。</value>
  </data>
  <data name="IDS_REFERENCEPATH_OPTION" xml:space="preserve">
    <value>/REFERENCEPATH 选项</value>
  </data>
  <data name="ERR_ExpressionTreeContainsLocalFunction" xml:space="preserve">
    <value>表达式树不能包含对本地函数的引用</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>字段具有多个不同的常量值。</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} 版本 {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>版权所有(C) Microsoft Corporation。保留所有权利。</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>安全特性“{0}”对此声明类型无效。安全特性仅对程序集、类型和方法声明有效。</value>
  </data>
  <data name="IDS_FeatureUsingStatic" xml:space="preserve">
    <value>using static</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>在当前调试会话期间添加的成员“{0}”只能从其声明的程序集“{1}”中访问。</value>
  </data>
  <data name="ERR_PPLoadFollowsToken" xml:space="preserve">
    <value>文件中的第一个令牌后面不得使用 #load</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOutVariable" xml:space="preserve">
    <value>表达式树不能包含输出参数变量声明。</value>
  </data>
  <data name="WRN_BadXMLRefParamType" xml:space="preserve">
    <value>XML 注释 cref 特性中参数 {0} 的类型无效:“{1}”</value>
  </data>
  <data name="ERR_BadVisBound" xml:space="preserve">
    <value>可访问性不一致: 约束类型“{1}”的可访问性低于“{0}”</value>
  </data>
  <data name="ERR_AbstractAndSealed" xml:space="preserve">
    <value>“{0}”不能既是抽象的又是密封的</value>
  </data>
  <data name="ERR_UnexpectedCharacter" xml:space="preserve">
    <value>意外的字符“{0}”</value>
  </data>
  <data name="ERR_BadNamedAttributeArgument" xml:space="preserve">
    <value>“{0}”不是有效的命名特性参数。命名特性参数必须是非只读、非静态或非常数的字段，或者是公共的和非静态的读写属性。</value>
  </data>
  <data name="WRN_IllegalPragma_Title" xml:space="preserve">
    <value>无法识别的 #pragma 指令</value>
  </data>
  <data name="ERR_VarDeclIsStaticClass" xml:space="preserve">
    <value>无法声明静态类型“{0}”的变量</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Description" xml:space="preserve">
    <value>使用 /link 添加了对程序集的引用(“嵌入互操作类型”属性设置为 True)。这指示编译器嵌入来自该程序集的互操作类型信息。但是，编译器无法嵌入来自该程序集的互操作类型信息，因为已引用的另一个程序集也使用 /reference 引用该程序集(“嵌入互操作类型”属性设置为 False)。

要嵌入两个程序集的互操作类型信息，请对每个程序集的引用使用 /link (将“嵌入互操作类型”属性设置为 True)。

要移除警告，可以改用 /reference (将“嵌入互操作类型”属性设置为 False)。在这种情况下，主互操作程序集 (PIA) 会提供互操作类型信息。</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedAccessor" xml:space="preserve">
    <value>表达式主体属性访问器</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals" xml:space="preserve">
    <value>“{0}”定义运算符 == 或运算符 !=，但不重写 Object.Equals(object o)</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>类型参数的数目不正确</value>
  </data>
  <data name="WRN_PatternBadSignature" xml:space="preserve">
    <value>“{0}”不实现“{1}”模式。“{2}”有错误的签名。</value>
  </data>
  <data name="ERR_BadModifiersOnNamespace" xml:space="preserve">
    <value>命名空间声明不能有修饰符或特性</value>
  </data>
  <data name="ERR_MissingStructOffset" xml:space="preserve">
    <value>“{0}”: 标记为 StructLayout(LayoutKind.Explicit) 的实例字段类型必须具有 FieldOffset 特性</value>
  </data>
  <data name="ERR_NoNewAbstract" xml:space="preserve">
    <value>无法创建抽象类或接口“{0}”的实例</value>
  </data>
  <data name="ERR_ExplicitEventFieldImpl" xml:space="preserve">
    <value>事件的显式接口实现必须使用事件访问器语法</value>
  </data>
  <data name="ERR_CircConstValue" xml:space="preserve">
    <value>“{0}”的常量值计算涉及循环定义</value>
  </data>
  <data name="WRN_AttributeLocationOnBadDeclaration" xml:space="preserve">
    <value>“{0}”不是此声明的有效特性位置。此声明的有效特性位置是“{1}”。此块中的所有特性都将被忽略。</value>
  </data>
  <data name="ERR_AmbiguousAttribute" xml:space="preserve">
    <value>“{0}”在“{1}”和“{2}”之间不明确；请使用“@{0}”或“{0}Attribute”</value>
  </data>
  <data name="ERR_SemicolonExpected" xml:space="preserve">
    <value>应输入 ;</value>
  </data>
  <data name="WRN_DynamicDispatchToConditionalMethod_Title" xml:space="preserve">
    <value>动态调度的调用可能会在运行时失败，因为一个或多个适用的重载为条件方法</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg_Title" xml:space="preserve">
    <value>命名空间与导入类型冲突</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneActual" xml:space="preserve">
    <value>分部方法不能有多个实现声明</value>
  </data>
  <data name="ERR_RefReadonlyLocalCause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，无法用作 ref 或 out 值</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>友元访问权限由“{0}”授予，但是输出程序集的强名称签名状态与授予程序集的强名称签名状态不匹配。</value>
  </data>
  <data name="ERR_ConstructedDynamicTypeAsBound" xml:space="preserve">
    <value>约束不能是动态类型“{0}”</value>
  </data>
  <data name="ERR_BadUnaryOp" xml:space="preserve">
    <value>运算符“{0}”无法应用于“{1}”类型的操作数</value>
  </data>
  <data name="WRN_VolatileByRef" xml:space="preserve">
    <value>“{0}”: 对 volatile 字段的引用不被视为 volatile</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDynamicOperation" xml:space="preserve">
    <value>表达式树不能包含动态操作</value>
  </data>
  <data name="ERR_ImplicitlyTypedLocalCannotBeFixed" xml:space="preserve">
    <value>隐式类型的局部变量不能是固定值</value>
  </data>
  <data name="ERR_ImportedCircularBase" xml:space="preserve">
    <value>导入的类型“{0}”无效。它包含循环的基类依赖项。</value>
  </data>
  <data name="ERR_QueryMultipleProviders" xml:space="preserve">
    <value>找到源类型“{0}”的多个查询模式实现。对“{1}”的调用不明确。</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>命令行开关“{0}”尚未实现，已忽略。</value>
  </data>
  <data name="WRN_ExternMethodNoImplementation" xml:space="preserve">
    <value>方法、运算符或访问器“{0}”标记为外部对象并且它上面没有任何特性。请考虑添加一个 DllImport 特性以指定外部实现。</value>
  </data>
  <data name="ERR_BadVisIndexerParam" xml:space="preserve">
    <value>可访问性不一致: 参数类型“{1}”的可访问性低于索引器“{0}”</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedProperty" xml:space="preserve">
    <value>expression-bodied 属性</value>
  </data>
  <data name="ERR_StructOffsetOnBadField" xml:space="preserve">
    <value>静态字段或常量字段上不允许存在 FieldOffset 特性</value>
  </data>
  <data name="ERR_AnonDelegateCantUseLocal" xml:space="preserve">
    <value>不能在匿名方法、lambda 表达式或查询表达式内使用 ref 局部变量“{0}”</value>
  </data>
  <data name="ERR_AmbigBinaryOps" xml:space="preserve">
    <value>运算符“{0}”对于“{1}”和“{2}”类型的操作数具有二义性</value>
  </data>
  <data name="WRN_CLS_BadReturnType" xml:space="preserve">
    <value>“{0}”的返回类型不符合 CLS</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Title" xml:space="preserve">
    <value>假定程序集引用与标识匹配</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtensionNeedUsing" xml:space="preserve">
    <value>“{0}”不包含“{1}”的定义，并且找不到可接受类型为“{0}”的第一个参数的扩展方法“{1}”(是否缺少针对“{2}”的 using 指令?)</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>指定了延迟签名，这需要公钥，但是未指定任何公钥</value>
  </data>
  <data name="WRN_DotOnDefault" xml:space="preserve">
    <value>由于“{0}”的默认值为 null，因此表达式总会导致 System.NullReferenceException</value>
  </data>
  <data name="ERR_IndexerNeedsParam" xml:space="preserve">
    <value>索引器必须至少有一个参数</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing" xml:space="preserve">
    <value>使用“{0}”测试与“{1}”的兼容性和测试与“{2}”的兼容性实质上是相同的，且对于所有非 null 值都将成功</value>
  </data>
  <data name="ERR_IntegralTypeValueExpected" xml:space="preserve">
    <value>应输入整型值</value>
  </data>
  <data name="ERR_MultiParamMod" xml:space="preserve">
    <value>参数不能具有所有指定的修饰符；该参数上的修饰符太多</value>
  </data>
  <data name="ERR_NotYetImplementedInRoslyn" xml:space="preserve">
    <value>尚未实现此语言功能(“{0}”)。</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>应从提交创建语法树。</value>
  </data>
  <data name="WRN_DebugFullNameTooLong_Title" xml:space="preserve">
    <value>完全限定名对于调试信息太长</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion" xml:space="preserve">
    <value>找不到 RuntimeMetadataVersion 的值。找不到包含 System.Object 的程序集，或未通过选项为 RuntimeMetadataVersion 指定值。</value>
  </data>
  <data name="WRN_CoClassWithoutComImport_Title" xml:space="preserve">
    <value>接口标记为 "CoClassAttribute" 而不是 "ComImportAttribute"</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title" xml:space="preserve">
    <value>已分配实例未按所有异常路径释放</value>
  </data>
  <data name="ERR_InExpected" xml:space="preserve">
    <value>应为 "in"</value>
  </data>
  <data name="ERR_ErrorInReferencedAssembly" xml:space="preserve">
    <value>引用的程序集“{0}”中有错误。</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>任何位置都不允许使用元组元素名称“{0}”。</value>
  </data>
  <data name="WRN_NegativeArrayIndex" xml:space="preserve">
    <value>用负索引对数组进行索引(数组索引总是从零开始)</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn" xml:space="preserve">
    <value>CLSCompliant 特性在应用于返回类型时无意义。请尝试将该特性应用于方法。</value>
  </data>
  <data name="ERR_MainClassNotClass" xml:space="preserve">
    <value>为 Main 方法指定的“{0}”必须是有效的非泛型类或结构</value>
  </data>
  <data name="ERR_DeprecatedCollectionInitAddStr" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法“{0}”已过时。{1}</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType_Title" xml:space="preserve">
    <value>CLS 遵从性检查在此程序集外部不可见，因此不会执行它</value>
  </data>
  <data name="ERR_PartialWrongConstraints" xml:space="preserve">
    <value>“{0}”的分部声明对类型参数“{1}”具有不一致的约束</value>
  </data>
  <data name="ERR_MainClassNotFound" xml:space="preserve">
    <value>未能找到为 Main 方法指定的“{0}”</value>
  </data>
  <data name="WRN_ByRefNonAgileField_Title" xml:space="preserve">
    <value>将引用封送类的字段用作 ref 或 out 值或获取其地址可能导致运行时异常</value>
  </data>
  <data name="ERR_PropertyAccessModInInterface" xml:space="preserve">
    <value>“{0}”: 可访问性修饰符不能在接口中的访问器上使用</value>
  </data>
  <data name="ERR_NoCorrespondingArgument" xml:space="preserve">
    <value>未提供与“{1}”的必需形参“{0}”对应的实参</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>提供的源代码类型不受支持或无效:“{0}”</value>
  </data>
  <data name="ERR_DefaultValueForParamsParameter" xml:space="preserve">
    <value>无法为参数数组指定默认值</value>
  </data>
  <data name="WRN_AssignmentToSelf_Title" xml:space="preserve">
    <value>对同一变量进行了赋值</value>
  </data>
  <data name="ERR_InvalidPreprocessingSymbol" xml:space="preserve">
    <value>预处理符号的名称无效；“{0}”不是有效的标识符</value>
  </data>
  <data name="ERR_UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>“{0}”不能同时实现“{1}”和“{2}”，原因是它们可以统一以进行某些类型参数替换</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>转发到程序集“{1}”的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</value>
  </data>
  <data name="ERR_ValConstraintNotSatisfied" xml:space="preserve">
    <value>类型“{2}”必须是不可以为 null 值的类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="WRN_InvalidMainSig_Title" xml:space="preserve">
    <value>方法的签名错误，不能作为入口点</value>
  </data>
  <data name="ERR_DuplicateModifier" xml:space="preserve">
    <value>“{0}”修饰符重复</value>
  </data>
  <data name="IDS_Contravariantly" xml:space="preserve">
    <value>逆变式</value>
  </data>
  <data name="ERR_ExpectedVerbatimLiteral" xml:space="preserve">
    <value>原义说明符 @ 之后应为关键字、标识符或字符串@</value>
  </data>
  <data name="ERR_ExplicitPropertyMissingAccessor" xml:space="preserve">
    <value>显式接口实现“{0}”缺少访问器“{1}”</value>
  </data>
  <data name="ERR_NewConstraintNotSatisfied" xml:space="preserve">
    <value>“{2}”必须是具有公共的无参数构造函数的非抽象类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="ERR_ClassDoesntImplementInterface" xml:space="preserve">
    <value>“{0}”: 包含类型不实现接口“{1}”</value>
  </data>
  <data name="ERR_QueryNoProviderStandard" xml:space="preserve">
    <value>未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。是否缺少对“System.Core.dll”的引用，或者缺少针对“System.Linq”的 using 指令?</value>
  </data>
  <data name="ERR_OperatorCantReturnVoid" xml:space="preserve">
    <value>用户定义的运算符不能返回 void</value>
  </data>
  <data name="IDS_FeatureBinaryLiteral" xml:space="preserve">
    <value>二进制文字</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>无法创建大小为负值的数组</value>
  </data>
  <data name="IDS_FeatureStaticClasses" xml:space="preserve">
    <value>静态类</value>
  </data>
  <data name="ERR_YieldInAnonMeth" xml:space="preserve">
    <value>不能在匿名方法或 lambda 表达式内使用 yield 语句</value>
  </data>
  <data name="ERR_GenericsUsedInNoPIAType" xml:space="preserve">
    <value>无法嵌入类型“{0}”，因为它有泛型参数。请考虑将“嵌入互操作类型”属性设置为 false。</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger_Title" xml:space="preserve">
    <value>源文件已超过在 PDB 中可表示的 16,707,565 行的限制；调试信息将不正确</value>
  </data>
  <data name="ERR_AutoPropertyInitializerInInterface" xml:space="preserve">
    <value>接口中自动实现的属性不能具有初始值设定项。</value>
  </data>
  <data name="ERR_UnimplementedInterfaceAccessor" xml:space="preserve">
    <value>“{0}”不实现接口成员“{1}”。“{2}”不是公共的。</value>
  </data>
  <data name="ERR_TyVarNotFoundInConstraint" xml:space="preserve">
    <value>“{1}”未定义类型参数“{0}”</value>
  </data>
  <data name="ERR_BadDynamicTypeof" xml:space="preserve">
    <value>typeof 运算符不能用在动态类型上</value>
  </data>
  <data name="ERR_IncrementLvalueExpected" xml:space="preserve">
    <value>递增或递减运算符的操作数必须是变量、属性或索引器</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>/仅在发出可移植 PDB 时支持嵌入式开关(/debug:portable 或 /debug:embedded)。</value>
  </data>
  <data name="ERR_AbstractAndExtern" xml:space="preserve">
    <value>“{0}”不能既是外部的又是抽象的</value>
  </data>
  <data name="ERR_RetObjectRequired" xml:space="preserve">
    <value>需要一个类型可转换为“{0}”的对象</value>
  </data>
  <data name="ERR_InstantiatingStaticClass" xml:space="preserve">
    <value>无法创建静态类“{0}”的实例</value>
  </data>
  <data name="WRN_NewRequired" xml:space="preserve">
    <value>“{0}”隐藏继承的成员“{1}”。如果是有意隐藏，请使用关键字 new。</value>
  </data>
  <data name="XML_InvalidUnicodeChar" xml:space="preserve">
    <value>Unicode 字符无效。</value>
  </data>
  <data name="ERR_BadRefReturnExpressionTree" xml:space="preserve">
    <value>按引用返回的 Lambda 表达式不能转换为表达式树</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>由于找不到编译器必需的类型“{0}”，因此无法使用元组来定义类或成员。是否缺少引用?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>使用来自文件“{0}”的公钥对输出签名时出错 -- {1}</value>
  </data>
  <data name="ERR_RefValBoundWithClass" xml:space="preserve">
    <value>“{0}”: 不能既指定约束类又指定“class”或“struct”约束</value>
  </data>
  <data name="ERR_BadUsingType" xml:space="preserve">
    <value>“using static” 指令只能应用于类型；“{0}”是一个命名空间而不是类型。请考虑改用“using namespace”指令</value>
  </data>
  <data name="ERR_BadDynamicMethodArgLambda" xml:space="preserve">
    <value>如果不事先将 lambda 表达式强制转换为委托或表达式树类型，则无法将该表达式用作动态调度的操作的参数。</value>
  </data>
  <data name="ERR_MustHaveRefReturn" xml:space="preserve">
    <value>按值返回只能在按值返回的方法中使用</value>
  </data>
  <data name="ERR_InvalidFwdType" xml:space="preserve">
    <value>指定为 TypeForwardedTo 特性的参数的类型无效</value>
  </data>
  <data name="ERR_DelegateOnConditional" xml:space="preserve">
    <value>无法用“{0}”创建委托，因为它或它重写的方法具有 Conditional 特性</value>
  </data>
  <data name="ERR_DefaultLiteralNotValid" xml:space="preserve">
    <value>在此背景下使用默认文本无效</value>
  </data>
  <data name="ERR_NoImplicitConvCast" xml:space="preserve">
    <value>无法将类型“{0}”隐式转换为“{1}”。存在一个显式转换(是否缺少强制转换?)</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>无法从 {1} 创建分析器 {0} 的实例: {2}。</value>
  </data>
  <data name="WRN_DuplicateUsing_Title" xml:space="preserve">
    <value>using 指令以前在此命名空间中出现过</value>
  </data>
  <data name="WRN_BadXMLRef_Title" xml:space="preserve">
    <value>XML 注释中有无法解析的 cref 特性</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>无法显式引用 "System.Runtime.CompilerServices.TupleElementNamesAttribute"。请使用元组语法指定元组名称。</value>
  </data>
  <data name="WRN_FilterIsConstant_Title" xml:space="preserve">
    <value>筛选器表达式是常量</value>
  </data>
  <data name="WRN_InvalidNumber" xml:space="preserve">
    <value>无效数字</value>
  </data>
  <data name="ERR_BadDelArgCount" xml:space="preserve">
    <value>委托“{0}”未采用 {1} 个参数</value>
  </data>
  <data name="ERR_HidingAbstractMethod" xml:space="preserve">
    <value>“{0}”隐藏继承的抽象成员“{1}”</value>
  </data>
  <data name="ERR_DuplicateTypeParameter" xml:space="preserve">
    <value>重复的类型参数“{0}”</value>
  </data>
  <data name="ERR_EventPropertyInInterface" xml:space="preserve">
    <value>接口中的事件不能具有 add 或 remove 访问器</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAddStr_Title" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法已过时</value>
  </data>
  <data name="WRN_ConflictingChecksum" xml:space="preserve">
    <value>为“{0}”提供了不同的校验和值</value>
  </data>
  <data name="ERR_EventNotDelegate" xml:space="preserve">
    <value>“{0}”: 事件必须是委托类型的</value>
  </data>
  <data name="ERR_EmptyYield" xml:space="preserve">
    <value>yield return 之后应为表达式</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>只在发出 PDB 时才支持 /sourcelink 开关。</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>安全特性的第一个参数必须是有效的 SecurityAction</value>
  </data>
  <data name="ERR_TypeVarNotFoundRangeVariable" xml:space="preserve">
    <value>不能在范围变量声明中使用上下文关键字“var”</value>
  </data>
  <data name="ERR_BadExternIdentifier" xml:space="preserve">
    <value>“/reference”的外部别名无效；“{0}”不是有效的标识符</value>
  </data>
  <data name="WRN_NewOrOverrideExpected_Title" xml:space="preserve">
    <value>成员隐藏继承的成员；缺少关键字 override</value>
  </data>
  <data name="ERR_StructOffsetOnBadStruct" xml:space="preserve">
    <value>FieldOffset 特性只能放置在标记为 StructLayout(LayoutKind.Explicit) 的类型的成员上</value>
  </data>
  <data name="WRN_DuplicateParamTag_Title" xml:space="preserve">
    <value>XML 注释中有重复的 param 标记</value>
  </data>
  <data name="IDS_SK_TYPE" xml:space="preserve">
    <value>类型</value>
  </data>
  <data name="ERR_GenericArgIsStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类型不能用作类型参数</value>
  </data>
  <data name="ERR_ThrowMisplaced" xml:space="preserve">
    <value>此上下文中不允许使用 throw 表达式。</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation" xml:space="preserve">
    <value>应用于形参“{0}”的 CallerLineNumberAttribute 将不起任何作用，因为它适用于不允许指定可选实参的上下文中使用的成员</value>
  </data>
  <data name="ERR_OvlBinaryOperatorExpected" xml:space="preserve">
    <value>应输入可重载的二元运算符</value>
  </data>
  <data name="ERR_ImplicitlyTypedArrayNoBestType" xml:space="preserve">
    <value>找不到隐式类型数组的最佳类型</value>
  </data>
  <data name="XML_InvalidWhitespace" xml:space="preserve">
    <value>此位置不允许使用空格。</value>
  </data>
  <data name="WRN_UnprocessedXMLComment" xml:space="preserve">
    <value>XML 注释没有放在有效语言元素上</value>
  </data>
  <data name="ERR_NegativeStackAllocSize" xml:space="preserve">
    <value>无法对 stackalloc 采用负值大小</value>
  </data>
  <data name="ERR_SwitchNeedsString" xml:space="preserve">
    <value>命令行语法错误:“{1}”选项缺少“{0}”</value>
  </data>
  <data name="ERR_UnsafeNeeded" xml:space="preserve">
    <value>指针和固定大小缓冲区只能在不安全的上下文中使用</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Title" xml:space="preserve">
    <value>仅未命名数组类型不同的重载方法不符合 CLS</value>
  </data>
  <data name="ERR_ErrorBuildingWin32Resources" xml:space="preserve">
    <value>生成 Win32 资源时出错 -- {0}</value>
  </data>
  <data name="ERR_PartialMethodInExpressionTree" xml:space="preserve">
    <value>不能在表达式树中使用只有定义声明的分部方法或已移除的条件方法</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>推断出元组元素名称“{0}”。请使用语言版本 {1} 或更高版本按推断名称访问元素。</value>
  </data>
  <data name="WRN_BadRefCompareRight" xml:space="preserve">
    <value>可能非有意的引用比较；若要获取值比较，请将右边转换为类型“{0}”</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag_Title" xml:space="preserve">
    <value>XML 注释中有重复的 typeparam 标记</value>
  </data>
  <data name="ERR_AssemblyMatchBadVersion" xml:space="preserve">
    <value>标识为“{1}”的程序集“{0}”所使用的“{2}”版本高于所引用的标识为“{4}”的程序集“{3}”</value>
  </data>
  <data name="ERR_HasNoTypeVars" xml:space="preserve">
    <value>非泛型 {1}“{0}”不能与类型参数一起使用</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>程序集名“{0}”保留名称，不能在交互会话中用作引用</value>
  </data>
  <data name="WRN_EqualityOpWithoutEquals_Title" xml:space="preserve">
    <value>类型定义运算符 == 或运算符 !=，但不重写 Object.Equals(object o)</value>
  </data>
  <data name="ERR_CantChangeTypeOnOverride" xml:space="preserve">
    <value>“{0}”: 类型必须是“{2}”才能与重写成员“{1}”匹配</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend" xml:space="preserve">
    <value>在经符号扩展的操作数上使用了按位“或”运算符；请考虑首先强制转换为较小的无符号类型</value>
  </data>
  <data name="ERR_FixedBufferNotFixed" xml:space="preserve">
    <value>不能使用非固定表达式中包含的固定大小缓冲区。请尝试使用 fixed 语句。</value>
  </data>
  <data name="ERR_InvalidAddrOp" xml:space="preserve">
    <value>无法获取给定表达式的地址</value>
  </data>
  <data name="ERR_FeatureNotValidInExpressionTree" xml:space="preserve">
    <value>表达式树不能包含“{0}”</value>
  </data>
  <data name="ERR_DefaultValueUsedWithAttributes" xml:space="preserve">
    <value>不能同时指定默认参数值与 DefaultParameterAttribute 或 OptionalAttribute</value>
  </data>
  <data name="ERR_MissingDeconstruct" xml:space="preserve">
    <value>找不到类型“{0}”适用的 Deconstruct 实例或扩展方法，输出参数为 {1}，返回类型为 void。</value>
  </data>
  <data name="ERR_BadExtensionAgg" xml:space="preserve">
    <value>扩展方法必须在非泛型静态类中定义</value>
  </data>
  <data name="ERR_NotNullConstRefField" xml:space="preserve">
    <value>“{0}”的类型为“{1}”。只能用 Null 对引用类型(字符串除外)的常量字段进行初始化。</value>
  </data>
  <data name="ERR_NewBoundWithVal" xml:space="preserve">
    <value>"new()" 约束不能与 "struct" 约束一起使用</value>
  </data>
  <data name="ERR_VarargsAsync" xml:space="preserve">
    <value>异步方法的参数列表中不允许有 __arglist</value>
  </data>
  <data name="ERR_ExplicitExtension" xml:space="preserve">
    <value>不要使用“System.Runtime.CompilerServices.ExtensionAttribute”。请改用“this”关键字。</value>
  </data>
  <data name="ERR_AddOrRemoveExpected" xml:space="preserve">
    <value>应为 add 访问器或 remove 访问器</value>
  </data>
  <data name="ERR_BadDelegateLeave" xml:space="preserve">
    <value>控制不能离开匿名方法体或 lambda 表达式体</value>
  </data>
  <data name="WRN_ObsoleteOverridingNonObsolete_Title" xml:space="preserve">
    <value>过时成员重写未过时成员</value>
  </data>
  <data name="ERR_ClassBoundNotFirst" xml:space="preserve">
    <value>类类型约束“{0}”必须在其他任何约束之前</value>
  </data>
  <data name="ERR_CantChangeRefReturnOnOverride" xml:space="preserve">
    <value>“{0}”必须{2}按引用返回，才能与重写成员“{1}”匹配</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath_Title" xml:space="preserve">
    <value>CallerFilePathAttribute 将不起任何作用；它由 CallerLineNumberAttribute 重写</value>
  </data>
  <data name="ERR_NameofExtensionMethod" xml:space="preserve">
    <value>扩展方法组不允许作为 "nameof" 的参数。</value>
  </data>
  <data name="ERR_InitializeByValueVariableWithReference" xml:space="preserve">
    <value>无法使用引用初始化按值变量</value>
  </data>
  <data name="ERR_NoSuchMemberOrExtension" xml:space="preserve">
    <value>“{0}”未包含“{1}”的定义，并且找不到可接受第一个“{0}”类型参数的扩展方法“{1}”(是否缺少 using 指令或程序集引用?)</value>
  </data>
  <data name="ERR_TypeArgsNotAllowed" xml:space="preserve">
    <value>{1}“{0}”不能与类型参数一起使用</value>
  </data>
  <data name="ERR_PartialMethodOnlyOneLatent" xml:space="preserve">
    <value>分部方法不能有多个定义声明</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>程序集引用“{0}”无效，无法解析</value>
  </data>
  <data name="ERR_ConstructorInStaticClass" xml:space="preserve">
    <value>静态类不能有实例构造函数</value>
  </data>
  <data name="ERR_BadAwaitArg" xml:space="preserve">
    <value>“await”要求类型 {0} 包含适当的 GetAwaiter 方法</value>
  </data>
  <data name="ERR_MemberReserved" xml:space="preserve">
    <value>类型“{1}”已保留了一个名为“{0}”的具有相同参数类型的成员</value>
  </data>
  <data name="WRN_CLS_BadArgType_Title" xml:space="preserve">
    <value>参数类型不符合 CLS</value>
  </data>
  <data name="ERR_IllegalEscape" xml:space="preserve">
    <value>无法识别的转义序列</value>
  </data>
  <data name="WRN_MissingParamTag_Title" xml:space="preserve">
    <value>参数在 XML 注释中没有匹配的 param 标记(但其他参数有)</value>
  </data>
  <data name="ERR_CycleInInterfaceInheritance" xml:space="preserve">
    <value>继承接口“{1}”在“{0}”的接口层次结构中导致一个循环</value>
  </data>
  <data name="ERR_GlobalSingleTypeNameNotFound" xml:space="preserve">
    <value>未能在全局命名空间中找到类型或命名空间名“{0}”(是否缺少程序集引用?)</value>
  </data>
  <data name="ERR_BadAwaitInCatchFilter" xml:space="preserve">
    <value>无法在 catch 子句的筛选器表达式中等待</value>
  </data>
  <data name="ERR_ArrayInitToNonArrayType" xml:space="preserve">
    <value>只能使用数组初始值设定项表达式为数组类型赋值。请尝试改用 new 表达式。</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableWithNoInitializer" xml:space="preserve">
    <value>隐式类型化的变量必须已初始化</value>
  </data>
  <data name="ERR_TypeParamMustBeIdentifier" xml:space="preserve">
    <value>类型形参声明必须是标识符，不能是类型</value>
  </data>
  <data name="ERR_ProtectedInStruct" xml:space="preserve">
    <value>“{0}”: 结构中已声明新的保护成员</value>
  </data>
  <data name="ERR_ProtectedInStatic" xml:space="preserve">
    <value>“{0}”: 静态类不能包含保护成员</value>
  </data>
  <data name="ERR_InstanceMemberInStaticClass" xml:space="preserve">
    <value>“{0}”: 不能在静态类中声明实例成员</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>可执行文件不能是附属程序集；区域性应始终为空</value>
  </data>
  <data name="ERR_BaseIllegal" xml:space="preserve">
    <value>在此上下文中使用关键字 "base" 无效</value>
  </data>
  <data name="ERR_NoTypeDef" xml:space="preserve">
    <value>类型“{0}”在未引用的程序集中定义。必须添加对程序集“{1}”的引用。</value>
  </data>
  <data name="ERR_ExplicitPropertyAddingAccessor" xml:space="preserve">
    <value>“{0}”添加了接口成员“{1}”中没有的访问器</value>
  </data>
  <data name="ERR_BadSwitch" xml:space="preserve">
    <value>无法识别的选项: “{0}”</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct" xml:space="preserve">
    <value>在具有“SecurityCritical”或“SecuritySafeCritical”特性的接口、类或结构中，不允许使用异步方法。</value>
  </data>
  <data name="ERR_LambdaInIsAs" xml:space="preserve">
    <value>“is”或“as”运算符的第一个操作数不能是 lambda 表达式、匿名方法或方法组。</value>
  </data>
  <data name="ERR_NamedArgumentForArray" xml:space="preserve">
    <value>数组访问可能没有命名参数说明符</value>
  </data>
  <data name="ERR_BadDynamicMethodArgMemgrp" xml:space="preserve">
    <value>无法将方法组用作动态调度的操作的参数。是否要调用该方法?</value>
  </data>
  <data name="ERR_RefReadonly" xml:space="preserve">
    <value>无法将只读字段用作 ref 或 out 值(构造函数中除外)</value>
  </data>
  <data name="InvalidGetDeclarationNameMultipleDeclarators" xml:space="preserve">
    <value>为可能包含多个变量声明符的声明节点调用了 GetDeclarationName。</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed_Description" xml:space="preserve">
    <value>如果具有采用交错数组的重载方法并且方法签名之间的唯一差异是该数组的元素类型时，则会发生此错误。要避免此错误，请考虑使用矩形数组而不是交错数组；使用附加参数区分函数调用；重命名一个或多个重载方法；或是，如果无需符合 CLS，请移除 CLSCompliantAttribute 特性。</value>
  </data>
  <data name="ERR_ImplBadTupleNames" xml:space="preserve">
    <value>方法“{0}”的签名中的元组元素名称必须与接口方法“{1}”的元组元素名称匹配(包括返回类型)。</value>
  </data>
  <data name="ERR_DuplicateAttributeInNetModule" xml:space="preserve">
    <value>“{0}”特性在“{1}”中重复</value>
  </data>
  <data name="IDS_FeatureAsync" xml:space="preserve">
    <value>异步函数</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>无效的调试信息格式: {0}</value>
  </data>
  <data name="WRN_DefaultInSwitch" xml:space="preserve">
    <value>你的意思是使用默认的切换标签(`default:`)而不是 `case default:`? 如果你的意思确实是使用默认文本，请根据需要考虑 `case (default):` 或其他文本(`case 0:` 或 `case null:`)。</value>
  </data>
  <data name="ERR_UnsafeAsyncArgType" xml:space="preserve">
    <value>异步方法不能具有不安全的参数或返回类型</value>
  </data>
  <data name="WRN_NonObsoleteOverridingObsolete_Title" xml:space="preserve">
    <value>成员将重写过时的成员</value>
  </data>
  <data name="ERR_BadAsyncLocalType" xml:space="preserve">
    <value>异步方法不能有按引用局部变量</value>
  </data>
  <data name="ERR_InitializerOnNonAutoProperty" xml:space="preserve">
    <value>只有自动实现的属性才能具有初始值设定项。</value>
  </data>
  <data name="FTL_OutputFileExists" xml:space="preserve">
    <value>包含短文件名“{0}”的长文件名已存在，无法创建同名短文件名</value>
  </data>
  <data name="WRN_WarningDirective" xml:space="preserve">
    <value>#警告:“{0}”</value>
  </data>
  <data name="ERR_StaticNotVirtual" xml:space="preserve">
    <value>静态成员“{0}”不能标记为 override、virtual 或 abstract</value>
  </data>
  <data name="ERR_AssgLvalueExpected" xml:space="preserve">
    <value>赋值号左边必须是变量、属性或索引器</value>
  </data>
  <data name="ERR_OverrideNotNew" xml:space="preserve">
    <value>标记为 override 的成员“{0}”不能标记为 new 或 virtual</value>
  </data>
  <data name="ERR_PartialMethodInconsistentTupleNames" xml:space="preserve">
    <value>两种分部方法声明(“{0}”和“{1}”)都必须使用相同的元组元素名称。</value>
  </data>
  <data name="ERR_RefReturnStructThis" xml:space="preserve">
    <value>结构成员无法按引用返回 "this" 或其他实例成员</value>
  </data>
  <data name="ERR_ReturnExpected" xml:space="preserve">
    <value>“{0}”: 并非所有的代码路径都返回值</value>
  </data>
  <data name="ERR_PatternIsSubsumed" xml:space="preserve">
    <value>switch case 已被上一事例处理。</value>
  </data>
  <data name="ERR_ForwardedTypeIsNested" xml:space="preserve">
    <value>类型“{0}”是“{1}”的嵌套类型，无法转发</value>
  </data>
  <data name="ERR_EndOfPPLineExpected" xml:space="preserve">
    <value>应输入单行注释或行尾</value>
  </data>
  <data name="ERR_DynamicTypeAsBound" xml:space="preserve">
    <value>约束不能为动态类型</value>
  </data>
  <data name="ERR_ParamUnassigned" xml:space="preserve">
    <value>控制离开当前方法之前必须对 out 参数“{0}”赋值</value>
  </data>
  <data name="WRN_DefineIdentifierRequired_Title" xml:space="preserve">
    <value>预处理符号的名称无效；不是有效的标识符</value>
  </data>
  <data name="WRN_LowercaseEllSuffix" xml:space="preserve">
    <value>“l”后缀容易与数字“1”混淆；为清楚起见，请使用“L”</value>
  </data>
  <data name="ERR_ExplicitInterfaceImplementationNotInterface" xml:space="preserve">
    <value>显式接口声明中的“{0}”不是接口</value>
  </data>
  <data name="ERR_CantOverrideBogusMethod" xml:space="preserve">
    <value>“{0}”: 无法重写“{1}”，因为该语言不支持它</value>
  </data>
  <data name="ERR_NonInvocableMemberCalled" xml:space="preserve">
    <value>不可调用的成员“{0}”不能像方法一样使用。</value>
  </data>
  <data name="ERR_RefLvalueExpected" xml:space="preserve">
    <value>ref 或 out 值必须是可以赋值的变量</value>
  </data>
  <data name="SyntaxTreeSemanticModelMust" xml:space="preserve">
    <value>必须提供 SyntaxTreeSemanticModel 才能提供最低程度的类型限定。</value>
  </data>
  <data name="ERR_NoTypeDefFromModule" xml:space="preserve">
    <value>类型“{0}”在未添加的模块中定义。必须添加模块“{1}”。</value>
  </data>
  <data name="ERR_SameFullNameNsAgg" xml:space="preserve">
    <value>“{0}”中的命名空间“{1}”与“{2}”中的类型“{3}”冲突</value>
  </data>
  <data name="ERR_StaticConstParam" xml:space="preserve">
    <value>“{0}”: 静态构造函数必须无参数</value>
  </data>
  <data name="ERR_InAttrOnOutParam" xml:space="preserve">
    <value>out 参数不能具有 In 特性</value>
  </data>
  <data name="IDS_MethodGroup" xml:space="preserve">
    <value>方法组</value>
  </data>
  <data name="WRN_UnassignedInternalField_Title" xml:space="preserve">
    <value>从未对字段赋值，字段将一直保持其默认值</value>
  </data>
  <data name="ERR_BadThisParam" xml:space="preserve">
    <value>方法“{0}”具有一个参数修饰符“this”，该修饰符不在第一个参数上</value>
  </data>
  <data name="XML_StringLiteralNonAsciiQuote" xml:space="preserve">
    <value>不能在字符串周围使用非 ASCII 问号。</value>
  </data>
  <data name="ERR_NoBaseClass" xml:space="preserve">
    <value>"base" 引用需要基类</value>
  </data>
  <data name="ERR_UnexpectedDirective" xml:space="preserve">
    <value>意外的预处理器指令</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnPrivateType" xml:space="preserve">
    <value>“{0}”在此程序集外部不可见，因此不会对它执行 CLS 遵从性检查</value>
  </data>
  <data name="ERR_CantOverrideNonProperty" xml:space="preserve">
    <value>“{0}”: 无法重写，因为“{1}”不是属性</value>
  </data>
  <data name="ERR_PatternWrongGenericTypeInVersion" xml:space="preserve">
    <value>在 C# {2} 中，“{1}”类型的模式无法处理“{0}”类型的表达式。请使用语言版本 {3} 或更高版本。</value>
  </data>
  <data name="WRN_UnreferencedVarAssg" xml:space="preserve">
    <value>变量“{0}”已被赋值，但从未使用过它的值</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>只允许位置 {1} 使用元组元素名称“{0}”。</value>
  </data>
  <data name="ERR_BadMemberProtection" xml:space="preserve">
    <value>多个保护修饰符</value>
  </data>
  <data name="WRN_BadXMLRefSyntax" xml:space="preserve">
    <value>XML 注释中有语法错误的 cref 特性“{0}”</value>
  </data>
  <data name="ERR_BindToBogus" xml:space="preserve">
    <value>现用语言不支持“{0}”</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag_Title" xml:space="preserve">
    <value>XML 注释中有 paramref 标记，但是没有该名称的参数</value>
  </data>
  <data name="ERR_BadAwaitWithoutVoidAsyncMethod" xml:space="preserve">
    <value>"await" 运算符只能用于异步方法中。请考虑用 "async" 修饰符标记此方法，并将其返回类型更改为 "Task"。</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>无法更新“{0}”；特性“{1}”缺失。</value>
  </data>
  <data name="WRN_ProtectedInSealed" xml:space="preserve">
    <value>“{0}”: 在密封类中声明了新的保护成员</value>
  </data>
  <data name="ERR_SwitchFallThrough" xml:space="preserve">
    <value>控制不能从一个 case 标签(“{0}”)贯穿到另一个 case 标签</value>
  </data>
  <data name="ERR_AnonMethToNonDel" xml:space="preserve">
    <value>无法将 {0} 转换为类型“{1}”，原因是它不是委托类型</value>
  </data>
  <data name="ERR_StatementLambdaToExpressionTree" xml:space="preserve">
    <value>无法将具有语句体的 lambda 表达式转换为表达式树</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Microsoft(R) Visual C# 编译器</value>
  </data>
  <data name="ERR_NoExplicitBuiltinConv" xml:space="preserve">
    <value>无法通过引用转换、装箱转换、取消装箱转换、包装转换或 null 类型转换将类型“{0}”转换为“{1}”</value>
  </data>
  <data name="ERR_PtrIndexSingle" xml:space="preserve">
    <value>指针必须只根据一个值进行索引</value>
  </data>
  <data name="WRN_BadWarningNumber_Title" xml:space="preserve">
    <value>不是有效警告编号</value>
  </data>
  <data name="IDS_FeatureRefLocalsReturns" xml:space="preserve">
    <value>byref 局部变量和返回</value>
  </data>
  <data name="ERR_DynamicLocalFunctionParamsParameter" xml:space="preserve">
    <value>不能将具有动态类型的实参传递给本地函数“{1}”的 params 形参“{0}”。</value>
  </data>
  <data name="ERR_InteropMethodWithBody" xml:space="preserve">
    <value>嵌入互操作方法“{0}”包含主体。</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法“{0}”已过时。</value>
  </data>
  <data name="IDS_FeatureDynamic" xml:space="preserve">
    <value>动态</value>
  </data>
  <data name="ERR_VariableUsedBeforeDeclarationAndHidesField" xml:space="preserve">
    <value>本地变量“{0}”在声明之前无法使用。声明该本地变量将隐藏字段“{1}”。</value>
  </data>
  <data name="ERR_PPDefFollowsToken" xml:space="preserve">
    <value>不能在文件的第一个标记之后定义或取消定义预处理器符号</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>无法同时指定编译选项“{0}”和“{1}”。</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="ERR_CheckedOverflow" xml:space="preserve">
    <value>在 checked 模式下，运算在编译时溢出</value>
  </data>
  <data name="IDS_FeatureGlobalNamespace" xml:space="preserve">
    <value>命名空间别名限定符</value>
  </data>
  <data name="ERR_BadEmptyThrow" xml:space="preserve">
    <value>无参数的 throw 语句不允许在 catch 子句之外使用</value>
  </data>
  <data name="WRN_UnreferencedEvent" xml:space="preserve">
    <value>从不使用事件“{0}”</value>
  </data>
  <data name="WRN_UnprocessedXMLComment_Title" xml:space="preserve">
    <value>XML 注释没有放在有效语言元素上</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>写入 XML 文档文件时出错: {0}</value>
  </data>
  <data name="IDS_FeatureGenerics" xml:space="preserve">
    <value>泛型</value>
  </data>
  <data name="WRN_CoClassWithoutComImport" xml:space="preserve">
    <value>“{0}”接口标记为“CoClassAttribute”而不是“ComImportAttribute”</value>
  </data>
  <data name="ERR_RefReadonlyLocal2Cause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，其字段不能用作 ref 或 out 值</value>
  </data>
  <data name="ERR_UseDefViolationProperty" xml:space="preserve">
    <value>使用可能未赋值的自动实现的属性“{0}”</value>
  </data>
  <data name="WRN_UnreferencedField" xml:space="preserve">
    <value>从不使用字段“{0}”</value>
  </data>
  <data name="WRN_UnreferencedLabel" xml:space="preserve">
    <value>这个标签尚未被引用</value>
  </data>
  <data name="ERR_DuplicateNamedAttributeArgument" xml:space="preserve">
    <value>“{0}”重复命名特性参数</value>
  </data>
  <data name="ERR_MethodArgCantBeRefAny" xml:space="preserve">
    <value>无法引用类型为“{0}”的变量</value>
  </data>
  <data name="ERR_BadAwaitWithoutAsync" xml:space="preserve">
    <value>"await" 运算符只能在它包含于标有“async”修饰符的方法或 lambda 表达式中时使用</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleLiteral" xml:space="preserve">
    <value>表达式树不能包含元组文本。</value>
  </data>
  <data name="WRN_ComparisonToSelf_Title" xml:space="preserve">
    <value>对同一变量进行了比较</value>
  </data>
  <data name="ERR_BadDynamicMethodArgDefaultLiteral" xml:space="preserve">
    <value>不能将默认文本用作动态分配操作的自变量。</value>
  </data>
  <data name="ERR_ObjectOrCollectionInitializerWithDelegateCreation" xml:space="preserve">
    <value>对象和集合初始值设定项表达式不能应用于委托创建表达式</value>
  </data>
  <data name="WRN_DuplicateTypeParamTag" xml:space="preserve">
    <value>XML 注释中对“{0}”有重复的 typeparam 标记</value>
  </data>
  <data name="ERR_ConversionWithDerived" xml:space="preserve">
    <value>“{0}”: 不允许进行以派生类为转换源或目标的用户定义转换</value>
  </data>
  <data name="ERR_InvalidSpecifier" xml:space="preserve">
    <value>“{0}”不是有效的格式说明符</value>
  </data>
  <data name="ERR_DuplicateImportSimple" xml:space="preserve">
    <value>已导入具有相同简单名称“{0}”的程序集。请尝试删除这些引用之一(例如“{1}”)，或对它们进行签名以并行启用。</value>
  </data>
  <data name="ERR_BadAwaitInStaticVariableInitializer" xml:space="preserve">
    <value>静态脚本变量初始值设定项中不可使用 "await" 运算符。</value>
  </data>
  <data name="ERR_ExplicitImplCollisionOnRefOut" xml:space="preserve">
    <value>无法使用指定的类型参数继承接口“{0}”，因为它会导致方法“{1}”包含仅在 ref 和 out 上存在不同的重载</value>
  </data>
  <data name="ERR_QueryOuterKey" xml:space="preserve">
    <value>名称“{0}”不在“equals”左侧的范围中。请考虑交换“equals”两侧的表达式。</value>
  </data>
  <data name="ERR_NoConversionForCallerFilePathParam" xml:space="preserve">
    <value>无法应用 CallerFilePathAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase" xml:space="preserve">
    <value>仅大小写不同的标识符“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_BadVisPropertyType" xml:space="preserve">
    <value>可访问性不一致: 属性类型“{1}”的可访问性低于属性“{0}”</value>
  </data>
  <data name="ERR_CantOpenWin32Res" xml:space="preserve">
    <value>打开 Win32 资源文件“{0}”时出错 --“{1}”</value>
  </data>
  <data name="ERR_EmptyFormatSpecifier" xml:space="preserve">
    <value>空格式说明符。</value>
  </data>
  <data name="WRN_BitwiseOrSignExtend_Title" xml:space="preserve">
    <value>对进行了带符号扩展的操作数使用了按位或运算符</value>
  </data>
  <data name="WRN_NubExprIsConstBool_Title" xml:space="preserve">
    <value>由于此类型的值永不等于 "null"，该表达式的结果始终相同</value>
  </data>
  <data name="ERR_UnsupportedTransparentIdentifierAccess" xml:space="preserve">
    <value>针对“{1}”的字段“{0}”的透明标识符成员访问失败。所查询的数据是否实现查询模式?</value>
  </data>
  <data name="ERR_NoConversionForCallerLineNumberParam" xml:space="preserve">
    <value>无法应用 CallerLineNumberAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换</value>
  </data>
  <data name="ERR_ExternAliasNotAllowed" xml:space="preserve">
    <value>“外部别名”在此上下文中无效</value>
  </data>
  <data name="ERR_NoPIANestedType" xml:space="preserve">
    <value>无法嵌入类型“{0}”，因为它是嵌套类型。请考虑将“嵌入互操作类型”属性设置为 false。</value>
  </data>
  <data name="WRN_CLS_NotOnModules2" xml:space="preserve">
    <value>不能在模块上指定与程序集的 CLSCompliant 特性不同的 CLSCompliant 特性</value>
  </data>
  <data name="WRN_ErrorOverride" xml:space="preserve">
    <value>{0}。另请参见错误 CS{1}。</value>
  </data>
  <data name="ERR_BadBaseType" xml:space="preserve">
    <value>无效的基类型</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInAgg" xml:space="preserve">
    <value>类型“{1}”中不存在类型名“{0}”</value>
  </data>
  <data name="IDS_XMLNOINCLUDE" xml:space="preserve">
    <value>未找到下列包含标记的匹配元素 </value>
  </data>
  <data name="ERR_FeatureIsExperimental" xml:space="preserve">
    <value>功能“{0}”是不受支持的实验性功能；使用“/features:{1}”来实现。</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode_Title" xml:space="preserve">
    <value>类型重写 Object.Equals(object o)，但不重写 Object.GetHashCode()</value>
  </data>
  <data name="WRN_GotoCaseShouldConvert_Title" xml:space="preserve">
    <value>"goto case" 值不可隐式转换为开关类型</value>
  </data>
  <data name="WRN_MissingXMLComment_Description" xml:space="preserve">
    <value>指定了 /doc 编译器选项，但是一个或多个构造没有注释。</value>
  </data>
  <data name="ERR_CantOverrideNonVirtual" xml:space="preserve">
    <value>“{0}”: 继承成员“{1}”未标记为 virtual、abstract 或 override，无法进行重写</value>
  </data>
  <data name="ERR_DuplicateParamName" xml:space="preserve">
    <value>参数名“{0}”重复</value>
  </data>
  <data name="ERR_StaticConstructorWithAccessModifiers" xml:space="preserve">
    <value>“{0}”: 静态构造函数中不允许出现访问修饰符</value>
  </data>
  <data name="ERR_UnexpectedUnboundGenericName" xml:space="preserve">
    <value>意外使用了未绑定的通用名称</value>
  </data>
  <data name="ERR_AccessorImplementingMethod" xml:space="preserve">
    <value>访问器“{0}”无法实现类型“{2}”的接口成员“{1}” 请使用显式接口实现。</value>
  </data>
  <data name="ERR_PartialMethodExtensionDifference" xml:space="preserve">
    <value>两个分部方法声明都必须是扩展方法，或者都不能是扩展方法</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>应输入 catch 或 finally</value>
  </data>
  <data name="ERR_BadNewExpr" xml:space="preserve">
    <value>new 表达式要求在类型后有 ()、[] 或 {}</value>
  </data>
  <data name="WRN_UnreferencedVar_Title" xml:space="preserve">
    <value>声明了变量，但从未使用过</value>
  </data>
  <data name="ERR_OpenEndedComment" xml:space="preserve">
    <value>发现文件尾，应输入 "*/"</value>
  </data>
  <data name="CantReferenceCompilationOf" xml:space="preserve">
    <value>无法从 {1} 编译引用类型为“{0}”的编译。</value>
  </data>
  <data name="WRN_NewOrOverrideExpected" xml:space="preserve">
    <value>“{0}”隐藏继承的成员“{1}”。若要使当前成员重写该实现，请添加关键字 override。否则，添加关键字 new。</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberNotPublic" xml:space="preserve">
    <value>“{0}”不实现接口成员“{1}”。“{2}”无法实现接口成员，因为它不是公共的。</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>应为 {0} SemanticModel。</value>
  </data>
  <data name="IDS_FeatureDefault" xml:space="preserve">
    <value>默认运算符</value>
  </data>
  <data name="ERR_ExpressionVariableInQueryClause" xml:space="preserve">
    <value>查询子句中不允许使用 out 变量和 pattern 变量 </value>
  </data>
  <data name="ERR_VoidAssignment" xml:space="preserve">
    <value>可能无法分配类型 "void" 的值。</value>
  </data>
  <data name="IDS_FeatureDefaultLiteral" xml:space="preserve">
    <value>默认文本</value>
  </data>
  <data name="ERR_PatternWrongType" xml:space="preserve">
    <value>“{1}”类型的模式无法处理“{0}”类型的表达式。</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndIcon" xml:space="preserve">
    <value>指定的选项冲突: Win32 资源文件；Win32 图标</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>指定公共签名时，将忽略特性。</value>
  </data>
  <data name="ERR_QueryInnerKey" xml:space="preserve">
    <value>名称“{0}”不在“equals”右侧的范围中。请考虑交换“equals”两侧的表达式。</value>
  </data>
  <data name="ERR_CantChangeTupleNamesOnOverride" xml:space="preserve">
    <value>{0}: 替代继承成员“{1}”时无法更改元组元素名称</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>该程序所使用的用户字符串的合并后长度超出所允许的限制。请尝试减少字符串文本的使用。</value>
  </data>
  <data name="ERR_LbraceExpected" xml:space="preserve">
    <value>应为 {</value>
  </data>
  <data name="WRN_LowercaseEllSuffix_Title" xml:space="preserve">
    <value>"l" 后缀容易与数字 "1" 混淆</value>
  </data>
  <data name="XML_ExpectedEndOfXml" xml:space="preserve">
    <value>此位置出现意外字符。</value>
  </data>
  <data name="XML_ExpectedEndOfTag" xml:space="preserve">
    <value>需要“&gt;”或“/&gt;”来结束标记“{0}”。</value>
  </data>
  <data name="WRN_MissingTypeParamTag_Title" xml:space="preserve">
    <value>类型参数在 XML 注释中没有匹配的 typeparam 标记(但其他类型参数有)</value>
  </data>
  <data name="WRN_GlobalAliasDefn" xml:space="preserve">
    <value>由于 "global::" 总是引用全局命名空间而非别名，因此定义一个名为 "global" 的别名是欠妥的</value>
  </data>
  <data name="WRN_CallerMemberNameParamForUnconsumedLocation" xml:space="preserve">
    <value>应用于形参“{0}”的 CallerMemberNameAttribute 将不起任何作用，因为它适用于不允许指定可选实参的上下文中使用的成员</value>
  </data>
  <data name="ERR_BadAttributeParamType" xml:space="preserve">
    <value>特性构造函数参数“{0}”具有类型“{1}”，这不是有效特性参数类型</value>
  </data>
  <data name="ERR_IllegalVarianceSyntax" xml:space="preserve">
    <value>方差修饰符无效。只有接口和委托类型的参数可以指定为变量。</value>
  </data>
  <data name="WRN_CLS_OverloadRefOut_Title" xml:space="preserve">
    <value>仅 ref 或 out 有区别，或者仅数组秩的重载方法不符合 CLS</value>
  </data>
  <data name="ERR_VolatileStruct" xml:space="preserve">
    <value>“{0}”: 可变字段的类型不能是“{1}”</value>
  </data>
  <data name="ERR_BadStackAllocExpr" xml:space="preserve">
    <value>stackalloc 表达式在类型后要求有 []</value>
  </data>
  <data name="ERR_InvalidAnonymousTypeMemberDeclarator" xml:space="preserve">
    <value>无效的匿名类型成员声明符。匿名类型成员必须使用成员赋值、简单名称或成员访问来声明。</value>
  </data>
  <data name="ERR_VoidInTuple" xml:space="preserve">
    <value>元组不能包含类型为 "void" 的值。</value>
  </data>
  <data name="ERR_OutAttrOnRefParam" xml:space="preserve">
    <value>不能在 ref 参数上仅指定 Out 特性。请同时使用 In 和 Out 特性，或者两者都不使用。</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>源文件“{0}”指定了多次</value>
  </data>
  <data name="ERR_ValueTypePropertyInObjectInitializer" xml:space="preserve">
    <value>无法使用对象初始值设定项为类型为“{1}”的属性“{0}”的成员赋值，因为它是值类型</value>
  </data>
  <data name="ERR_StructWithBaseConstructorCall" xml:space="preserve">
    <value>“{0}”: 结构无法调用基类构造函数</value>
  </data>
  <data name="WRN_PatternIsAmbiguous_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员不明确</value>
  </data>
  <data name="ERR_StackallocInCatchFinally" xml:space="preserve">
    <value>stackalloc 不能用在 catch 或 finally 块中</value>
  </data>
  <data name="XML_StringLiteralNoStartQuote" xml:space="preserve">
    <value>应是字符串，但是找不到左引号。</value>
  </data>
  <data name="ERR_ExternHasBody" xml:space="preserve">
    <value>“{0}”不能是外部的，也无法声明主体</value>
  </data>
  <data name="ERR_InvalidPreprocExpr" xml:space="preserve">
    <value>无效的预处理器表达式</value>
  </data>
  <data name="ERR_ThisInBadContext" xml:space="preserve">
    <value>关键字 "this" 在当前上下文中不可用</value>
  </data>
  <data name="SyntaxTreeFromLoadNoRemoveReplace" xml:space="preserve">
    <value>#load 指令生成了 SyntaxTree“{0}”，并且无法直接移除或替代此 SyntaxTree。</value>
  </data>
  <data name="WRN_IllegalPragma" xml:space="preserve">
    <value>无法识别的 #pragma 指令</value>
  </data>
  <data name="ERR_AnonymousTypeDuplicatePropertyName" xml:space="preserve">
    <value>匿名类型不能有多个同名属性</value>
  </data>
  <data name="ERR_MetadataNameTooLong" xml:space="preserve">
    <value>名称“{0}”超出元数据中允许的最大长度。</value>
  </data>
  <data name="ERR_NoAliasHere" xml:space="preserve">
    <value>“using static”指令不能用于声明别名</value>
  </data>
  <data name="WRN_AssignmentToSelf" xml:space="preserve">
    <value>对同一变量进行赋值；是否希望对其他变量赋值?</value>
  </data>
  <data name="WRN_UnreferencedEvent_Title" xml:space="preserve">
    <value>事件从未使用过</value>
  </data>
  <data name="ERR_BadEventUsageNoField" xml:space="preserve">
    <value>事件“{0}”只能出现在 += 或 -= 的左边</value>
  </data>
  <data name="IDS_XMLBADINCLUDE" xml:space="preserve">
    <value> 包含标记无效 </value>
  </data>
  <data name="ERR_CycleInTypeForwarder" xml:space="preserve">
    <value>程序集“{1}”中类型“{0}”的类型转发器导致循环</value>
  </data>
  <data name="ERR_DuplicateNameInClass" xml:space="preserve">
    <value>类型“{0}”已经包含“{1}”的定义</value>
  </data>
  <data name="ERR_ExpressionTreeContainsOptionalArgument" xml:space="preserve">
    <value>表达式树可能不包含使用可选参数的调用</value>
  </data>
  <data name="FTL_MetadataCantOpenFile" xml:space="preserve">
    <value>无法打开元数据文件“{0}”-- {1}</value>
  </data>
  <data name="WRN_CmpAlwaysFalse" xml:space="preserve">
    <value>与类型为“{0}”的 null 进行比较始终产生“false”</value>
  </data>
  <data name="IDS_FeatureModuleAttrLoc" xml:space="preserve">
    <value>作为特性目标说明符的模块</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches_Description" xml:space="preserve">
    <value>两个接口方法的唯一区别是特定参数是标记为 ref 还是 out 时，可能会生成此警告。最好更改代码以避免此警告，因为运行时调用的方法不明显或不受保证。

虽然 C# 可区分 out 和 ref，但是 CLR 会将它们视为相同的。 决定实现接口的方法时，CLR 只选取一个。

为编译器提供某种方式来区分方法。例如，可以为它们提供不同名称或对其中之一提供附加参数。</value>
  </data>
  <data name="ERR_PPReferenceFollowsToken" xml:space="preserve">
    <value>不能在文件的第一个标记之后使用 #r</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberStatic" xml:space="preserve">
    <value>“{0}”不实现接口成员“{1}”。“{2}”无法实现接口成员，因为它是静态的。</value>
  </data>
  <data name="ERR_InitializeByReferenceVariableWithValue" xml:space="preserve">
    <value>无法使用值初始化按引用变量</value>
  </data>
  <data name="IDS_FeatureNamedArgument" xml:space="preserve">
    <value>命名参数</value>
  </data>
  <data name="WRN_MultiplePredefTypes" xml:space="preserve">
    <value>预定义类型“{0}”是在全局别名的多个程序集中定义的；将使用“{1}”中的定义</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含对按引用返回的方法、属性或索引器的调用</value>
  </data>
  <data name="ERR_PartialMethodInvalidModifier" xml:space="preserve">
    <value>分部方法不能具有访问修饰符或 virtual、abstract、override、new、sealed 或 extern 修饰符</value>
  </data>
  <data name="XML_MissingEqualsAttribute" xml:space="preserve">
    <value>特性与特性值之间缺少等号。</value>
  </data>
  <data name="ERR_DeconstructWrongCardinality" xml:space="preserve">
    <value>无法将“{0}”元素的元组析构为“{1}”变量。</value>
  </data>
  <data name="ERR_UnimplementedAbstractMethod" xml:space="preserve">
    <value>“{0}”不实现继承的抽象成员“{1}”</value>
  </data>
  <data name="ERR_NoNewTyvar" xml:space="preserve">
    <value>变量类型“{0}”没有 new() 约束，因此无法创建该类型的实例</value>
  </data>
  <data name="ERR_RecursivelyTypedVariable" xml:space="preserve">
    <value>无法推理“{0}”类型，因为其初始值设定项直接或间接地引用定义。</value>
  </data>
  <data name="ERR_LoadDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>只允许在脚本中使用 #load</value>
  </data>
  <data name="WRN_CLS_OverloadUnnamed" xml:space="preserve">
    <value>仅未命名数组类型不同的重载方法“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_RefValBoundMustBeFirst" xml:space="preserve">
    <value>"class" 或 "struct" 约束必须在其他任何约束之前</value>
  </data>
  <data name="ERR_BadAttributeArgument" xml:space="preserve">
    <value>特性实参必须是特性形参类型的常量表达式、typeof 表达式或数组创建表达式</value>
  </data>
  <data name="IDS_ThrowExpression" xml:space="preserve">
    <value>&lt;throw 表达式&gt;</value>
  </data>
  <data name="IDS_FeaturePartialTypes" xml:space="preserve">
    <value>分部类型</value>
  </data>
  <data name="GenericParameterDefinition" xml:space="preserve">
    <value>泛型参数是定义，但应是引用 {0}</value>
  </data>
  <data name="ERR_VarInvocationLvalueReserved" xml:space="preserve">
    <value>语法 "var (...)" 作为左值保留。</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine" xml:space="preserve">
    <value>/noconfig 选项是在响应文件中指定的，因此被忽略</value>
  </data>
  <data name="ERR_BadIsPatternExpression" xml:space="preserve">
    <value>用于模式匹配的操作数无效；需要值，但找到的是“{0}”。</value>
  </data>
  <data name="ERR_PropertyCantHaveVoidType" xml:space="preserve">
    <value>“{0}”: 属性或索引器不能具有 void 类型</value>
  </data>
  <data name="ERR_CantOverrideSealed" xml:space="preserve">
    <value>“{0}”: 继承成员“{1}”是密封的，无法进行重写</value>
  </data>
  <data name="ERR_BadIteratorArgType" xml:space="preserve">
    <value>迭代器不能有 ref 或 out 参数</value>
  </data>
  <data name="ERR_IndexedPropertyMustHaveAllOptionalParams" xml:space="preserve">
    <value>索引属性“{0}”的所有参数都必须可选</value>
  </data>
  <data name="ERR_InconsistentLambdaParameterUsage" xml:space="preserve">
    <value>lambda 参数的用法不一致；参数类型必须全部为显式或全部为隐式</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>无法加载分析器程序集</value>
  </data>
  <data name="ERR_DiscardTypeInferenceFailed" xml:space="preserve">
    <value>无法推断隐式类型放弃的类型。</value>
  </data>
  <data name="ERR_NonInterfaceInInterfaceList" xml:space="preserve">
    <value>接口列表中的类型“{0}”不是接口</value>
  </data>
  <data name="IDS_SK_UNKNOWN" xml:space="preserve">
    <value>元素</value>
  </data>
  <data name="ERR_VarargsLast" xml:space="preserve">
    <value>__arglist 参数必须是形参表中的最后一个参数</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIsMatch" xml:space="preserve">
    <value>表达式树不能包含 "is" 模式匹配运算符。</value>
  </data>
  <data name="ERR_AttributesInLocalFuncDecl" xml:space="preserve">
    <value>属性在本地函数参数或类型参数中不被允许</value>
  </data>
  <data name="ERR_AmbigUDConv" xml:space="preserve">
    <value>从“{2}”转换为“{3}”时，用户定义的转换“{0}”和“{1}”具有二义性</value>
  </data>
  <data name="ERR_NewCoClassOnLink" xml:space="preserve">
    <value>无法嵌入互操作类型“{0}”。请改用适用的接口。</value>
  </data>
  <data name="ERR_RefAssignmentMustHaveIdentityConversion" xml:space="preserve">
    <value>表达式必须为“{0}”类型，因为它按引用赋值</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>程序集不包含任何分析器</value>
  </data>
  <data name="WRN_NegativeArrayIndex_Title" xml:space="preserve">
    <value>正在使用负值对数组编制索引</value>
  </data>
  <data name="ERR_RefPropertyCannotHaveSetAccessor" xml:space="preserve">
    <value>按引用返回的属性不能有 set 访问器</value>
  </data>
  <data name="ERR_SwitchNeedsNumber" xml:space="preserve">
    <value>命令行语法错误:“{0}”选项缺少“:&lt;number&gt;”</value>
  </data>
  <data name="ERR_MissingTypeInAssembly" xml:space="preserve">
    <value>对类型“{0}”的引用声称该类型是在“{1}”中定义的，但未能找到</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose" xml:space="preserve">
    <value>对局部变量“{0}”的赋值可能不正确，该变量是 using 或 lock 语句的参数。Dispose 调用或解锁将发生在该局部变量的原始值上。</value>
  </data>
  <data name="ERR_ConversionNotTupleCompatible" xml:space="preserve">
    <value>包含 {0} 个元素的元组不能转换为类型 "{1}"。</value>
  </data>
  <data name="XML_LessThanInAttributeValue" xml:space="preserve">
    <value>不能在特性值中使用字符“&lt;”。</value>
  </data>
  <data name="WRN_IllegalPPChecksum" xml:space="preserve">
    <value>无效的 #pragma checksum 语法；应为 #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX..."</value>
  </data>
  <data name="IDS_Invariantly" xml:space="preserve">
    <value>固定式</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>“{0}”仅用于评估，在将来的更新中可能会被更改或删除。</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>位置不在具有完整范围 {0} 的语法树中</value>
  </data>
  <data name="ERR_ExtensionAttrNotFound" xml:space="preserve">
    <value>无法定义新的扩展方法，因为找不到编译器需要的类型“{0}”。是否缺少对 System.Core.dll 的引用?</value>
  </data>
  <data name="ERR_BadBoolOp" xml:space="preserve">
    <value>为了可以像短路运算符一样应用，用户定义的逻辑运算符(“{0}”)的返回类型和参数类型必须相同</value>
  </data>
  <data name="WRN_ComparisonToSelf" xml:space="preserve">
    <value>对同一变量进行比较；是否希望比较其他变量?</value>
  </data>
  <data name="WRN_CLS_BadIdentifierCase_Title" xml:space="preserve">
    <value>仅大小写不同的标识符不符合 CLS</value>
  </data>
  <data name="ERR_InvalidReal" xml:space="preserve">
    <value>无效的实数。</value>
  </data>
  <data name="ERR_FixedNotNeeded" xml:space="preserve">
    <value>不能使用 fixed 语句来获取已固定的表达式的地址</value>
  </data>
  <data name="WRN_CLS_BadAttributeType" xml:space="preserve">
    <value>“{0}”没有只使用符合 CLS 类型的可访问的构造函数</value>
  </data>
  <data name="ERR_DecConstError" xml:space="preserve">
    <value>计算十进制常量表达式失败</value>
  </data>
  <data name="ERR_DuplicateLabel" xml:space="preserve">
    <value>标签“{0}”重复</value>
  </data>
  <data name="ERR_AssgReadonly" xml:space="preserve">
    <value>无法对只读的字段赋值(构造函数或变量初始值指定项中除外)</value>
  </data>
  <data name="ERR_DuplicateAlias" xml:space="preserve">
    <value>using 别名“{0}”以前在此命名空间中出现过</value>
  </data>
  <data name="ERR_BadArgRef" xml:space="preserve">
    <value>参数 {0} 必须与关键字“{1}”一起传递</value>
  </data>
  <data name="ERR_InvalidNamedArgument" xml:space="preserve">
    <value>命名特性参数“{0}”的值无效</value>
  </data>
  <data name="ERR_DuplicateBound" xml:space="preserve">
    <value>类型参数“{1}”的约束“{0}”重复</value>
  </data>
  <data name="ERR_ReadonlyValueTypeInObjectInitializer" xml:space="preserve">
    <value>无法使用对象初始值设定项为类型为“{1}”的只读字段“{0}”的成员赋值，因为它是值类型</value>
  </data>
  <data name="ERR_BadAsyncLacksBody" xml:space="preserve">
    <value>只能在具有正文的方法中使用 "async" 修饰符。</value>
  </data>
  <data name="ERR_PartialMultipleBases" xml:space="preserve">
    <value>“{0}”的分部声明一定不能指定不同的基类</value>
  </data>
  <data name="ERR_BadAccess" xml:space="preserve">
    <value>“{0}”不可访问，因为它具有一定的保护级别</value>
  </data>
  <data name="ERR_AmbigOverride" xml:space="preserve">
    <value>继承的成员“{0}”和“{1}”在类型“{2}”中具有相同的签名，因此不能重写这些成员</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseIndexer" xml:space="preserve">
    <value>索引器访问需要进行动态调度，但未能如此，因为它是基访问表达式的一般分。请考虑强制转换动态参数或消除基访问。</value>
  </data>
  <data name="ERR_BadArgTypeDynamicExtension" xml:space="preserve">
    <value>“{0}”不具有名为“{1}”的适用方法，但是似乎有该名称的扩展方法。无法动态调度扩展方法。请考虑强制转换动态参数或在不使用扩展方法语法的情况下调用扩展方法。</value>
  </data>
  <data name="ERR_PrivateAbstractAccessor" xml:space="preserve">
    <value>“{0}”: 抽象属性不能具有专用访问器</value>
  </data>
  <data name="WRN_IsAlwaysFalse_Title" xml:space="preserve">
    <value>"is" 表达式的给定表达式始终不是所提供的类型</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>指定版本字符串不符合所需格式 - major.minor.build.revision</value>
  </data>
  <data name="ERR_CantOpenWin32Manifest" xml:space="preserve">
    <value>打开 Win32 清单文件 {0} 时出错 -- {1}</value>
  </data>
  <data name="ERR_NewVirtualInSealed" xml:space="preserve">
    <value>“{0}”是密封类“{1}”中新的虚拟成员</value>
  </data>
  <data name="ERR_ExpressionTreeContainsIndexedProperty" xml:space="preserve">
    <value>表达式树不能包含索引属性</value>
  </data>
  <data name="WRN_IllegalPPChecksum_Title" xml:space="preserve">
    <value>#pragma checksum 语法无效</value>
  </data>
  <data name="LookupOptionsHasInvalidCombo" xml:space="preserve">
    <value>LookupOptions 具有无效的选项组合</value>
  </data>
  <data name="ERR_ArrayInitializerIncorrectLength" xml:space="preserve">
    <value>应为一个长度为“{0}”的数组初始值设定项</value>
  </data>
  <data name="ERR_RefReturnReadonly" xml:space="preserve">
    <value>只读字段无法按引用返回</value>
  </data>
  <data name="ERR_V6SwitchGoverningTypeValueExpected" xml:space="preserve">
    <value>switch 表达式或事例标签必须是 bool、char、string、integral、enum 或 C#6 及更早版本中相应的可以为 null 的类型。</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>必须提供位置才能提供最低程度的类型限定。</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS" xml:space="preserve">
    <value>添加的模块必须用 CLSCompliant 特性标记才能与程序集匹配</value>
  </data>
  <data name="ERR_RefConstraintNotSatisfied" xml:space="preserve">
    <value>类型“{2}”必须是引用类型才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="SubmissionCanOnlyInclude" xml:space="preserve">
    <value>提交只能包含脚本代码。</value>
  </data>
  <data name="ERR_NoGetToOverride" xml:space="preserve">
    <value>“{0}”: 无法重写，因为“{1}”没有可重写的 get 访问器</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch_Title" xml:space="preserve">
    <value>上一个 catch 子句已经捕获了所有异常</value>
  </data>
  <data name="ERR_InterfacesCantContainOperators" xml:space="preserve">
    <value>接口不能包含运算符</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>“{0}”是二进制文件而非文本文件</value>
  </data>
  <data name="ERR_SwitchExpressionValueExpected" xml:space="preserve">
    <value>switch 表达式必须是一个值；找到的是“{0}”。</value>
  </data>
  <data name="ERR_AnonymousTypePropertyAssignedBadValue" xml:space="preserve">
    <value>无法将“{0}”分配给匿名类型属性</value>
  </data>
  <data name="ERR_OverloadRefOutCtor" xml:space="preserve">
    <value>无法定义重载的构造函数“{0}”，因为它与另一构造函数仅在 ref 和 out 上存在不同</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>无法打开“{0}”进行写入 --“{1}”</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement" xml:space="preserve">
    <value>空语句可能有错误</value>
  </data>
  <data name="ERR_PartialMethodToDelegate" xml:space="preserve">
    <value>无法通过方法“{0}”创建委托，因为该方法是没有实现声明的分部方法</value>
  </data>
  <data name="ERR_OverrideFinalizeDeprecated" xml:space="preserve">
    <value>请不要重写 object.Finalize，而是提供一个析构函数。</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedDeOrConstructor" xml:space="preserve">
    <value>表达式主体构造函数和析构函数</value>
  </data>
  <data name="ERR_ExplicitLayoutAndAutoImplementedProperty" xml:space="preserve">
    <value>“{0}”: 自动实现的属性不能在用 StructLayout(LayoutKind.Explicit) 标记的类型内部使用</value>
  </data>
  <data name="ERR_MissingPPFile" xml:space="preserve">
    <value>应是应用的文件名、单行注释或行尾</value>
  </data>
  <data name="WRN_BadXMLRefTypeVar" xml:space="preserve">
    <value>XML 注释中有引用类型参数的 cref 特性“{0}”</value>
  </data>
  <data name="ERR_BadDelegateConstructor" xml:space="preserve">
    <value>委托“{0}”没有有效的构造函数</value>
  </data>
  <data name="ERR_DeconstructTooFewElements" xml:space="preserve">
    <value>析构函数必须包含至少两个变量。</value>
  </data>
  <data name="ERR_ValueTypeExtDelegate" xml:space="preserve">
    <value>不能使用值类型“{1}”上定义的扩展方法“{0}”来创建委托</value>
  </data>
  <data name="ERR_BadVisBaseClass" xml:space="preserve">
    <value>可访问性不一致: 基类“{1}”的可访问性低于类“{0}”</value>
  </data>
  <data name="ERR_InvalidGotoCase" xml:space="preserve">
    <value>goto case 只在 switch 语句中有效</value>
  </data>
  <data name="ERR_ObjectCantHaveBases" xml:space="preserve">
    <value>类 System.Object 不能有基类也不能实现接口</value>
  </data>
  <data name="ERR_CantChangeAccessOnOverride" xml:space="preserve">
    <value>“{0}”: 当重写“{1}”继承成员“{2}”时，无法更改访问修饰符</value>
  </data>
  <data name="ERR_IndexerCantHaveVoidType" xml:space="preserve">
    <value>索引器不能有 void 类型</value>
  </data>
  <data name="ERR_BadVisOpParam" xml:space="preserve">
    <value>可访问性不一致: 参数类型“{1}”的可访问性低于运算符“{0}”</value>
  </data>
  <data name="ERR_ConstValueRequired" xml:space="preserve">
    <value>常量字段要求提供一个值</value>
  </data>
  <data name="ERR_RefReturnReceiver" xml:space="preserve">
    <value>无法按引用返回“{0}”，因为其接收器不能按引用返回</value>
  </data>
  <data name="WRN_BadRestoreNumber" xml:space="preserve">
    <value>“CS{0}”警告已被全局禁用，无法还原</value>
  </data>
  <data name="WRN_FinalizeMethod" xml:space="preserve">
    <value>引入 "Finalize" 方法会妨碍析构函数调用。是否希望声明析构函数?</value>
  </data>
  <data name="ERR_BadIteratorReturnRef" xml:space="preserve">
    <value>“{0}”的主体不能是迭代器块，因为“{0}”按引用返回</value>
  </data>
  <data name="ERR_BadIndexCount" xml:space="preserve">
    <value>[] 内的索引数错误，应为 {0}</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>指定了延迟签名，这需要公钥，但是未指定任何公钥</value>
  </data>
  <data name="ERR_PartialMethodCannotHaveOutParameters" xml:space="preserve">
    <value>分部方法不能有 out 参数</value>
  </data>
  <data name="ERR_InvalidExprTerm" xml:space="preserve">
    <value>表达式项“{0}”无效</value>
  </data>
  <data name="ERR_InvalidPropertyAccessMod" xml:space="preserve">
    <value>“{0}”访问器的可访问性修饰符必须比属性或索引器“{1}”具有更强的限制</value>
  </data>
  <data name="ERR_BadCallerFilePathParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerFilePathAttribute 只能应用于具有默认值的参数</value>
  </data>
  <data name="ERR_NoFileSpec" xml:space="preserve">
    <value>“{0}”选项缺少文件规范</value>
  </data>
  <data name="ERR_ExpectedPPFile" xml:space="preserve">
    <value>应是引用的文件名</value>
  </data>
  <data name="ERR_DuplicateConversionInClass" xml:space="preserve">
    <value>类型“{0}”中有重复的用户定义转换</value>
  </data>
  <data name="ERR_IntegralTypeExpected" xml:space="preserve">
    <value>应输入类型 byte、sbyte、short、ushort、int、uint、long 或 ulong</value>
  </data>
  <data name="ERR_UnexpectedGenericName" xml:space="preserve">
    <value>意外使用了通用名称</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS2" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此“{0}”不需要 CLSCompliant 特性</value>
  </data>
  <data name="ERR_BadCoClassSig" xml:space="preserve">
    <value>接口“{1}”的托管组件类包装器类签名“{0}”不是有效的类名签名</value>
  </data>
  <data name="ERR_SameFullNameAggAgg" xml:space="preserve">
    <value>类型“{1}”同时存在于“{0}”和“{2}”中</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg_Title" xml:space="preserve">
    <value>类型与导入类型冲突</value>
  </data>
  <data name="ERR_EscapedCurly" xml:space="preserve">
    <value>在插补的字符串中，仅可通过加倍“{0}{0}”对“{0}”字符进行转义。</value>
  </data>
  <data name="WRN_InvalidInclude_Title" xml:space="preserve">
    <value>XML 包含元素无效</value>
  </data>
  <data name="WRN_FinalizeMethod_Description" xml:space="preserve">
    <value>创建的类具有签名为 public virtual void Finalize 的方法时，会出现此警告。

如果将这样一个类用作基类，并且如果派生类定义一个析构函数，则该析构函数会重写基类 Finalize 方法，而不是 Finalize。</value>
  </data>
  <data name="ERR_DoNotUseFixedBufferAttr" xml:space="preserve">
    <value>请不要使用 "System.Runtime.CompilerServices.FixedBuffer" 特性。请改用 "fixed" 字段修饰符。</value>
  </data>
  <data name="ERR_NullNotValid" xml:space="preserve">
    <value>在此上下文中使用 null 无效</value>
  </data>
  <data name="ERR_AliasQualAsExpression" xml:space="preserve">
    <value>命名空间别名限定符 "::" 始终解析为类型或命名空间，因此在这里是非法的。请考虑改用 "."。</value>
  </data>
  <data name="ERR_AsWithTypeVar" xml:space="preserve">
    <value>由于类型参数“{0}”既没有类类型约束也没有“class”约束，因此不能与“as”运算符一起使用</value>
  </data>
  <data name="ERR_BaseInStaticMeth" xml:space="preserve">
    <value>关键字“base”在静态方法中不可用</value>
  </data>
  <data name="ERR_MemberCannotBeInitialized" xml:space="preserve">
    <value>成员“{0}”无法初始化。它不是字段或属性。</value>
  </data>
  <data name="ERR_AmbigMember" xml:space="preserve">
    <value>在“{0}”和“{1}”之间具有二义性</value>
  </data>
  <data name="ERR_PartialMethodOnlyMethods" xml:space="preserve">
    <value>只有方法、类、结构或接口才能为分部形式</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>命令行语法错误: 选项“{1}”缺少 Guid</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>引用程序集“{0}”面向的是另一个处理器。</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedBadValue" xml:space="preserve">
    <value>无法将 {0} 赋予隐式类型化的变量</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>写入输出文件时出错: {0}。</value>
  </data>
  <data name="ERR_StaticConstructorWithExplicitConstructorCall" xml:space="preserve">
    <value>“{0}”: 静态构造函数不能具有显式的“this”或“base”构造函数调用</value>
  </data>
  <data name="IDS_LIB_ENV" xml:space="preserve">
    <value>LIB 环境变量</value>
  </data>
  <data name="ERR_MixingWinRTEventWithRegular" xml:space="preserve">
    <value>“{0}”无法实现“{1}”，因为“{2}”是 Windows 运行时事件，“{3}”是常规 .NET 事件。</value>
  </data>
  <data name="WRN_DeprecatedSymbol" xml:space="preserve">
    <value>“{0}”已过时</value>
  </data>
  <data name="ERR_InvalidConstantDeclarationType" xml:space="preserve">
    <value>“{0}”的类型为“{1}”。在常量声明中指定的类型必须为 sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、string、枚举类型或引用类型。</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>指定版本字符串不符合建议格式 - major.minor.build.revision</value>
  </data>
  <data name="WRN_MissingParamTag" xml:space="preserve">
    <value>参数“{0}”在“{1}”的 XML 注释中没有匹配的 param 标记(但其他参数有)</value>
  </data>
  <data name="ERR_IndexedPropertyRequiresParams" xml:space="preserve">
    <value>索引属性“{0}”具有必须提供的非可选参数</value>
  </data>
  <data name="ERR_BadAsyncMethodBuilderTaskProperty" xml:space="preserve">
    <value>对于用作类型“{1}”的 AsyncMethodBuilder 的类型“{0}”，它的任务属性应返回类型“{1}”，而不是类型“{2}”。</value>
  </data>
  <data name="ERR_VolatileAndReadonly" xml:space="preserve">
    <value>“{0}”: 字段不能既是可变的又是只读的</value>
  </data>
  <data name="ERR_EndRegionDirectiveExpected" xml:space="preserve">
    <value>应输入 #endregion 指令</value>
  </data>
  <data name="ERR_DuplicateGeneratedName" xml:space="preserve">
    <value>参数名“{0}”与某个自动生成的参数名冲突</value>
  </data>
  <data name="ERR_NameofMethodGroupWithTypeParameters" xml:space="preserve">
    <value>类型参数不允许在方法组中作为 "nameof" 的参数使用。</value>
  </data>
  <data name="ERR_BadVisDelegateParam" xml:space="preserve">
    <value>可访问性不一致: 参数类型“{1}”的可访问性低于委托“{0}”</value>
  </data>
  <data name="WRN_UnreachableGeneralCatch" xml:space="preserve">
    <value>上一个 catch 子句已捕获所有异常。引发的所有非异常均被包装在 System.Runtime.CompilerServices.RuntimeWrappedException 中。</value>
  </data>
  <data name="IDS_XMLFAILEDINCLUDE" xml:space="preserve">
    <value>未能插入某些或全部所包含的 XML </value>
  </data>
  <data name="ERR_BadAwaitArgIntrinsic" xml:space="preserve">
    <value>无法等待“{0}”</value>
  </data>
  <data name="ERR_MixedDeconstructionUnsupported" xml:space="preserve">
    <value>析构不能在左侧混合声明和表达式。</value>
  </data>
  <data name="ERR_ConstantExpected" xml:space="preserve">
    <value>应输入常量值</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter" xml:space="preserve">
    <value>类型参数“{0}”与外部类型“{1}”中的类型参数同名</value>
  </data>
  <data name="ERR_LiteralDoubleCast" xml:space="preserve">
    <value>无法将 Double 类型隐式转换为“{1}”类型；请使用“{0}”后缀创建此类型</value>
  </data>
  <data name="IDS_CSCHelp" xml:space="preserve">
    <value>
                              Visual C# 编译器选项

                        - 输出文件 -
 /out:&lt;file&gt;                   指定输出文件名称(默认: 具有主类的文件或
                               第一个文件的基名称)
 /target:exe                   生成控制台可执行文件(默认)(缩
                               写: /t:exe)
 /target:winexe                生成 Windows 可执行文件(缩写: 
                               /t:winexe)
 /target:library               生成库(缩写: /t:library)
 /target:module                生成可添加到另一个程序集的
                               模块(缩写: /t:module)
 /target:appcontainerexe       生成 Appcontainer 可执行文件(缩写: 
                               /t:appcontainerexe)
 /target:winmdobj              生成 WinMDExp 使用的
                               Windows 运行时中间文件(缩写: /t:winmdobj)
 /doc:&lt;file&gt;                   要生成的 XML 文档文件
 /refout:&lt;file&gt;                要生成的引用程序集输出
 /platform:&lt;string&gt;            限制此代码可以在其上运行的平台: x86、
                               Itanium、x64、arm、anycpu32bitpreferred 或
                               anycpu。默认平台为 anycpu。

                        - 输入文件 -
 /recurse:&lt;wildcard&gt;           根据通配符规范包括当前目录和
                               子目录中的所有
                               文件
 /reference:&lt;alias &gt;=&lt;file&gt;     使用给定别名从指定程序集
                               引用元数据(缩写: /r)
 /reference:&lt;file list&gt;        从指定程序集文件引用
                               元数据(缩写: /r)
 /addmodule:&lt;file list&gt;        将指定模块链接到此程序集中
 /link:&lt;file list&gt;             嵌入指定互操作程序集文件中的
                               元数据(缩写: /l)
 /analyzer:&lt;file list&gt;         运行此程序集中的分析器
                               (缩写: /a)
 /additionalfile:&lt;file list&gt;   不会直接影响代码生成
                               但可能被分析器用于生成
                               错误或警告的其他文件。
 /embed                        嵌入 PDB 中的所有源文件。
 /embed:&lt;file list&gt;            嵌入 PDB 中的特定文件

                        - 资源 -
 /win32res:&lt;file&gt;              指定 Win32 资源文件(.res)
 /win32icon:&lt;file&gt;             使用此图标输出
 /win32manifest:&lt;file&gt;         指定 Win32 清单文件(.xml)
 /nowin32manifest              不包括默认的 Win32 清单
 /resource:&lt;resinfo&gt;           嵌入指定资源(缩写: /res)
 /linkresource:&lt;resinfo&gt;       将指定资源链接到此程序集
                               (缩写: /linkres)其中 resinfo 的格式
                               是 &lt;文件&gt;[,&lt;字符串名称&gt;[,public|private]]

                        - 代码生成 -
 /debug[+|-]                   发出调试信息
 /debug:{full|pdbonly|portable|embedded}
                               指定调试类型(默认为 "full"，
                               "portable" 为跨平台格式，
                               "embedded" 为嵌入目标 .dll 或 .exe 的
                               跨平台格式)
 /optimize[+|-]                启用优化(缩写: /o)
 /deterministic                生成确定性的程序集
                               (包括模块版本 GUID 和时间戳)
 /refonly                      生成引用程序集来替换主要输出
 /instrument:TestCoverage      生成对其检测以收集覆盖率信息的
                               程序集
 /sourcelink:&lt;file&gt;            要嵌入到可移植 PDB 中的源链接。

                        - 错误和警告 -
 /warnaserror[+|-]             将所有警告报告为错误
 /warnaserror[+|-]:&lt;warn list&gt; 将特定警告报告为错误
 /warn:&lt;n&gt;                     设置警告级别(0-4)(缩写: /w)
 /nowarn:&lt;warn list&gt;           禁用特定警告消息
 /ruleset:&lt;file&gt;               指定禁用特定诊断的
                               规则集文件。
 /errorlog:&lt;file&gt;              指定用于记录所有编译器和分析器诊断的
                               文件。
 /reportanalyzer               报告其他分析器信息，如
                               执行时间。
 
                        - 语言 -
 /checked[+|-]                 生成溢出检查
 /unsafe[+|-]                  允许 "unsafe" 代码
 /define:&lt;symbol list&gt;         定义条件编译符号(缩 
                               写: /d)
 /langversion:&lt;string&gt;         指定语言版本模式: ISO-1、ISO-2、3、
                               4、5、6、7、7.1、默认或最新模式

                        - 安全 -
 /delaysign[+|-]               仅使用强名称密钥的公共部分对程序集
                               进行延迟签名
 /publicsign[+|-]              仅使用强名称密钥的公共部分对程序集
                               进行公共签名
 /keyfile:&lt;file&gt;               指定强名称密钥文件
 /keycontainer:&lt;string&gt;        指定强名称密钥容器
 /highentropyva[+|-]           启用高平均信息量 ASLR

                        - 杂项 -
 @&lt;file&gt;                       读取响应文件以获取更多选项
 /help                         显示此用法消息(缩写: /?)
 /nologo                       取消显示编译器版权消息
 /noconfig                     不自动包括 CSC.RSP 文件
 /parallel[+|-]                并发生成。
 /version                      显示编译器版本号并退出。

                        - 高级 -
 /baseaddress:&lt;address&gt;        要生成的库的基址
 /checksumalgorithm:&lt;alg&gt;      指定计算存储在 PDB 中的源文件
                               校验和的算法。支持的值是:
                               SHA1 (默认)或 SHA256。
 /codepage:&lt;n&gt;                 指定打开源文件时要使用的
                               代码页
 /utf8output                   以 UTF-8 编码格式输出编译器消息
 /main:&lt;type&gt;                  指定包含入口点的类型
                               (忽略所有其他可能的入口点)(缩 
                               写: /m)
 /fullpaths                    编译器生成完全限定路径
 /filealign:&lt;n&gt;                指定用于输出文件节的
                               对齐方式
 /pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                               通过编译器指定源路径名称输出的
                               映射。
 /pdb:&lt;file&gt;                   指定调试信息文件名称(默认: 
                               具有 .pdb 扩展名的输出文件名)
 /errorendlocation             输出每个错误的结束位置
                               行和列
 /preferreduilang              指定首选输出语言名称。
 /nostdlib[+|-]                不引用标准库(mscorlib.dll)
 /subsystemversion:&lt;string&gt;    指定此程序集的子系统版本
 /lib:&lt;file list&gt;              指定要在其中搜索引用的附加
                               目录
 /errorreport:&lt;string&gt;         指定如何处理内部编译器错误:
                               prompt、send、queue 或 none。默认为
                               queue。
 /appconfig:&lt;file&gt;             指定包含程序集绑定设置的
                               应用程序配置文件
 /moduleassemblyname:&lt;string&gt;  此模块所属程序集
                               的名称
 /modulename:&lt;string&gt;          指定源模块的名称
</value>
  </data>
  <data name="ERR_ValueExpected" xml:space="preserve">
    <value>语法错误，应为值</value>
  </data>
  <data name="ERR_SealedNonOverride" xml:space="preserve">
    <value>因为“{0}”不是重写，所以无法将其密封</value>
  </data>
  <data name="ERR_ErrorDirective" xml:space="preserve">
    <value>#错误:“{0}”</value>
  </data>
  <data name="ERR_QueryDuplicateRangeVariable" xml:space="preserve">
    <value>已声明范围变量“{0}”</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>在 AssemblySignatureKeyAttribute 中指定的签名公钥无效。</value>
  </data>
  <data name="ERR_OverloadRefOut" xml:space="preserve">
    <value>“{0}”无法定义仅在 ref 和 out 上存在不同的重载方法</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>由于目标类型“{1}”指定了其他名称或未指定名称，因此元组元素名称“{0}”被忽略。</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Description" xml:space="preserve">
    <value>尝试对从 MarshalByRefObject 派生的类的成员调用方法、属性或索引器，并且成员具有值类型时，会出现此警告。从 MarshalByRefObject 继承的对象通常旨在跨应用程序域进行引用封送。如果任何代码尝试跨应用程序域直接访问这样一个对象的值类型成员，则会出现运行时异常。要解决该警告，请先将成员复制到本地变量中，然后对该变量调用方法。</value>
  </data>
  <data name="ERR_InconsistentIndexerNames" xml:space="preserve">
    <value>两个索引器的名称不同；在类型中的每个索引器上的 IndexerName 特性都必须使用相同的名称</value>
  </data>
  <data name="ERR_BadAwaiterPattern" xml:space="preserve">
    <value>“await”要求“{1}.GetAwaiter()”的返回类型“{0}”包含适当的 IsCompleted、OnCompleted 和 GetResult 成员，并实现 INotifyCompletion 或 ICriticalNotifyCompletion</value>
  </data>
  <data name="ERR_AmbigContext" xml:space="preserve">
    <value>“{0}”是“{1}”和“{2}”之间的不明确的引用</value>
  </data>
  <data name="ERR_ParamsCantBeRefOut" xml:space="preserve">
    <value>params 参数不能声明为 ref 或 out</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Title" xml:space="preserve">
    <value>选项重写源文件或添加的模块中给出的特性</value>
  </data>
  <data name="ERR_PartialMethodMustReturnVoid" xml:space="preserve">
    <value>分部方法必须具有 void 返回类型</value>
  </data>
  <data name="ERR_CircularBase" xml:space="preserve">
    <value>涉及“{0}”和“{1}”的循环基类依赖项</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected_Title" xml:space="preserve">
    <value>应为标识符或数字参数</value>
  </data>
  <data name="ERR_NoImplicitConv" xml:space="preserve">
    <value>无法将类型“{0}”隐式转换为“{1}”</value>
  </data>
  <data name="WRN_FailedInclude_Title" xml:space="preserve">
    <value>无法包括 XML 段落。</value>
  </data>
  <data name="ERR_InterfaceEventInitializer" xml:space="preserve">
    <value>“{0}”: 接口中的事件不能有初始值设定项</value>
  </data>
  <data name="ERR_RecursiveConstructorCall" xml:space="preserve">
    <value>构造函数“{0}”不能调用自身</value>
  </data>
  <data name="ERR_SingleLineCommentInExpressionHole" xml:space="preserve">
    <value>单行无法用于插补的字符串。</value>
  </data>
  <data name="ERR_LocalDuplicate" xml:space="preserve">
    <value>已在此范围定义了名为“{0}”的局部变量或函数</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin_Description" xml:space="preserve">
    <value>两个程序集的版本和/或版本号不同。为进行统一，必须在应用程序的 .config 文件中指定指令，并且必须提供程序集的正确强名称。</value>
  </data>
  <data name="ERR_ReturnNotLValue" xml:space="preserve">
    <value>无法修改“{0}”的返回值，因为它不是变量</value>
  </data>
  <data name="WRN_CLS_BadBase" xml:space="preserve">
    <value>“{0}”: 基类型“{1}”不符合 CLS</value>
  </data>
  <data name="ERR_AssgReadonlyLocal" xml:space="preserve">
    <value>无法为“{0}”赋值，因为它是只读的</value>
  </data>
  <data name="ERR_BadParamType" xml:space="preserve">
    <value>参数 {0} 声明为类型“{1}{2}”，但它应为“{3}{4}”</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>读取为 PermissionSet 特性的命名参数“{1}”指定的文件“{0}”时出错:“{2}”</value>
  </data>
  <data name="ERR_DuplicateConstraintClause" xml:space="preserve">
    <value>已经为类型参数“{0}”指定了 constraint 子句。必须在单个 where 子句中指定类型参数的所有约束。</value>
  </data>
  <data name="ERR_BadAwaitArgVoidCall" xml:space="preserve">
    <value>无法等待“void”</value>
  </data>
  <data name="ERR_RefReturnLocal" xml:space="preserve">
    <value>局部变量“{0}”不是 ref 局部变量，无法按引用返回</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBaseCtor" xml:space="preserve">
    <value>构造函数调用需要进行动态调度，但无法如此，因为它是构造函数初始值的一部分。请考虑强制转换动态参数。</value>
  </data>
  <data name="ERR_RefReturnCall2" xml:space="preserve">
    <value>无法按引用返回“{0}”的结果的成员，因为传递给形式参数“{1}”的实际参数不能按引用返回</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedOutVariable" xml:space="preserve">
    <value>无法推断出隐式类型化 out 变量“{0}”的类型。</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttribute" xml:space="preserve">
    <value>无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性。</value>
  </data>
  <data name="IDS_FeatureObjectInitializer" xml:space="preserve">
    <value>对象初始值设定项</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableMultipleDeclarator" xml:space="preserve">
    <value>隐式类型化的变量不能有多个声明符</value>
  </data>
  <data name="ERR_NamespaceUnexpected" xml:space="preserve">
    <value>命名空间不能直接包含字段或方法之类的成员</value>
  </data>
  <data name="ERR_BadModifierLocation" xml:space="preserve">
    <value>成员修饰符“{0}”必须位于成员类型和名称之前</value>
  </data>
  <data name="ERR_RbraceExpected" xml:space="preserve">
    <value>应输入 }</value>
  </data>
  <data name="WRN_EmptySwitch_Title" xml:space="preserve">
    <value>空的 switch 块</value>
  </data>
  <data name="ERR_NamedArgumentExpected" xml:space="preserve">
    <value>应为命名特性参数</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>参数具有多个不同的默认值。</value>
  </data>
  <data name="ERR_DefaultValueBadValueType" xml:space="preserve">
    <value>“{0}”类型的参数不适用于 DefaultParameterValue 特性</value>
  </data>
  <data name="ERR_ConversionNotInvolvingContainedType" xml:space="preserve">
    <value>用户定义的转换必须是转换成封闭类型，或者从封闭类型转换</value>
  </data>
  <data name="ERR_StructLayoutCycle" xml:space="preserve">
    <value>“{1}”类型的结构成员“{0}”在结构布局中导致循环</value>
  </data>
  <data name="WRN_CLS_BadTypeVar_Title" xml:space="preserve">
    <value>约束类型不符合 CLS</value>
  </data>
  <data name="ERR_AbstractAttributeClass" xml:space="preserve">
    <value>无法应用特性类“{0}”，因为它是抽象的</value>
  </data>
  <data name="ERR_ConcreteMissingBody" xml:space="preserve">
    <value>“{0}”必须声明主体，因为它未标记为 abstract、extern 或 partial</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>检测到无法访问的代码</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>此异步方法缺少 "await" 运算符，将以同步方式运行。请考虑使用 "await" 运算符等待非阻止的 API 调用，或者使用 "await Task.Run(...)" 在后台线程上执行占用大量 CPU 的工作。</value>
  </data>
  <data name="ERR_QueryRangeVariableSameAsTypeParam" xml:space="preserve">
    <value>范围变量“{0}”的名称不能与方法类型参数相同</value>
  </data>
  <data name="ERR_NoConstructors" xml:space="preserve">
    <value>类型“{0}”未定义构造函数</value>
  </data>
  <data name="IDS_AnonMethod" xml:space="preserve">
    <value>匿名方法</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>需要一个脚本 (.csx file) 文件，但并未指定</value>
  </data>
  <data name="IDS_FeatureNullable" xml:space="preserve">
    <value>可以为 null 的类型</value>
  </data>
  <data name="WRN_NoConfigNotOnCommandLine_Title" xml:space="preserve">
    <value>/noconfig 选项是在响应文件中指定的，因此被忽略</value>
  </data>
  <data name="ERR_DeconstructionVarFormDisallowsSpecificType" xml:space="preserve">
    <value>析构函数 "var (...)" 窗体驳回 "var" 的特定类型。</value>
  </data>
  <data name="ERR_InvalidLineNumber" xml:space="preserve">
    <value>为 #line 指令指定的行号缺少或无效</value>
  </data>
  <data name="IDS_XMLIGNORED2" xml:space="preserve">
    <value> 无法包括格式错误的 XML 文件“{0}” </value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>无法加载分析器程序集 {0}: {1}</value>
  </data>
  <data name="ERR_OperatorsMustBeStatic" xml:space="preserve">
    <value>用户定义的运算符“{0}”必须声明为 static 和 public</value>
  </data>
  <data name="ERR_BadOperatorSyntax" xml:space="preserve">
    <value>声明无效；请改用“{0} operator &lt;dest-type&gt; (...”</value>
  </data>
  <data name="ERR_ReturnTypeIsStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类型不能用作返回类型</value>
  </data>
  <data name="ERR_ExplicitImplParams" xml:space="preserve">
    <value>由于“{1}”没有 params 数组，因此“{0}”也不应当有 params 参数</value>
  </data>
  <data name="ERR_CantMakeTempFile" xml:space="preserve">
    <value>无法创建临时文件 -- {0}</value>
  </data>
  <data name="ERR_BadNamedArgument" xml:space="preserve">
    <value>“{0}”的最佳重载没有名为“{1}”的参数</value>
  </data>
  <data name="ERR_TypeVariableSameAsParent" xml:space="preserve">
    <value>类型参数“{0}”与包含类型或方法同名</value>
  </data>
  <data name="WRN_NewRequired_Title" xml:space="preserve">
    <value>成员隐藏继承的成员；缺少关键字 new</value>
  </data>
  <data name="ERR_PartialMethodOnlyInPartialClass" xml:space="preserve">
    <value>分部方法必须在分部类或分部结构内声明</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs" xml:space="preserve">
    <value>“{0}”中的类型“{1}”与“{2}”中的导入命令空间“{3}”冲突。请使用“{0}”中定义的类型。</value>
  </data>
  <data name="WRN_SameFullNameThisNsAgg" xml:space="preserve">
    <value>“{0}”中的命名空间“{1}”与“{2}”中的导入类型“{3}”冲突。请使用“{0}”中定义的命名空间。</value>
  </data>
  <data name="ERR_BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>集合初始值设定项的最佳重载 Add 方法“{0}”具有一些无效参数</value>
  </data>
  <data name="ERR_MissingArraySize" xml:space="preserve">
    <value>数组创建必须有数组大小或数组初始值设定项</value>
  </data>
  <data name="WRN_MissingTypeParamTag" xml:space="preserve">
    <value>类型参数“{0}”在“{1}”的 XML 注释中没有匹配的 typeparam 标记(但其他类型参数有)</value>
  </data>
  <data name="WRN_IncorrectBooleanAssg" xml:space="preserve">
    <value>条件表达式中的赋值总是常量；是否希望使用 "==" 而非 "="?</value>
  </data>
  <data name="ERR_AttributeCantBeGeneric" xml:space="preserve">
    <value>无法应用特性类“{0}”，因为它是泛型的</value>
  </data>
  <data name="ERR_CantSetWin32Manifest" xml:space="preserve">
    <value>读取 Win32 清单文件“{0}”时出错 --“{1}”</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>来自模块“{1}”的特性“{0}”将忽略，以便支持源中出现的实例</value>
  </data>
  <data name="ERR_QueryRangeVariableAssignedBadValue" xml:space="preserve">
    <value>无法将 {0} 赋给范围变量</value>
  </data>
  <data name="ERR_ParamsLast" xml:space="preserve">
    <value>params 参数必须是形参表中的最后一个参数</value>
  </data>
  <data name="ERR_BadEmptyThrowInFinally" xml:space="preserve">
    <value>在嵌套在最近的封闭 catch 子句内部的 finally 子句内不允许使用不带参数的 throw 语句</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>元组必须包含至少两个元素。</value>
  </data>
  <data name="ERR_BadTypeArgument" xml:space="preserve">
    <value>类型“{0}”不能用作类型参数</value>
  </data>
  <data name="ERR_InteropTypeMissingAttribute" xml:space="preserve">
    <value>无法嵌入互操作类型“{0}”，因为它缺少必需的“{1}”特性。</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequiredLambda" xml:space="preserve">
    <value>转换为“Task”返回委托的异步 lambda 表达式不能返回值。是否要返回“Task&lt;T&gt;”?</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>语言名“{0}”无效。</value>
  </data>
  <data name="ERR_MultiTypeInDeclaration" xml:space="preserve">
    <value>在 for、using、fixed 或声明语句中不能使用多个类型</value>
  </data>
  <data name="ERR_QueryRangeVariableReadOnly" xml:space="preserve">
    <value>无法对范围变量“{0}”赋值 -- 它是只读的</value>
  </data>
  <data name="ERR_BadCtorArgCount" xml:space="preserve">
    <value>“{0}”不包含采用 {1} 个参数的构造函数</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>程序集区域性字符串可能不包含嵌入式 NUL 字符。</value>
  </data>
  <data name="ERR_AddrOnReadOnlyLocal" xml:space="preserve">
    <value>无法获得只读局部变量的地址</value>
  </data>
  <data name="ERR_PatternNullableType" xml:space="preserve">
    <value>在模式中使用可以为 null 的类型“{0}”是非法的；请改用基础类型“{1}”。</value>
  </data>
  <data name="ERR_PartialMethodParamsDifference" xml:space="preserve">
    <value>两种分部方法声明必须要么都使用 params 参数，要么都不使用 params 参数</value>
  </data>
  <data name="ERR_InterfaceMemberNotFound" xml:space="preserve">
    <value>显式接口声明中的“{0}”不是接口成员</value>
  </data>
  <data name="WRN_SameFullNameThisAggAgg" xml:space="preserve">
    <value>“{0}”中的类型“{1}”与“{2}”中的导入类型“{3}”冲突。请使用“{0}”中定义的类型。</value>
  </data>
  <data name="ERR_ArrayElementCantBeRefAny" xml:space="preserve">
    <value>数组元素不能是“{0}”类型</value>
  </data>
  <data name="ERR_NoModifiersOnAccessor" xml:space="preserve">
    <value>修饰符不能放置在事件访问器声明上</value>
  </data>
  <data name="ERR_BaseClassMustBeFirst" xml:space="preserve">
    <value>基类“{0}”必须在任何接口之前</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>指定了冲突的选项: Win32 资源文件；Win32 清单</value>
  </data>
  <data name="ERR_UnsafeIteratorArgType" xml:space="preserve">
    <value>迭代器不能有不安全的参数或 yield 类型</value>
  </data>
  <data name="ERR_NoConversionForCallerMemberNameParam" xml:space="preserve">
    <value>无法应用 CallerMemberNameAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换</value>
  </data>
  <data name="ERR_RefReturnParameter2" xml:space="preserve">
    <value>参数“{0}”不是 ref 或 out 参数，无法按引用返回其成员</value>
  </data>
  <data name="IDS_RELATEDERROR" xml:space="preserve">
    <value>(与前一个错误相关的符号位置)</value>
  </data>
  <data name="ERR_BadYieldInCatch" xml:space="preserve">
    <value>无法在 catch 子句体中生成值</value>
  </data>
  <data name="ERR_BadAsyncReturnExpression" xml:space="preserve">
    <value>这是一个异步方法，因此返回表达式的类型必须为“{0}”而不是“Task&lt;{0}&gt;”</value>
  </data>
  <data name="ERR_SemiOrLBraceExpected" xml:space="preserve">
    <value>应为 { 或 ;</value>
  </data>
  <data name="ERR_ThisInStaticMeth" xml:space="preserve">
    <value>关键字 "this" 在静态属性、静态方法或静态字段初始值设定项中无效</value>
  </data>
  <data name="IDS_FeatureOptionalParameter" xml:space="preserve">
    <value>可选参数</value>
  </data>
  <data name="WRN_InvalidSearchPathDir_Title" xml:space="preserve">
    <value>指定的搜索路径无效</value>
  </data>
  <data name="ERR_RefReturnCall" xml:space="preserve">
    <value>无法按引用返回“{0}”的结果，因为传递给形式参数“{1}”的实际参数不能按引用返回</value>
  </data>
  <data name="ERR_NoCanonicalView" xml:space="preserve">
    <value>找不到与嵌入互操作类型“{0}”相匹配的互操作类型。是否缺少程序集引用?</value>
  </data>
  <data name="WRN_CmdOptionConflictsSource_Description" xml:space="preserve">
    <value>如果源中出现的程序集特性 AssemblyKeyFileAttribute 或 AssemblyKeyNameAttribute 与 /keyfile 或 /keycontainer 命令行选项或是“项目属性”中指定的密钥文件名或密钥容器冲突，则会出现此警告。</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Description" xml:space="preserve">
    <value>此警告指示特性(如 InternalsVisibleToAttribute)未正确指定。</value>
  </data>
  <data name="ERR_ByReferenceVariableMustBeInitialized" xml:space="preserve">
    <value>按引用变量的声明必须有初始值设定项</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>"MethodImplOptions.Synchronized" 不能应用于异步方法</value>
  </data>
  <data name="ERR_RefReturnParameter" xml:space="preserve">
    <value>无法按引用“{0}”返回参数，因为它不是 ref 或 out 参数</value>
  </data>
  <data name="ERR_NoNamespacePrivate" xml:space="preserve">
    <value>命名空间中定义的元素无法显式声明为 private、protected 或 protected internal</value>
  </data>
  <data name="ERR_AssemblyNameOnNonModule" xml:space="preserve">
    <value>只有在生成 "module" 目标类型时才能指定 /moduleassemblyname 选项</value>
  </data>
  <data name="ERR_BaseConstraintConflict" xml:space="preserve">
    <value>类型参数“{0}”继承了彼此冲突的“{1}”和“{2}”约束</value>
  </data>
  <data name="ERR_ResourceNotUnique" xml:space="preserve">
    <value>此程序集中已使用了资源标识符“{0}”</value>
  </data>
  <data name="ERR_DefaultValueMustBeConstant" xml:space="preserve">
    <value>“{0}”的默认参数值必须是编译时常量</value>
  </data>
  <data name="ERR_NoEntryPoint" xml:space="preserve">
    <value>程序不包含适合于入口点的静态 "Main" 方法</value>
  </data>
  <data name="WRN_MultiplePredefTypes_Description" xml:space="preserve">
    <value>在两个程序集中找到预定义系统类型(如 System.Int32)时会发生此错误。可能发生这种情况的一种方式是从两个不同位置引用 mscorlib 或 System.Runtime.dll (如尝试并行运行两个版本的 .NET Framework)。</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal2" xml:space="preserve">
    <value>“{0}”已初始化为不能按引用返回的值，因此无法按引用返回其成员</value>
  </data>
  <data name="WRN_CLS_NoVarArgs_Title" xml:space="preserve">
    <value>带有变量参数的方法不符合 CLS</value>
  </data>
  <data name="UseLiteralForNumeric" xml:space="preserve">
    <value>使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal 可创建数字文本标记。</value>
  </data>
  <data name="ERR_PartialMethodStaticDifference" xml:space="preserve">
    <value>两个分部方法声明必须都是静态声明，或者两者都不能是静态声明</value>
  </data>
  <data name="ERR_LockNeedsReference" xml:space="preserve">
    <value>“{0}”不是 lock 语句要求的引用类型</value>
  </data>
  <data name="ERR_RefReturnReadonlyStatic" xml:space="preserve">
    <value>静态只读字段无法按引用返回</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember_Title" xml:space="preserve">
    <value>符合 CLS 的接口必须仅有符合 CLS 的成员</value>
  </data>
  <data name="WRN_CLS_ModuleMissingCLS_Title" xml:space="preserve">
    <value>添加的模块必须用 CLSCompliant 特性标记才能与程序集匹配</value>
  </data>
  <data name="ERR_LocalSameNameAsTypeParam" xml:space="preserve">
    <value>“{0}”: 参数、局部变量或本地函数不能与方法类型参数同名</value>
  </data>
  <data name="WRN_CLS_BadReturnType_Title" xml:space="preserve">
    <value>返回类型不符合 CLS</value>
  </data>
  <data name="ERR_CantOpenIcon" xml:space="preserve">
    <value>打开图标文件 {0} 时出错 -- {1}</value>
  </data>
  <data name="SyntaxTreeNotFoundTo" xml:space="preserve">
    <value>未找到要删除的 SyntaxTree“{0}”。</value>
  </data>
  <data name="ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable" xml:space="preserve">
    <value>无法推断隐式类型的解构变量“{0}”的类型。</value>
  </data>
  <data name="ERR_OverrideWithConstraints" xml:space="preserve">
    <value>重写和显式接口实现方法的约束是从基方法继承的，因此不能直接指定这些约束</value>
  </data>
  <data name="WRN_FileNameTooLong_Title" xml:space="preserve">
    <value>为预处理器指令指定的文件名无效</value>
  </data>
  <data name="ERR_UnescapedCurly" xml:space="preserve">
    <value>在插补的字符串中，必需对“{0}”字符进行转义(通过加倍)。</value>
  </data>
  <data name="IDS_FeatureExtensionMethod" xml:space="preserve">
    <value>扩展方法</value>
  </data>
  <data name="ERR_ExpressionHasNoName" xml:space="preserve">
    <value>表达式不具有名称。</value>
  </data>
  <data name="FTL_DebugEmitFailure" xml:space="preserve">
    <value>写入调试信息时出错 --“{0}”</value>
  </data>
  <data name="CompilationC" xml:space="preserve">
    <value>编译(C#): </value>
  </data>
  <data name="WRN_CLS_BadFieldPropType_Title" xml:space="preserve">
    <value>类型不符合 CLS</value>
  </data>
  <data name="ERR_ConvertToStaticClass" xml:space="preserve">
    <value>无法转换为静态类型“{0}”</value>
  </data>
  <data name="WRN_CLS_BadAttributeType_Title" xml:space="preserve">
    <value>类型没有只使用符合 CLS 类型的可访问的构造函数</value>
  </data>
  <data name="WRN_CLS_IllegalTrueInFalse" xml:space="preserve">
    <value>“{0}”是不符合 CLS 的类型“{1}”的成员，因此不能将其标记为符合 CLS</value>
  </data>
  <data name="IDS_FeatureAnonymousTypes" xml:space="preserve">
    <value>匿名类型</value>
  </data>
  <data name="ERR_StaticConstant" xml:space="preserve">
    <value>常量“{0}”不能标记为 static</value>
  </data>
  <data name="ERR_PropertyLacksGet" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为它缺少 get 访问器</value>
  </data>
  <data name="ERR_LanguageVersionCannotHaveLeadingZeroes" xml:space="preserve">
    <value>指定的语言版本“{0}”不能含前导零</value>
  </data>
  <data name="ERR_OpenResponseFile" xml:space="preserve">
    <value>打开响应文件“{0}”时出错</value>
  </data>
  <data name="WRN_DeprecatedCollectionInitAdd_Title" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法已过时</value>
  </data>
  <data name="ERR_BadVisOpReturn" xml:space="preserve">
    <value>可访问性不一致: 返回类型“{1}”的可访问性低于运算符“{0}”</value>
  </data>
  <data name="HDN_UnusedExternAlias" xml:space="preserve">
    <value>未使用的外部别名。</value>
  </data>
  <data name="ERR_ImplicitlyTypedOutVariableUsedInTheSameArgumentList" xml:space="preserve">
    <value>对隐式类型化出变量“{0}”的引用不允许出现在同一个参数列表中。</value>
  </data>
  <data name="ERR_MissingPartial" xml:space="preserve">
    <value>类型“{0}”的声明上缺少 partial 修饰符；存在此类型的其他分部声明</value>
  </data>
  <data name="ERR_NoSetToOverride" xml:space="preserve">
    <value>“{0}”: 无法重写，因为“{1}”没有可重写的 set 访问器</value>
  </data>
  <data name="ERR_BadExternAlias" xml:space="preserve">
    <value>在 /reference 选项中未指定外部别名“{0}”</value>
  </data>
  <data name="WRN_DefaultInSwitch_Title" xml:space="preserve">
    <value>你的意思是使用默认的切换标签(`default:`)而不是 `case default:`? 如果你的意思确实是使用默认文本，请根据需要考虑 `case (default):` 或其他文本(`case 0:` 或 `case null:`)。</value>
  </data>
  <data name="WRN_InvalidAttributeLocation" xml:space="preserve">
    <value>“{0}”不是可识别的特性位置。此声明的有效特性位置为“{1}”。此块中的所有特性都将被忽略。</value>
  </data>
  <data name="ERR_BadParamRef" xml:space="preserve">
    <value>参数 {0} 必须使用“{1}”关键字进行声明</value>
  </data>
  <data name="ERR_MissingSourceInterface" xml:space="preserve">
    <value>接口“{0}”的源接口无效，该源接口是嵌入事件“{1}”所必需的。</value>
  </data>
  <data name="ERR_InitializerAddHasParamModifiers" xml:space="preserve">
    <value>无法使用集合初始值设定项元素的最佳重载方法匹配项“{0}”。集合初始值设定项 "Add" 方法不能具有 ref 或 out 参数。</value>
  </data>
  <data name="ERR_OverrideNotExpected" xml:space="preserve">
    <value>“{0}”: 没有找到适合的方法来重写</value>
  </data>
  <data name="IDS_PathList" xml:space="preserve">
    <value>&lt;路径列表&gt;</value>
  </data>
  <data name="ERR_AssgReadonlyLocal2Cause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，因此无法修改其成员</value>
  </data>
  <data name="WRN_CLS_NoAbstractMembers" xml:space="preserve">
    <value>“{0}”: 只有符合 CLS 的成员才能是抽象的</value>
  </data>
  <data name="HDN_UnusedUsingDirective_Title" xml:space="preserve">
    <value>不需要的 using 指令</value>
  </data>
  <data name="ERR_CantRefResource" xml:space="preserve">
    <value>生成模块时，无法链接资源文件</value>
  </data>
  <data name="IDS_GlobalNamespace" xml:space="preserve">
    <value>&lt;全局命名空间&gt;</value>
  </data>
  <data name="ERR_CircularConstraint" xml:space="preserve">
    <value>涉及“{0}”和“{1}”的循环约束依赖项</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode" xml:space="preserve">
    <value>“{0}”定义运算符 == 或运算符 !=，但不重写 Object.GetHashCode()</value>
  </data>
  <data name="ERR_BadBinaryOperatorSignature" xml:space="preserve">
    <value>二元运算符的参数之一必须是包含类型</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface" xml:space="preserve">
    <value>“{0}”不实现“{1}”</value>
  </data>
  <data name="ERR_BadProtectedAccess" xml:space="preserve">
    <value>无法通过“{1}”类型的限定符访问受保护的成员“{0}”；限定符必须是“{2}”类型(或者从该类型派生)</value>
  </data>
  <data name="ERR_MissingPredefinedMember" xml:space="preserve">
    <value>缺少编译器要求的成员“{0}.{1}”</value>
  </data>
  <data name="ERR_GlobalAttributesNotAllowed" xml:space="preserve">
    <value>在此上下文中不允许有程序集和模块特性</value>
  </data>
  <data name="WRN_EndOfPPLineExpected" xml:space="preserve">
    <value>应输入单行注释或行尾</value>
  </data>
  <data name="WRN_NewNotRequired_Title" xml:space="preserve">
    <value>成员不会隐藏继承的成员；不需要关键字 new</value>
  </data>
  <data name="ERR_InitializerInStructWithoutExplicitConstructor" xml:space="preserve">
    <value>没有显式构造函数的结构不能包含具有初始值设定项的成员。</value>
  </data>
  <data name="ERR_ConstraintIsStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类不能用作约束</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>异步方法的返回类型必须为 void、Task 或 Task&lt;T&gt;</value>
  </data>
  <data name="WRN_BadXMLRef" xml:space="preserve">
    <value>XML 注释中有未能解析的 cref 特性“{0}”</value>
  </data>
  <data name="ERR_DottedTypeNameNotFoundInNSFwd" xml:space="preserve">
    <value>未能在命名空间“{1}”中找到类型名“{0}”。此类型已转发到程序集“{2}”。请考虑添加对该程序集的引用。</value>
  </data>
  <data name="ERR_AnonMethGrpInForEach" xml:space="preserve">
    <value>Foreach 不能操作“{0}”。是否要调用“{0}”?</value>
  </data>
  <data name="WRN_VolatileByRef_Title" xml:space="preserve">
    <value>对可变字段的引用不被视为可变字段</value>
  </data>
  <data name="WRN_CallOnNonAgileField_Title" xml:space="preserve">
    <value>访问引用封送类的字段上的成员可能导致运行时异常</value>
  </data>
  <data name="ERR_FieldCantHaveVoidType" xml:space="preserve">
    <value>字段不能有 void 类型</value>
  </data>
  <data name="WRN_CLS_BadBase_Title" xml:space="preserve">
    <value>基类型不符合 CLS</value>
  </data>
  <data name="ERR_ExtensionMethodsDecl" xml:space="preserve">
    <value>扩展方法必须在顶级静态类中定义；{0} 是嵌套类</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>模块“{0}”已在此程序集中定义。每个模块必须具有唯一的文件名。</value>
  </data>
  <data name="ERR_AttributesNotAllowed" xml:space="preserve">
    <value>特性在此上下文中无效。</value>
  </data>
  <data name="IDS_FeatureFixedBuffer" xml:space="preserve">
    <value>固定大小缓冲区</value>
  </data>
  <data name="ERR_UnexpectedSemicolon" xml:space="preserve">
    <value>方法或访问器块后面的分号无效</value>
  </data>
  <data name="ERR_LocalTypeNameClash" xml:space="preserve">
    <value>嵌入来自程序集“{1}”的互操作类型“{0}”会导致当前程序集中发生名称冲突。请考虑将“嵌入互操作类型”属性设置为 false。</value>
  </data>
  <data name="WRN_CLS_NoVarArgs" xml:space="preserve">
    <value>带有变量参数的方法不符合 CLS</value>
  </data>
  <data name="ERR_AccessModMissingAccessor" xml:space="preserve">
    <value>“{0}”: 仅当属性或索引器同时具有 get 访问器和 set 访问器时，才能对访问器使用可访问性修饰符</value>
  </data>
  <data name="ERR_DynamicAttributeMissing" xml:space="preserve">
    <value>无法定义使用“dynamic”的类或成员，因为找不到编译器所需的类型“{0}”。是否缺少引用?</value>
  </data>
  <data name="ERR_AbstractField" xml:space="preserve">
    <value>修饰符 "abstract" 对于字段无效。请尝试改用属性。</value>
  </data>
  <data name="IDS_FeatureSwitchOnBool" xml:space="preserve">
    <value>启用布尔值类型</value>
  </data>
  <data name="WRN_AlwaysNull" xml:space="preserve">
    <value>表达式的结果总是“{0}”类型的“null”</value>
  </data>
  <data name="WRN_CLS_MeaninglessOnReturn_Title" xml:space="preserve">
    <value>CLSCompliant 特性在应用于返回类型时无意义</value>
  </data>
  <data name="ERR_CantConvAnonMethReturns" xml:space="preserve">
    <value>无法将 {0} 转换为预期委托类型，因为块中的某些返回类型不可隐式转换为委托返回类型</value>
  </data>
  <data name="WRN_MissingXMLComment" xml:space="preserve">
    <value>缺少对公共可见类型或成员“{0}”的 XML 注释</value>
  </data>
  <data name="WRN_MultipleRuntimeImplementationMatches" xml:space="preserve">
    <value>成员“{0}”实现类型“{2}”中的接口成员“{1}”。在运行时该接口成员有多个匹配项。此实现取决于将要调用的方法。</value>
  </data>
  <data name="WRN_ErrorOverride_Description" xml:space="preserve">
    <value>编译器在将错误重写为警告时发出此警告。有关该问题的信息，请搜索提到的错误代码。</value>
  </data>
  <data name="IDS_USINGLOCAL" xml:space="preserve">
    <value>using 变量</value>
  </data>
  <data name="ERR_NewBoundMustBeLast" xml:space="preserve">
    <value>new() 约束必须是指定的最后一个约束</value>
  </data>
  <data name="ERR_DuplicateInterfaceWithTupleNamesInBaseList" xml:space="preserve">
    <value>“{0}”已列入类型“{2}”的接口列表中，其中包含不同的元组元素名称，例如“{1}”。</value>
  </data>
  <data name="WRN_UnassignedInternalField" xml:space="preserve">
    <value>从未对字段“{0}”赋值，字段将一直保持其默认值 {1}</value>
  </data>
  <data name="ERR_FriendAssemblySNReq" xml:space="preserve">
    <value>友元程序集引用“{0}”无效。强名称签名的程序集必须在其 InternalsVisibleTo 声明中指定一个公钥。</value>
  </data>
  <data name="WRN_CLS_BadInterface_Title" xml:space="preserve">
    <value>类型不符合 CLS，因为基接口不符合 CLS</value>
  </data>
  <data name="ERR_MemberAlreadyExists" xml:space="preserve">
    <value>类型“{1}”已定义了一个名为“{0}”的具有相同参数类型的成员</value>
  </data>
  <data name="IDS_XMLIGNORED" xml:space="preserve">
    <value>&lt;!-- 对于成员“{0}”忽略有格式错误的 XML 注释 --&gt;</value>
  </data>
  <data name="ERR_CantConvAnonMethNoParams" xml:space="preserve">
    <value>无法将不含参数列表的匿名方法块转换为委托类型“{0}”，原因是该方法块具有一个或多个 out 参数</value>
  </data>
  <data name="ERR_ConditionalOnNonAttributeClass" xml:space="preserve">
    <value>特性“{0}”仅对方法或特性类有效</value>
  </data>
  <data name="ERR_NoVoidHere" xml:space="preserve">
    <value>关键字 "void" 不能在此上下文中使用</value>
  </data>
  <data name="ERR_DuplicateNameInNS" xml:space="preserve">
    <value>命名空间“{1}”已经包含“{0}”的定义</value>
  </data>
  <data name="ItemsMustBeNonEmpty" xml:space="preserve">
    <value>项目: 不能为空</value>
  </data>
  <data name="WRN_IdentifierOrNumericLiteralExpected" xml:space="preserve">
    <value>应为标识符或数字参数。</value>
  </data>
  <data name="WRN_UnmatchedParamRefTag" xml:space="preserve">
    <value>“{1}”上的 XML 注释中有“{0}”的 paramref 标记，但是没有该名称的参数</value>
  </data>
  <data name="ERR_OvlUnaryOperatorExpected" xml:space="preserve">
    <value>应输入可重载的一元运算符</value>
  </data>
  <data name="ERR_BadOpOnNullOrDefault" xml:space="preserve">
    <value>运算符“{0}”无法应用于操作数“{1}”</value>
  </data>
  <data name="ERR_LookupInTypeVariable" xml:space="preserve">
    <value>“{0}”是一个类型参数，无法在其中执行成员查找</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>存储在“{1}”中的模块名“{0}”必须与其文件名匹配。</value>
  </data>
  <data name="WRN_ByRefNonAgileField" xml:space="preserve">
    <value>由于“{0}”是引用封送类的字段，将它用作 ref 或 out 值或获取它的地址可能导致运行时异常</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>指定版本字符串不符合建议格式 - major.minor.build.revision</value>
  </data>
  <data name="ERR_ArrayOfStaticClass" xml:space="preserve">
    <value>“{0}”: 数组元素不能是静态类型的</value>
  </data>
  <data name="ERR_InvalidQM" xml:space="preserve">
    <value>无法确定条件表达式的类型，因为“{0}”和“{1}”之间没有隐式转换</value>
  </data>
  <data name="ERR_AssgReadonlyLocalCause" xml:space="preserve">
    <value>无法为“{0}”赋值，因为它是“{1}”</value>
  </data>
  <data name="ERR_BadEventUsage" xml:space="preserve">
    <value>事件“{0}”只能出现在 += 或 -= 的左边(从类型“{1}”中使用时除外)</value>
  </data>
  <data name="ERR_InaccessibleSetter" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为 set 访问器不可访问</value>
  </data>
  <data name="ERR_NamedArgumentUsedInPositional" xml:space="preserve">
    <value>命名参数“{0}”指定的形参已被赋予位置参数</value>
  </data>
  <data name="ERR_MethGrpToNonDel" xml:space="preserve">
    <value>无法将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?</value>
  </data>
  <data name="WRN_CantHaveManifestForModule_Title" xml:space="preserve">
    <value>对模块忽略 /win32manifest，因为它仅应用于程序集</value>
  </data>
  <data name="ERR_BadGetEnumerator" xml:space="preserve">
    <value>foreach 要求“{1}”的返回类型“{0}”必须具有适当的公共 MoveNext 方法和公共 Current 属性</value>
  </data>
  <data name="IDS_RELATEDWARNING" xml:space="preserve">
    <value>(与前一个警告相关的符号位置)</value>
  </data>
  <data name="ERR_ArrayInitInBadPlace" xml:space="preserve">
    <value>数组初始值设定项只能在变量或字段初始值设定项中使用。请尝试改用 new 表达式。</value>
  </data>
  <data name="IDS_NULL" xml:space="preserve">
    <value>&lt;null&gt;</value>
  </data>
  <data name="IDS_Text" xml:space="preserve">
    <value>&lt;文本&gt;</value>
  </data>
  <data name="ERR_DelegateRefMismatch" xml:space="preserve">
    <value>“{0}”和委托“{1}”之间引用不匹配</value>
  </data>
  <data name="ERR_CantOverrideNonFunction" xml:space="preserve">
    <value>“{0}”: 无法重写，因为“{1}”不是函数</value>
  </data>
  <data name="IDS_FeatureImplicitLocal" xml:space="preserve">
    <value>隐式类型的局部变量</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>预定义类型“{0}”必须是一个结构。</value>
  </data>
  <data name="IDS_FeatureImplicitArray" xml:space="preserve">
    <value>隐式类型的数组</value>
  </data>
  <data name="UseVerbatimIdentifier" xml:space="preserve">
    <value>使用 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier 或 Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier 可创建标识符标记。</value>
  </data>
  <data name="ERR_FieldInitializerInStruct" xml:space="preserve">
    <value>“{0}”: 结构中不能实例属性或字段初始值设定项</value>
  </data>
  <data name="ERR_IteratorInInteractive" xml:space="preserve">
    <value>Yield 语句不能出现在交互代码中的顶层。</value>
  </data>
  <data name="ERR_NoConvToIDisp" xml:space="preserve">
    <value>“{0}”: using 语句中使用的类型必须可隐式转换为“System.IDisposable”</value>
  </data>
  <data name="WRN_BadRefCompareLeft" xml:space="preserve">
    <value>可能非有意的引用比较；若要获取值比较，请将左边转换为类型“{0}”</value>
  </data>
  <data name="ERR_InvalidArray" xml:space="preserve">
    <value>无效的秩说明符: 应为“,”或“]”</value>
  </data>
  <data name="ERR_DuplicateAccessor" xml:space="preserve">
    <value>属性访问器已经定义</value>
  </data>
  <data name="ERR_ImplicitlyTypedVariableAssignedArrayInitializer" xml:space="preserve">
    <value>无法使用数组初始值设定项初始化隐式类型化的变量</value>
  </data>
  <data name="ERR_NewlineInConst" xml:space="preserve">
    <value>常量中有换行符</value>
  </data>
  <data name="ERR_GenericDerivingFromAttribute" xml:space="preserve">
    <value>“{0}”是一个特性类，无法从它派生泛型类型</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>无法创建分析器实例</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>“{1}”不是迭代器接口类型，因此“{0}”体不能是迭代器块</value>
  </data>
  <data name="ERR_NotConstantExpression" xml:space="preserve">
    <value>指派给“{0}”的表达式必须是常量</value>
  </data>
  <data name="ERR_ArraySizeInDeclaration" xml:space="preserve">
    <value>不能在变量声明中指定数组大小(请尝试使用 "new" 表达式初始化)</value>
  </data>
  <data name="ERR_AbstractEventInitializer" xml:space="preserve">
    <value>“{0}”: 抽象事件不能有初始值设定项</value>
  </data>
  <data name="ERR_DuplicateImport" xml:space="preserve">
    <value>导入了具有等效标识的多个程序集:“{0}”和“{1}”。请删除重复引用之一。</value>
  </data>
  <data name="ERR_SameFullNameThisAggThisNs" xml:space="preserve">
    <value>“{0}”中的类型“{1}”与“{2}”中的命名空间“{3}”冲突</value>
  </data>
  <data name="WRN_CallerLineNumberParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerLineNumberAttribute 将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="ERR_TypeExpected" xml:space="preserve">
    <value>应输入类型</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>位置必须处于语法树范围内。</value>
  </data>
  <data name="ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer" xml:space="preserve">
    <value>表达式树不能包含多维数组初始值</value>
  </data>
  <data name="ERR_InterfacesCantContainFields" xml:space="preserve">
    <value>接口不能包含字段</value>
  </data>
  <data name="ERR_RefReturnNonreturnableLocal" xml:space="preserve">
    <value>“{0}”已初始化为不能按引用返回的值，因此无法按引用返回</value>
  </data>
  <data name="ERR_UnexpectedAliasedName" xml:space="preserve">
    <value>意外使用了别名</value>
  </data>
  <data name="ERR_BadParamModThis" xml:space="preserve">
    <value>参数数组不能与“this”修饰符一起在扩展方法中使用</value>
  </data>
  <data name="ERR_NoDynamicPhantomOnBase" xml:space="preserve">
    <value>需要动态调度对方法“{0}”的调用，但无法实现，因为该调用是基访问表达式的一部分。请考虑强制转换动态参数或消除基访问。</value>
  </data>
  <data name="ERR_SealedStaticClass" xml:space="preserve">
    <value>“{0}”: 类不能既是静态的又是密封的</value>
  </data>
  <data name="ERR_PartialTypeKindConflict" xml:space="preserve">
    <value>“{0}”的分部声明必须是所有的类、所有的结构或所有的接口</value>
  </data>
  <data name="WRN_CLS_VolatileField" xml:space="preserve">
    <value>符合 CLS 的字段“{0}”不能是可变字段</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordEquals" xml:space="preserve">
    <value>应为上下文关键字 "equals"</value>
  </data>
  <data name="ERR_LegacyObjectIdSyntax" xml:space="preserve">
    <value>不再支持 "id #" 语法。应使用 "$id"。</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>程序的入口点是全局脚本代码；正在忽略入口点</value>
  </data>
  <data name="WRN_UnreferencedField_Title" xml:space="preserve">
    <value>字段从未使用过</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes" xml:space="preserve">
    <value>可以多次释放对象“{0}”。</value>
  </data>
  <data name="ERR_CloseUnimplementedInterfaceMemberWrongRefReturn" xml:space="preserve">
    <value>“{0}”未实现接口成员“{1}”。“{2}”无法实现“{1}”，因为它不按{3}返回</value>
  </data>
  <data name="ERR_FixedNeedsLvalue" xml:space="preserve">
    <value>只能通过局部变量或字段访问固定大小缓冲区</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag" xml:space="preserve">
    <value>“{1}”上的 XML 注释中有“{0}”的 typeparamref 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref_Title" xml:space="preserve">
    <value>在 cref 特性中，应限定泛型类型的嵌套类型</value>
  </data>
  <data name="ERR_ExpressionTreeContainsNamedArgument" xml:space="preserve">
    <value>表达式树可能不包含命名参数规范</value>
  </data>
  <data name="FTL_InvalidTarget" xml:space="preserve">
    <value>/target 的目标类型无效: 必须指定“exe”、“winexe”、“library”或“module”</value>
  </data>
  <data name="ERR_AssgReadonlyStatic" xml:space="preserve">
    <value>无法对静态只读字段赋值(静态构造函数或变量初始值中除外)</value>
  </data>
  <data name="ERR_ObjectProhibited" xml:space="preserve">
    <value>无法使用实例引用来访问成员“{0}”；请改用类型名来限定它</value>
  </data>
  <data name="WRN_AssignmentToLockOrDispose_Title" xml:space="preserve">
    <value>对局部变量的赋值可能不正确，该变量是 using 或 lock 语句的参数</value>
  </data>
  <data name="ERR_BadFinallyLeave" xml:space="preserve">
    <value>控制不能离开 finally 子句主体</value>
  </data>
  <data name="SyntaxNodeIsNotWithinSynt" xml:space="preserve">
    <value>语法节点不在语法树中</value>
  </data>
  <data name="ERR_MustNotHaveRefReturn" xml:space="preserve">
    <value>按引用返回只能在按引用返回的方法中使用</value>
  </data>
  <data name="ERR_BadConstType" xml:space="preserve">
    <value>不能将类型“{0}”声明为 const</value>
  </data>
  <data name="ERR_BadAsyncArgType" xml:space="preserve">
    <value>异步方法不能使用 ref 或 out 参数</value>
  </data>
  <data name="ERR_SwitchFallOut" xml:space="preserve">
    <value>控件无法从最终用例标签(“{0}”)脱离开关</value>
  </data>
  <data name="WRN_DuplicateUsing" xml:space="preserve">
    <value>“{0}”的 using 指令以前在此命名空间中出现过</value>
  </data>
  <data name="ERR_BindToBogusProp1" xml:space="preserve">
    <value>属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”</value>
  </data>
  <data name="ERR_BindToBogusProp2" xml:space="preserve">
    <value>属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”或“{2}”</value>
  </data>
  <data name="ERR_ConversionWithInterface" xml:space="preserve">
    <value>“{0}”: 不允许进行以接口为转换源或目标用户定义转换</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>不要在使用 refonly 时使用 refout。</value>
  </data>
  <data name="ERR_AnonDelegateCantUse" xml:space="preserve">
    <value>不能在匿名方法、lambda 表达式或查询表达式中使用 ref 或 out 参数“{0}”</value>
  </data>
  <data name="WRN_AlwaysNull_Title" xml:space="preserve">
    <value>表达式的结果总是 "null"</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>未能发出模块“{0}”。</value>
  </data>
  <data name="IDS_FeatureThrowExpression" xml:space="preserve">
    <value>throw 表达式</value>
  </data>
  <data name="ERR_MethodImplementingAccessor" xml:space="preserve">
    <value>方法“{0}”无法实现类型“{2}”的接口访问器“{1}” 请使用显式接口实现。</value>
  </data>
  <data name="ERR_ConflictingAliasAndDefinition" xml:space="preserve">
    <value>别名“{0}”与 {1} 定义冲突</value>
  </data>
  <data name="ERR_NoSuchMember" xml:space="preserve">
    <value>“{0}”未包含“{1}”的定义</value>
  </data>
  <data name="ERR_IntOverflow" xml:space="preserve">
    <value>整数常量太大</value>
  </data>
  <data name="CouldNotFindFile" xml:space="preserve">
    <value>无法找到文件。</value>
  </data>
  <data name="ERR_DeclarationExpressionNotPermitted" xml:space="preserve">
    <value>此上下文中不允许使用声明。</value>
  </data>
  <data name="ERR_NonTaskMainCantBeAsync" xml:space="preserve">
    <value>返回入口点的 void 或 int 不能是异步的</value>
  </data>
  <data name="WRN_UnmatchedTypeParamRefTag_Title" xml:space="preserve">
    <value>XML 注释中有 typeparamref 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>本地名称对于 PDB 太长</value>
  </data>
  <data name="ERR_ComImportWithoutUuidAttribute" xml:space="preserve">
    <value>Guid 特性必须用 ComImport 特性指定</value>
  </data>
  <data name="ERR_BadYieldInTryOfCatch" xml:space="preserve">
    <value>无法在包含 catch 子句的 Try 块体中生成值</value>
  </data>
  <data name="WRN_ExplicitImplCollision_Title" xml:space="preserve">
    <value>显式接口实现与多个接口成员匹配</value>
  </data>
  <data name="ERR_NoMainOnDLL" xml:space="preserve">
    <value>如果生成模块或库，则无法指定 /main</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>类型仅用于评估，在将来的更新中可能会被更改或删除。</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailedSelectMany" xml:space="preserve">
    <value>在源类型为“{1}”的查询表达式中，不允许在后面的 from 子句中使用类型“{0}”的表达式。在对“{2}”的调用中，类型推理失败。</value>
  </data>
  <data name="IDS_FeatureNullPropagatingOperator" xml:space="preserve">
    <value>空传播运算符</value>
  </data>
  <data name="ERR_AssemblySpecifiedForLinkAndRef" xml:space="preserve">
    <value>程序集“{0}”和“{1}”引用相同元数据，但是只有一个是链接引用(使用 /link 选项指定)；请考虑删除其中一个引用。</value>
  </data>
  <data name="IDS_Covariant" xml:space="preserve">
    <value>协变</value>
  </data>
  <data name="ERR_FixedNotInStruct" xml:space="preserve">
    <value>固定大小缓冲区字段只能是结构的成员</value>
  </data>
  <data name="ERR_ExpressionTreeContainsTupleConversion" xml:space="preserve">
    <value>表达式树不能包含元组转换。</value>
  </data>
  <data name="ERR_CantReadConfigFile" xml:space="preserve">
    <value>无法读取配置文件“{0}”--“{1}”</value>
  </data>
  <data name="ERR_BadAsyncExpressionTree" xml:space="preserve">
    <value>异步 lambda 表达式无法转换为表达式树</value>
  </data>
  <data name="ERR_ConWithValCon" xml:space="preserve">
    <value>类型参数“{1}”具有 "struct" 约束，因此“{1}”不能用作“{0}”的约束</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeNotFound" xml:space="preserve">
    <value>未定义或导入预定义类型“{0}”</value>
  </data>
  <data name="TypeArgumentCannotBeNull" xml:space="preserve">
    <value>类型参数不能是 null</value>
  </data>
  <data name="ERR_ExternAfterElements" xml:space="preserve">
    <value>外部别名声明必须位于命名空间中定义的所有其他元素之前</value>
  </data>
  <data name="ERR_BadPlatformType" xml:space="preserve">
    <value>选项“{0}”对 /platform 无效；必须是 anycpu、x86、Itanium 或 x64</value>
  </data>
  <data name="ERR_BadArgumentToAttribute" xml:space="preserve">
    <value>“{0}”特性的参数必须是有效的标识符</value>
  </data>
  <data name="WRN_CallerFilePathPreferredOverCallerMemberName" xml:space="preserve">
    <value>应用于参数“{0}”的 CallerMemberNameAttribute 将不起任何作用。它由 CallerFilePathAttribute 重写。</value>
  </data>
  <data name="ERR_BadVisDelegateReturn" xml:space="preserve">
    <value>可访问性不一致: 返回类型“{1}”的可访问性低于委托“{0}”</value>
  </data>
  <data name="ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync" xml:space="preserve">
    <value>安全特性“{0}”不可应用于异步方法。</value>
  </data>
  <data name="ERR_GlobalAttributesNotFirst" xml:space="preserve">
    <value>程序集和模块特性必须位于文件中定义的所有其他元素之前(using 子句和外部别名声明除外)</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA_Title" xml:space="preserve">
    <value>由于使用间接程序集引用，因此创建了对嵌入互操作程序集的引用</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>非托管类型“{0}”仅对字段有效。</value>
  </data>
  <data name="ERR_UnassignedThisAutoProperty" xml:space="preserve">
    <value>在控制返回调用方之前，自动实现的属性“{0}”必须完全赋值。</value>
  </data>
  <data name="ERR_BadUnOpArgs" xml:space="preserve">
    <value>重载的一元运算符“{0}”采用一个参数</value>
  </data>
  <data name="ERR_UnsafeTypeInObjectCreation" xml:space="preserve">
    <value>对象创建中不能使用不安全的类型“{0}”</value>
  </data>
  <data name="ERR_UseDefViolationOut" xml:space="preserve">
    <value>使用了未赋值的 out 参数“{0}”</value>
  </data>
  <data name="IDS_Contravariant" xml:space="preserve">
    <value>逆变</value>
  </data>
  <data name="ERR_ConditionalOnInterfaceMethod" xml:space="preserve">
    <value>Conditional 特性在接口成员上无效</value>
  </data>
  <data name="ERR_UnboxNotLValue" xml:space="preserve">
    <value>无法修改取消装箱转换的结果</value>
  </data>
  <data name="ERR_IllegalRefParam" xml:space="preserve">
    <value>ref 和 out 参数在此上下文中无效</value>
  </data>
  <data name="XML_ElementTypeMatch" xml:space="preserve">
    <value>结束标记“{0}”与开始标记“{1}”不匹配。</value>
  </data>
  <data name="ERR_BadCastInFixed" xml:space="preserve">
    <value>fixed 语句赋值的右边不能是强制转换表达式</value>
  </data>
  <data name="ERR_AssgReadonly2" xml:space="preserve">
    <value>无法修改只读字段“{0}”的成员(在构造函数或变量初始值设定项中除外)</value>
  </data>
  <data name="WRN_UnifyReferenceBldRev" xml:space="preserve">
    <value>假定“{1}”使用的程序集引用“{0}”与“{3}”的标识“{2}”匹配，您可能需要提供运行时策略</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>SecurityAction 值“{0}”对于应用于程序集的安全特性无效</value>
  </data>
  <data name="ERR_QueryRangeVariableOverrides" xml:space="preserve">
    <value>范围变量“{0}”与“{0}”的以前声明冲突</value>
  </data>
  <data name="ERR_SingleTypeNameNotFound" xml:space="preserve">
    <value>未能找到类型或命名空间名“{0}”(是否缺少 using 指令或程序集引用?)</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordOn" xml:space="preserve">
    <value>应为上下文关键字 "on"</value>
  </data>
  <data name="ERR_ExpectedContextualKeywordBy" xml:space="preserve">
    <value>应为上下文关键字 "by"</value>
  </data>
  <data name="ERR_FeatureIsUnimplemented" xml:space="preserve">
    <value>此编译器中未实现功能“{0}”。</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换。</value>
  </data>
  <data name="ERR_BadExtensionMeth" xml:space="preserve">
    <value>扩展方法必须是静态的</value>
  </data>
  <data name="WRN_BadXMLRefReturnType" xml:space="preserve">
    <value>XML 注释的 cref 特性中的返回类型无效</value>
  </data>
  <data name="WRN_DeprecatedSymbolStr" xml:space="preserve">
    <value>“{0}”已过时:“{1}”</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>程序集 {0} 不包含任何分析器。</value>
  </data>
  <data name="IDS_Covariantly" xml:space="preserve">
    <value>协变式</value>
  </data>
  <data name="WRN_ReferencedAssemblyReferencesLinkedPIA" xml:space="preserve">
    <value>由于程序集“{1}”创建了对嵌入互操作程序集“{0}”的间接引用，因此创建了对该程序集的引用。请考虑更改其中一个程序集的“嵌入互操作类型”属性。</value>
  </data>
  <data name="WRN_TooManyLinesForDebugger" xml:space="preserve">
    <value>源文件已超过在 PDB 中可表示的 16,707,565 行的限制；调试信息将不正确</value>
  </data>
  <data name="IDS_Collection" xml:space="preserve">
    <value>集合</value>
  </data>
  <data name="ERR_ExplicitDynamicAttr" xml:space="preserve">
    <value>不要使用“System.Runtime.CompilerServices.DynamicAtribute”。请改用“dynamic”关键字。</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>文件名“{0}”为空、包含无效字符、未使用绝对路径指定驱动器或太长</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此不能将“{0}”标记为符合 CLS</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>提供的语言版本不受支持或无效:“{0}”。</value>
  </data>
  <data name="ERR_InterfaceMemberHasBody" xml:space="preserve">
    <value>“{0}”: 接口成员不能有定义</value>
  </data>
  <data name="ERR_ExpressionOrDeclarationExpected" xml:space="preserve">
    <value>应是表达式或声明语句。</value>
  </data>
  <data name="ERR_AssgReadonlyProp" xml:space="preserve">
    <value>无法为属性或索引器“{0}”赋值 - 它是只读的</value>
  </data>
  <data name="ERR_MethodReturnCantBeRefAny" xml:space="preserve">
    <value>方法或委托不能返回“{0}”类型</value>
  </data>
  <data name="ERR_BadVisFieldType" xml:space="preserve">
    <value>可访问性不一致: 字段类型“{1}”的可访问性低于字段“{0}”</value>
  </data>
  <data name="ERR_MissingDebugSwitch" xml:space="preserve">
    <value>要使用 /pdb 选项，必须同时使用 /debug 选项</value>
  </data>
  <data name="WRN_IsAlwaysTrue_Title" xml:space="preserve">
    <value>"is" 表达式的给定表达式始终是所提供的类型</value>
  </data>
  <data name="IDS_FeaturePragma" xml:space="preserve">
    <value>#pragma</value>
  </data>
  <data name="ERR_ResourceFileNameNotUnique" xml:space="preserve">
    <value>每个链接资源和模块必须具有唯一的文件名。在此程序集中多次指定了文件名 {0}</value>
  </data>
  <data name="WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title" xml:space="preserve">
    <value>在对已分配实例的所有引用超出范围之前，对它调用 System.IDisposable.Dispose()</value>
  </data>
  <data name="ERR_ComRefCallInExpressionTree" xml:space="preserve">
    <value>表达式树 lambda 不能包含参数中省略 ref 的 COM 调用</value>
  </data>
  <data name="ERR_BadForeachDecl" xml:space="preserve">
    <value>在 foreach 语句中，类型和标识符都是必需的</value>
  </data>
  <data name="ERR_BadArgType" xml:space="preserve">
    <value>参数 {0}: 无法从“{1}”转换为“{2}”</value>
  </data>
  <data name="ERR_NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>命名参数规范必须出现在已指定的所有固定参数之后</value>
  </data>
  <data name="ERR_ImplBadConstraints" xml:space="preserve">
    <value>方法“{1}”的类型参数“{0}”的约束必须与接口方法“{3}”的类型参数“{2}”的约束相匹配。请考虑改用显式接口实现。</value>
  </data>
  <data name="ERR_RefReturnRangeVariable" xml:space="preserve">
    <value>无法按引用返回范围变量“{0}”</value>
  </data>
  <data name="ERR_IllegalInnerUnsafe" xml:space="preserve">
    <value>迭代器中不能出现不安全的代码</value>
  </data>
  <data name="ERR_ArgsInvalid" xml:space="preserve">
    <value>__arglist 构造只在变量参数方法中有效</value>
  </data>
  <data name="ERR_AmbigQM" xml:space="preserve">
    <value>无法确定条件表达式的类型，因为“{0}”和“{1}”可相互隐式转换</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>"new" 不能与元组类型共同使用。改用元组文本表达式。</value>
  </data>
  <data name="ERR_UnexpectedToken" xml:space="preserve">
    <value>意外标记“{0}”</value>
  </data>
  <data name="ERR_CantDeriveFromSealedType" xml:space="preserve">
    <value>“{0}”: 无法从密封类型“{1}”派生</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>调试入口点必须是当前编译中声明的方法的定义。</value>
  </data>
  <data name="WRN_SequentialOnPartialClass_Title" xml:space="preserve">
    <value>在分部结构的多个声明中的字段之间没有已定义的排序方式</value>
  </data>
  <data name="WRN_UnifyReferenceMajMin" xml:space="preserve">
    <value>假定“{1}”使用的程序集引用“{0}”与“{3}”的标识“{2}”匹配，您可能需要提供运行时策略</value>
  </data>
  <data name="WRN_UnmatchedTypeParamTag" xml:space="preserve">
    <value>XML 注释中有“{0}”的 typeparam 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>必须指定特性参数“{0}”或“{1}”。</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>必须指定特性参数“{0}”。</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedMethod" xml:space="preserve">
    <value>expression-bodied 方法</value>
  </data>
  <data name="WRN_CallerFilePathParamForUnconsumedLocation_Title" xml:space="preserve">
    <value>CallerFilePathAttribute 将不起作用，因为它应用到的成员在不允许使用可选参数的上下文中使用</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>无法在使用 /refout 或 /refonly 时编译 Net 模块。</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。可以为 null 的类型不能满足任何接口约束。</value>
  </data>
  <data name="WRN_XMLParseIncludeError_Title" xml:space="preserve">
    <value>所包含的注释文件中有格式错误的 XML</value>
  </data>
  <data name="ERR_ConflictAliasAndMember" xml:space="preserve">
    <value>命名空间“{1}”包含与别名“{0}”冲突的定义</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>无效的程序集名称: {0}</value>
  </data>
  <data name="ERR_ExpressionTreeContainsDiscard" xml:space="preserve">
    <value>表达式树不能包含放弃。</value>
  </data>
  <data name="WRN_IsDynamicIsConfusing_Title" xml:space="preserve">
    <value>使用 "is" 测试与 "dynamic" 的兼容性和测试与 "object" 的兼容性实质上是相同的</value>
  </data>
  <data name="ERR_BadUsingNamespace" xml:space="preserve">
    <value>“using namespace”指令只能应用于命名空间；“{0}”是一个类型而不是命名空间。请考虑改用“using static”指令</value>
  </data>
  <data name="ERR_RefReadonly2" xml:space="preserve">
    <value>无法将只读字段“{0}”的成员用作 ref 或 out 值(构造函数中除外)</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>命令行语法错误: Guid 格式“{0}”对于选项“{1}”无效</value>
  </data>
  <data name="WRN_UnqualifiedNestedTypeInCref" xml:space="preserve">
    <value>在 cref 特性中，应限定泛型类型的嵌套类型。</value>
  </data>
  <data name="ERR_BadCallerLineNumberParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerLineNumberAttribute 只能应用于具有默认值的参数</value>
  </data>
  <data name="WRN_NubExprIsConstBool2" xml:space="preserve">
    <value>由于“{1}”类型的值永不等于“{2}”类型的 "null"，该表达式的结果始终为“{0}”</value>
  </data>
  <data name="ERR_ReturnInIterator" xml:space="preserve">
    <value>无法从迭代器返回值。请使用 yield return 语句返回值，或使用 yield break 语句结束迭代。</value>
  </data>
  <data name="WRN_IllegalPPWarning" xml:space="preserve">
    <value>应为 disable 或 restore</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>选项“{0}”必须是绝对路径。</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>版本 {0} 对于 /subsystemversion 无效。对于 ARM 或 AppContainerExe，此版本必须是 6.02 或更高，其他情况下必须为 4.00 或更高</value>
  </data>
  <data name="ERR_InvalidInitializerElementInitializer" xml:space="preserve">
    <value>初始值设定项成员声明符无效</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>路径映射选项的格式不正确。</value>
  </data>
  <data name="ERR_IllegalFixedType" xml:space="preserve">
    <value>固定大小的缓冲区类型必须为下列类型之一: bool、byte、short、int、long、char、sbyte、ushort、uint、ulong、float 或 double</value>
  </data>
  <data name="ERR_ConstOutOfRange" xml:space="preserve">
    <value>常量值“{0}”无法转换为“{1}”</value>
  </data>
  <data name="ERR_BadArgExtraRef" xml:space="preserve">
    <value>参数 {0} 不可与关键字“{1}”一起传递</value>
  </data>
  <data name="ERR_InaccessibleGetter" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为 get 访问器不可访问</value>
  </data>
  <data name="IDS_FeatureLocalFunctions" xml:space="preserve">
    <value>本地函数</value>
  </data>
  <data name="IDS_FeatureTuples" xml:space="preserve">
    <value>元组</value>
  </data>
  <data name="IDS_SK_EXTERNALIAS" xml:space="preserve">
    <value>外部别名</value>
  </data>
  <data name="WRN_InvalidInclude" xml:space="preserve">
    <value>无效的 XML 包含元素 -- {0}</value>
  </data>
  <data name="WRN_AlignmentMagnitude_Title" xml:space="preserve">
    <value>对齐值具有可能产生较大的格式化字符串的度量值</value>
  </data>
  <data name="ERR_BadExceptionType" xml:space="preserve">
    <value>捕获或抛弃的类型必须从 System.Exception 派生</value>
  </data>
  <data name="WRN_NoSources_Title" xml:space="preserve">
    <value>未指定源文件</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>指定公共签名时，将忽略特性“{0}”。</value>
  </data>
  <data name="ERR_FixedOverflow" xml:space="preserve">
    <value>长度为 {0}、类型为“{1}”的固定大小缓冲区太大</value>
  </data>
  <data name="ERR_BogusExplicitImpl" xml:space="preserve">
    <value>“{0}”无法实现“{1}”，因为该语言不支持它</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion2" xml:space="preserve">
    <value>功能“{0}”在 C# 2 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion3" xml:space="preserve">
    <value>功能“{0}”在 C# 3 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion1" xml:space="preserve">
    <value>功能“{0}”在 C# 1 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion6" xml:space="preserve">
    <value>功能“{0}”在 C# 6 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion7" xml:space="preserve">
    <value>功能“{0}”在 C# 7 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion4" xml:space="preserve">
    <value>功能“{0}”在 C# 4 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="ERR_FeatureNotAvailableInVersion5" xml:space="preserve">
    <value>功能“{0}”在 C# 5 中不可用。请使用 {1} 或更高的语言版本。</value>
  </data>
  <data name="IDS_LIB_OPTION" xml:space="preserve">
    <value>/LIB 选项</value>
  </data>
  <data name="ERR_ConditionalMustReturnVoid" xml:space="preserve">
    <value>Conditional 特性在“{0}”上无效，因为其返回类型不是 void</value>
  </data>
  <data name="ERR_DllImportOnGenericMethod" xml:space="preserve">
    <value>DllImport 特性不能应用于属于泛型类型或者包含在泛型类型中的方法。</value>
  </data>
  <data name="ERR_UseDefViolation" xml:space="preserve">
    <value>使用了未赋值的局部变量“{0}”</value>
  </data>
  <data name="ERR_RefProperty" xml:space="preserve">
    <value>属性或索引器不能作为 out 或 ref 参数传递</value>
  </data>
  <data name="WRN_MultipleRuntimeOverrideMatches_Title" xml:space="preserve">
    <value>成员在运行时使用多个重写候选项重写基成员</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocalCause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，无法按引用返回</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>跳过加载分析器程序集中因 ReflectionTypeLoadException 而失败的类型</value>
  </data>
  <data name="ERR_BadSpecialByRefLocal" xml:space="preserve">
    <value>不能在异步方法或 lambda 表达式中声明“{0}”类型的参数或局部变量</value>
  </data>
  <data name="ERR_PartialMethodMustHaveLatent" xml:space="preserve">
    <value>没有为分部方法“{0}”的实现声明找到定义声明</value>
  </data>
  <data name="ERR_MissingTypeInSource" xml:space="preserve">
    <value>对类型“{0}”的引用声称在此程序集中定义了该类型，但源代码或任何添加的模块中并未定义该类型</value>
  </data>
  <data name="ERR_CannotPassNullForFriendAssembly" xml:space="preserve">
    <value>无法为友元程序集名称传递 null</value>
  </data>
  <data name="WRN_DefaultValueForUnconsumedLocation_Title" xml:space="preserve">
    <value>指定的默认值将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="WRN_EmptySwitch" xml:space="preserve">
    <value>空的 switch 块</value>
  </data>
  <data name="ERR_AbstractSealedStatic" xml:space="preserve">
    <value>“{0}”: 抽象类不能是密封的或静态的</value>
  </data>
  <data name="WRN_FinalizeMethod_Title" xml:space="preserve">
    <value>引入 "Finalize" 方法可能会妨碍析构函数调用</value>
  </data>
  <data name="ERR_FixedMustInit" xml:space="preserve">
    <value>必须在 fixed 或者 using 语句声明中提供初始值设定项</value>
  </data>
  <data name="ERR_BadIncDecRetType" xml:space="preserve">
    <value>++ 或 -- 运算符的返回类型必须与参数类型匹配或从参数类型派生</value>
  </data>
  <data name="ERR_UnexpectedVariance" xml:space="preserve">
    <value>差异无效: 类型参数“{1}”必须是在“{0}”上有效的 {3}。“{1}”为 {2}。</value>
  </data>
  <data name="ERR_BadDynamicConversion" xml:space="preserve">
    <value>“{0}”: 不允许对动态类型执行用户定义的转换</value>
  </data>
  <data name="ERR_BadAppConfigPath" xml:space="preserve">
    <value>AppConfigPath 必须是绝对的。</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerFilePath" xml:space="preserve">
    <value>应用于参数“{0}”的 CallerFilePathAttribute 将不起任何作用。它由 CallerLineNumberAttribute 重写。</value>
  </data>
  <data name="WRN_PossibleMistakenNullStatement_Title" xml:space="preserve">
    <value>空语句可能有错误</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换或类型参数转换。</value>
  </data>
  <data name="WRN_XMLParseIncludeError" xml:space="preserve">
    <value>所包含的注释文件中有格式错误的 XML --“{0}”</value>
  </data>
  <data name="ERR_AutoPropertyMustOverrideSet" xml:space="preserve">
    <value>自动实现的属性必须覆盖被覆盖属性的所有访问器。</value>
  </data>
  <data name="ERR_SubexpressionNotInNameof" xml:space="preserve">
    <value>子表达式不能在 nameof 的参数中使用。</value>
  </data>
  <data name="ERR_FixedDimsRequired" xml:space="preserve">
    <value>固定大小缓冲区字段的字段名称后必须带有数组大小说明符</value>
  </data>
  <data name="WRN_WarningDirective_Title" xml:space="preserve">
    <value>#warning 指令</value>
  </data>
  <data name="ERR_BadArgCount" xml:space="preserve">
    <value>“{0}”方法没有采用 {1} 个参数的重载</value>
  </data>
  <data name="ERR_BadIndexLHS" xml:space="preserve">
    <value>无法将带 [] 的索引应用于“{0}”类型的表达式</value>
  </data>
  <data name="ERR_BadBoundType" xml:space="preserve">
    <value>“{0}”不是有效的约束。作为约束使用的类型必须是接口、非密封类或类型参数。</value>
  </data>
  <data name="WRN_AmbiguousXMLReference" xml:space="preserve">
    <value>cref 特性中有不明确的引用:“{0}”。假定为“{1}”，但可能还与其他重载匹配，包括“{2}”。</value>
  </data>
  <data name="ERR_NoMultipleInheritance" xml:space="preserve">
    <value>类“{0}”不能具有多个基类:“{1}”和“{2}”</value>
  </data>
  <data name="WRN_EqualsWithoutGetHashCode" xml:space="preserve">
    <value>“{0}”重写 Object.Equals(object o) 但不重写 Object.GetHashCode()</value>
  </data>
  <data name="HDN_UnusedUsingDirective" xml:space="preserve">
    <value>不需要的 using 指令。</value>
  </data>
  <data name="ERR_NameNotInContext" xml:space="preserve">
    <value>当前上下文中不存在名称“{0}”</value>
  </data>
  <data name="ERR_NoBreakOrCont" xml:space="preserve">
    <value>没有要中断或继续的封闭循环</value>
  </data>
  <data name="WRN_ExplicitImplCollision" xml:space="preserve">
    <value>显式接口实现“{0}”与多个接口成员匹配。实际选择哪个接口成员取决于具体的实现。请考虑改用非显式实现。</value>
  </data>
  <data name="XML_RefUndefinedEntity_1" xml:space="preserve">
    <value>引用未定义的实体“{0}”。</value>
  </data>
  <data name="WRN_XMLParseError" xml:space="preserve">
    <value>XML 注释出现 XML 格式错误 --“{0}”</value>
  </data>
  <data name="ERR_RefPropertyMustHaveGetAccessor" xml:space="preserve">
    <value>按引用返回的属性必须有 get 访问器</value>
  </data>
  <data name="ERR_BadVisBaseInterface" xml:space="preserve">
    <value>可访问性不一致: 基接口“{1}”的可访问性低于接口“{0}”</value>
  </data>
  <data name="ERR_ExpressionTreeContainsAnonymousMethod" xml:space="preserve">
    <value>表达式树不能包含匿名方法表达式</value>
  </data>
  <data name="IDS_Lambda" xml:space="preserve">
    <value>lambda 表达式</value>
  </data>
  <data name="ERR_EOFExpected" xml:space="preserve">
    <value>应输入类型、命名空间定义或文件尾</value>
  </data>
  <data name="ERR_UnterminatedStringLit" xml:space="preserve">
    <value>字符串未终止</value>
  </data>
  <data name="ERR_BadConstraintType" xml:space="preserve">
    <value>约束类型无效。作为约束使用的类型必须是接口、非密封类或类型形参。</value>
  </data>
  <data name="WRN_DotOnDefault_Title" xml:space="preserve">
    <value>由于类型的默认值为 null，因此表达式总会导致 System.NullReferenceException</value>
  </data>
  <data name="ERR_PointerInAsOrIs" xml:space="preserve">
    <value>"is" 和 "as" 在指针类型上都无效</value>
  </data>
  <data name="WRN_TypeParameterSameAsOuterTypeParameter_Title" xml:space="preserve">
    <value>类型参数与外部类型中的类型参数同名</value>
  </data>
  <data name="WRN_CLS_BadInterfaceMember" xml:space="preserve">
    <value>“{0}”: 符合 CLS 的接口必须仅有符合 CLS 的成员</value>
  </data>
  <data name="ERR_AnonymousMethodToExpressionTree" xml:space="preserve">
    <value>无法将匿名方法表达式转换为表达式树</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>多次指定源文件</value>
  </data>
  <data name="XML_IncorrectComment" xml:space="preserve">
    <value>注释中使用的语法不正确。</value>
  </data>
  <data name="ERR_ExtensionCollectionElementInitializerInExpressionTree" xml:space="preserve">
    <value>表达式 lambda 中的集合初始值设定项不支持扩展 Add 方法。</value>
  </data>
  <data name="ERR_BadIndexerNameAttr" xml:space="preserve">
    <value>“{0}”特性仅在不是显式接口成员声明的索引器上有效</value>
  </data>
  <data name="ERR_NotAnAttributeClass" xml:space="preserve">
    <value>“{0}”不是特性类</value>
  </data>
  <data name="ERR_AnonymousTypeNotAvailable" xml:space="preserve">
    <value>无法在常量表达式中使用匿名类型</value>
  </data>
  <data name="ERR_GlobalStatement" xml:space="preserve">
    <value>表达式和语句只能在方法体中出现</value>
  </data>
  <data name="WRN_CLS_BadFieldPropType" xml:space="preserve">
    <value>“{0}”的类型不符合 CLS</value>
  </data>
  <data name="ERR_AmbigBinaryOpsOnDefault" xml:space="preserve">
    <value>运算符“{0}”在操作数 "default" 和 "default" 上不明确</value>
  </data>
  <data name="WRN_CLS_BadArgType" xml:space="preserve">
    <value>参数类型“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_ParamsMustBeArray" xml:space="preserve">
    <value>params 参数必须是一维数组</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>程序的入口点是全局脚本代码；正在忽略“{0}”入口点。</value>
  </data>
  <data name="ERR_AbstractBaseCall" xml:space="preserve">
    <value>无法调用抽象基成员:“{0}”</value>
  </data>
  <data name="ERR_TypeVarCantBeNull" xml:space="preserve">
    <value>无法将 null 转换为类型参数“{0}”，因为它可能是不可以为 null 的值类型。请考虑改用“default({0})”。</value>
  </data>
  <data name="WRN_NonECMAFeature_Title" xml:space="preserve">
    <value>功能不是标准化 ISO C# 语言规范的一部分，其他编译器可能不接受它</value>
  </data>
  <data name="ERR_RefReturnLocal2" xml:space="preserve">
    <value>局部变量“{0}”不是 ref 局部变量，无法按引用返回其成员</value>
  </data>
  <data name="ERR_ObjectCallingBaseConstructor" xml:space="preserve">
    <value>“{0}”没有基类，无法调用基构造函数</value>
  </data>
  <data name="ERR_InitializerAddHasWrongSignature" xml:space="preserve">
    <value>与“{0}”最匹配的重载方法具有对于初始值设定项元素而言错误的签名。可初始化的 Add 必须是可访问的实例方法。</value>
  </data>
  <data name="ERR_PublicSignButNoKey" xml:space="preserve">
    <value>指定了公共签名并需要公钥，但未指定公钥。</value>
  </data>
  <data name="ERR_CloseParenExpected" xml:space="preserve">
    <value>应输入 )</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>未能找到源文件“{0}”。</value>
  </data>
  <data name="IDS_SK_PROPERTY" xml:space="preserve">
    <value>属性</value>
  </data>
  <data name="ERR_RefReturnReadonlyLocal" xml:space="preserve">
    <value>“{0}”是只读的，无法按引用返回</value>
  </data>
  <data name="ERR_RetNoObjectRequiredLambda" xml:space="preserve">
    <value>转换为 void 返回委托的匿名函数不能返回值</value>
  </data>
  <data name="ERR_PatternDynamicType" xml:space="preserve">
    <value>在模式中使用类型“动态”是不合法的。</value>
  </data>
  <data name="ERR_CallingFinalizeDeprecated" xml:space="preserve">
    <value>无法直接调用析构函数和 object.Finalize。如果可用，请考虑调用 IDisposable.Dispose。</value>
  </data>
  <data name="ERR_TooManyCharsInConst" xml:space="preserve">
    <value>字符文本中的字符太多</value>
  </data>
  <data name="WRN_ConflictingChecksum_Title" xml:space="preserve">
    <value>提供了不同的 #pragma 校验和值</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>SecurityAction 值“{0}”对于 PrincipalPermission 特性无效</value>
  </data>
  <data name="ERR_CStyleArray" xml:space="preserve">
    <value>错误的数组声明符: 要声明托管数组，秩说明符应位于变量标识符之前。要声明固定大小缓冲区字段，应在字段类型之前使用 fixed 关键字。</value>
  </data>
  <data name="ERR_PartialWrongTypeParamsVariance" xml:space="preserve">
    <value>“{0}”的分部声明必须具有相同类型的参数名和差异修饰符，同时顺序也必须相同</value>
  </data>
  <data name="ERR_DeriveFromEnumOrValueType" xml:space="preserve">
    <value>“{0}”无法从特殊类“{1}”派生</value>
  </data>
  <data name="ERR_TaskRetNoObjectRequired" xml:space="preserve">
    <value>由于“{0}”是返回“Task”的异步方法，因此返回关键字不能后接对象表达式。是否要返回“Task&lt;T&gt;”?</value>
  </data>
  <data name="ERR_RefReadonlyLocal" xml:space="preserve">
    <value>“{0}”是只读的，无法用作 ref 或 out 值</value>
  </data>
  <data name="ERR_QueryNoProvider" xml:space="preserve">
    <value>未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。</value>
  </data>
  <data name="ERR_BadCallerMemberNameParamWithoutDefaultValue" xml:space="preserve">
    <value>CallerMemberNameAttribute 只能应用于具有默认值的参数</value>
  </data>
  <data name="WRN_SameFullNameThisAggNs_Title" xml:space="preserve">
    <value>类型与导入命名空间冲突</value>
  </data>
  <data name="WRN_UnmatchedParamTag" xml:space="preserve">
    <value>XML 注释中有“{0}”的 param 标记，但是没有该名称的参数</value>
  </data>
  <data name="WRN_MissingXMLComment_Title" xml:space="preserve">
    <value>缺少对公共可见类型或成员的 XML 注释</value>
  </data>
  <data name="WRN_VacuousIntegralComp_Title" xml:space="preserve">
    <value>与整数常量比较无意义；该常量不在类型的范围之内</value>
  </data>
  <data name="WRN_EqualityOpWithoutGetHashCode_Title" xml:space="preserve">
    <value>类型定义运算符 == 或运算符 !=，但不重写 Object.GetHashCode()</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>将忽略特性，以便支持源中出现的实例</value>
  </data>
  <data name="ERR_NoSourceFile" xml:space="preserve">
    <value>无法打开源文件“{0}”-- {1}</value>
  </data>
  <data name="ERR_AttributeOnBadSymbolType" xml:space="preserve">
    <value>特性“{0}”对此声明类型无效。它仅对“{1}”声明有效。</value>
  </data>
  <data name="ERR_LocalIllegallyOverrides" xml:space="preserve">
    <value>无法在此范围中声明名为“{0}”的局部变量或参数，因为该名称在封闭局部范围中用于定义局部变量或参数</value>
  </data>
  <data name="ERR_NotNullRefDefaultParameter" xml:space="preserve">
    <value>“{0}”的类型为“{1}”。只能用 Null 对引用类型(字符串除外)的默认参数值进行初始化</value>
  </data>
  <data name="ERR_NoPIAAssemblyMissingAttributes" xml:space="preserve">
    <value>无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性或“{2}”特性。</value>
  </data>
  <data name="WRN_CLS_BadTypeVar" xml:space="preserve">
    <value>约束类型“{0}”不符合 CLS</value>
  </data>
  <data name="ERR_StaticMemberInObjectInitializer" xml:space="preserve">
    <value>无法在对象初始值设定项中为静态字段或属性“{0}”赋值</value>
  </data>
  <data name="ERR_DuplicateAttribute" xml:space="preserve">
    <value>“{0}”特性重复</value>
  </data>
  <data name="ERR_AttributeUsageOnNonAttributeClass" xml:space="preserve">
    <value>特性“{0}”仅在从 System.Attribute 派生的类上有效</value>
  </data>
  <data name="WRN_CmpAlwaysFalse_Title" xml:space="preserve">
    <value>与结构类型的 null 进行比较始终产生 "false"</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>C# 类型上不允许有 RequiredAttribute 特性</value>
  </data>
  <data name="ERR_TooManyLocals" xml:space="preserve">
    <value>仅允许 65534 个局部变量，包括编译器生成的局部变量</value>
  </data>
  <data name="WRN_VolatileByRef_Description" xml:space="preserve">
    <value>可变字段通常不应用作 ref 或 out 值，因为它不会被视为可变字段。这种情况存在例外情况，如调用联锁 API 时。</value>
  </data>
  <data name="ERR_InteropTypesWithSameNameAndGuid" xml:space="preserve">
    <value>无法嵌入在程序集“{1}”和“{2}”中同时找到的互操作类型“{0}”。请考虑将“嵌入互操作类型”属性设置为 false。</value>
  </data>
  <data name="IDS_DirectoryHasInvalidPath" xml:space="preserve">
    <value>路径太长或无效</value>
  </data>
  <data name="ERR_BadRetType" xml:space="preserve">
    <value>“{1} {0}”的返回类型错误</value>
  </data>
  <data name="WRN_PatternBadSignature_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员有错误的签名</value>
  </data>
  <data name="IDS_FeatureAsyncMain" xml:space="preserve">
    <value>主异步</value>
  </data>
  <data name="ERR_PredefinedTypeMemberNotFoundInAssembly" xml:space="preserve">
    <value>未在程序集“{2}”中找到类型“{1}”上的成员“{0}”。</value>
  </data>
  <data name="XML_EndTagNotExpected" xml:space="preserve">
    <value>在此位置不应为结束标记。</value>
  </data>
  <data name="ERR_StaticBaseClass" xml:space="preserve">
    <value>“{0}”: 无法从静态类“{1}”派生</value>
  </data>
  <data name="WRN_CallOnNonAgileField" xml:space="preserve">
    <value>由于“{0}”是引用封送类的字段，访问上面的成员可能导致运行时异常</value>
  </data>
  <data name="TypeMustBeVar" xml:space="preserve">
    <value>类型必须是 "var"。</value>
  </data>
  <data name="ERR_ExpressionExpected" xml:space="preserve">
    <value>应为表达式</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>友元访问权限由“{0}”授予，但是输出程序集的公钥与授予程序集中特性指定的公钥不匹配。</value>
  </data>
  <data name="ERR_BogusType" xml:space="preserve">
    <value>“{0}”不是现用语言支持的类型</value>
  </data>
  <data name="ERR_InvalidDynamicCondition" xml:space="preserve">
    <value>表达式必须可隐式转换为布尔值，或其类型“{0}”必须定义运算符“{1}”。</value>
  </data>
  <data name="WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title" xml:space="preserve">
    <value>可以多次释放对象</value>
  </data>
  <data name="WRN_CallerLineNumberPreferredOverCallerMemberName" xml:space="preserve">
    <value>应用于参数“{0}”的 CallerMemberNameAttribute 将不起任何作用。它由 CallerLineNumberAttribute 重写。</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>程序集引用无效，无法解析</value>
  </data>
  <data name="ERR_BadIncDecSignature" xml:space="preserve">
    <value>++ 或 -- 运算符的参数类型必须是包含类型</value>
  </data>
  <data name="WRN_NoRuntimeMetadataVersion_Title" xml:space="preserve">
    <value>找不到 RuntimeMetadataVersion 的值</value>
  </data>
  <data name="ERR_ObjectRequired" xml:space="preserve">
    <value>对象引用对于非静态的字段、方法或属性“{0}”是必需的</value>
  </data>
  <data name="ERR_InterfacesCannotContainTypes" xml:space="preserve">
    <value>“{0}”: 接口不能声明类型</value>
  </data>
  <data name="WRN_CLS_AssemblyNotCLS_Title" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此不能将类型或成员标记为符合 CLS</value>
  </data>
  <data name="ERR_CantChangeReturnTypeOnOverride" xml:space="preserve">
    <value>“{0}”: 返回类型必须是“{2}”才能与重写成员“{1}”匹配</value>
  </data>
  <data name="SubmissionCanHaveAtMostOne" xml:space="preserve">
    <value>提交最多可以具有一个语法树。</value>
  </data>
  <data name="ERR_MethDelegateMismatch" xml:space="preserve">
    <value>“{0}”没有与委托“{1}”匹配的重载</value>
  </data>
  <data name="WRN_BadXMLRefParamType_Title" xml:space="preserve">
    <value>XML 注释 cref 特性中参数的类型无效</value>
  </data>
  <data name="ERR_DefaultMemberOnIndexedType" xml:space="preserve">
    <value>不能对包含索引器的类型指定 DefaultMember 特性</value>
  </data>
  <data name="ERR_BadWarningLevel" xml:space="preserve">
    <value>警告等级必须在 0-4 的范围内</value>
  </data>
  <data name="IDS_FeatureExpressionBodiedIndexer" xml:space="preserve">
    <value>expression-bodied 索引器</value>
  </data>
  <data name="ERR_DeriveFromDynamic" xml:space="preserve">
    <value>“{0}”: 无法从动态类型派生</value>
  </data>
  <data name="TreeNotPartOfCompilation" xml:space="preserve">
    <value>树不属于编译</value>
  </data>
  <data name="ERR_ExpressionTreeContainsBadCoalesce" xml:space="preserve">
    <value>表达式树 lambda 不能包含左侧为 null 或默认文本的合并运算符</value>
  </data>
  <data name="ERR_SyntaxError" xml:space="preserve">
    <value>语法错误，应输入“{0}”</value>
  </data>
  <data name="WRN_InvalidAttributeLocation_Title" xml:space="preserve">
    <value>不是可识别的特性位置</value>
  </data>
  <data name="ERR_EmptyElementInitializer" xml:space="preserve">
    <value>元素初始值设定项不能为空</value>
  </data>
  <data name="ERR_QueryTypeInferenceFailed" xml:space="preserve">
    <value>{0} 子句中的表达式的类型不正确。在对“{1}”的调用中，类型推理失败。</value>
  </data>
  <data name="IDS_FeatureExceptionFilter" xml:space="preserve">
    <value>异常筛选器</value>
  </data>
  <data name="ERR_PartialMethodInconsistentConstraints" xml:space="preserve">
    <value>“{0}”的分部方法声明具有不一致的类型参数约束</value>
  </data>
</root>