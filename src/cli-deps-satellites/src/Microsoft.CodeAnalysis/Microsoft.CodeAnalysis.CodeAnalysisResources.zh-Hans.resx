<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Struct1" xml:space="preserve">
    <value>结构</value>
  </data>
  <data name="ElementIsExpected" xml:space="preserve">
    <value>应为元素</value>
  </data>
  <data name="PEImageNotAvailable" xml:space="preserve">
    <value>PE 映像不可用。</value>
  </data>
  <data name="InvalidSizeOfPublicKeyToken" xml:space="preserve">
    <value>公钥标记的大小无效。</value>
  </data>
  <data name="Event1" xml:space="preserve">
    <value>事件</value>
  </data>
  <data name="InconsistentLanguageVersions" xml:space="preserve">
    <value>不一致的语言版本</value>
  </data>
  <data name="ReferenceResolverShouldReturnReadableNonNullStream" xml:space="preserve">
    <value>引用解析程序应返回非空的可读流。</value>
  </data>
  <data name="InvalidCompilationOptions" xml:space="preserve">
    <value>无效的编译选项 -- 不能签署提交。</value>
  </data>
  <data name="EmptyKeyInPathMap" xml:space="preserve">
    <value>pathMap 中的键为空。</value>
  </data>
  <data name="RuleSetHasDuplicateRules" xml:space="preserve">
    <value>规则集文件对有不同操作 “{1}” 和“{2}”的“{0}”有重复规则。</value>
  </data>
  <data name="TypeMustBeASubclassOfSyntaxAnnotation" xml:space="preserve">
    <value>类型必须是 SyntaxAnnotation 的子类。</value>
  </data>
  <data name="CompilerAnalyzerThrowsDescription" xml:space="preserve">
    <value>分析器“{0}”引发了以下异常:
“{1}”。</value>
  </data>
  <data name="Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer" xml:space="preserve">
    <value>值太大，无法表示为 30 位无符号整数。</value>
  </data>
  <data name="CannotAliasModule" xml:space="preserve">
    <value>不能给模块起别名。</value>
  </data>
  <data name="InvalidCharactersInAssemblyCultureName" xml:space="preserve">
    <value>程序集区域性名称中有无效字符</value>
  </data>
  <data name="Module" xml:space="preserve">
    <value>模块</value>
  </data>
  <data name="Method" xml:space="preserve">
    <value>方法</value>
  </data>
  <data name="SymWriterNotDeterministic" xml:space="preserve">
    <value>Windows PDB 编写器不支持确定性的编译:“{0}”</value>
  </data>
  <data name="AnalyzerNameColumnHeader" xml:space="preserve">
    <value>分析器</value>
  </data>
  <data name="Class1" xml:space="preserve">
    <value>类</value>
  </data>
  <data name="ModuleCopyCannotBeUsedToCreateAssemblyMetadata" xml:space="preserve">
    <value>模块复制不能用于创建程序集元数据。</value>
  </data>
  <data name="IconStreamUnexpectedFormat" xml:space="preserve">
    <value>图标流不是预期格式。</value>
  </data>
  <data name="FileNotFound" xml:space="preserve">
    <value>未找到文件。</value>
  </data>
  <data name="RuleSetBadAttributeValue" xml:space="preserve">
    <value>属性 {0} 具有无效值 {1}。</value>
  </data>
  <data name="CoffResourceInvalidSectionSize" xml:space="preserve">
    <value>Win32 资源，假定为 COFF 对象格式，具有一个无效的节大小。</value>
  </data>
  <data name="UnrecognizedResourceFileFormat" xml:space="preserve">
    <value>无法识别的资源文件格式。</value>
  </data>
  <data name="Parameter" xml:space="preserve">
    <value>参数</value>
  </data>
  <data name="Property" xml:space="preserve">
    <value>属性、索引器</value>
  </data>
  <data name="RuleSetMissingAttribute" xml:space="preserve">
    <value>元素 {0} 缺少名为 {1} 的属性。</value>
  </data>
  <data name="MetadataRefNotFoundToRemove1" xml:space="preserve">
    <value>未找到要删除的 MetadataReference“{0}”。</value>
  </data>
  <data name="InvalidModuleName" xml:space="preserve">
    <value>在元数据模块“{0}”中所指定的模块名称无效:“{1}”</value>
  </data>
  <data name="NameContainsInvalidCharacter" xml:space="preserve">
    <value>名称包含无效字符。</value>
  </data>
  <data name="PdbStreamUnexpectedWhenEmbedding" xml:space="preserve">
    <value>将 PE 流嵌入 PDB 时，无法提供 PDB 流。</value>
  </data>
  <data name="PdbStreamUnexpectedWhenEmittingMetadataOnly" xml:space="preserve">
    <value>仅发出元数据时不应提供 PDB 流。</value>
  </data>
  <data name="AnalyzerDriverFailure" xml:space="preserve">
    <value>分析器驱动程序故障</value>
  </data>
  <data name="MustIncludePrivateMembersUnlessRefAssembly" xml:space="preserve">
    <value>必须包括私有成员，除非发出 ref 程序集。</value>
  </data>
  <data name="ChangesMustBeOrderedAndNotOverlapping" xml:space="preserve">
    <value>更改必须有序且不重叠。</value>
  </data>
  <data name="KeepAliveIsTooSmall" xml:space="preserve">
    <value>小于 -1 的 "/keepalive" 选项的参数无效。</value>
  </data>
  <data name="IOperationFeatureDisabled" xml:space="preserve">
    <value>功能 "IOperation" 已禁用。</value>
  </data>
  <data name="AbsolutePathExpected" xml:space="preserve">
    <value>预期的绝对路径。</value>
  </data>
  <data name="InvalidDataAtOffset" xml:space="preserve">
    <value>偏移量 {0} 处的数据无效: {1}{2}*{3}{4}</value>
  </data>
  <data name="XmlReferencesNotSupported" xml:space="preserve">
    <value>不支持 XML 文档的引用。</value>
  </data>
  <data name="StreamIsTooLong" xml:space="preserve">
    <value>“流”过长。</value>
  </data>
  <data name="ReturnTypeCannotBeValuePointerbyRefOrOpen" xml:space="preserve">
    <value>返回类型不能是值类型、指针、引用传递或开放式泛型类型</value>
  </data>
  <data name="TupleUnderlyingTypeMustBeTupleCompatible" xml:space="preserve">
    <value>元组的基础类型必须符合元组。</value>
  </data>
  <data name="AnalyzerDriverThrowsDescription" xml:space="preserve">
    <value>分析器驱动程序抛出以下异常:
“{0}”。</value>
  </data>
  <data name="ExceptionContext" xml:space="preserve">
    <value>出现异常，上下文如下:
{0}</value>
  </data>
  <data name="The_type_0_is_not_understood_by_the_serialization_binder" xml:space="preserve">
    <value>序列化绑定器不理解“{0}”类型。</value>
  </data>
  <data name="InconsistentSyntaxTreeFeature" xml:space="preserve">
    <value>不一致的语法树特征</value>
  </data>
  <data name="CannotEmbedInteropTypesFromModule" xml:space="preserve">
    <value>不能从模块嵌入互操作类型。</value>
  </data>
  <data name="SourceTextCannotBeEmbedded" xml:space="preserve">
    <value>不能嵌入 SourceText。在构造时提供编码或 canBeEmbedded=true。</value>
  </data>
  <data name="Stream_contains_invalid_data" xml:space="preserve">
    <value>流包含无效的数据</value>
  </data>
  <data name="AnalyzerExecutionTimeColumnHeader" xml:space="preserve">
    <value>时间(秒)</value>
  </data>
  <data name="AsyncAnalyzerActionCannotBeRegistered" xml:space="preserve">
    <value>分析器尝试注册 "async" 操作，但此操作不受支持。</value>
  </data>
  <data name="InvalidTree" xml:space="preserve">
    <value>语法树不属于底层“Compilation”。</value>
  </data>
  <data name="InvalidHash" xml:space="preserve">
    <value>哈希无效。</value>
  </data>
  <data name="KeepAliveWithoutShared" xml:space="preserve">
    <value>"/keepalive" 选项仅在与 "/shared" 选项一起使用时有效。</value>
  </data>
  <data name="IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream" xml:space="preserve">
    <value>发出到辅助程序集输出时不应包含私有成员。</value>
  </data>
  <data name="PathReturnedByResolveStrongNameKeyFileMustBeAbsolute" xml:space="preserve">
    <value>由 {0}.ResolveStrongNameKeyFile 返回的路径必须是绝对路径:“{1}”</value>
  </data>
  <data name="FailedToResolveRuleSetName" xml:space="preserve">
    <value>未能找到规则集文件“{0}”。</value>
  </data>
  <data name="KeyInPathMapEndsWithSeparator" xml:space="preserve">
    <value>pathMap 中的键以路径分隔符结束。</value>
  </data>
  <data name="AssemblySigningNotSupported" xml:space="preserve">
    <value>不支持程序集签名。</value>
  </data>
  <data name="InvalidDiagnosticSpanReported" xml:space="preserve">
    <value>报告的诊断“{0}”的源位置“{1}”位于文件“{2}”中，后者不是给定文件。</value>
  </data>
  <data name="InvalidNodeToTrack" xml:space="preserve">
    <value>要跟踪的节点不是根的后代。</value>
  </data>
  <data name="MissingListItem" xml:space="preserve">
    <value>指定的项不是列表的元素。</value>
  </data>
  <data name="Delegate1" xml:space="preserve">
    <value>委托</value>
  </data>
  <data name="TheStreamCannotBeWrittenTo" xml:space="preserve">
    <value>无法向流中写入。</value>
  </data>
  <data name="SharedArgumentMissing" xml:space="preserve">
    <value>参数“/shared:”的值不能为空</value>
  </data>
  <data name="Deserialization_reader_for_0_read_incorrect_number_of_values" xml:space="preserve">
    <value>“{0}”的反序列化读取器读取到错误数量的值。</value>
  </data>
  <data name="CannotCreateReferenceToSubmission" xml:space="preserve">
    <value>不能创建对提交的引用。</value>
  </data>
  <data name="PathReturnedByResolveMetadataFileMustBeAbsolute" xml:space="preserve">
    <value>由 {0}.ResolveMetadataFile 返回的路径必须是绝对路径:“{1}”</value>
  </data>
  <data name="Unresolved" xml:space="preserve">
    <value>未解析:</value>
  </data>
  <data name="KeepAliveIsNotAnInteger" xml:space="preserve">
    <value>"/keepalive" 选项的参数不是一个 32 位整数。</value>
  </data>
  <data name="SpanDoesNotIncludeStartOfLine" xml:space="preserve">
    <value>范围不包括行的开头。</value>
  </data>
  <data name="CantCreateReferenceToAssemblyWithoutLocation" xml:space="preserve">
    <value>无法对不含位置的程序集创建元数据引用。</value>
  </data>
  <data name="InvalidCultureName" xml:space="preserve">
    <value>无效的区域性名称:“{0}”</value>
  </data>
  <data name="TuplesNeedAtLeastTwoElements" xml:space="preserve">
    <value>元组必须包含至少两个元素。</value>
  </data>
  <data name="MismatchedVersion" xml:space="preserve">
    <value>Roslyn 编译器服务器报告不同于生成任务的协议版本。</value>
  </data>
  <data name="AnalyzerTotalExecutionTime" xml:space="preserve">
    <value>分析器总执行时间: {0} 秒。</value>
  </data>
  <data name="CompilationOptionsMustNotHaveErrors" xml:space="preserve">
    <value>编译选项必须无错误。</value>
  </data>
  <data name="Cannot_serialize_type_0" xml:space="preserve">
    <value>无法序列化类型“{0}”。</value>
  </data>
  <data name="MetadataPeStreamUnexpectedWhenEmittingMetadataOnly" xml:space="preserve">
    <value>仅发出元数据时不应提供元数据 PE 流。</value>
  </data>
  <data name="EmptyOrInvalidResourceName" xml:space="preserve">
    <value>空的或无效的资源名</value>
  </data>
  <data name="ReturnTypeCannotBeVoidByRefOrOpen" xml:space="preserve">
    <value>返回类型不能是无效、引用传递或是开放式泛型类型</value>
  </data>
  <data name="SymWriterDoesNotSupportSourceLink" xml:space="preserve">
    <value>Windows PDB 编写器不支持 SourceLink 功能:“{0}”</value>
  </data>
  <data name="InvalidPublicKeyToken" xml:space="preserve">
    <value>公钥标记无效。</value>
  </data>
  <data name="MissingKeepAlive" xml:space="preserve">
    <value>缺少 "/keepalive" 选项的参数。</value>
  </data>
  <data name="InMemoryModule" xml:space="preserve">
    <value>&lt;内存中的模块&gt;</value>
  </data>
  <data name="SymWriterOlderVersionThanRequired" xml:space="preserve">
    <value>Windows PDB 编写器的版本早于要求的版本:“{0}”</value>
  </data>
  <data name="NodeOrTokenOutOfSequence" xml:space="preserve">
    <value>某个节点或标记的顺序不正确。</value>
  </data>
  <data name="EmbeddingPdbUnexpectedWhenEmittingMetadata" xml:space="preserve">
    <value>不允许在发出元数据时嵌入 PDB。</value>
  </data>
  <data name="CantCreateReferenceToDynamicAssembly" xml:space="preserve">
    <value>无法对动态程序集创建元数据引用。</value>
  </data>
  <data name="CoffResourceInvalidSymbol" xml:space="preserve">
    <value>Win32 资源，假定为 COFF 对象格式，具有一个或多个无效的符号值。</value>
  </data>
  <data name="StreamMustSupportReadAndSeek" xml:space="preserve">
    <value>流必须支持读取和搜寻操作。</value>
  </data>
  <data name="Enum1" xml:space="preserve">
    <value>枚举</value>
  </data>
  <data name="InvalidDiagnosticLocationReported" xml:space="preserve">
    <value>报告的诊断“{0}”的源位置位于文件“{1}”中，后者不是要分析的编译的一部分。</value>
  </data>
  <data name="Field" xml:space="preserve">
    <value>字段</value>
  </data>
  <data name="NameCannotBeEmpty" xml:space="preserve">
    <value>名称不能为空。</value>
  </data>
  <data name="CoffResourceMissingSection" xml:space="preserve">
    <value>Win32 资源，假定为 COFF 对象格式，缺少其中一个或全部两个节:“.rsrc$01” 和“.rsrc$02”</value>
  </data>
  <data name="TupleElementNameCountMismatch" xml:space="preserve">
    <value>如果指定了元组元素名称，元素名称的数量必须与元组基数相匹配。</value>
  </data>
  <data name="InvalidContentType" xml:space="preserve">
    <value>无效的内容类型</value>
  </data>
  <data name="GetMetadataMustReturnInstance" xml:space="preserve">
    <value>{0}.GetMetadata() 必须返回 {1} 的实例。</value>
  </data>
  <data name="InvalidDiagnosticIdReported" xml:space="preserve">
    <value>报告的诊断 ID“{0}”不是有效的标识符。</value>
  </data>
  <data name="CantCreateModuleReferenceToAssembly" xml:space="preserve">
    <value>无法对程序集创建模块引用.</value>
  </data>
  <data name="DuplicateAnalyzerInstances" xml:space="preserve">
    <value>参数包含重复的分析器实例。</value>
  </data>
  <data name="NameCannotStartWithWhitespace" xml:space="preserve">
    <value>名称不能以空格开头。</value>
  </data>
  <data name="Arrays_with_more_than_one_dimension_cannot_be_serialized" xml:space="preserve">
    <value>不能序列化具有多个维度的数组。</value>
  </data>
  <data name="UnsupportedDiagnosticReported" xml:space="preserve">
    <value>分析器不支持 ID 为“{0}”的报告的诊断。</value>
  </data>
  <data name="OutputKindNotSupported" xml:space="preserve">
    <value>输出类型不受支持。</value>
  </data>
  <data name="SeparatorIsExpected" xml:space="preserve">
    <value>需要分隔符</value>
  </data>
  <data name="UnexpectedTypeOfNodeInList" xml:space="preserve">
    <value>列表中的某个节点不是预期的类型。</value>
  </data>
  <data name="AnonymousTypeArgumentCountMismatch2" xml:space="preserve">
    <value>{0} 必须为“默认值”或具有与 {1} 相同的长度。</value>
  </data>
  <data name="NameCannotBeNull" xml:space="preserve">
    <value>名称不能为 null。</value>
  </data>
  <data name="UnsupportedHashAlgorithm" xml:space="preserve">
    <value>不支持的哈希算法。</value>
  </data>
  <data name="ResourceStreamProviderShouldReturnNonNullStream" xml:space="preserve">
    <value>资源流提供程序应返回非空流。</value>
  </data>
  <data name="WinRTIdentityCantBeRetargetable" xml:space="preserve">
    <value>WindowsRuntime 标识不可重定目标</value>
  </data>
  <data name="UnsupportedAnalyzerInstance" xml:space="preserve">
    <value>参数包含的分析器实例不属于此 CompilationWithAnalyzers 实例的“Analyzers”。</value>
  </data>
  <data name="CannotTargetNetModuleWhenEmittingRefAssembly" xml:space="preserve">
    <value>无法在发出引用程序集时将 Net 模块作为目标。</value>
  </data>
  <data name="Cannot_deserialize_type_0" xml:space="preserve">
    <value>无法反序列化类型“{0}”。</value>
  </data>
  <data name="StreamMustSupportRead" xml:space="preserve">
    <value>流必须为可读。</value>
  </data>
  <data name="Interface1" xml:space="preserve">
    <value>接口</value>
  </data>
  <data name="CoffResourceInvalidRelocation" xml:space="preserve">
    <value>Win32 资源，假定为 COFF 对象格式，具有一个或多个无效的重定位标头值。</value>
  </data>
  <data name="CompilerAnalyzerThrows" xml:space="preserve">
    <value>分析器“{0}”抛出类型为“{1}”的异常，并显示消息“{2}”。</value>
  </data>
  <data name="InMemoryAssembly" xml:space="preserve">
    <value>&lt;内存中的程序集&gt;</value>
  </data>
  <data name="AnonymousTypeMemberAndNamesCountMismatch2" xml:space="preserve">
    <value>{0} 和 {1} 长度必须相同。</value>
  </data>
  <data name="TupleElementNameEmpty" xml:space="preserve">
    <value>元组元素名称不能为空字符串。</value>
  </data>
  <data name="EmbeddedTextsRequirePortablePdb" xml:space="preserve">
    <value>仅在发出可移植 PDB 时支持嵌入的文本。</value>
  </data>
  <data name="InvalidOutputKindForSubmission" xml:space="preserve">
    <value>无效的提交输出类型。预期为 DynamicallyLinkedLibrary。</value>
  </data>
  <data name="StreamMustSupportWrite" xml:space="preserve">
    <value>流必须是可写的。</value>
  </data>
  <data name="InvalidAssemblyName" xml:space="preserve">
    <value>无效程序集名称: “{0}”</value>
  </data>
  <data name="InvalidAlias" xml:space="preserve">
    <value>无效别名。</value>
  </data>
  <data name="Constructor" xml:space="preserve">
    <value>构造函数</value>
  </data>
  <data name="NoAnalyzersFound" xml:space="preserve">
    <value>找不到分析器</value>
  </data>
  <data name="AssemblyMustHaveAtLeastOneModule" xml:space="preserve">
    <value>程序集必须有至少一个模块。</value>
  </data>
  <data name="ResourceDataProviderShouldReturnNonNullStream" xml:space="preserve">
    <value>资源数据提供程序应返回非空流</value>
  </data>
  <data name="ResourceStreamEndedUnexpectedly" xml:space="preserve">
    <value>资源流在 {0} 字节结束，预期为 {1} 字节。</value>
  </data>
  <data name="PEImageDoesntContainManagedMetadata" xml:space="preserve">
    <value>PE 映像不包含任何托管元数据。</value>
  </data>
  <data name="EmptyOrInvalidFileName" xml:space="preserve">
    <value>空的或无效的文件名</value>
  </data>
  <data name="Return1" xml:space="preserve">
    <value>返回</value>
  </data>
  <data name="AnalyzerDriverThrows" xml:space="preserve">
    <value>分析器驱动程序抛出类型为“{0}”的异常，并显示消息“{1}”。</value>
  </data>
  <data name="FileSizeExceedsMaximumAllowed" xml:space="preserve">
    <value>文件大小超过有效元数据文件所允许的最大大小。</value>
  </data>
  <data name="SpanDoesNotIncludeEndOfLine" xml:space="preserve">
    <value>范围不包括行的末尾。</value>
  </data>
  <data name="PreviousSubmissionHasErrors" xml:space="preserve">
    <value>上一个提交有错误。</value>
  </data>
  <data name="CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion" xml:space="preserve">
    <value>编译将引用多个程序集(其版本只在自动生成的版本和/或修订号方面有所不同)。</value>
  </data>
  <data name="AssemblyFileNotFound" xml:space="preserve">
    <value>未找到程序集文件</value>
  </data>
  <data name="InvalidPublicKey" xml:space="preserve">
    <value>公钥无效</value>
  </data>
  <data name="TheStreamCannotBeReadFrom" xml:space="preserve">
    <value>无法从流中读取。</value>
  </data>
  <data name="ReferenceOfTypeIsInvalid1" xml:space="preserve">
    <value>引用类型“{0}”对该编译无效。</value>
  </data>
  <data name="DiagnosticIdCantBeNullOrWhitespace" xml:space="preserve">
    <value>DiagnosticDescriptor 必须有一个 ID，该 ID 不能为 null、空字符串或只包含空格的字符串。</value>
  </data>
  <data name="TypeMustBeSameAsHostObjectTypeOfPreviousSubmission" xml:space="preserve">
    <value>类型须与之前提交的宿主对象的类型相同。</value>
  </data>
  <data name="TupleElementLocationCountMismatch" xml:space="preserve">
    <value>如果已指定元组元素位置，则位置的数量必须与元组基数相匹配。</value>
  </data>
  <data name="EndMustNotBeLessThanStart" xml:space="preserve">
    <value>“结束时间”不得早于“开始时间”</value>
  </data>
  <data name="CannotCreateReferenceToModule" xml:space="preserve">
    <value>不能创建对模块的引用。</value>
  </data>
  <data name="CompilerAnalyzerFailure" xml:space="preserve">
    <value>分析器故障</value>
  </data>
  <data name="ExpectedNonEmptyPublicKey" xml:space="preserve">
    <value>预期的非空公钥</value>
  </data>
  <data name="InvalidRuleSetInclude" xml:space="preserve">
    <value>加载所含规则集文件 {0} - {1} 时出错</value>
  </data>
  <data name="InvalidCharactersInAssemblyName" xml:space="preserve">
    <value>程序集名称中有无效字符</value>
  </data>
  <data name="MultithreadedAnalyzerExecutionNote" xml:space="preserve">
    <value>注意: 运行时间可能小于分析器执行时间，因为分析器可以同时运行。</value>
  </data>
  <data name="ArgumentElementCannotBeNull" xml:space="preserve">
    <value>参数不能具有 null 元素。</value>
  </data>
  <data name="ArgumentCannotBeEmpty" xml:space="preserve">
    <value>参数不能为空。</value>
  </data>
  <data name="Assembly" xml:space="preserve">
    <value>程序集</value>
  </data>
  <data name="TypeParameter" xml:space="preserve">
    <value>类型形参</value>
  </data>
  <data name="StartMustNotBeNegative" xml:space="preserve">
    <value>“开始”不能为负</value>
  </data>
  <data name="SizeHasToBePositive" xml:space="preserve">
    <value>大小必须为正数。</value>
  </data>
  <data name="NullValueInPathMap" xml:space="preserve">
    <value>pathMap 中的一个值为 null。</value>
  </data>
</root>