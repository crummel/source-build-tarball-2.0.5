<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ERR_OperatorRequiresBoolReturnType1" xml:space="preserve">
    <value>Operator „{0}” musi mieć typ zwracany Boolean.</value>
  </data>
  <data name="ERR_LocalNamedSameAsParamInLambda1" xml:space="preserve">
    <value>Zmienna „{0}” jest już zadeklarowana jako parametr tego lub otaczającego wyrażenia lambda.</value>
  </data>
  <data name="ERR_ElseNoMatchingIf" xml:space="preserve">
    <value>Element „Else” musi być poprzedzony odpowiadającym mu elementem „If” lub „ElseIf”.</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer" xml:space="preserve">
    <value>Niektóre typy zestawu analizatora {0} zostaną pominięte z powodu wyjątku ReflectionTypeLoadException: {1}.</value>
  </data>
  <data name="ERR_AnonymousTypeNameWithoutPeriod" xml:space="preserve">
    <value>Nazwa elementu członkowskiego typu anonimowego musi być poprzedzona kropką.</value>
  </data>
  <data name="ERR_CannotConvertValue2" xml:space="preserve">
    <value>Wartości „{0}” nie można skonwertować na typ „{1}”.</value>
  </data>
  <data name="ERR_InvalidImplements" xml:space="preserve">
    <value>Element Implements nie jest prawidłowy w deklaracjach operatora.</value>
  </data>
  <data name="WRN_SynthMemberShadowsMember5_Title" xml:space="preserve">
    <value>Właściwość lub zdarzenie niejawnie deklaruje typ lub element członkowski powodujący konflikt z elementem członkowskim w typie podstawowym</value>
  </data>
  <data name="ERR_AccessMismatch6" xml:space="preserve">
    <value>Element „{0}” nie może ujawnić typu „{1}” w zakresie od {2} „{3}” do {4} „{5}”.</value>
  </data>
  <data name="ERR_InvalidMultipleAttributeUsage1" xml:space="preserve">
    <value>Nie można wielokrotnie zastosować atrybutu „{0}”.</value>
  </data>
  <data name="ERR_InvalidOptionStrict" xml:space="preserve">
    <value>Po instrukcji Option Strict może wystąpić jedynie opcja On lub Off.</value>
  </data>
  <data name="WRN_NamespaceCaseMismatch3_Title" xml:space="preserve">
    <value>Niezgodna wielkość liter w nazwie przestrzeni nazw</value>
  </data>
  <data name="ERR_IndirectUnreferencedAssembly4" xml:space="preserve">
    <value>Projekt „{0}” wykonuje pośrednie odwołanie do zestawu „{1}”, który zawiera element „{2}”. Dodaj do projektu odwołanie pliku do elementu „{3}”.</value>
  </data>
  <data name="ERR_VarianceOutByRefDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany w tym kontekście, ponieważ parametry typu „In” i „Out” nie mogą być używane dla typów parametrów ByRef, a „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="FEATURE_WarningDirectives" xml:space="preserve">
    <value>dyrektywy ostrzeżenia</value>
  </data>
  <data name="ERR_OverloadWithByref2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie parametrami zadeklarowanymi jako „ByRef” lub „ByVal”.</value>
  </data>
  <data name="ERR_BadModuleName" xml:space="preserve">
    <value>Nieprawidłowa nazwa modułu: {0}</value>
  </data>
  <data name="ERR_IllegalXmlStartNameChar" xml:space="preserve">
    <value>Znak „{0}” ({1}) jest niedozwolony na początku nazwy XML.</value>
  </data>
  <data name="IdentifierSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Element IdentifierSyntax nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="ERR_ConversionFromDerivedType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu pochodnego.</value>
  </data>
  <data name="ERR_InvalidAttributeUsage2" xml:space="preserve">
    <value>Nie można zastosować atrybutu „{0}” do elementu „{1}”, ponieważ atrybut nie jest prawidłowy w tym typie deklaracji.</value>
  </data>
  <data name="ERR_IfNoType" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu.</value>
  </data>
  <data name="ERR_SubRequiresSingleStatement" xml:space="preserve">
    <value>Jednowierszowe instrukcje lambda muszą zawierać dokładnie jedną instrukcję.</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags" xml:space="preserve">
    <value>Metod dostępu do właściwości nie można deklarować jako „{0}”.</value>
  </data>
  <data name="ERR_MetadataReferencesNotSupported" xml:space="preserve">
    <value>Odwołania do metadanych nie są obsługiwane.</value>
  </data>
  <data name="ERR_NewArgsDisallowedForTypeParam" xml:space="preserve">
    <value>Argumentów nie można przekazać do elementu „New” używanego w parametrze typu.</value>
  </data>
  <data name="ERR_BadDimFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest poprawny w deklaracji zmiennej elementu członkowskiego.</value>
  </data>
  <data name="NodeIsNotWithinSyntaxTree" xml:space="preserve">
    <value>Węzeł nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="WRN_ArrayInitNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu</value>
  </data>
  <data name="ERR_UnimplementedMember3" xml:space="preserve">
    <value>Element {0} „{1}” musi implementować element „{2}” dla interfejsu „{3}”.</value>
  </data>
  <data name="ERR_NoCallableOverloadCandidates2" xml:space="preserve">
    <value>Ustalanie przeciążenia nie powiodło się, ponieważ brak jest dostępnego elementu „{0}”, który można wywołać z tymi argumentami: {1}</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch_Title" xml:space="preserve">
    <value>Przełącznik wiersza polecenia nie jest jeszcze zaimplementowany</value>
  </data>
  <data name="ERR_AutoPropertyInitializedInStructure" xml:space="preserve">
    <value>Automatycznie implementowany obiekt Properties zawarty w obiekcie Structures nie może mieć inicjatorów, chyba że są oznaczone jako „Shared”.</value>
  </data>
  <data name="WRN_UnobservedAwaitableDelegate" xml:space="preserve">
    <value>Zadanie zwrócone z tej funkcji asynchronicznej zostanie porzucone i wszelkie zawarte w nim wyjątki zostaną zignorowane. Rozważ zmianę tej funkcji na procedurę asynchroniczną, tak aby jej wyjątki były propagowane.</value>
  </data>
  <data name="ERR_MethodAlreadyImplemented2" xml:space="preserve">
    <value>Nie można zaimplementować elementu „{0}.{1}” więcej niż raz.</value>
  </data>
  <data name="ERR_NamedParamArrayArgument" xml:space="preserve">
    <value>Nie można dopasować nazwanego argumentu do parametru ParamArray.</value>
  </data>
  <data name="ERR_DuplicatePrefix" xml:space="preserve">
    <value>Prefiks przestrzeni nazw XML „{0}” jest już zadeklarowany.</value>
  </data>
  <data name="ERR_GotoIntoFor" xml:space="preserve">
    <value>Instrukcja „GoTo {0}” jest nieprawidłowa, ponieważ element „{0}” znajduje się wewnątrz instrukcji „For” lub „For Each”, która nie zawiera tej instrukcji.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefStr_Title" xml:space="preserve">
    <value>Zmienna została użyta przed przypisaniem do niej wartości</value>
  </data>
  <data name="ERR_ComClassRequiresPublicClass1" xml:space="preserve">
    <value>Nie można zastosować elementu „Microsoft.VisualBasic.ComClassAttribute” do elementu „{0}”, ponieważ nie jest on zadeklarowany jako „Public”.</value>
  </data>
  <data name="ERR_ComClassRequiresPublicClass2" xml:space="preserve">
    <value>Nie można zastosować elementu „Microsoft.VisualBasic.ComClassAttribute” do elementu „{0}”, ponieważ jego kontener „{1}” nie jest zadeklarowany jako „Public”.</value>
  </data>
  <data name="WRN_UnreachableCode" xml:space="preserve">
    <value>Wykryto nieosiągalny kod.</value>
  </data>
  <data name="ERR_IterationVariableShadowLocal1" xml:space="preserve">
    <value>Zmienna zakresu „{0}” ukrywa zmienną w otaczającym bloku lub zmiennej zakresu wcześniej zdefiniowanej w wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_IterationVariableShadowLocal2" xml:space="preserve">
    <value>Zmienna zakresu „{0}” ukrywa zmienną w otaczającym bloku, w uprzednio zdefiniowanej zmiennej zakresu lub w niejawnie zadeklarowanej zmiennej w wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_AmbiguousAcrossInterfaces3" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny w obrębie odziedziczonych interfejsów „{1}” i „{2}”.</value>
  </data>
  <data name="ERR_CantCallIIF" xml:space="preserve">
    <value>Operatora „If” nie można użyć w instrukcji „Call”.</value>
  </data>
  <data name="ERR_LambdaNotCreatableDelegate1" xml:space="preserve">
    <value>Wyrażenia lambda nie można przekonwertować na typ „{0}”, ponieważ typ „{0}” jest zadeklarowany jako „MustInherit” i nie można go utworzyć.</value>
  </data>
  <data name="ERR_CaseNoSelect" xml:space="preserve">
    <value>Instrukcja Case może wystąpić tylko wewnątrz instrukcji Select Case.</value>
  </data>
  <data name="WRN_XMLDocCrefToTypeParameter" xml:space="preserve">
    <value>Komentarz XML ma tag z atrybutem „cref” „{0}”, który jest wiązany z parametrem typu. Zamiast tego użyj tagu &lt;typeparamref&gt;.</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropVal1_Title" xml:space="preserve">
    <value>Właściwość nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_InvInsideProc" xml:space="preserve">
    <value>Instrukcja nie jest prawidłowa wewnątrz metody.</value>
  </data>
  <data name="ERR_InvInsideEnum" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści wyliczenia.</value>
  </data>
  <data name="ERR_IllegalOperandInIIFCount" xml:space="preserve">
    <value>Operator „If” wymaga dwóch lub trzech argumentów.</value>
  </data>
  <data name="ERR_AmbiguousInNamespace2" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny w przestrzeni nazw „{1}”.</value>
  </data>
  <data name="WRN_XMLDocGenericParamTagWithoutName" xml:space="preserve">
    <value>Parametr typu komentarza XML musi mieć atrybut „name”.</value>
  </data>
  <data name="ERR_ModuleMemberCantImplement" xml:space="preserve">
    <value>Elementy członkowskie w module nie mogą implementować elementów członkowskich interfejsu.</value>
  </data>
  <data name="ERR_InvalidMultipleAttributeUsageInNetModule2" xml:space="preserve">
    <value>Nie można wielokrotnie zastosować atrybutu „{0}” w elemencie „{1}”.</value>
  </data>
  <data name="ERR_ImportsMustBeFirst" xml:space="preserve">
    <value>Instrukcje Imports muszą znajdować się przed wszelkimi deklaracjami.</value>
  </data>
  <data name="ERR_VarianceConversionFailedIn6" xml:space="preserve">
    <value>Element „{4}” nie może zostać skonwertowany na „{5}”, ponieważ element „{0}” nie dziedziczy od „{1}”, co jest wymagane dla parametru ogólnego „In” „{2}” w „{3}”.</value>
  </data>
  <data name="ERR_ExpectedXmlEndCData" xml:space="preserve">
    <value>Oczekiwano zamykających znaków „]]&gt;” dla sekcji CDATA XML.</value>
  </data>
  <data name="WRN_RecursiveAddHandlerCall" xml:space="preserve">
    <value>Instrukcja cyklicznie wywołuje zawierający ją element „{0}” dla zdarzenia „{1}”.</value>
  </data>
  <data name="ERR_LoopDoubleCondition" xml:space="preserve">
    <value>Instrukcja Loop nie może zawierać warunku, jeśli zawiera go już odpowiadająca jej instrukcja Do.</value>
  </data>
  <data name="ERR_CannotLiftStructureMeQuery" xml:space="preserve">
    <value>Nie można używać elementów członkowskich wystąpień i elementu „Me” w wyrażeniach zapytań w strukturach.</value>
  </data>
  <data name="ERR_SharedStructMemberCannotSpecifyNew" xml:space="preserve">
    <value>Nie można zadeklarować nieudostępnionych elementów członkowskich w strukturze jako „New”.</value>
  </data>
  <data name="WRN_XMLCannotWriteToXMLDocFile2_Title" xml:space="preserve">
    <value>Nie można utworzyć pliku XML dokumentacji</value>
  </data>
  <data name="ERR_MethodMustBeFirstStatementOnLine" xml:space="preserve">
    <value>Instrukcja deklaracji metody musi być pierwszą instrukcją w wierszu logicznym.</value>
  </data>
  <data name="ERR_NamespaceNotAtNamespace" xml:space="preserve">
    <value>Instrukcje Namespace mogą wystąpić tylko na poziomie pliku lub przestrzeni nazw.</value>
  </data>
  <data name="ERR_CantReadRulesetFile" xml:space="preserve">
    <value>Błąd podczas odczytywania pliku zestawu reguł {0} — {1}</value>
  </data>
  <data name="ERR_EmbeddedExpression" xml:space="preserve">
    <value>Tutaj nie można użyć wyrażenia osadzonego.</value>
  </data>
  <data name="ERR_TypeMismatch2" xml:space="preserve">
    <value>Nie można przekonwertować wartości typu „{0}” na „{1}”.</value>
  </data>
  <data name="ERR_ExpectedAs" xml:space="preserve">
    <value>Oczekiwano klauzuli „As”.</value>
  </data>
  <data name="ERR_ExpectedEQ" xml:space="preserve">
    <value>Oczekiwano znaku „=”.</value>
  </data>
  <data name="ERR_ExpectedBy" xml:space="preserve">
    <value>Oczekiwano elementu „By”.</value>
  </data>
  <data name="ERR_ExpectedIn" xml:space="preserve">
    <value>Oczekiwano elementu „In”.</value>
  </data>
  <data name="ERR_ExpectedLT" xml:space="preserve">
    <value>Oczekiwano rozpoczynającego znaku „&lt;” dla tagu XML.</value>
  </data>
  <data name="ERR_ExpectedOn" xml:space="preserve">
    <value>Oczekiwano operatora „On”.</value>
  </data>
  <data name="ERR_WithEventsAsStruct" xml:space="preserve">
    <value>Zmienne „WithEvents” można określać tylko jako klasy, interfejsy lub parametry typu z ograniczeniami klasy.</value>
  </data>
  <data name="ERR_DuplicateReferenceStrong" xml:space="preserve">
    <value>Zostało zaimportowanych wiele zestawów o równoważnej tożsamości: „{0}” i „{1}”. Usuń jedno ze zduplikowanych odwołań.</value>
  </data>
  <data name="WRN_XMLDocIllegalTagOnElement2_Title" xml:space="preserve">
    <value>Tag komentarza XML nie jest dozwolony w elemencie języka</value>
  </data>
  <data name="ERR_OneOrTwoParametersRequired1" xml:space="preserve">
    <value>Operator „{0}” musi mieć jeden lub dwa parametry.</value>
  </data>
  <data name="ERR_MissingRemoveHandlerDef1" xml:space="preserve">
    <value>Brak definicji elementu „RemoveHandler” dla zdarzenia „{0}”.</value>
  </data>
  <data name="ERR_InvInsideBlock" xml:space="preserve">
    <value>Instrukcja nie jest prawidłowa w ramach bloku „{0}”.</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeNotValidForFields" xml:space="preserve">
    <value>Niezarządzany typ „{0}” jest nieprawidłowy dla pól.</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor3_Title" xml:space="preserve">
    <value>Metoda dostępu do właściwości jest przestarzała</value>
  </data>
  <data name="ERR_PublicKeyContainerFailure" xml:space="preserve">
    <value>Błąd podczas wyodrębniania klucza publicznego z kontenera „{0}”: {1}</value>
  </data>
  <data name="ERR_OverloadCandidate2" xml:space="preserve">
    <value>
    „{0}”: {1}</value>
  </data>
  <data name="ERR_OverloadCandidate1" xml:space="preserve">
    <value>
    {0}</value>
  </data>
  <data name="ERR_InheritanceAccessMismatch5" xml:space="preserve">
    <value>Element „{0}” nie może dziedziczyć po elemencie {1} „{2}”, ponieważ rozszerza on dostęp podstawowego elementu {1} do {3} „{4}”.</value>
  </data>
  <data name="ERR_XmlFeaturesNotAvailable" xml:space="preserve">
    <value>Literały XML i właściwości osi XML są niedostępne. Dodaj odwołania do zestawów System.Xml, System.Xml.Linq i System.Core lub innych zestawów deklarujących typy System.Linq.Enumerable, System.Xml.Linq.XElement, System.Xml.Linq.XName, System.Xml.Linq.XAttribute i System.Xml.Linq.XNamespace.</value>
  </data>
  <data name="ERR_LanguageVersion" xml:space="preserve">
    <value>Język Visual Basic {0} nie obsługuje {1}.</value>
  </data>
  <data name="ERR_ShadowingTypeOutsideClass1" xml:space="preserve">
    <value>Nie można zadeklarować elementu „{0}” jako „Shadows” poza klasą, strukturą lub interfejsem.</value>
  </data>
  <data name="ERR_GenericSubMainsFound1" xml:space="preserve">
    <value>Żadna z dostępnych metod „Main” z odpowiednią sygnaturą znalezionych w elemencie „{0}” nie może być metodą startową, ponieważ są one metodami ogólnymi lub zagnieżdżonymi w typach ogólnych.</value>
  </data>
  <data name="WRN_ConstraintsFailedForInferredArgs2_Title" xml:space="preserve">
    <value>Argumenty typu wywnioskowane dla metody powodują ostrzeżenia</value>
  </data>
  <data name="FEATURE_DigitSeparators" xml:space="preserve">
    <value>separatory cyfr</value>
  </data>
  <data name="ERR_ObsoleteRedimAs" xml:space="preserve">
    <value>Nie można już używać instrukcji ReDim do deklarowania zmiennych tablicowych.</value>
  </data>
  <data name="ERR_ExtensionAttributeInvalid" xml:space="preserve">
    <value>Niestandardowo zaprojektowana wersja klasy „System.Runtime.CompilerServices.ExtensionAttribute” odnaleziona przez kompilator jest nieprawidłowa. Jej flagi użycia atrybutów należy ustawić tak, aby zezwalały na zestawy, klasy i metody.</value>
  </data>
  <data name="TypeArgumentCannotBeNothing" xml:space="preserve">
    <value>Argument typu nie może mieć wartości Nothing</value>
  </data>
  <data name="ERR_ConflictingMachineModule" xml:space="preserve">
    <value>Zestaw i moduł „{0}” nie mogą wskazywać różnych procesorów.</value>
  </data>
  <data name="ERR_AnonymousTypeNeedField" xml:space="preserve">
    <value>Typ anonimowy musi zawierać co najmniej jeden element członkowski.</value>
  </data>
  <data name="ERR_InvInsideEndsEvent" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści zdarzenia. Założono koniec zdarzenia.</value>
  </data>
  <data name="ERR_InitWithMultipleDeclarators" xml:space="preserve">
    <value>Jawne inicjowanie nie jest dozwolone, gdy wiele zmiennych zadeklarowano za pomocą jednego specyfikatora typu.</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall4_Title" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” powinna być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ konstruktor w klasie podstawowej został oznaczony jako przestarzały</value>
  </data>
  <data name="FEATURE_CoContraVariance" xml:space="preserve">
    <value>wariancja</value>
  </data>
  <data name="ERR_InterfaceNoDefault1" xml:space="preserve">
    <value>Nie można zaindeksować elementu „{0}”, ponieważ nie ma on domyślnej właściwości.</value>
  </data>
  <data name="ERR_ConstraintClashIndirectDirect3" xml:space="preserve">
    <value>Ograniczenie pośrednie „{0}” uzyskane z ograniczenia parametru typu „{1}” powoduje konflikt z ograniczeniem „{2}”.</value>
  </data>
  <data name="ERR_DuplicateResourceName1" xml:space="preserve">
    <value>Nie można użyć nazwy zasobu „{0}” więcej niż raz.</value>
  </data>
  <data name="ERR_MissingLibInDeclare" xml:space="preserve">
    <value>Oczekiwano instrukcji Lib.</value>
  </data>
  <data name="ERR_AmbiguousInNamespaces2" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny między deklaracjami w przestrzeniach nazw „{1}”.</value>
  </data>
  <data name="WRN_InvalidAssemblyName" xml:space="preserve">
    <value>Odwołanie do zestawu „{0}” jest nieprawidłowe i nie można go rozpoznać.</value>
  </data>
  <data name="ERR_DuplicateAccessCategoryUsed" xml:space="preserve">
    <value>Można określić tylko jeden z modyfikatorów: Public, Private, Protected, Friend lub Protected Friend.</value>
  </data>
  <data name="WRN_LambdaPassedToRemoveHandler_Title" xml:space="preserve">
    <value>Wyrażenie lambda nie zostanie usunięte z tej procedury obsługi zdarzeń</value>
  </data>
  <data name="ERR_DuplicateModifierCategoryUsed" xml:space="preserve">
    <value>Można określić tylko jeden z modyfikatorów: NotOverridable, MustOverride lub Overridable.</value>
  </data>
  <data name="ERR_InvalidFileAlignment" xml:space="preserve">
    <value>Nieprawidłowe wyrównanie sekcji pliku „{0}”</value>
  </data>
  <data name="WRN_RecursivePropertyCall" xml:space="preserve">
    <value>Wyrażenie cyklicznie wywołuje zawierającą je właściwość „{0}”.</value>
  </data>
  <data name="ERR_ReservedXmlNamespace" xml:space="preserve">
    <value>Nie można powiązać prefiksu „{0}” z nazwą przestrzeni nazw zastrzeżoną dla elementu „{1}”.</value>
  </data>
  <data name="ERR_ExpectedDotAfterMyBase" xml:space="preserve">
    <value>Po elemencie „MyBase” musi wystąpić znak „.” i identyfikator.</value>
  </data>
  <data name="ERR_BadAsyncReturnOperand1" xml:space="preserve">
    <value>Ze względu na to, że jest to metoda asynchroniczna, zwracane wyrażenie musi być typu „{0}”, a nie typu „Task(Of {0})”.</value>
  </data>
  <data name="ERR_SynthMemberClashesWithSynth7" xml:space="preserve">
    <value>Element {0} „{1}” niejawnie definiuje element „{2}”, który powoduje konflikt z elementem członkowskim zadeklarowanym niejawnie dla elementu {3} „{4}” w elemencie {5} „{6}”.</value>
  </data>
  <data name="ERR_BadChecksumAlgorithm" xml:space="preserve">
    <value>Algorytm „{0}” nie jest obsługiwany</value>
  </data>
  <data name="ERR_NamedArgUsedTwice3" xml:space="preserve">
    <value>Parametr „{0}” metody rozszerzenia „{1}” zdefiniowanej w elemencie „{2}” ma już pasujący argument.</value>
  </data>
  <data name="ERR_NamedArgUsedTwice2" xml:space="preserve">
    <value>Parametr „{0}” („{1}”) ma już zgodny argument.</value>
  </data>
  <data name="ERR_NamedArgUsedTwice1" xml:space="preserve">
    <value>Parametr „{0}” ma już pasujący argument.</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly_Title" xml:space="preserve">
    <value>Celem przywołanego zestawu jest inny procesor</value>
  </data>
  <data name="ERR_HandlesSyntaxInClass" xml:space="preserve">
    <value>Element „Handles” w klasach musi określać zmienną „WithEvents”, „MyBase”, „MyClass” lub „Me” kwalifikowaną za pomocą pojedynczego identyfikatora.</value>
  </data>
  <data name="ERR_BinaryParamMustBeContainingType1" xml:space="preserve">
    <value>Co najmniej jeden parametr tego operatora binarnego musi być typu zawierającego „{0}”.</value>
  </data>
  <data name="ERR_ExtensionMethodNoParams" xml:space="preserve">
    <value>Metody rozszerzenia muszą deklarować co najmniej jeden parametr. Pierwszy parametr określa typ do rozszerzenia.</value>
  </data>
  <data name="FEATURE_AsyncExpressions" xml:space="preserve">
    <value>metody asynchroniczne lub wyrażenia lambda</value>
  </data>
  <data name="ERR_BadFlagsOnNew1" xml:space="preserve">
    <value>Nie można zadeklarować elementu „Sub New” jako „{0}”.</value>
  </data>
  <data name="ERR_ExpectedSubOrFunction" xml:space="preserve">
    <value>Oczekiwano instrukcji Sub lub Function po instrukcji Delegate.</value>
  </data>
  <data name="ERR_BadFlagsOnSharedMeth1" xml:space="preserve">
    <value>Nie można łączyć instrukcji „Shared” z elementem „{0}” w deklaracji metody.</value>
  </data>
  <data name="WRN_MissingAsClauseinOperator" xml:space="preserve">
    <value>Operator bez klauzuli As; przyjęto typ Object.</value>
  </data>
  <data name="WRN_OverrideType5" xml:space="preserve">
    <value>Element {0} „{1}” powoduje konflikt z elementem {2} „{1}” w podstawowym elemencie {3} „{4}” i powinien być zadeklarowany jako „Shadows”.</value>
  </data>
  <data name="WRN_ImplicitConversionSubst1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_ContinueDoNotWithinDo" xml:space="preserve">
    <value>Element Continue Do może się znajdować tylko w instrukcji Do.</value>
  </data>
  <data name="ERR_OverrideWithOptional2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się parametrami opcjonalnymi.</value>
  </data>
  <data name="ERR_InheritsTypeArgAccessMismatch7" xml:space="preserve">
    <value>Element „{0}” nie może dziedziczyć po elemencie {1} „{2}”, ponieważ rozszerza on dostęp do typu „{3}” do elementu {4} „{5}”.</value>
  </data>
  <data name="ERR_TooLongOrComplexExpression" xml:space="preserve">
    <value>Wyrażenie jest zbyt długie lub zbyt złożone do skompilowania</value>
  </data>
  <data name="WRN_MutableGenericStructureInUsing" xml:space="preserve">
    <value>Zmienna lokalna „{0}” jest tylko do odczytu. Gdy jej typ jest strukturą, wywoływanie jej elementów członkowskich lub przekazywanie jej przez odwołanie (ByRef) nie zmienia jej zawartości i może prowadzić do nieoczekiwanych wyników. Rozważ zadeklarowanie tej zmiennej poza blokiem „Using”.</value>
  </data>
  <data name="ERR_AmbiguousImplementsMember3" xml:space="preserve">
    <value>Element „{0}” istnieje w wielu interfejsach podstawowych. Użyj nazwy interfejsu deklarującego element „{0}” w klauzuli „Implements” zamiast nazwy interfejsu pochodnego.</value>
  </data>
  <data name="ERR_InvalidInstrumentationKind" xml:space="preserve">
    <value>Nieprawidłowy rodzaj instrumentacji: {0}</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpVal1" xml:space="preserve">
    <value>Operator „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Czy nie brakuje instrukcji „Return”?</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpRef1" xml:space="preserve">
    <value>Operator „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Podczas wykonywania może wystąpić wyjątek pustej referencji, gdy zostanie użyty wynik.</value>
  </data>
  <data name="ERR_NamespaceNotAllowedInScript" xml:space="preserve">
    <value>W kodzie skryptu nie można zadeklarować przestrzeni nazw</value>
  </data>
  <data name="ERR_BadFlagsOnNewOverloads" xml:space="preserve">
    <value>Słowo kluczowe „{0}” służy do przeciążania dziedziczonych elementów członkowskich; nie należy używać słowa kluczowego „{0}” do przeciążania elementu „Sub New”.</value>
  </data>
  <data name="ERR_QueryAnonTypeFieldXMLNameInference" xml:space="preserve">
    <value>Nie można wywnioskować nazwy zmiennej zakresu na podstawie identyfikatora XML, który nie jest prawidłowym identyfikatorem języka Visual Basic.</value>
  </data>
  <data name="ERR_XmlEndElementNoMatchingStart" xml:space="preserve">
    <value>Końcowy element XML musi być poprzedzony zgodnym elementem początkowym.</value>
  </data>
  <data name="IDS_MSG_ADDLINKREFERENCE" xml:space="preserve">
    <value>Dodawanie osadzonego odwołania do zestawu „{0}”</value>
  </data>
  <data name="WRN_AsyncLacksAwaits_Title" xml:space="preserve">
    <value>W tej metodzie asynchronicznej brakuje operatorów „Await” — zostanie ona uruchomiona synchronicznie</value>
  </data>
  <data name="WRN_UseSwitchInsteadOfAttribute_Title" xml:space="preserve">
    <value>Użyj opcji wiersza polecenia /keyfile, /keycontainer lub /delaysign zamiast AssemblyKeyFileAttribute, AssemblyKeyNameAttribute lub AssemblyDelaySignAttribute</value>
  </data>
  <data name="ERR_NoAccessibleConstructorOnBase" xml:space="preserve">
    <value>Klasa „{0}” nie ma dostępnego elementu „Sub New” i nie może być dziedziczona.</value>
  </data>
  <data name="ERR_NoConstructorOnBase2" xml:space="preserve">
    <value>Klasa „{0}” musi mieć deklarację elementu „Sub New”, ponieważ jej klasa podstawowa „{1}” nie ma dostępnego elementu „Sub New”, który można wywołać bez argumentów.</value>
  </data>
  <data name="ERR_VarianceInterfaceNesting" xml:space="preserve">
    <value>Wyliczenia, klasy i struktury nie mogą być deklarowane w interfejsie mającym parametr typu „In” lub „Out”.</value>
  </data>
  <data name="WRN_RecursiveOperatorCall_Title" xml:space="preserve">
    <value>Wyrażenie rekursywnie wywołuje zawierający je operator</value>
  </data>
  <data name="WRN_XMLDocBadGenericParamTag2_Title" xml:space="preserve">
    <value>Parametr typu komentarza XML jest niezgodny z parametrem typu w odpowiedniej instrukcji deklaracji</value>
  </data>
  <data name="ERR_StructureNoDefault1" xml:space="preserve">
    <value>Nie można indeksować struktury „{0}”, ponieważ nie ma ona domyślnej właściwości.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu, ponieważ nie można konwertować ich na jeden typ. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”, ponieważ nie można konwertować ich na ten sam typ. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoBest2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”, ponieważ nie można konwertować ich na ten sam typ. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_BadIsCompletedOnCompletedGetResult2" xml:space="preserve">
    <value>Element „Await” wymaga, aby zwracany typ „{0}” metody „{1}.GetAwaiter()” miał odpowiednie elementy członkowskie IsCompleted, OnCompleted i GetResult oraz implementował interfejs INotifyCompletion lub ICriticalNotifyCompletion.</value>
  </data>
  <data name="ERR_AmbiguousWidestType3" xml:space="preserve">
    <value>Typ „{0}” jest niejednoznaczny, ponieważ granice pętli i klauzula step nie są konwertowane na ten sam typ.</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncVal1" xml:space="preserve">
    <value>Funkcja „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Czy nie brakuje instrukcji „Return”?</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncRef1" xml:space="preserve">
    <value>Funkcja „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Podczas wykonywania może wystąpić wyjątek pustej referencji, gdy zostanie użyty wynik.</value>
  </data>
  <data name="ERR_UnsupportedConstant2" xml:space="preserve">
    <value>Pole „{0}.{1}” ma nieprawidłową wartość stałej.</value>
  </data>
  <data name="ERR_DelegateBindingMismatch" xml:space="preserve">
    <value>Metoda nie ma sygnatury zgodnej z delegatem.</value>
  </data>
  <data name="ERR_ModuleCantUseEventSpecifier1" xml:space="preserve">
    <value>Zdarzenia w module nie mogą być zadeklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_VoidValue" xml:space="preserve">
    <value>Wyrażenie nie zwraca wartości.</value>
  </data>
  <data name="ERR_CmdOptionConflictsSource" xml:space="preserve">
    <value>Atrybut „{0}” podany w pliku źródłowym jest w konflikcie z opcją „{1}”.</value>
  </data>
  <data name="ERR_ArrayInitializerTooFewDimensions" xml:space="preserve">
    <value>Inicjator tablicy ma za mało wymiarów.</value>
  </data>
  <data name="ERR_RestrictedResumableType1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako parametr typu dla metody Iterator lub Async.</value>
  </data>
  <data name="ERR_ConvertArrayMismatch4" xml:space="preserve">
    <value>Nie można przekonwertować wartości typu „{0}” na „{1}”, ponieważ element „{2}” nie pochodzi od elementu „{3}”.</value>
  </data>
  <data name="ERR_CannotLiftByRefParamLambda1" xml:space="preserve">
    <value>Nie można użyć parametru ByRef „{0}” w wyrażeniu lambda.</value>
  </data>
  <data name="ERR_InheritsFrom2" xml:space="preserve">
    <value>
    Element „{0}” dziedziczy po elemencie „{1}”.</value>
  </data>
  <data name="ERR_DllImportNotLegalOnEventMethod" xml:space="preserve">
    <value>Elementu System.Runtime.InteropServices.DllImportAttribute nie można zastosować do metody AddHandler, RemoveHandler ani RaiseEvent.</value>
  </data>
  <data name="WRN_LateBindingResolution_Title" xml:space="preserve">
    <value>Rozpoznawanie późnego wiązania</value>
  </data>
  <data name="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage" xml:space="preserve">
    <value>Połączone metadane modułu netmodule muszą określać pełny obraz PE: „{0}”.</value>
  </data>
  <data name="ERR_BadIteratorByRefParam" xml:space="preserve">
    <value>Metody iteracyjne nie mogą mieć parametrów ByRef.</value>
  </data>
  <data name="ERR_VarianceOutPropertyDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako typ właściwości w tym kontekście, ponieważ „{0}” jest parametrem typu „Out”, a ta właściwość nie jest oznaczona jako ReadOnly.</value>
  </data>
  <data name="ERR_QuotedEmbeddedExpression" xml:space="preserve">
    <value>Wyrażenie osadzone nie może występować wewnątrz wartości atrybutu umieszczonej w cudzysłowie. Spróbuj usunąć znaki cudzysłowu.</value>
  </data>
  <data name="ERR_ExtensionOnlyAllowedOnModuleSubOrFunction" xml:space="preserve">
    <value>Atrybut „Extension” można stosować tylko w deklaracjach „Module”, „Sub” lub „Function”.</value>
  </data>
  <data name="WRN_ArrayInitTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu, ponieważ możliwe jest użycie więcej niż jednego typu</value>
  </data>
  <data name="RangeVariableSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Element RangeVariableSyntax nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant1_Title" xml:space="preserve">
    <value>Główna przestrzeń nazw jest niezgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_BadTypeArgForStructConstraintNull" xml:space="preserve">
    <value>Typ „{0}” musi być typem wartości lub typem argumentu ograniczonym do elementu „Structure”, aby można go było używać z modyfikatorem „Nullable” lub modyfikatorem dopuszczającym wartość null „?”.</value>
  </data>
  <data name="ERR_DuplicateLocalTypes3" xml:space="preserve">
    <value>Nie można osadzić typu międzyoperacyjnego „{0}” znalezionego w zestawie „{1}” i „{2}”. Rozważ wyłączenie osadzenia typów międzyoperacyjnych.</value>
  </data>
  <data name="HDN_UnusedImportClause" xml:space="preserve">
    <value>Nieużywana klauzula importu.</value>
  </data>
  <data name="WRN_UseSwitchInsteadOfAttribute" xml:space="preserve">
    <value>Użyj opcji wiersza polecenia „{0}” lub odpowiednich ustawień projektu zamiast elementu „{1}”.</value>
  </data>
  <data name="WRN_InheritedInterfaceNotCLSCompliant2" xml:space="preserve">
    <value>Element „{0}” jest niezgodny ze specyfikacją CLS, ponieważ interfejs „{1}”, po którym dziedziczy, jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="WRN_XMLMissingFileOrPathAttribute1_Title" xml:space="preserve">
    <value>Tag komentarza XML „include” musi mieć atrybuty „file” i „path”</value>
  </data>
  <data name="ERR_UnsupportedField1" xml:space="preserve">
    <value>Pole „{0}” jest nieobsługiwanego typu.</value>
  </data>
  <data name="ERR_BadDocumentationMode" xml:space="preserve">
    <value>Podany tryb dokumentacji jest nieobsługiwany lub nieprawidłowy: „{0}”.</value>
  </data>
  <data name="NotAVbSymbol" xml:space="preserve">
    <value>Nie jest to symbol języka Visual Basic.</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant2" xml:space="preserve">
    <value>Nazwa „{0}” w głównej przestrzeni nazw „{1}” jest niezgodna ze specyfikacją CLS.</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant1" xml:space="preserve">
    <value>Główna przestrzeń nazw „{0}” jest niezgodna ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_LoopControlMustNotAwait" xml:space="preserve">
    <value>Zmienna sterująca pętli nie może zawierać słowa kluczowego „Await”.</value>
  </data>
  <data name="WRN_DefAsgNoRetValWinRtEventVal1_Title" xml:space="preserve">
    <value>Element AddHandler dla zdarzenia środowiska uruchomieniowego systemu Windows nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_DuplicateRawGenericTypeImport1" xml:space="preserve">
    <value>Typ ogólny „{0}” nie może zostać zaimportowany więcej niż raz.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch_Title" xml:space="preserve">
    <value>Nazwa elementu krotki została zignorowana, ponieważ element docelowy przypisania określa inną nazwę lub nie określa żadnej nazwy.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title" xml:space="preserve">
    <value>Przywoływany zestaw nie ma silnej nazwy</value>
  </data>
  <data name="ERR_PropertyNameConflictInMyCollection" xml:space="preserve">
    <value>Element „{0}” ma taką samą nazwę jak element członkowski użyty dla typu „{1}” ujawniony w grupie „My”. Zmień nazwę typu lub obejmującej go przestrzeni nazw.</value>
  </data>
  <data name="ERR_NameNotEvent2" xml:space="preserve">
    <value>Element „{0}” nie jest zdarzeniem elementu „{1}”.</value>
  </data>
  <data name="ERR_ConstantStringTooLong" xml:space="preserve">
    <value>Długość stałej typu String przekracza bieżący limit pamięci. Spróbuj podzielić ciąg na wiele stałych.</value>
  </data>
  <data name="ERR_ParamArrayIllegal1" xml:space="preserve">
    <value>Parametrów „{0}” nie można zadeklarować jako „ParamArray”.</value>
  </data>
  <data name="WRN_ReferencedAssemblyDoesNotHaveStrongName" xml:space="preserve">
    <value>Przywoływany zestaw „{0}” nie ma silnej nazwy.</value>
  </data>
  <data name="ERR_ImplementationMustBePrivate2" xml:space="preserve">
    <value>Metoda „{0}” musi być zadeklarowana jako „Private”, aby mogła implementować metodę częściową „{1}”.</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlagsRestrict" xml:space="preserve">
    <value>Modyfikator dostępu „{0}” jest nieprawidłowy. Modyfikator dostępu elementu „Get” i „Set” powinien być bardziej restrykcyjny niż poziom dostępu do właściwości.</value>
  </data>
  <data name="ERR_InheritsFromRestrictedType1" xml:space="preserve">
    <value>Dziedziczenie po typie „{0}” jest niepoprawne.</value>
  </data>
  <data name="ERR_IconFileAndWin32ResFile" xml:space="preserve">
    <value>nie można jednocześnie określić parametrów /win32icon i /win32resource</value>
  </data>
  <data name="FEATURE_AutoProperties" xml:space="preserve">
    <value>właściwości zaimplementowane automatycznie</value>
  </data>
  <data name="FEATURE_PartialInterfaces" xml:space="preserve">
    <value>interfejsy częściowe</value>
  </data>
  <data name="WRN_XMLDocBadParamTag2_Title" xml:space="preserve">
    <value>Parametr komentarza XML jest niezgodny z parametrem w odpowiedniej instrukcji deklaracji</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w tym kontekście, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_DefaultMissingFromProperty2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ tylko jeden z nich jest zadeklarowany jako „Default”.</value>
  </data>
  <data name="ERR_EncodinglessSyntaxTree" xml:space="preserve">
    <value>Nie można wyemitować informacji debugowania dla tekstu źródłowego bez kodowania.</value>
  </data>
  <data name="ERR_BaseMismatchForPartialClass3" xml:space="preserve">
    <value>Klasa podstawowa „{0}” określona dla klasy „{1}” nie może się różnić od klasy podstawowej „{2}” jednego z jej pozostałych typów częściowych.</value>
  </data>
  <data name="ERR_DuplicateAggrMemberInit1" xml:space="preserve">
    <value>Wiele operacji inicjowania elementu „{0}”. W wyrażeniu inicjatora obiektów pola i właściwości mogą być inicjowane tylko raz.</value>
  </data>
  <data name="ERR_ExitSelectNotWithinSelect" xml:space="preserve">
    <value>Instrukcja Exit Select może wystąpić tylko wewnątrz instrukcji Select.</value>
  </data>
  <data name="ERR_IfNoTypeObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu, a ustawienie Option Strict On nie pozwala przyjąć obiektu „Object”.</value>
  </data>
  <data name="ERR_AmbiguousInUnnamedNamespace1" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny.</value>
  </data>
  <data name="ERR_LibNotFound" xml:space="preserve">
    <value>nie można znaleźć biblioteki „{0}”</value>
  </data>
  <data name="WRN_MustOverloadBase4_Title" xml:space="preserve">
    <value>Element członkowski zasłania element członkowski z możliwością przeciążenia zadeklarowany w typie podstawowym</value>
  </data>
  <data name="ERR_DefaultValueForNonOptionalParam" xml:space="preserve">
    <value>Nie można podać wartości domyślnych dla parametrów, które nie są zadeklarowane jako Optional.</value>
  </data>
  <data name="ERR_DateToDoubleConversion" xml:space="preserve">
    <value>Konwersja typu Date na typ Double wymaga wywołania metody Date.ToOADate.</value>
  </data>
  <data name="WRN_EventDelegateTypeNotCLSCompliant2_Title" xml:space="preserve">
    <value>Typ delegowania zdarzenia jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_CannotLiftStructureMeLambda" xml:space="preserve">
    <value>Nie można używać elementów członkowskich wystąpień i elementu „Me” w wyrażeniach lambda w strukturach.</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeQuery" xml:space="preserve">
    <value>Nie można użyć wystąpienia typu ograniczonego „{0}” w wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_InvalidEndRaiseEvent" xml:space="preserve">
    <value>Element „End RaiseEvent” musi być poprzedzony odpowiadającą mu deklaracją „RaiseEvent”.</value>
  </data>
  <data name="ERR_QueryOperatorNotFound" xml:space="preserve">
    <value>Definicja metody „{0}” jest niedostępna w tym kontekście.</value>
  </data>
  <data name="ERR_InaccessibleMember3" xml:space="preserve">
    <value>Element „{0}.{1}” nie jest dostępny w tym kontekście, ponieważ jest to element „{2}”.</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor2" xml:space="preserve">
    <value>Metoda dostępu „{0}” elementu „{1}” jest przestarzała.</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor3" xml:space="preserve">
    <value>Metoda dostępu „{0}” elementu „{1}” jest przestarzała: „{2}”.</value>
  </data>
  <data name="ERR_VarianceInNullableDisallowed2" xml:space="preserve">
    <value>Typ „{0}” nie może być używany w elemencie „{1}”, ponieważ parametry typu „In” i „Out” nie mogą dopuszczać wartości null, a „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="ERR_InValidSubMainsFound1" xml:space="preserve">
    <value>W elemencie „{0}” nie odnaleziono dostępnej metody „Main” z odpowiednią sygnaturą.</value>
  </data>
  <data name="ERR_TypeFwdCycle2" xml:space="preserve">
    <value>Element „{0}” w zestawie „{1}” został przesłany dalej do samego siebie, i dlatego jest nieobsługiwanym typem.</value>
  </data>
  <data name="WRN_AssemblyGeneration0_Title" xml:space="preserve">
    <value>Wykryto potencjalny problem podczas kompilowania zestawu</value>
  </data>
  <data name="ERR_BadInterfacePropertyFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji właściwości interfejsu.</value>
  </data>
  <data name="ERR_ExtensionMethodOverloadCandidate2" xml:space="preserve">
    <value>
    Metoda rozszerzenia „{0}” zdefiniowana w elemencie „{1}”.</value>
  </data>
  <data name="ERR_ExtensionMethodOverloadCandidate3" xml:space="preserve">
    <value>
    Metoda rozszerzenia „{0}” zdefiniowana w elemencie „{1}”: {2}</value>
  </data>
  <data name="WRN_ObjectAssumedVar1_Title" xml:space="preserve">
    <value>Deklaracja zmiennej bez klauzuli „As”</value>
  </data>
  <data name="WRN_XMLDocOnAPartialType" xml:space="preserve">
    <value>Komentarza XML nie można zastosować więcej niż raz w częściowym elemencie {0}. Komentarze XML dla tego elementu {0} zostaną zignorowane.</value>
  </data>
  <data name="IDS_MSG_ADDMODULE" xml:space="preserve">
    <value>Dodawanie odwołania do modułu „{0}”</value>
  </data>
  <data name="ERR_LambdaTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu, ponieważ jest możliwy więcej niż jeden typ. Rozważ dodanie klauzuli „As” w celu określenia zwracanego typu.</value>
  </data>
  <data name="WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title" xml:space="preserve">
    <value>Przestrzeń nazw lub typ zaimportowany na poziomie projektu nie zawiera publicznych elementów członkowskich lub nie można go odnaleźć</value>
  </data>
  <data name="ERR_ForwardedTypesConflict" xml:space="preserve">
    <value>Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” przesłanym do zestawu „{3}”.</value>
  </data>
  <data name="ERR_NoGetProperty1" xml:space="preserve">
    <value>Właściwość „{0}” jest tylko do zapisu.</value>
  </data>
  <data name="ERR_ComClassCantBeAbstract0" xml:space="preserve">
    <value>Nie można zastosować elementu „Microsoft.VisualBasic.ComClassAttribute” do klasy, która jest zadeklarowana jako „MustInherit”.</value>
  </data>
  <data name="WRN_GenericConstraintNotCLSCompliant1" xml:space="preserve">
    <value>Typ ograniczenia parametru ogólnego „{0}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_ParamArrayRank" xml:space="preserve">
    <value>Parametr ParamArray musi być tablicą jednowymiarową.</value>
  </data>
  <data name="ERR_NullPropagatingOpInExpressionTree" xml:space="preserve">
    <value>Nie można przekonwertować operatora propagowania wartości null na drzewo wyrażenia.</value>
  </data>
  <data name="ERR_DllImportOnInstanceMethod" xml:space="preserve">
    <value>Elementu System.Runtime.InteropServices.DllImportAttribute nie można zastosować do metody wystąpienia.</value>
  </data>
  <data name="ERR_EndOperatorExpected" xml:space="preserve">
    <value>Oczekiwano elementu „End Operator”.</value>
  </data>
  <data name="WRN_XMLDocParseError1" xml:space="preserve">
    <value>Błąd analizowania dokumentacji XML: komentarz XML {0} zostanie zignorowany.</value>
  </data>
  <data name="ERR_OverridingPropertyKind2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się ustawieniem „ReadOnly” lub „WriteOnly”.</value>
  </data>
  <data name="WRN_XMLDocParseError1_Title" xml:space="preserve">
    <value>Błąd analizowania dokumentacji XML</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicit1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu.</value>
  </data>
  <data name="ERR_MissingRaiseEventDef1" xml:space="preserve">
    <value>Brak definicji elementu „RaiseEvent” dla zdarzenia „{0}”.</value>
  </data>
  <data name="ERR_PartialDeclarationImplements1" xml:space="preserve">
    <value>W metodzie częściowej „{0}” nie można używać słowa kluczowego „Implements”.</value>
  </data>
  <data name="WRN_UndefinedOrEmptyNamespaceOrClass1_Title" xml:space="preserve">
    <value>Przestrzeń nazw lub typ określony w instrukcji Imports nie zawiera publicznych elementów członkowskich lub nie można go odnaleźć</value>
  </data>
  <data name="ERR_NoPartialMethodInAddressOf1" xml:space="preserve">
    <value>Nie można zastosować wyrażenia „AddressOf” do metody „{0}”, ponieważ „{0}” jest metodą częściową bez implementacji.</value>
  </data>
  <data name="ERR_AttrAssignmentNotFieldOrProp1" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako parametru w specyfikatorze atrybutu, ponieważ nie jest to pole ani właściwość.</value>
  </data>
  <data name="ERR_OnlyOneImplementingMethodAllowed3" xml:space="preserve">
    <value>Metoda „{0}” nie może implementować metody częściowej „{1}”, ponieważ już implementuje ją metoda „{2}”. Tylko jedna metoda może implementować metodę częściową.</value>
  </data>
  <data name="ERR_AccessMismatchImplementedEvent4" xml:space="preserve">
    <value>Element „{0}” nie może ujawnić podstawowego typu delegowanego „{1}” zdarzenia, które implementuje poza projektem za pomocą elementu {2} „{3}”.</value>
  </data>
  <data name="ERR_AccessMismatchImplementedEvent6" xml:space="preserve">
    <value>Element „{0}” nie może ujawnić podstawowego typu delegowanego „{1}” zdarzenia, które implementuje w elemencie {2} „{3}” za pomocą elementu {4} „{5}”.</value>
  </data>
  <data name="ERR_StrictDisallowsObjectOperand1" xml:space="preserve">
    <value>Ustawienie Option Strict On nie zezwala na stosowanie argumentów typu Object dla operatora „{0}”.</value>
  </data>
  <data name="ERR_ExpectedEndSelect" xml:space="preserve">
    <value>Instrukcja Select Case musi być zakończona odpowiadającą jej instrukcją End Select.</value>
  </data>
  <data name="ERR_AutoPropertyCantBeWriteOnly" xml:space="preserve">
    <value>Automatycznie implementowane właściwości nie mogą być tylko do odczytu.</value>
  </data>
  <data name="ERR_DllImportOnGenericSubOrFunction" xml:space="preserve">
    <value>Nie można zastosować elementu „System.Runtime.InteropServices.DllImportAttribute” do metody ogólnej lub zawartej w typie ogólnym.</value>
  </data>
  <data name="ERR_InheritanceAccessMismatchOutside3" xml:space="preserve">
    <value>Element „{0}” nie może dziedziczyć po elemencie {1} „{2}”, ponieważ rozszerza on dostęp podstawowego elementu {1} poza zestaw.</value>
  </data>
  <data name="WRN_MissingAsClauseinProperty_Title" xml:space="preserve">
    <value>Właściwość bez klauzuli „As”</value>
  </data>
  <data name="ERR_SxSIndirectRefHigherThanDirectRef3" xml:space="preserve">
    <value>Projekt obecnie zawiera odwołania do więcej niż jednej wersji elementu {0}, bezpośrednie odwołanie do wersji {2} i pośrednie odwołanie do wersji {1}. Zmień odwołanie bezpośrednie tak, aby używana w nim była wersja {1} (lub wyższa) elementu {0}.</value>
  </data>
  <data name="ERR_EndFunctionExpected" xml:space="preserve">
    <value>Oczekiwano instrukcji End Function.</value>
  </data>
  <data name="ERR_GotoIntoSyncLock" xml:space="preserve">
    <value>Instrukcja „GoTo {0}” jest nieprawidłowa, ponieważ element „{0}” znajduje się wewnątrz instrukcji „SyncLock”, która nie zawiera tej instrukcji.</value>
  </data>
  <data name="ERR_ExpressionDoesntHaveName" xml:space="preserve">
    <value>To wyrażenie nie ma nazwy.</value>
  </data>
  <data name="WRN_IfTooManyTypesObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu, ponieważ jest możliwy więcej niż jeden typ; przyjęto „Object”.</value>
  </data>
  <data name="ERR_ExpectedStringLiteral" xml:space="preserve">
    <value>Oczekiwano stałej w postaci ciągu.</value>
  </data>
  <data name="ERR_UnsupportedEvent1" xml:space="preserve">
    <value>Element „{0}” jest nieobsługiwanym zdarzeniem.</value>
  </data>
  <data name="ERR_OperatorRequiresIntegerParameter1" xml:space="preserve">
    <value>Operator „{0}” musi mieć drugi parametr typu „Integer” lub „Integer?”.</value>
  </data>
  <data name="ERR_BadAttributeUuid2" xml:space="preserve">
    <value>Nie można zastosować elementu „{0}”, ponieważ format identyfikatora GUID „{1}” jest niepoprawny.</value>
  </data>
  <data name="ERR_UsingResourceVarCantBeArray" xml:space="preserve">
    <value>Typ zmiennej zasobu „Using” nie może być typem tablicowym.</value>
  </data>
  <data name="ERR_MixingWinRTAndNETEvents" xml:space="preserve">
    <value>Zdarzenie „{0}” nie może implementować zdarzenia wykonawczego systemu Windows „{1}” i zwykłego zdarzenia platformy .NET „{2}”.</value>
  </data>
  <data name="ERR_LoopControlMustNotBeProperty" xml:space="preserve">
    <value>Zmienna sterująca pętli nie może być właściwością ani tablicą indeksowaną z późnym wiązaniem.</value>
  </data>
  <data name="ERR_PropertyDoesntImplementAllAccessors" xml:space="preserve">
    <value>Elementy „{0}” nie mogą zostać zaimplementowane przez właściwość {1}.</value>
  </data>
  <data name="ERR_ImplementsGenericParam" xml:space="preserve">
    <value>Parametr typu niedozwolony w klauzuli Implements.</value>
  </data>
  <data name="ERR_FinallyNoMatchingTry" xml:space="preserve">
    <value>Instrukcja Finally nie może wystąpić poza instrukcją Try.</value>
  </data>
  <data name="ERR_EndWithWithoutWith" xml:space="preserve">
    <value>Instrukcja End With musi być poprzedzona odpowiadającą jej instrukcją With.</value>
  </data>
  <data name="WRN_XMLDocInvalidXMLFragment_Title" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML</value>
  </data>
  <data name="ERR_ExpectedEndRegion" xml:space="preserve">
    <value>Instrukcja #Region musi być zakończona odpowiadającą jej instrukcją #End Region.</value>
  </data>
  <data name="ERR_LocalNamedSameAsParam1" xml:space="preserve">
    <value>Element „{0}” jest już zadeklarowany jako parametr tej metody.</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Typ przesłany „{0}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</value>
  </data>
  <data name="ERR_ExpectedCase" xml:space="preserve">
    <value>Instrukcje i etykiety nie są prawidłowe między instrukcją Select Case a pierwszą instrukcją Case.</value>
  </data>
  <data name="ERR_ExpectedInto" xml:space="preserve">
    <value>Oczekiwano operatora „Into”.</value>
  </data>
  <data name="ERR_ExpectedFrom" xml:space="preserve">
    <value>Oczekiwano instrukcji „From”.</value>
  </data>
  <data name="ERR_ExpectedLoop" xml:space="preserve">
    <value>Instrukcja Do musi być zakończona odpowiadającą jej instrukcją Loop.</value>
  </data>
  <data name="ERR_ExpectedJoin" xml:space="preserve">
    <value>Oczekiwano operatora „Join”.</value>
  </data>
  <data name="ERR_ExpectedNext" xml:space="preserve">
    <value>Instrukcja For musi być zakończona odpowiadającą jej instrukcją Next.</value>
  </data>
  <data name="ERR_MultipleExtends" xml:space="preserve">
    <value>Instrukcja Inherits może wystąpić tylko raz w instrukcji Class i może określać tylko jedną klasę.</value>
  </data>
  <data name="ERR_IllegalXmlnsPrefix" xml:space="preserve">
    <value>W nazwach elementów nie można używać prefiksu „xmlns”.</value>
  </data>
  <data name="NoNoneSearchCriteria" xml:space="preserve">
    <value>Oczekiwano elementu SearchCriteria.</value>
  </data>
  <data name="ERR_BadAttributePropertyType1" xml:space="preserve">
    <value>Właściwość lub pole „{0}” nie ma prawidłowego typu atrybutu.</value>
  </data>
  <data name="ERR_EncNoPIAReference" xml:space="preserve">
    <value>Nie można kontynuować, ponieważ edycja zawiera odwołanie do typu osadzonego: „{0}”</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression" xml:space="preserve">
    <value>Ponieważ to wywołanie nie jest oczekiwane, wykonywanie bieżącej metody będzie kontynuowane do czasu ukończenia wywołania. Rozważ zastosowanie operatora Await do wyniku wywołania.</value>
  </data>
  <data name="ERR_TypeNotExpression1" xml:space="preserve">
    <value>Element „{0}” jest typem i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation" xml:space="preserve">
    <value>Drzewo składni do przeanalizowania nie może należeć do drzewa składni bieżącej kompilacji.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidAction" xml:space="preserve">
    <value>Atrybut zabezpieczeń „{0}” ma nieprawidłową wartość SecurityAction: „{1}”.</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong" xml:space="preserve">
    <value>Lokalna nazwa „{0}” jest za długa dla pliku PDB. Rozważ skrócenie jej lub skompilowanie bez opcji /debug.</value>
  </data>
  <data name="WRN_IgnoreModuleManifest_Title" xml:space="preserve">
    <value>Opcja /win32manifest została zignorowana</value>
  </data>
  <data name="ERR_OmittedArgument2" xml:space="preserve">
    <value>Nie określono argumentu dla parametru „{0}” elementu „{1}”.</value>
  </data>
  <data name="ERR_OmittedArgument3" xml:space="preserve">
    <value>Nie określono argumentu dla parametru „{0}” metody rozszerzenia „{1}” zdefiniowanej w elemencie „{2}”.</value>
  </data>
  <data name="ERR_OmittedArgument1" xml:space="preserve">
    <value>Nie określono parametru dla argumentu „{0}”.</value>
  </data>
  <data name="WRN_UnobservedAwaitableExpression_Title" xml:space="preserve">
    <value>To wywołanie nie jest oczekiwane, dlatego wykonywanie bieżącej metody będzie kontynuowane do czasu ukończenia wywołania</value>
  </data>
  <data name="ERR_RefAndClassTypeConstrCombined" xml:space="preserve">
    <value>Nie można łączyć ograniczenia Class i określonego ograniczenia typu klasy.</value>
  </data>
  <data name="ERR_ForEachAmbiguousIEnumerable1" xml:space="preserve">
    <value>Element „For Each” w typie „{0}” jest niejednoznaczny, ponieważ typ implementuje wiele wystąpień elementu „System.Collections.Generic.IEnumerable(Of T)”.</value>
  </data>
  <data name="FEATURE_NullPropagatingOperator" xml:space="preserve">
    <value>operacje warunkowe o wartości null</value>
  </data>
  <data name="WRN_NonCLSMustOverrideInCLSType1_Title" xml:space="preserve">
    <value>Niezgodny ze specyfikacją CLS element członkowski „MustOverride” jest niedozwolony w typie zgodnym ze specyfikacją CLS</value>
  </data>
  <data name="ERR_MethodTypeArgsUnexpected" xml:space="preserve">
    <value>Nieoczekiwane argumenty typu metody.</value>
  </data>
  <data name="ERR_Merge_conflict_marker_encountered" xml:space="preserve">
    <value>Napotkano znacznik konfliktu scalania</value>
  </data>
  <data name="ERR_PlatformDoesntSupport" xml:space="preserve">
    <value>Element {0} nie jest obsługiwany w bieżącym typie projektu.</value>
  </data>
  <data name="NumberOfTypeParametersAndArgumentsMustMatch" xml:space="preserve">
    <value>liczba parametrów typu i argumentów typu powinna być taka sama</value>
  </data>
  <data name="WRN_InvalidWarningId_Title" xml:space="preserve">
    <value>Nie można skonfigurować numeru ostrzeżenia lub numer jest nieprawidłowy</value>
  </data>
  <data name="ERR_StaticInLambda" xml:space="preserve">
    <value>Nie można deklarować statycznych zmiennych lokalnych wewnątrz wyrażeń lambda.</value>
  </data>
  <data name="ERR_GenericArgsOnAttributeSpecifier" xml:space="preserve">
    <value>Argumenty typu są nieprawidłowe, ponieważ atrybuty nie mogą być ogólne.</value>
  </data>
  <data name="ERR_TooLongMetadataName" xml:space="preserve">
    <value>Długość nazwy „{0}” przekracza maksymalną długość dozwoloną w metadanych.</value>
  </data>
  <data name="ERR_PublicSignNetModule" xml:space="preserve">
    <value>Publiczne podpisywanie nie jest obsługiwane w przypadku modułów sieciowych.</value>
  </data>
  <data name="WRN_UseValueForXmlExpression3" xml:space="preserve">
    <value>Nie można przekonwertować elementu „{0}” na „{1}”. Przy użyciu właściwości „Value” można uzyskać wartość ciągu pierwszego elementu obiektu „{2}”.</value>
  </data>
  <data name="ERR_BadStaticLocalInStruct" xml:space="preserve">
    <value>W metodach struktur nie można deklarować zmiennych lokalnych jako „Static”.</value>
  </data>
  <data name="ERR_StructLayoutAttributeNotAllowed" xml:space="preserve">
    <value>Nie można zastosować atrybutu „StructLayout” do typu ogólnego.</value>
  </data>
  <data name="ERR_CantOverrideNotOverridable2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ jest on zadeklarowany jako „NotOverridable”.</value>
  </data>
  <data name="ChainingSpeculativeModelIsNotSupported" xml:space="preserve">
    <value>Tworzenie łańcuchów spekulacyjnego modelu semantycznego nie jest obsługiwane. Należy utworzyć model spekulacyjny z nadrzędnego modelu niespekulacyjnego.</value>
  </data>
  <data name="ERR_GotoIntoUsing" xml:space="preserve">
    <value>Instrukcja „GoTo {0}” jest nieprawidłowa, ponieważ element „{0}” znajduje się wewnątrz instrukcji „Using”, która nie zawiera tej instrukcji.</value>
  </data>
  <data name="ERR_LambdaNoTypeObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu. Rozważ dodanie klauzuli „As” w celu określenia zwracanego typu.</value>
  </data>
  <data name="ERR_BadAttribute1" xml:space="preserve">
    <value>Atrybut „{0}” jest niepoprawny: niepoprawna wartość argumentu.</value>
  </data>
  <data name="ERR_ExpectedExitKind" xml:space="preserve">
    <value>Po instrukcji „Exit” musi występować instrukcja „Sub”, „Function”, „Property”, „Do”, „For”, „While”, „Select” lub „Try”.</value>
  </data>
  <data name="ERR_RequiredNewCall2" xml:space="preserve">
    <value>Pierwsza instrukcja w tym elemencie „Sub New” musi być wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ klasa podstawowa „{0}” klasy „{1}” nie ma dostępnego elementu „Sub New”, który można wywoływać bez argumentów.</value>
  </data>
  <data name="ERR_ExportedTypesConflict" xml:space="preserve">
    <value>Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</value>
  </data>
  <data name="ERR_DelegateCantImplement" xml:space="preserve">
    <value>Obiekty delegatów nie mogą implementować metod interfejsu.</value>
  </data>
  <data name="ERR_EndModuleNoModule" xml:space="preserve">
    <value>Instrukcja End Module musi być poprzedzona odpowiadającą jej instrukcją Module.</value>
  </data>
  <data name="ERR_NeedModule" xml:space="preserve">
    <value>opcję /moduleassemblyname można określić tylko w przypadku kompilowania elementu docelowego typu „module”</value>
  </data>
  <data name="WRN_InvalidWarningId" xml:space="preserve">
    <value>numeru ostrzeżenia „{0}” dla opcji „{1}” nie można skonfigurować lub jest on nieprawidłowy</value>
  </data>
  <data name="ERR_InterfaceUnifiesWithBase3" xml:space="preserve">
    <value>Nie można dziedziczyć interfejsu „{0}”, ponieważ może on być taki sam jak interfejs „{1}”, po którym dziedziczy interfejs „{2}” dla niektórych argumentów typu.</value>
  </data>
  <data name="ERR_OfExpected" xml:space="preserve">
    <value>Wymagany element „Of” podczas określania argumentów typu dla typu ogólnego lub metody ogólnej.</value>
  </data>
  <data name="ERR_ResumableLambdaInExpressionTree" xml:space="preserve">
    <value>Wyrażeń lambda z modyfikatorami „Async” i „Iterator” nie można konwertować na drzewa wyrażeń.</value>
  </data>
  <data name="ERR_InvalidOverrideDueToReturn2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ różnią się one zwracanym typem.</value>
  </data>
  <data name="ERR_BadGetAwaiterMethod1" xml:space="preserve">
    <value>Element „Await” wymaga, aby typ „{0}” miał odpowiednią metodę GetAwaiter.</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu, ponieważ jest możliwy więcej niż jeden typ. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”, ponieważ możliwe jest użycie więcej niż jednego typu. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailureAmbiguous3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”, ponieważ możliwe jest użycie więcej niż jednego typu. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”, ponieważ możliwe jest użycie więcej niż jednego typu.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”, ponieważ możliwe jest użycie więcej niż jednego typu.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitAmbiguous1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu, ponieważ jest możliwy więcej niż jeden typ.</value>
  </data>
  <data name="ERR_TryAndOnErrorDoNotMix" xml:space="preserve">
    <value>Metoda nie może zawierać jednocześnie instrukcji Try i instrukcji On Error lub Resume.</value>
  </data>
  <data name="ERR_IsNotOperatorGenericParam1" xml:space="preserve">
    <value>Argument operacji „IsNot” typu „{0}” można porównać tylko z elementem „Nothing”, ponieważ element „{0}” jest parametrem typu bez ograniczenia klasy.</value>
  </data>
  <data name="ERR_StartupCodeNotFound1" xml:space="preserve">
    <value>Nie odnaleziono instrukcji „Sub Main” w elemencie „{0}”.</value>
  </data>
  <data name="ERR_AgnosticToMachineModule" xml:space="preserve">
    <value>Zestaw agnostyczny nie może mieć modułu specyficznego dla procesora „{0}”.</value>
  </data>
  <data name="WRN_ConstraintsFailedForInferredArgs2" xml:space="preserve">
    <value>Argumenty typu wywnioskowane dla metody „{0}” powodują wystąpienie następujących ostrzeżeń: {1}.</value>
  </data>
  <data name="ERR_RecordCycle2" xml:space="preserve">
    <value>Struktura „{0}” nie może zawierać wystąpienia samej siebie: {1}.</value>
  </data>
  <data name="ERR_ReturnWithoutValue" xml:space="preserve">
    <value>Instrukcja Return w bloku Function, Get lub Operator musi zwracać wartość.</value>
  </data>
  <data name="WRN_XMLDocReturnsOnWriteOnlyProperty_Title" xml:space="preserve">
    <value>Tag komentarza XML „returns” jest niedozwolony we właściwości „WriteOnly”</value>
  </data>
  <data name="ERR_RequiredConstExpr" xml:space="preserve">
    <value>Wymagane jest wyrażenie stałe.</value>
  </data>
  <data name="ERR_DuplicateResourceFileName1" xml:space="preserve">
    <value>Każdy połączony zasób oraz moduł muszą mieć unikatową nazwę pliku. Nazwa pliku „{0}” jest określona więcej niż jeden raz w tym zestawie.</value>
  </data>
  <data name="ERR_CantCombineInitializers" xml:space="preserve">
    <value>Nie można łączyć inicjatora obiektu i inicjatora kolekcji w tej samej inicjacji.</value>
  </data>
  <data name="ERR_InaccessibleSymbol2" xml:space="preserve">
    <value>Element „{0}” nie jest dostępny w tym kontekście, ponieważ jest to element „{1}”.</value>
  </data>
  <data name="ERR_StrictDisallowImplicitObject" xml:space="preserve">
    <value>Ustawienie Option Strict On wymaga, aby wszystkie deklaracje zmiennych miały klauzulę „As”.</value>
  </data>
  <data name="WRN_CannotFindStandardLibrary1_Title" xml:space="preserve">
    <value>Nie można odnaleźć biblioteki standardowej</value>
  </data>
  <data name="ERR_IllegalCondTypeInIIF" xml:space="preserve">
    <value>Typem pierwszego argumentu operacji w binarnym wyrażeniu „If” musi być typ dopuszczający wartość null lub typ referencyjny.</value>
  </data>
  <data name="ERR_ConstraintCycle2" xml:space="preserve">
    <value>Parametru typu „{0}” nie można ograniczyć do niego samego: {1}.</value>
  </data>
  <data name="ERR_TypeConflict6" xml:space="preserve">
    <value>Element {0} „{1}” i {2} „{3}” powoduje konflikt w elemencie {4} „{5}”.</value>
  </data>
  <data name="ERR_BadEventFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji zdarzenia.</value>
  </data>
  <data name="WRN_ProcTypeNotCLSCompliant1_Title" xml:space="preserve">
    <value>Zwracany typ funkcji jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_DllImportOnResumableMethod" xml:space="preserve">
    <value>Atrybutu „System.Runtime.InteropServices.DllImportAttribute” nie można zastosować do metody asynchronicznej ani iteracyjnej.</value>
  </data>
  <data name="ERR_StrictDisallowsImplicitArgs" xml:space="preserve">
    <value>Ustawienie Option Strict On wymaga, aby wszystkie parametry metody miały klauzulę „As”.</value>
  </data>
  <data name="ERR_StrictDisallowsImplicitProc" xml:space="preserve">
    <value>Ustawienie Option Strict On wymaga, aby wszystkie deklaracje funkcji, właściwości i operatorów miały klauzulę „As”.</value>
  </data>
  <data name="ERR_IsNestedIn2" xml:space="preserve">
    <value>
    Element „{0}” jest zagnieżdżony w elemencie „{1}”.</value>
  </data>
  <data name="ERR_BadOverloadCandidates2" xml:space="preserve">
    <value>Rozpoznanie przeciążenia nie powiodło się, ponieważ nie ma dostępnego elementu „{0}” do wywołania: {1}</value>
  </data>
  <data name="ERR_ReferenceDirectiveOnlyAllowedInScripts" xml:space="preserve">
    <value>Element #R jest dozwolony tylko w skryptach</value>
  </data>
  <data name="WRN_ObjectMath1_Title" xml:space="preserve">
    <value>Dla operatora użyto argumentów operacji typu Object</value>
  </data>
  <data name="SyntaxTreeAlreadyPresent" xml:space="preserve">
    <value>Drzewo składni już istnieje</value>
  </data>
  <data name="AggregateSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Brak elementu AggregateSyntax w drzewie składni</value>
  </data>
  <data name="ERR_NoZeroCountArgumentInitCandidates1" xml:space="preserve">
    <value>Nie można zainicjować właściwości „{0}” w wyrażeniu inicjatora obiektów, ponieważ wszystkie dostępne przeciążenia wymagają argumentów.</value>
  </data>
  <data name="ERR_InvalidOutputName" xml:space="preserve">
    <value>Nieprawidłowa nazwa wyjścia: {0}</value>
  </data>
  <data name="ERR_ExpectedXmlWhiteSpace" xml:space="preserve">
    <value>Brak wymaganych białych znaków.</value>
  </data>
  <data name="ERR_CantSpecifyTypeCharacterOnIIF" xml:space="preserve">
    <value>Wyrażenia używane w wyrażeniu „If” nie mogą zawierać znaków typu.</value>
  </data>
  <data name="ERR_BadPdbData" xml:space="preserve">
    <value>Błąd podczas odczytywania informacji dotyczących debugowania elementu „{0}”</value>
  </data>
  <data name="ERR_ExpectedSubFunction" xml:space="preserve">
    <value>Oczekiwano instrukcji Sub lub Function.</value>
  </data>
  <data name="ERR_BinaryOperands3" xml:space="preserve">
    <value>Operator „{0}” nie jest zdefiniowany dla typu „{1}” i „{2}”.</value>
  </data>
  <data name="WRN_MissingAsClauseinVarDecl" xml:space="preserve">
    <value>Deklaracja zmiennej bez klauzuli „As”; przyjęto typ Object.</value>
  </data>
  <data name="ERR_OptionalsCantBeStructGenericParams" xml:space="preserve">
    <value>Parametry ogólne używane jako opcjonalne typy parametrów muszą mieć ograniczenia klasy.</value>
  </data>
  <data name="ERR_ObsoleteLetSetNotNeeded" xml:space="preserve">
    <value>Instrukcje przypisania Let i Set nie są już obsługiwane.</value>
  </data>
  <data name="ERR_TypeInItsInheritsClause1" xml:space="preserve">
    <value>Klasa „{0}” nie może odwoływać się siebie samej w klauzuli Inherits.</value>
  </data>
  <data name="ERR_EndRegionNoRegion" xml:space="preserve">
    <value>Instrukcja #End Region musi być poprzedzona odpowiadającą jej instrukcją #Region.</value>
  </data>
  <data name="ERR_EndWhileNoWhile" xml:space="preserve">
    <value>Instrukcja End While musi być poprzedzona odpowiadającą jej instrukcją While.</value>
  </data>
  <data name="ERR_BadNullTypeInCCExpression" xml:space="preserve">
    <value>Typy dopuszczające wartości null nie są dozwolone w wyrażeniach kompilacji warunkowej.</value>
  </data>
  <data name="WRN_CannotFindStandardLibrary1" xml:space="preserve">
    <value>Nie można odnaleźć biblioteki standardowej „{0}”.</value>
  </data>
  <data name="ERR_TooManyArgs" xml:space="preserve">
    <value>Za dużo argumentów.</value>
  </data>
  <data name="ERR_ImplementsOnNew" xml:space="preserve">
    <value>Element Sub New nie może implementować elementów członkowskich interfejsu.</value>
  </data>
  <data name="ERR_DuplicateDefaultProps1" xml:space="preserve">
    <value>Element „Default” można stosować tylko do jednej nazwy właściwości w elemencie {0}.</value>
  </data>
  <data name="ERR_ClassInheritsBaseUnifiesWithInterfaces3" xml:space="preserve">
    <value>Nie można zaimplementować interfejsu „{0}”, ponieważ interfejs „{1}”, po którym ten interfejs dziedziczy, może być taki sam jak zaimplementowany interfejs „{2}” dla niektórych argumentów typu.</value>
  </data>
  <data name="WRN_AsyncSubCouldBeFunction" xml:space="preserve">
    <value>Niektóre widoczne tu przeciążenia korzystają z funkcji asynchronicznych, a nie procedur asynchronicznych. Rozważ użycie funkcji asynchronicznej albo rzutowanie tej procedury asynchronicznej jawnie na żądany typ.</value>
  </data>
  <data name="WRN_MutableStructureInUsing_Title" xml:space="preserve">
    <value>Zmienna lokalna zadeklarowana przez instrukcję Using jest przeznaczona tylko do odczytu i jej typem jest struktura</value>
  </data>
  <data name="ERR_BadAttributeNonPublicContType2" xml:space="preserve">
    <value>Nie można użyć typu „{0}” w atrybucie, ponieważ jego kontener „{1}” nie jest zadeklarowany jako „Public”.</value>
  </data>
  <data name="ERR_TupleDuplicateElementName" xml:space="preserve">
    <value>Nazwy elementów krotek muszą być unikatowe.</value>
  </data>
  <data name="WRN_BadUILang_Title" xml:space="preserve">
    <value>Nazwa języka dla parametru /preferreduilang jest nieprawidłowa</value>
  </data>
  <data name="ERR_FunctionResultCannotBeIndexed1" xml:space="preserve">
    <value>Element „{0}” nie ma parametrów, a jego typ zwracany nie może być indeksowany.</value>
  </data>
  <data name="ERR_ComClassDuplicateGuids1" xml:space="preserve">
    <value>Parametry „InterfaceId” i „EventsId” dla elementu „Microsoft.VisualBasic.ComClassAttribute” w elemencie „{0}” nie mogą mieć tej samej wartości.</value>
  </data>
  <data name="ERR_MissingNetModuleReference" xml:space="preserve">
    <value>Brak odwołania do modułu netmodule „{0}”.</value>
  </data>
  <data name="ERR_NewIfNullOnGenericParam" xml:space="preserve">
    <value>Elementu New nie można używać w parametrze typu, który nie ma ograniczenia New.</value>
  </data>
  <data name="ERR_ReferenceComparison3" xml:space="preserve">
    <value>Operator „{0}” nie jest zdefiniowany dla typów „{1}” i „{2}”. Użyj operatora „Is”, aby porównać dwa typy referencyjne.</value>
  </data>
  <data name="FEATURE_LineContinuation" xml:space="preserve">
    <value>niejawna kontynuacja wiersza</value>
  </data>
  <data name="ERR_NoUniqueConstructorOnBase2" xml:space="preserve">
    <value>Klasa „{0}” musi mieć deklarację elementu „Sub New”, ponieważ jej klasa podstawowa „{1}” ma więcej niż jeden dostępny element „Sub New”, który można wywołać bez argumentów.</value>
  </data>
  <data name="WRN_ImplicitConversionCopyBack" xml:space="preserve">
    <value>Niejawna konwersja z „{1}” na „{2}” podczas kopiowania wartości parametru „ByRef” „{0}” z powrotem do pasującego argumentu.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRefStr" xml:space="preserve">
    <value>Zmienna „{0}” jest przekazywana przez odwołanie, zanim zostanie do niej przypisana wartość. Podczas wykonywania może wystąpić wyjątek pustej referencji. Upewnij się, że struktura lub wszystkie elementy członkowskie odwołania są zainicjowane przed użyciem</value>
  </data>
  <data name="ERR_ObsoleteArgumentsNeedParens" xml:space="preserve">
    <value>Argumenty metod muszą być ujęte w nawiasy.</value>
  </data>
  <data name="WRN_IndirectRefToLinkedAssembly2_Title" xml:space="preserve">
    <value>Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego z powodu pośredniego odwołania do tego zestawu</value>
  </data>
  <data name="WRN_LiftControlVariableQuery_Title" xml:space="preserve">
    <value>Użycie zmiennej iteracji w wyrażeniu zapytania może mieć nieoczekiwane skutki</value>
  </data>
  <data name="ERR_CannotUseGenericTypeAcrossAssemblyBoundaries" xml:space="preserve">
    <value>Typ „{0}” nie może być używany między granicami zestawu, ponieważ ma argument typu ogólnego, który jest osadzonym typem międzyoperacyjnym.</value>
  </data>
  <data name="ERR_CannotLinkClassWithNoPIA1" xml:space="preserve">
    <value>Odwołanie do klasy „{0}” jest niedozwolone, gdy jej zestaw jest skonfigurowany do osadzania typów międzyoperacyjnych.</value>
  </data>
  <data name="ERR_VarianceInPropertyDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako typ właściwości w tym kontekście, ponieważ „{0}” jest parametrem typu „In”, a właściwość nie jest oznaczona jako WriteOnly.</value>
  </data>
  <data name="WRN_DefaultnessShadowed4_Title" xml:space="preserve">
    <value>Wystąpił konflikt właściwości domyślnej z właściwością domyślną w typie podstawowym</value>
  </data>
  <data name="ERR_ExitTryNotWithinTry" xml:space="preserve">
    <value>Instrukcja Exit Try może wystąpić tylko wewnątrz instrukcji Try.</value>
  </data>
  <data name="ERR_ExitPropNot" xml:space="preserve">
    <value>Instrukcja Exit Property nie jest prawidłowa w przypadku funkcji lub procedury.</value>
  </data>
  <data name="ERR_PermissionSetAttributeInvalidFile" xml:space="preserve">
    <value>Nie można rozpoznać ścieżki do pliku „{0}” określonej dla nazwanego argumentu „{1}” dla atrybutu PermissionSet.</value>
  </data>
  <data name="WRN_RefCultureMismatch" xml:space="preserve">
    <value>Przywoływany zestaw „{0}” ma inne ustawienie kultury — „{1}”.</value>
  </data>
  <data name="WRN_XMLCannotWriteToXMLDocFile2" xml:space="preserve">
    <value>Nie można utworzyć pliku XML dokumentacji „{0}”: {1}</value>
  </data>
  <data name="ERR_NextForMismatch1" xml:space="preserve">
    <value>Zmienna sterująca w instrukcji Next nie pasuje do zmiennej „{0}” sterującej pętlą For.</value>
  </data>
  <data name="ERR_ForLoopType1" xml:space="preserve">
    <value>Zmienna sterująca pętli „For” nie może być zmienną typu „{0}”, ponieważ ten typ nie obsługuje wymaganych operatorów.</value>
  </data>
  <data name="ERR_DuplicateProcDefWithDifferentTupleNames2" xml:space="preserve">
    <value>Element „{0}” ma wiele definicji z identycznymi sygnaturami z różnymi nazwami elementów krotki, w tym „{1}”.</value>
  </data>
  <data name="FEATURE_SubLambdas" xml:space="preserve">
    <value>Wyrażenia lambda „Sub”</value>
  </data>
  <data name="WRN_BadSwitch_Title" xml:space="preserve">
    <value>Nierozpoznana opcja wiersza polecenia</value>
  </data>
  <data name="Trees0" xml:space="preserve">
    <value>trees({0})</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedForGeneric4" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{2}” w „{3}” w tym kontekście, ponieważ zarówno kontekst, jak i definicja elementu „{0}” są zagnieżdżone w obrębie interfejsu „{1}”, a „{1}” ma parametry typu „In” lub „Out”. Rozważ przeniesienie definicji „{0}” poza interfejs „{1}”.</value>
  </data>
  <data name="ERR_UnableToOpenResourceFile1" xml:space="preserve">
    <value>Nie można otworzyć pliku zasobów „{0}”: {1}.</value>
  </data>
  <data name="WRN_SharedMemberThroughInstance" xml:space="preserve">
    <value>Dostęp przez wystąpienie do udostępnionego elementu członkowskiego, stałego elementu członkowskiego, elementu członkowskiego wyliczenia lub typu zagnieżdżonego; wyrażenie kwalifikujące nie zostanie obliczone.</value>
  </data>
  <data name="WRN_IfNoTypeObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu; przyjęto „Object”.</value>
  </data>
  <data name="ERR_ReadOnlyProperty1" xml:space="preserve">
    <value>Właściwość „{0}” typu „ReadOnly” nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="ThereAreNoPointerTypesInVB" xml:space="preserve">
    <value>Brak typów wskaźnikowych w języku Visual Basic.</value>
  </data>
  <data name="ERR_ArgumentSyntax" xml:space="preserve">
    <value>Oczekiwano przecinka, znaku ) lub prawidłowej kontynuacji wyrażenia.</value>
  </data>
  <data name="ERR_DllImportOnNonEmptySubOrFunction" xml:space="preserve">
    <value>Elementu „System.Runtime.InteropServices.DllImportAttribute” nie można zastosować do elementu Sub, Function lub Operator z niepustą treścią.</value>
  </data>
  <data name="WRN_XMLDocStartTagWithNoEndTag_Title" xml:space="preserve">
    <value>Błąd analizowania dokumentacji XML: tag początkowy nie ma zgodnego tagu końcowego</value>
  </data>
  <data name="ERR_PropertyOrFieldNotDefined1" xml:space="preserve">
    <value>Nie odnaleziono pola lub właściwości „{0}”.</value>
  </data>
  <data name="WRN_SelectCaseInvalidRange" xml:space="preserve">
    <value>Zakres określony dla instrukcji „Case” jest nieprawidłowy. Upewnij się, że dolna granica jest mniejsza lub równa górnej granicy.</value>
  </data>
  <data name="ERR_RedimNoSizes" xml:space="preserve">
    <value>Instrukcja ReDim wymaga ujętej w nawiasy listy nowych granic dla każdego wymiaru tablicy.</value>
  </data>
  <data name="ERR_InvalidAttributeUsageOnAccessor" xml:space="preserve">
    <value>Nie można zastosować atrybutu „{0}” do elementu „{1}” w „{2}”, ponieważ atrybut nie jest prawidłowy w tym typie deklaracji.</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeResumable1" xml:space="preserve">
    <value>Zmienna ograniczonego typu „{0}” nie może zostać zadeklarowana w metodzie asynchronicznej lub iteratora.</value>
  </data>
  <data name="WRN_PrefixAndXmlnsLocalName" xml:space="preserve">
    <value>Zaleca się, aby atrybuty nie miały nazwy xmlns. Czy w celu zdefiniowania prefiksu o nazwie „{0}” nie miał zostać wprowadzony ciąg „xmlns:{0}”?</value>
  </data>
  <data name="ElementsCannotBeNull" xml:space="preserve">
    <value>Elementy nie mogą mieć wartości null.</value>
  </data>
  <data name="ERR_ExportedTypeConflictsWithDeclaration" xml:space="preserve">
    <value>Typ „{0}” wyeksportowany z modułu „{1}” powoduje konflikt z typem zadeklarowanym w podstawowym module tego zestawu.</value>
  </data>
  <data name="ERR_InvalidVersionFormat" xml:space="preserve">
    <value>Określony ciąg wersji nie jest zgodny z wymaganym formatem: wersja_główna[.wersja_podrzędna[.kompilacja|*[.poprawka|*]]].</value>
  </data>
  <data name="ERR_AddRemoveParamNotEventType" xml:space="preserve">
    <value>Parametry metody „AddHandler” i „RemoveHandler” muszą mieć ten sam typ delegata co zawierające je zdarzenie.</value>
  </data>
  <data name="WRN_AmbiguousCastConversion2" xml:space="preserve">
    <value>Konwersja z „{0}” na „{1}” może być niejednoznaczna.</value>
  </data>
  <data name="ERR_EventTypeNotDelegate" xml:space="preserve">
    <value>Zdarzenia deklarowane z klauzulą „As” muszą mieć typ delegata.</value>
  </data>
  <data name="ERR_ConversionToDerivedType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu na typ, który od niego pochodzi.</value>
  </data>
  <data name="ERR_ExpectedIdentifier" xml:space="preserve">
    <value>Oczekiwano identyfikatora.</value>
  </data>
  <data name="ERR_QueryStrictDisallowImplicitObject" xml:space="preserve">
    <value>Nie można wywnioskować typu zmiennej zakresu, a późne wiązanie nie jest dozwolone z ustawieniem Option Strict on. Użyj klauzuli „As”, aby określić typ.</value>
  </data>
  <data name="WRN_RootNamespaceNotCLSCompliant2_Title" xml:space="preserve">
    <value>Część głównej przestrzeni nazw jest niezgodna ze specyfikacją CLS</value>
  </data>
  <data name="ERR_FriendAssemblyBadAccessOverride2" xml:space="preserve">
    <value>Element członkowski „{0}” nie może przesłaniać elementu członkowskiego „{1}” zdefiniowanego w innym zestawie/projekcie, ponieważ modyfikator dostępu „Protected Friend” rozszerza dostępność. Zamiast niego użyj modyfikatora „Protected”.</value>
  </data>
  <data name="ERR_ParamArrayMustBeByVal" xml:space="preserve">
    <value>Parametry ParamArray muszą być zadeklarowane jako ByVal.</value>
  </data>
  <data name="WRN_RefCultureMismatch_Title" xml:space="preserve">
    <value>Przywoływany zestaw ma inne ustawienie kultury</value>
  </data>
  <data name="ERR_InvalidEndAddHandler" xml:space="preserve">
    <value>Element „End AddHandler” musi być poprzedzony odpowiadającą mu deklaracją „AddHandler”.</value>
  </data>
  <data name="ERR_TypeArgsUnexpected" xml:space="preserve">
    <value>Nieoczekiwane argumenty typu.</value>
  </data>
  <data name="ERR_CannotLiftByRefParamQuery1" xml:space="preserve">
    <value>Nie można użyć parametru ByRef „{0}” w wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_InvalidLambdaModifier" xml:space="preserve">
    <value>Tylko modyfikator „Async” lub „Iterator” jest poprawny w przypadku wyrażenia lambda.</value>
  </data>
  <data name="ERR_UndefinedXmlPrefix" xml:space="preserve">
    <value>Nie zdefiniowano prefiksu przestrzeni nazw XML „{0}”.</value>
  </data>
  <data name="ERR_TypeForwardedToMultipleAssemblies" xml:space="preserve">
    <value>Moduł „{0}” w zestawie „{1}” przekazuje typ „{2}” do wielu zestawów: „{3}” i „{4}”.</value>
  </data>
  <data name="WRN_XMLDocReturnsOnADeclareSub" xml:space="preserve">
    <value>Tag komentarza XML „returns” jest niedozwolony w elemencie języka „declare sub”.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionTypeOrMethod" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest niepoprawna dla atrybutów zabezpieczeń zastosowanych względem typu lub metody.</value>
  </data>
  <data name="ERR_PartialMethodMustBeEmpty" xml:space="preserve">
    <value>Metody częściowe muszą mieć pustą treść metody.</value>
  </data>
  <data name="WRN_MissingAsClauseinOperator_Title" xml:space="preserve">
    <value>Operator bez klauzuli „As”</value>
  </data>
  <data name="WRN_RelDelegatePassedToRemoveHandler" xml:space="preserve">
    <value>Wyrażenie „AddressOf” nie przynosi efektów w tym kontekście, ponieważ argument metody dla wyrażenia „AddressOf” wymaga swobodnej konwersji na typ delegata zdarzenia. Przypisz wyrażenie „AddressOf” do zmiennej i używaj jej do dodawania lub usuwania metody jako procedury obsługi.</value>
  </data>
  <data name="CantReferenceCompilationFromTypes" xml:space="preserve">
    <value>Nie można odwołać się do kompilacji typu „{0}” z kompilacji {1}.</value>
  </data>
  <data name="ERR_BadInterfaceDelegateSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować delegatu w interfejsie jako „{0}”.</value>
  </data>
  <data name="ERR_LocalTypeNameClash2" xml:space="preserve">
    <value>Osadzenie typu międzyoperacyjnego „{0}” z zestawu „{1}” spowoduje konflikt nazw w bieżącym zestawie. Rozważ wyłączenie osadzania typów międzyoperacyjnych.</value>
  </data>
  <data name="WRN_XMLDocNotFirstOnLine_Title" xml:space="preserve">
    <value>Komentarz XML musi być pierwszą instrukcją w wierszu</value>
  </data>
  <data name="ERR_StandaloneAttribute" xml:space="preserve">
    <value>Specyfikator atrybutu nie jest kompletną instrukcją. Użyj kontynuacji wiersza, aby zastosować atrybut do następnej instrukcji.</value>
  </data>
  <data name="ERR_SignButNoPrivateKey" xml:space="preserve">
    <value>W pliku klucza „{0}” brak klucza prywatnego wymaganego do podpisu</value>
  </data>
  <data name="ERR_VarianceConversionFailedOut6" xml:space="preserve">
    <value>Element „{4}” nie może zostać skonwertowany na „{5}”, ponieważ element „{0}” nie dziedziczy od „{1}”, co jest wymagane dla parametru ogólnego „Out” „{2}” w „{3}”.</value>
  </data>
  <data name="WRN_AmbiguousCastConversion2_Title" xml:space="preserve">
    <value>Konwersja może być niejednoznaczna</value>
  </data>
  <data name="ERR_WithEventsRequiresClass" xml:space="preserve">
    <value>Zmienne WithEvents muszą mieć klauzulę As.</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbol2_Title" xml:space="preserve">
    <value>Typ lub element członkowski jest przestarzały</value>
  </data>
  <data name="ERR_MetaDataIsNotAssembly" xml:space="preserve">
    <value>Element „{0}” jest modułem i nie można się do niego odwoływać jako do zestawu.</value>
  </data>
  <data name="ERR_EndStructureNoStructure" xml:space="preserve">
    <value>Instrukcja End Structure musi być poprzedzona odpowiadającą jej instrukcją Structure.</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncVal1_Title" xml:space="preserve">
    <value>Funkcja nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_ExpectedDotAfterGlobalNameSpace" xml:space="preserve">
    <value>Po elemencie „Global” musi wystąpić znak „.” i identyfikator.</value>
  </data>
  <data name="ERR_ArgumentRequired" xml:space="preserve">
    <value>opcja „{0}” wymaga argumentu „{1}”</value>
  </data>
  <data name="ERR_ExpectedXmlName" xml:space="preserve">
    <value>Oczekiwano nazwy XML.</value>
  </data>
  <data name="ERR_IllegalCharConstant" xml:space="preserve">
    <value>Stała znakowa musi zawierać dokładnie jeden znak.</value>
  </data>
  <data name="ERR_AddressOfNotCreatableDelegate1" xml:space="preserve">
    <value>Nie można przekonwertować wyrażenia „AddressOf” na typ „{0}”, ponieważ typ „{0}” został zadeklarowany jako „MustInherit” i nie można go utworzyć.</value>
  </data>
  <data name="ERR_CryptoHashFailed" xml:space="preserve">
    <value>Wystąpił błąd kryptograficzny w czasie tworzenia mieszań.</value>
  </data>
  <data name="FEATURE_YearFirstDateLiterals" xml:space="preserve">
    <value>literały daty z numerem roku na początku</value>
  </data>
  <data name="ERR_BadLocalDimFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest poprawny w deklaracji zmiennej lokalnej.</value>
  </data>
  <data name="ERR_BadLocalConstFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji stałej lokalnej.</value>
  </data>
  <data name="ERR_CustomEventRequiresAs" xml:space="preserve">
    <value>Modyfikator „Custom” jest nieprawidłowy w zdarzeniach deklarowanych bez jawnych typów delegata.</value>
  </data>
  <data name="ERR_BadYieldInTryHandler" xml:space="preserve">
    <value>Instrukcja „Yield” nie może być używana wewnątrz instrukcji „Catch” ani „Finally”.</value>
  </data>
  <data name="WRN_RelDelegatePassedToRemoveHandler_Title" xml:space="preserve">
    <value>Wyrażenie „AddressOf” nie przynosi efektów w tym kontekście, ponieważ argument metody dla wyrażenia „AddressOf” wymaga swobodnej konwersji na typ delegata zdarzenia</value>
  </data>
  <data name="WRN_XMLDocParamTagWithoutName_Title" xml:space="preserve">
    <value>Parametr komentarza XML musi mieć atrybut „name”</value>
  </data>
  <data name="ERR_MyBaseAbstractCall1" xml:space="preserve">
    <value>Instrukcja „MyBase” nie może być użyta z metodą „{0}”, ponieważ jest ona zadeklarowana jako „MustOverride”.</value>
  </data>
  <data name="ERR_LbExpectedEndIf" xml:space="preserve">
    <value>Blok #If musi kończyć się instrukcją #End If.</value>
  </data>
  <data name="ERR_InvInsideEndsInterface" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści interfejsu. Założono koniec interfejsu.</value>
  </data>
  <data name="ERR_NestedBase2" xml:space="preserve">
    <value>Element {0} „{1}” nie może dziedziczyć po typie, który jest w nim zagnieżdżony.</value>
  </data>
  <data name="ERR_ComClassAndReservedAttribute1" xml:space="preserve">
    <value>Nie można zastosować elementów „Microsoft.VisualBasic.ComClassAttribute” i „{0}” w tej samej klasie.</value>
  </data>
  <data name="WRN_XMLDocWithoutLanguageElement" xml:space="preserve">
    <value>Komentarze dokumentacji XML muszą występować przed deklaracjami elementu członkowskiego lub typu.</value>
  </data>
  <data name="ERR_SubRequiresParenthesesBang" xml:space="preserve">
    <value>Jednowierszowa instrukcja lambda musi być ujęta w nawiasy. Na przykład: (Sub() &lt;instrukcja&gt;)!key</value>
  </data>
  <data name="ERR_ParameterNotValidForType" xml:space="preserve">
    <value>Parametr jest nieprawidłowy dla określonego niezarządzanego typu.</value>
  </data>
  <data name="ERR_FieldHasMultipleDistinctConstantValues" xml:space="preserve">
    <value>Pole ma wiele unikatowych wartości stałych.</value>
  </data>
  <data name="IDS_LogoLine1" xml:space="preserve">
    <value>{0} w wersji {1}</value>
  </data>
  <data name="IDS_LogoLine2" xml:space="preserve">
    <value>Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.</value>
  </data>
  <data name="ERR_NoTypeArgumentCountOverloadCand1" xml:space="preserve">
    <value>Rozpoznanie przeciążenia nie powiodło się, ponieważ żaden z dostępnych elementów „{0}” nie akceptuje tej liczby argumentów typu.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidTarget" xml:space="preserve">
    <value>Atrybut zabezpieczeń „{0}” jest nieprawidłowy w tym typie deklaracji. Atrybuty zabezpieczeń są prawidłowe tylko dla deklaracji zestawu, typu i metody.</value>
  </data>
  <data name="ERR_AddParamWrongForWinRT" xml:space="preserve">
    <value>Typ parametru metody „AddHandler” musi być taki sam jak typ zdarzenia.</value>
  </data>
  <data name="ERR_EncReferenceToAddedMember" xml:space="preserve">
    <value>Dostęp do elementu członkowskiego „{0}” dodanego podczas bieżącej sesji debugowania można uzyskać tylko w deklarowanym zestawie „{1}”.</value>
  </data>
  <data name="ERR_PIAHasNoAssemblyGuid1" xml:space="preserve">
    <value>Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}”.</value>
  </data>
  <data name="WRN_NamespaceCaseMismatch3" xml:space="preserve">
    <value>Wielkość liter nazwy przestrzeni nazw „{0}” nie pasuje do wielkości liter nazwy przestrzeni nazw „{1}” w pliku „{2}”.</value>
  </data>
  <data name="WrongNumberOfTypeArguments" xml:space="preserve">
    <value>Nieprawidłowa liczba argumentów typu</value>
  </data>
  <data name="HDN_UnusedImportStatement" xml:space="preserve">
    <value>Nieużywana instrukcja importu.</value>
  </data>
  <data name="ERR_InitializerExpected" xml:space="preserve">
    <value>Oczekiwano inicjatora.</value>
  </data>
  <data name="WRN_DefAsgNoRetValWinRtEventVal1" xml:space="preserve">
    <value>Element AddHandler dla zdarzenia środowiska uruchomieniowego systemu Windows „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Czy nie brakuje instrukcji „Return”?</value>
  </data>
  <data name="HDN_UnusedImportStatement_Title" xml:space="preserve">
    <value>Nieużywana instrukcja importu</value>
  </data>
  <data name="ERR_TypeOrMemberNotGeneric2" xml:space="preserve">
    <value>Metoda rozszerzenia „{0}” zdefiniowana w elemencie „{1}” nie jest ogólna (lub nie ma parametrów typu dowolnego) i dlatego nie może mieć argumentów typu.</value>
  </data>
  <data name="ERR_TypeOrMemberNotGeneric1" xml:space="preserve">
    <value>Element „{0}” nie ma parametrów typu i dlatego nie może mieć argumentów typu.</value>
  </data>
  <data name="ERR_NoResponseFile" xml:space="preserve">
    <value>nie można otworzyć pliku odpowiedzi „{0}”</value>
  </data>
  <data name="ERR_FriendRefSigningMismatch" xml:space="preserve">
    <value>Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale silna nazwa stanu podpisywania zestawu wyjściowego nie jest zgodna z nazwą określoną przez atrybut w zestawie udzielającym dostępu.</value>
  </data>
  <data name="ERR_BadNamespaceName1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłową nazwą i nie można go użyć jako nazwy głównej przestrzeni nazw.</value>
  </data>
  <data name="ERR_ExpectedQualifiedNameInInit" xml:space="preserve">
    <value>Nazwa pola lub właściwości inicjowanej w inicjatorze obiektów musi zaczynać się od znaku „.”.</value>
  </data>
  <data name="ERR_ProtectedTypeOutsideClass" xml:space="preserve">
    <value>Typy chronione mogą być deklarowane tylko wewnątrz klasy.</value>
  </data>
  <data name="FEATURE_PartialModules" xml:space="preserve">
    <value>moduły częściowe</value>
  </data>
  <data name="WRN_MemberShadowsSynthMember6_Title" xml:space="preserve">
    <value>Wystąpił konflikt elementu członkowskiego z elementem członkowskim niejawnie zadeklarowanym dla właściwości lub zdarzenia w typie podstawowym</value>
  </data>
  <data name="ERR_InvInsideEndsEnum" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści wyliczenia. Założono koniec wyliczenia.</value>
  </data>
  <data name="ERR_InvInsideEndsProc" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści metody. Założono koniec metody.</value>
  </data>
  <data name="ERR_XmlEndCDataNotAllowedInContent" xml:space="preserve">
    <value>Ciąg literału „]]&gt;” jest niedozwolony w zawartości elementu.</value>
  </data>
  <data name="ERR_InterfaceMemberSyntax" xml:space="preserve">
    <value>Elementy członkowskie interfejsu muszą być metodami, właściwościami, zdarzeniami lub definicjami typów.</value>
  </data>
  <data name="ERR_AmbiguousInImports2" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny. Element ten został zaimportowany z przestrzeni nazw lub typów: „{1}”.</value>
  </data>
  <data name="WRN_UnimplementedCommandLineSwitch" xml:space="preserve">
    <value>Przełącznik wiersza polecenia „{0}” nie został jeszcze wdrożony i został zignorowany.</value>
  </data>
  <data name="ERR_ExpectedXmlEndPI" xml:space="preserve">
    <value>Oczekiwano zamykających znaków „?&gt;” dla instrukcji procesora XML.</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedHere2" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w elemencie „{1}” w tym kontekście, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="WRN_UseValueForXmlExpression3_Title" xml:space="preserve">
    <value>Nie można przekonwertować interfejsu IEnumerable(Of XElement) na ciąg</value>
  </data>
  <data name="ERR_BadWithEventsFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest poprawny w deklaracji WithEvents.</value>
  </data>
  <data name="ERR_InheritsTypeArgAccessMismatchOutside5" xml:space="preserve">
    <value>Element „{0}” nie może dziedziczyć po elemencie {1} „{2}”, ponieważ rozszerza on dostęp do typu „{3}” poza zestaw.</value>
  </data>
  <data name="WRN_XMLDocMoreThanOneCommentBlock_Title" xml:space="preserve">
    <value>Dozwolony jest tylko jeden blok komentarza XML na element języka</value>
  </data>
  <data name="ERR_AddressOfNullableMethod" xml:space="preserve">
    <value>Nie można używać metod typu „System.Nullable(Of T)” jako argumentów operatora „AddressOf”.</value>
  </data>
  <data name="WRN_RecursiveAddHandlerCall_Title" xml:space="preserve">
    <value>Instrukcja rekursywnie wywołuje zawierający ją element AddHandler dla zdarzenia</value>
  </data>
  <data name="WRN_ArrayInitTooManyTypesObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu, ponieważ jest możliwy więcej niż jeden typ; przyjęto „Object”.</value>
  </data>
  <data name="ERR_TypeParamNameFunctionNameCollision" xml:space="preserve">
    <value>Parametr typu nie może mieć nazwy takiej samej jak definiująca go funkcja.</value>
  </data>
  <data name="ERR_LbNoMatchingIf" xml:space="preserve">
    <value>Instrukcje #ElseIf, #Else i #End If muszą być poprzedzone odpowiadającą im instrukcją #If.</value>
  </data>
  <data name="WRN_DelaySignButNoKey_Title" xml:space="preserve">
    <value>Określono podpisywanie opóźnione wymagające klucza publicznego, ale nie określono klucza publicznego</value>
  </data>
  <data name="ERR_VBCoreNetModuleConflict" xml:space="preserve">
    <value>Nie można łączyć opcji /vbruntime* i /target:module.</value>
  </data>
  <data name="WRN_DuplicateCatch_Title" xml:space="preserve">
    <value>Blok „Catch” nie jest nigdy osiągany; typ wyjątku jest obsługiwany powyżej w tej samej instrukcji Try</value>
  </data>
  <data name="ERR_CannotEmbedInterfaceWithGeneric" xml:space="preserve">
    <value>Typ „{0}” nie może zostać osadzony, ponieważ ma argument ogólny. Rozważ wyłączenie osadzania typów międzyoperacyjnych.</value>
  </data>
  <data name="SyntaxTreeIsNotASubmission" xml:space="preserve">
    <value>Drzewo składni powinno zostać utworzone na podstawie przesłanych danych.</value>
  </data>
  <data name="ERR_IdentNotMemberOfInterface4" xml:space="preserve">
    <value>Element „{0}” nie może zaimplementować elementu „{1}”, ponieważ nie ma pasującego elementu {2} w interfejsie „{3}”.</value>
  </data>
  <data name="ERR_MethodBodyNotAtLineStart" xml:space="preserve">
    <value>Pierwsza instrukcja treści metody nie może znajdować się w tym samym wierszu co deklaracja metody.</value>
  </data>
  <data name="WRN_EqualToLiteralNothing" xml:space="preserve">
    <value>Wartością tego wyrażenia zawsze będzie Nothing (z powodu propagacji wartości null z operatora równości). Aby sprawdzać, czy wartość jest równa null, rozważ użycie warunku „Is Nothing”.</value>
  </data>
  <data name="WRN_MemberShadowsSynthMember6" xml:space="preserve">
    <value>Element {0} „{1}” powoduje konflikt z elementem członkowskim niejawnie zadeklarowanym dla elementu {2} „{3}” w podstawowym elemencie {4} „{5}” i dlatego powinien być zadeklarowany jako „Shadows”.</value>
  </data>
  <data name="ERR_SetHasOnlyOneParam" xml:space="preserve">
    <value>Metoda „Set” nie może mieć więcej parametrów niż jeden.</value>
  </data>
  <data name="ERR_HandlesInvalidOnGenericMethod" xml:space="preserve">
    <value>Metody ogólne nie mogą używać klauzuli Handles.</value>
  </data>
  <data name="ERR_NullableDisallowedForStructConstr1" xml:space="preserve">
    <value>Element „System.Nullable” nie spełnia warunków ograniczenia „Structure” dla parametru typu „{0}”. Dozwolone są tylko typy „Structure” niedopuszczające wartości null.</value>
  </data>
  <data name="ERR_AttributeOrder" xml:space="preserve">
    <value>Atrybut XML „{0}” musi występować przed atrybutem XML „{1}”.</value>
  </data>
  <data name="FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite" xml:space="preserve">
    <value>implementowanie właściwości read-only lub write-only z właściwością read-write</value>
  </data>
  <data name="ERR_TupleReservedElementNameAnyPosition" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}“ nie jest dozwolona na żadnej pozycji.</value>
  </data>
  <data name="ERR_BadModuleFile1" xml:space="preserve">
    <value>Nie można załadować pliku modułu „{0}”: {1}</value>
  </data>
  <data name="ERR_InvalidUseOfKeyword" xml:space="preserve">
    <value>Słowo kluczowe nie jest prawidłowe jako identyfikator.</value>
  </data>
  <data name="ERR_QueryNameNotDeclared" xml:space="preserve">
    <value>Nazwa „{0}” nie jest zadeklarowana lub nie znajduje się w bieżącym zakresie.</value>
  </data>
  <data name="ERR_Overflow" xml:space="preserve">
    <value>Przepełnienie.</value>
  </data>
  <data name="WRN_ComClassInterfaceShadows5_Title" xml:space="preserve">
    <value>Atrybut „Microsoft.VisualBasic.ComClassAttribute” klasy niejawnie deklaruje element członkowski pozostający w konflikcie z elementem członkowskim o tej samej nazwie</value>
  </data>
  <data name="ERR_InvalidPreprocessorConstantType" xml:space="preserve">
    <value>Stała preprocesora „{0}” typu „{1}” nie jest obsługiwana. Dozwolone są tylko typy pierwotne.</value>
  </data>
  <data name="ERR_TypeInferenceArrayRankMismatch1" xml:space="preserve">
    <value>Nie można wywnioskować typu danych dla elementu „{0}”, ponieważ wymiary tablicy nie są zgodne.</value>
  </data>
  <data name="WRN_XMLDocInsideMethod_Title" xml:space="preserve">
    <value>Komentarz XML nie może występować w metodzie ani właściwości</value>
  </data>
  <data name="ERR_BadSourceCodeKind" xml:space="preserve">
    <value>Podany rodzaj kodu źródłowego jest nieobsługiwany lub nieprawidłowy: „{0}”</value>
  </data>
  <data name="WRN_CLSMemberInNonCLSType3_Title" xml:space="preserve">
    <value>Nie można oznaczyć elementu członkowskiego jako zgodnego ze specyfikacją CLS, ponieważ jego typ zawierający jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="WRN_AsyncSubCouldBeFunction_Title" xml:space="preserve">
    <value>Niektóre widoczne tu przeciążenia korzystają z funkcji asynchronicznych, a nie procedur asynchronicznych</value>
  </data>
  <data name="ERR_UnaryParamMustBeContainingType1" xml:space="preserve">
    <value>Parametr tego operatora jednoargumentowego musi być typu zawierającego „{0}”.</value>
  </data>
  <data name="ERR_MultipleNewConstraints" xml:space="preserve">
    <value>Ograniczenie New nie może być określone wiele razy dla tego samego parametru typu.</value>
  </data>
  <data name="ERR_ForwardedTypeConflictsWithExportedType" xml:space="preserve">
    <value>Typ „{0}” przesłany do zestawu „{1}” powoduje konflikt z typem „{2}” wyeksportowanym z modułu „{3}”.</value>
  </data>
  <data name="WRN_XMLDocReturnsOnADeclareSub_Title" xml:space="preserve">
    <value>Tag komentarza XML „returns” jest niedozwolony w elemencie języka „declare sub”</value>
  </data>
  <data name="ERR_BlockLocalShadowing1" xml:space="preserve">
    <value>Zmienna „{0}” ukrywa zmienną w otaczającym bloku.</value>
  </data>
  <data name="ERR_BadTypeInCCExpression" xml:space="preserve">
    <value>Nazwy typu niewewnętrznego nie są dozwolone w wyrażeniach kompilacji warunkowej.</value>
  </data>
  <data name="ERR_CircularInference1" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu „{0}” na podstawie wyrażenia zawierającego element „{0}”.</value>
  </data>
  <data name="ERR_ConstraintIsRestrictedType1" xml:space="preserve">
    <value>Elementu „{0}” nie można użyć jako ograniczenia typu.</value>
  </data>
  <data name="ERR_NoMostSpecificOverload2" xml:space="preserve">
    <value>Ustalanie przeciążenia nie powiodło się, ponieważ brak jest dostępnego elementu „{0}”, który jest najbardziej konkretny dla tych argumentów: {1}.</value>
  </data>
  <data name="ERR_InvalidEndProperty" xml:space="preserve">
    <value>Instrukcja End Property musi być poprzedzona odpowiadającą jej instrukcją Property.</value>
  </data>
  <data name="ERR_EndDisallowedInDllProjects" xml:space="preserve">
    <value>Nie można użyć instrukcji End w projektach biblioteki klas.</value>
  </data>
  <data name="WRN_OverlappingCatch_Title" xml:space="preserve">
    <value>Blok „Catch” nie jest nigdy osiągany; typ podstawowy typu wyjątku jest obsługiwany powyżej w tej samej instrukcji Try</value>
  </data>
  <data name="WRN_TypeInferenceAssumed3_Title" xml:space="preserve">
    <value>Nie można wywnioskować typu danych</value>
  </data>
  <data name="ERR_NegativeArraySize" xml:space="preserve">
    <value>Wymiary tablicy nie mogą mieć rozmiaru ujemnego.</value>
  </data>
  <data name="ERR_ErrorCreatingWin32ResourceFile" xml:space="preserve">
    <value>Błąd podczas tworzenia zasobów Win32: {0}.</value>
  </data>
  <data name="ERR_LibAnycpu32bitPreferredConflict" xml:space="preserve">
    <value>Polecenia /platform:anycpu32bitpreferred można używać tylko z przełącznikami /t:exe, /t:winexe i /t:appcontainerexe.</value>
  </data>
  <data name="ERR_LambdaBindingMismatch1" xml:space="preserve">
    <value>Funkcja zagnieżdżona nie ma takiej samej sygnatury jak obiekt delegowany „{0}”.</value>
  </data>
  <data name="ERR_LambdaBindingMismatch2" xml:space="preserve">
    <value>Zagnieżdżony element sub nie ma sygnatury zgodnej z obiektem delegowanym „{0}”.</value>
  </data>
  <data name="ERR_InvalidEndEvent" xml:space="preserve">
    <value>Element „End Event” musi być poprzedzony odpowiadającym mu elementem „Custom Event”.</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase4_Title" xml:space="preserve">
    <value>Należy zadeklarować element „Sub New” w klasie, ponieważ konstruktor w klasie podstawowej został oznaczony jako przestarzały</value>
  </data>
  <data name="ERR_InitializerTooManyElements1" xml:space="preserve">
    <value>Inicjator tablicy ma za dużo elementów (o {0}).</value>
  </data>
  <data name="WRN_ComClassNoMembers1" xml:space="preserve">
    <value>Element „Microsoft.VisualBasic.ComClassAttribute” jest określony dla klasy „{0}”, ale klasa „{0}” nie ma publicznych elementów członkowskich, których można ujawnić w modelu COM. Z tego powodu nie wygenerowano interfejsów modelu COM.</value>
  </data>
  <data name="ERR_InvalidNameOfSubExpression" xml:space="preserve">
    <value>Nie można użyć tego podwyrażenia wewnątrz argumentu NameOf.</value>
  </data>
  <data name="ERR_VariancePreventsSynthesizedEvents2" xml:space="preserve">
    <value>Definicje zdarzeń z parametrami nie są dozwolone w interfejsie takim jak „{0}”, który ma parametry typu „In” lub „Out”. Rozważ zadeklarowanie zdarzenia przy użyciu typu delegowanego, który nie jest zdefiniowany w obrębie elementu „{0}”. Na przykład „Event {1} As Action(Of ...)”.</value>
  </data>
  <data name="ERR_MetaDataIsNotModule" xml:space="preserve">
    <value>Element „{0}” jest zestawem i nie można się do niego odwoływać jako do modułu.</value>
  </data>
  <data name="ERR_InvalidEndGet" xml:space="preserve">
    <value>Instrukcja End Get musi być poprzedzona odpowiadającą jej instrukcją Get.</value>
  </data>
  <data name="ERR_InvalidEndSub" xml:space="preserve">
    <value>Instrukcja End Sub musi być poprzedzona odpowiadającą jej instrukcją Sub.</value>
  </data>
  <data name="ERR_InvalidEndSet" xml:space="preserve">
    <value>Instrukcja End Set musi być poprzedzona odpowiadającą jej instrukcją Set.</value>
  </data>
  <data name="ERR_CannotEmbedWithoutPdb" xml:space="preserve">
    <value>Przełącznik /embed jest obsługiwany tylko w przypadku emitowania przenośnego pliku PDB (/debug:portable lub /debug:embedded).</value>
  </data>
  <data name="WRN_VarianceDeclarationAmbiguous3" xml:space="preserve">
    <value>Interfejs „{0}” jest niejednoznaczny z innym zaimplementowanym interfejsem „{1}” ze względu na parametry „In” i „Out” w „{2}”.</value>
  </data>
  <data name="ERR_OverloadWithReturnType2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie zwracanymi typami.</value>
  </data>
  <data name="FEATURE_CObjInAttributeArguments" xml:space="preserve">
    <value>CObj w argumentach atrybutów</value>
  </data>
  <data name="ERR_VarianceConversionFailedTryIn4" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ zmianę elementu „{2}” w definicji „{3}” na parametr typu In, „In {2}”.</value>
  </data>
  <data name="ERR_UnreferencedAssembly3" xml:space="preserve">
    <value>Wymagane odwołanie do zestawu „{0}” z typem „{1}”. Dodaj je do projektu.</value>
  </data>
  <data name="ERR_StructCantUseVarSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować elementów członkowskich w strukturze jako „{0}”.</value>
  </data>
  <data name="ERR_TupleElementNamesAttributeMissing" xml:space="preserve">
    <value>Nie można zdefiniować klasy lub elementu członkowskiego, który wykorzystuje krotki, ponieważ nie można znaleźć wymaganego typu kompilatora „{0}”. Czy brakuje odwołania?</value>
  </data>
  <data name="ERR_PublicKeyFileFailure" xml:space="preserve">
    <value>Błąd podczas wyodrębniania klucza publicznego z pliku „{0}”: {1}</value>
  </data>
  <data name="WRN_ArrayInitNoTypeObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu; przyjęto „Object”.</value>
  </data>
  <data name="ERR_ParameterizedPropertyInAggrInit1" xml:space="preserve">
    <value>Nie można zainicjować właściwości „{0}” w wyrażeniu inicjatora obiektów, ponieważ wymaga ona argumentów.</value>
  </data>
  <data name="FEATURE_GlobalNamespace" xml:space="preserve">
    <value>deklarowanie globalnej przestrzeni nazw</value>
  </data>
  <data name="ERR_DuplicatePropertyGet" xml:space="preserve">
    <value>Element „Get” jest już zadeklarowany.</value>
  </data>
  <data name="ERR_DuplicatePropertySet" xml:space="preserve">
    <value>Element „Set” jest już zadeklarowany.</value>
  </data>
  <data name="FEATURE_Tuples" xml:space="preserve">
    <value>krotki</value>
  </data>
  <data name="ERR_ConflictingManifestSwitches" xml:space="preserve">
    <value>Błąd podczas osadzania manifestu Win32: opcja /win32manifest powoduje konflikt z opcją /nowin32manifest.</value>
  </data>
  <data name="ERR_VarianceInParamDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w tym kontekście, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="WRN_QueryMissingAsClauseinVarDecl_Title" xml:space="preserve">
    <value>Przyjęto, że zmienna zakresu będzie typu Object, ponieważ nie można wywnioskować jej typu</value>
  </data>
  <data name="ERR_SharedOnProcThatImpl" xml:space="preserve">
    <value>Metody lub zdarzenia, które implementują elementy członkowskie interfejsu, nie mogą być zadeklarowane jako Shared.</value>
  </data>
  <data name="WRN_GenericConstraintNotCLSCompliant1_Title" xml:space="preserve">
    <value>Typ ograniczenia parametru ogólnego jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated" xml:space="preserve">
    <value>Wystąpienia analizatora {0} nie można utworzyć z elementu {1}: {2}.</value>
  </data>
  <data name="ERR_OnlyOnePartialMethodAllowed2" xml:space="preserve">
    <value>Metody „{0}” nie można zadeklarować jako „Partial”, ponieważ tylko jedną metodę „{1}” można oznaczyć jako „Partial”.</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropVal1" xml:space="preserve">
    <value>Właściwość „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Czy nie brakuje instrukcji „Return”?</value>
  </data>
  <data name="ERR_ExplicitTupleElementNamesAttribute" xml:space="preserve">
    <value>Nie można odwołać się do atrybutu „System.Runtime.CompilerServices.TupleElementNamesAttribute” jawnie. Użyj składni krotek, aby zdefiniować nazwy krotek.</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropRef1" xml:space="preserve">
    <value>Właściwość „{0}” nie zwraca wartości na wszystkich ścieżkach kodu. Podczas wykonywania może wystąpić wyjątek pustej referencji, gdy zostanie użyty wynik.</value>
  </data>
  <data name="ERR_ExpectedDotAfterMyClass" xml:space="preserve">
    <value>Po elemencie „MyClass” musi wystąpić znak „.” i identyfikator.</value>
  </data>
  <data name="ERR_EventDelegatesCantBeFunctions" xml:space="preserve">
    <value>Zdarzenia nie mogą być zadeklarowane z typem delegata, który ma zwracany typ.</value>
  </data>
  <data name="ERR_RuntimeMemberNotFound2" xml:space="preserve">
    <value>Nie można odnaleźć elementu członkowskiego „{0}” w klasie „{1}”. Ta sytuacja jest zazwyczaj wynikiem niedopasowania biblioteki „Microsoft.VisualBasic.dll”.</value>
  </data>
  <data name="ERR_PartialMethodsMustBeSub1" xml:space="preserve">
    <value>Nie można zadeklarować metody „{0}” jako „Partial”, ponieważ metody częściowe muszą być typu Sub.</value>
  </data>
  <data name="ERR_ConversionToObject" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować na element Object.</value>
  </data>
  <data name="ERR_OptionStmtWrongOrder" xml:space="preserve">
    <value>Instrukcje Option muszą występować przed wszelkimi deklaracjami i instrukcjami Imports.</value>
  </data>
  <data name="ERR_OnlyNullLowerBound" xml:space="preserve">
    <value>Dolne granice tablicy mogą mieć tylko wartość „0”.</value>
  </data>
  <data name="ERR_CannotInferNullableForVariable1" xml:space="preserve">
    <value>Nie można wywnioskować typu dopuszczającego wartość null dla zmiennej „{0}”.</value>
  </data>
  <data name="ERR_ConditionalCompilationConstantNotValid" xml:space="preserve">
    <value>Stała kompilacji warunkowej „{1}” jest nieprawidłowa: {0}</value>
  </data>
  <data name="ERR_OnlyPrivatePartialMethods1" xml:space="preserve">
    <value>Metody częściowe muszą być zadeklarowane jako „Private” zamiast „{0}”.</value>
  </data>
  <data name="ERR_ConversionToSameType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu na ten sam typ.</value>
  </data>
  <data name="ERR_ObsoleteOnGotoGosub" xml:space="preserve">
    <value>Instrukcje On GoTo i On GoSub nie są już obsługiwane.</value>
  </data>
  <data name="ERR_SourceLinkRequiresPdb" xml:space="preserve">
    <value>Przełącznik /sourcelink jest obsługiwany tylko w przypadku emitowania pliku PDB.</value>
  </data>
  <data name="ERR_VoidArrayDisallowed" xml:space="preserve">
    <value>Tablice typu „System.Void” są niedozwolone w tym wyrażeniu.</value>
  </data>
  <data name="ERR_SecurityAttributeMissingAction" xml:space="preserve">
    <value>Pierwszy argument atrybutu zabezpieczeń musi być poprawnym elementem SecurityAction.</value>
  </data>
  <data name="ERR_PartialMethodsMustNotBeAsync1" xml:space="preserve">
    <value>Nie można zadeklarować metody „{0}” jako „Partial”, ponieważ ma ona modyfikator „Async”.</value>
  </data>
  <data name="WRN_LambdaNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu</value>
  </data>
  <data name="ERR_ArrayRankLimit" xml:space="preserve">
    <value>Liczba wymiarów tablicy przekracza 32.</value>
  </data>
  <data name="IDS_FunctionReturnType" xml:space="preserve">
    <value>zwracany typ funkcji</value>
  </data>
  <data name="ERR_ValueAndClassTypeConstrCombined" xml:space="preserve">
    <value>Nie można łączyć ograniczenia Structure i określonego ograniczenia typu klasy.</value>
  </data>
  <data name="ERR_AmbiguousImplements3" xml:space="preserve">
    <value>Element członkowski „{0}.{1}” zgodny z tą sygnaturą nie może zostać zaimplementowany, ponieważ interfejs „{2}” zawiera wiele elementów członkowskich o tej samej nazwie i sygnaturze:
   „{3}”
   „{4}”</value>
  </data>
  <data name="WRN_TypeNotCLSCompliant1" xml:space="preserve">
    <value>Typ „{0}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_AttributeOnLambdaReturnType" xml:space="preserve">
    <value>Nie można stosować atrybutów do zwracanych typów wyrażeń lambda.</value>
  </data>
  <data name="ERR_ConversionFromInterfaceType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu interfejsu.</value>
  </data>
  <data name="ERR_InvalidEndOperator" xml:space="preserve">
    <value>Element „End Operator” musi być poprzedzony odpowiadającym mu elementem „Operator”.</value>
  </data>
  <data name="ERR_DuplicateWriteabilityCategoryUsed" xml:space="preserve">
    <value>Nie można łączyć elementów „ReadOnly” i „WriteOnly”.</value>
  </data>
  <data name="ERR_ConstructorNotFound1" xml:space="preserve">
    <value>Typ „{0}” nie ma konstruktorów.</value>
  </data>
  <data name="ERR_CharToIntegralTypeMismatch1" xml:space="preserve">
    <value>Nie można konwertować wartości „Char” na elementy „{0}”. Użyj elementu „Microsoft.VisualBasic.AscW”, aby zinterpretować znak jako wartość Unicode, lub elementu „Microsoft.VisualBasic.Val”, aby zinterpretować go jako cyfrę.</value>
  </data>
  <data name="ERR_AddressOfOperandNotMethod" xml:space="preserve">
    <value>Argument operacji „AddressOf” musi być nazwą metody (bez nawiasów).</value>
  </data>
  <data name="ERR_XmlPrefixNotExpression" xml:space="preserve">
    <value>Element „{0}” jest prefiksem XML i nie można go używać jako wyrażenia. Użyj operatora GetXmlNamespace, aby utworzyć obiekt przestrzeni nazw.</value>
  </data>
  <data name="ERR_UnableToCreateTempFile" xml:space="preserve">
    <value>Nie można utworzyć pliku tymczasowego: {0}</value>
  </data>
  <data name="ERR_EndSyncLockNoSyncLock" xml:space="preserve">
    <value>Instrukcja End SyncLock musi być poprzedzona odpowiadającą jej instrukcją SyncLock.</value>
  </data>
  <data name="ERR_TupleInferredNamesNotAvailable" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}” została wywnioskowana. Użyj wersji języka {1} lub nowszej, aby uzyskać dostęp do elementu według jego wywnioskowanej nazwy.</value>
  </data>
  <data name="ERR_ExpectedIdentifierOrGroup" xml:space="preserve">
    <value>Oczekiwano elementu „Group” lub identyfikatora.</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbolNoMessage1_Title" xml:space="preserve">
    <value>Typ lub element członkowski jest przestarzały</value>
  </data>
  <data name="ERR_EndNamespaceNoNamespace" xml:space="preserve">
    <value>Instrukcja End Namespace musi być poprzedzona odpowiadającą jej instrukcją Namespace.</value>
  </data>
  <data name="WRN_FieldNotCLSCompliant1" xml:space="preserve">
    <value>Typ elementu członkowskiego „{0}” nie jest zgodny ze specyfikacją CLS.</value>
  </data>
  <data name="WRN_ComClassInterfaceShadows5" xml:space="preserve">
    <value>Element „Microsoft.VisualBasic.ComClassAttribute” w klasie „{0}” niejawnie deklaruje element {1} „{2}”, który powoduje konflikt z elementem członkowskim o tej samej nazwie w elemencie {3} „{4}”. Użyj elementu „Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)”, jeśli chcesz ukryć nazwę w podstawowym elemencie {4}.</value>
  </data>
  <data name="ERR_VarianceInReturnDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako typ zwracany, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="ERR_ReservedAssemblyName" xml:space="preserve">
    <value>Nazwa zestawu „{0}” jest zarezerwowana i nie można jej użyć jako odwołania w sesji interaktywnej</value>
  </data>
  <data name="ERR_ExpectedProcedure" xml:space="preserve">
    <value>Wyrażenie nie jest metodą.</value>
  </data>
  <data name="WRN_UnusedLocal_Title" xml:space="preserve">
    <value>Nieużyta zmienna lokalna</value>
  </data>
  <data name="ERR_NoAddMethod1" xml:space="preserve">
    <value>Nie można zainicjować typu „{0}” za pomocą inicjatora kolekcji, ponieważ nie ma on dostępnej metody „Add”.</value>
  </data>
  <data name="ERR_StrictDisallowImplicitObjectLambda" xml:space="preserve">
    <value>Ustawienie Option Strict On wymaga zadeklarowania każdego parametru wyrażenia lambda za pomocą klauzuli „As”, jeśli nie można wywnioskować ich typu.</value>
  </data>
  <data name="ERR_ExpectedEndOfExpression" xml:space="preserve">
    <value>Oczekiwano końca wyrażenia.</value>
  </data>
  <data name="WRN_UnusedLocalConst_Title" xml:space="preserve">
    <value>Nieużywana stała lokalna</value>
  </data>
  <data name="ERR_MoreThanOneValidMainWasFound2" xml:space="preserve">
    <value>Element „Sub Main” zadeklarowano więcej niż raz w elemencie „{0}”: {1}</value>
  </data>
  <data name="WRN_XMLDocCrefAttributeNotFound1" xml:space="preserve">
    <value>Komentarz XML ma tag z atrybutem „cref” „{0}”, którego nie można rozpoznać.</value>
  </data>
  <data name="ERR_CantThrowNonException" xml:space="preserve">
    <value>Argument operacji „Throw” musi pochodzić od klasy „System.Exception”.</value>
  </data>
  <data name="ERR_PropertyAccessIgnored" xml:space="preserve">
    <value>Operacja dostępu do właściwości musi przypisywać wartość właściwości lub używać jej wartości.</value>
  </data>
  <data name="ERR_FieldOfValueFieldOfMarshalByRef3" xml:space="preserve">
    <value>Nie można odwołać się do elementu „{0}”, ponieważ jest to element członkowski pola „{1}” o typie wartości klasy „{2}”, której klasą podstawową jest „System.MarshalByRefObject”.</value>
  </data>
  <data name="ERR_LocalsCannotHaveAttributes" xml:space="preserve">
    <value>Nie można zastosować atrybutów do zmiennych lokalnych.</value>
  </data>
  <data name="ERR_InvalidParameterSyntax" xml:space="preserve">
    <value>Oczekiwano przecinka lub znaku ).</value>
  </data>
  <data name="ERR_BadAttributeSharedProperty1" xml:space="preserve">
    <value>Właściwość „{0}” atrybutu „Shared” nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="ERR_CatchNotException1" xml:space="preserve">
    <value>Instrukcja „Catch” nie może przechwycić typu „{0}”, ponieważ nie jest to „System.Exception” ani klasa, która dziedziczy po „System.Exception”.</value>
  </data>
  <data name="ERR_NullableParameterMustSpecifyType" xml:space="preserve">
    <value>Parametry dopuszczające wartości null muszą określać typ.</value>
  </data>
  <data name="ERR_CantSpecifyArraysOnBoth" xml:space="preserve">
    <value>Modyfikatory tablicy nie mogą być określone jednocześnie w zmiennej i jej typie.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefStr" xml:space="preserve">
    <value>Zmienna „{0}” jest używana, zanim zostanie do niej przypisana wartość. Podczas wykonywania może wystąpić wyjątek pustej referencji. Upewnij się, że struktura lub wszystkie elementy członkowskie odwołania są zainicjowane przed użyciem.</value>
  </data>
  <data name="ERR_CantSpecifyParamsOnLambdaParamNoType" xml:space="preserve">
    <value>Nie można określić modyfikatorów tablicy w nazwie parametru wyrażenia lambda. Muszą być one określone w jego typie.</value>
  </data>
  <data name="ERR_CircularBaseDependencies4" xml:space="preserve">
    <value>To dziedziczenie powoduje powstanie zależności cyklicznych między elementem {0} „{1}” a jego zagnieżdżonym lub podstawowym typem „{2}”.</value>
  </data>
  <data name="ERR_RequiredAttributeConstConversion2" xml:space="preserve">
    <value>Konwersja z elementu „{0}” na element „{1}” nie może wystąpić w wyrażeniu stałym używanym jako argument atrybutu.</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryIn4_Title" xml:space="preserve">
    <value>Nie można przekonwertować typu na typ docelowy</value>
  </data>
  <data name="ERR_LbElseifAfterElse" xml:space="preserve">
    <value>Instrukcja „#ElseIf” nie może wystąpić po instrukcji „#Else” jako część bloku „#If”.</value>
  </data>
  <data name="ERR_NoSources" xml:space="preserve">
    <value>nie określono źródeł wejściowych</value>
  </data>
  <data name="ERR_SecurityCriticalAsync" xml:space="preserve">
    <value>Nie można zastosować atrybutu zabezpieczeń „{0}” do metody Async lub Iterator.</value>
  </data>
  <data name="ERR_ObsoleteOptionalWithoutValue" xml:space="preserve">
    <value>Parametry opcjonalne muszą określać wartość domyślną.</value>
  </data>
  <data name="ERR_MultiplyDefinedEnumMember2" xml:space="preserve">
    <value>Element „{0}” jest już zadeklarowany w tym elemencie {1}.</value>
  </data>
  <data name="WRN_ComClassPropertySetObject1_Title" xml:space="preserve">
    <value>Nie można ujawnić właściwości modelowi COM jako właściwości „Let”</value>
  </data>
  <data name="ERR_UndefinedType1" xml:space="preserve">
    <value>Typ „{0}” nie został zdefiniowany.</value>
  </data>
  <data name="ERR_NullableTypeInferenceNotSupported" xml:space="preserve">
    <value>Wnioskowanie typu dopuszczającego wartość null nie jest obsługiwane w tym kontekście.</value>
  </data>
  <data name="ERR_EndTryNoTry" xml:space="preserve">
    <value>Instrukcja End Try musi być poprzedzona odpowiadającą jej instrukcją Try.</value>
  </data>
  <data name="ERR_DuplicateRemoveHandlerDef" xml:space="preserve">
    <value>Element „RemoveHandler” jest już zadeklarowany.</value>
  </data>
  <data name="StatementOrExpressionIsNotAValidType" xml:space="preserve">
    <value>Element StatementOrExpression nie jest typu ExecutableStatementSyntax lub ExpressionSyntax</value>
  </data>
  <data name="ERR_InvalidAssemblyName" xml:space="preserve">
    <value>Wartość „{0}” nie jest prawidłowa dla parametru /moduleassemblyname</value>
  </data>
  <data name="ERR_ExpectedResumeOrGoto" xml:space="preserve">
    <value>Oczekiwano instrukcji Resume lub GoTo.</value>
  </data>
  <data name="ERR_CopyBackTypeMismatch3" xml:space="preserve">
    <value>Nie można skopiować wartości parametru „ByRef” „{0}” z powrotem do zgodnego argumentu, ponieważ typu „{1}” nie można przekonwertować na typ „{2}”.</value>
  </data>
  <data name="ERR_ObsoletePropertyGetLetSet" xml:space="preserve">
    <value>Instrukcje Get/Let/Set dotyczące właściwości nie są już obsługiwane; użyj nowej składni deklaracji właściwości.</value>
  </data>
  <data name="ERR_InvInsideInterface" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści interfejsu.</value>
  </data>
  <data name="ERR_NamedParamNotFound1" xml:space="preserve">
    <value>Element „{0}” nie jest parametrem metody.</value>
  </data>
  <data name="ERR_NamedParamNotFound2" xml:space="preserve">
    <value>Element „{0}” nie jest parametrem elementu „{1}”.</value>
  </data>
  <data name="ERR_NamedParamNotFound3" xml:space="preserve">
    <value>Element „{0}” nie jest parametrem metody rozszerzenia „{1}” zdefiniowanej w elemencie „{2}”.</value>
  </data>
  <data name="ERR_ExpectedConditionalDirective" xml:space="preserve">
    <value>Oczekiwano instrukcji „If”, „ElseIf”, „Else”, „Const”, „Region”, „ExternalSource”, „ExternalChecksum”, „Enable”, „Disable”, „End” lub „R”.</value>
  </data>
  <data name="WRN_BadChecksumValExtChecksum_Title" xml:space="preserve">
    <value>Nieprawidłowa wartość sumy kontrolnej, cyfry nieszesnastkowe lub nieparzysta liczba cyfr szesnastkowych</value>
  </data>
  <data name="ERR_UnaryOperand2" xml:space="preserve">
    <value>Operator „{0}” nie jest zdefiniowany dla typu „{1}”.</value>
  </data>
  <data name="ERR_OverriddenCandidate1" xml:space="preserve">
    <value>
   „{0}”</value>
  </data>
  <data name="WRN_ParamNotCLSCompliant1_Title" xml:space="preserve">
    <value>Typ parametru jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_TypeInferenceFailure1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailure2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_TypeInferenceFailure3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”. Jawne określenie typów danych może rozwiązać ten problem.</value>
  </data>
  <data name="ERR_ObsoleteStructureNotType" xml:space="preserve">
    <value>Instrukcje „Type” nie są już obsługiwane. Zamiast nich używaj instrukcji „Structure”.</value>
  </data>
  <data name="ERR_LValueRequired" xml:space="preserve">
    <value>Wyrażenie jest wartością i dlatego nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="AnonymousObjectCreationExpressionSyntaxNotWithinTree" xml:space="preserve">
    <value>Brak elementu AnonymousObjectCreationExpressionSyntax w drzewie składni</value>
  </data>
  <data name="ERR_ArrayOfRawGenericInvalid" xml:space="preserve">
    <value>Nieoczekiwany znak „(”. Tablice typów ogólnych bez wystąpień nie są dozwolone.</value>
  </data>
  <data name="ERR_InvalidAssemblyCultureForExe" xml:space="preserve">
    <value>Pliki wykonywalne nie mogą być zestawami satelity, element Culture powinien zawsze być pusty</value>
  </data>
  <data name="ERR_ObsoleteInvalidOnEventMember" xml:space="preserve">
    <value>Elementu „{0}” nie można stosować do definicji „AddHandler”, „RemoveHandler” ani „RaiseEvent”. Jeśli jest to wymagane, zastosuj atrybut bezpośrednio do zdarzenia.</value>
  </data>
  <data name="ERR_BadAttributeConstructor1" xml:space="preserve">
    <value>Konstruktor atrybutu ma parametr typu „{0}”, który nie jest typem całkowitym, zmiennoprzecinkowym ani wyliczeniowym, jak również żadnym z typów Object, Char, String, Boolean lub System.Type ani jednowymiarową tablicą składającą się z tych typów.</value>
  </data>
  <data name="ERR_BadAttributeConstructor2" xml:space="preserve">
    <value>Konstruktor atrybutu ma parametr „ByRef” typu „{0}”; konstruktorów z parametrami byref nie można używać do zastosowania atrybutu.</value>
  </data>
  <data name="ERR_ClashWithReservedEnumMember1" xml:space="preserve">
    <value>Element „{0}” powoduje konflikt z zastrzeżonym elementem członkowskim o tej nazwie, który został niejawnie zadeklarowany we wszystkich wyliczeniach.</value>
  </data>
  <data name="ERR_ExpectedExpression" xml:space="preserve">
    <value>Oczekiwano wyrażenia.</value>
  </data>
  <data name="WRN_XMLDocBadFormedXML_Title" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML</value>
  </data>
  <data name="IDS_TheSystemCannotFindThePathSpecified" xml:space="preserve">
    <value>System nie może odnaleźć określonej ścieżki.</value>
  </data>
  <data name="ERR_HandlesSyntaxInModule" xml:space="preserve">
    <value>Elementy „Handles” w module muszą określać zmienną „WithEvents” kwalifikowaną za pomocą pojedynczego identyfikatora.</value>
  </data>
  <data name="WRN_MissingAsClauseinFunction" xml:space="preserve">
    <value>Funkcja bez klauzuli „As”; przyjęto zwracany typ Object.</value>
  </data>
  <data name="ERR_TryWithoutCatchOrFinally" xml:space="preserve">
    <value>Blok Try musi zawierać co najmniej jedną instrukcję Catch lub Finally.</value>
  </data>
  <data name="ERR_ReadOnlyHasSet" xml:space="preserve">
    <value>Właściwości zadeklarowane jako ReadOnly nie mogą mieć procedury Set.</value>
  </data>
  <data name="WRN_ConditionalNotValidOnFunction" xml:space="preserve">
    <value>Atrybut „Conditional” jest prawidłowy tylko w deklaracjach „Sub”.</value>
  </data>
  <data name="ERR_InvalidDebugInformationFormat" xml:space="preserve">
    <value>Nieprawidłowy format informacji debugowania: {0}</value>
  </data>
  <data name="ERR_UnacceptableForLoopOperator2" xml:space="preserve">
    <value>Typy zwracane i typy parametrów „{0}” muszą być typu „{1}”, aby można było używać ich w instrukcji „For”.</value>
  </data>
  <data name="ERR_BadConstFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest poprawny w deklaracji stałej.</value>
  </data>
  <data name="ERR_VarianceInReadOnlyPropertyDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako typ właściwości ReadOnly, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="WRN_ObjectAssumedProperty1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_CatchNoMatchingTry" xml:space="preserve">
    <value>Instrukcja Catch nie może wystąpić poza instrukcją Try.</value>
  </data>
  <data name="WRN_BaseClassNotCLSCompliant2_Title" xml:space="preserve">
    <value>Typ jest niezgodny ze specyfikacją CLS, ponieważ pochodzi od typu podstawowego, który jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_InteropMethodWithBody1" xml:space="preserve">
    <value>Osadzona metoda międzyoperacyjna „{0}” zawiera treść.</value>
  </data>
  <data name="ERR_EndIfNoMatchingIf" xml:space="preserve">
    <value>Instrukcja End If musi być poprzedzona odpowiadającą jej instrukcją If.</value>
  </data>
  <data name="ERR_MissingEndInterface" xml:space="preserve">
    <value>Instrukcja Interface musi być zakończona odpowiadającą jej instrukcją End Interface.</value>
  </data>
  <data name="ERR_ClassNotExpression1" xml:space="preserve">
    <value>Typem elementu „{0}” jest typ klasy i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="ERR_BaseTypeReferences2" xml:space="preserve">
    <value>
    Typ podstawowy elementu „{0}” potrzebuje elementu „{1}”, aby mógł zostać rozpoznany.</value>
  </data>
  <data name="WRN_ImplicitConversion2_Title" xml:space="preserve">
    <value>Niejawna konwersja</value>
  </data>
  <data name="ERR_NameNotMember2" xml:space="preserve">
    <value>Element „{0}” nie jest elementem członkowskim elementu „{1}”.</value>
  </data>
  <data name="ERR_WriteOnlyNoAccessorFlag" xml:space="preserve">
    <value>Właściwości „WriteOnly” nie mogą mieć modyfikatora dostępu w elemencie „Set”.</value>
  </data>
  <data name="ERR_ExpectedGreater" xml:space="preserve">
    <value>Oczekiwano znaku „&gt;”.</value>
  </data>
  <data name="ERR_BadTypeArgForStructConstraint2" xml:space="preserve">
    <value>Argument typu „{0}” nie spełnia warunków ograniczenia „Structure” dla parametru typu „{1}”.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRef" xml:space="preserve">
    <value>Zmienna „{0}” jest przekazywana przez odwołanie, zanim zostanie do niej przypisana wartość. W czasie wykonania może wystąpić wyjątek pustej referencji.</value>
  </data>
  <data name="ERR_EventSourceIsArray" xml:space="preserve">
    <value>Zmienne WithEvents nie mogą być zmiennymi typu tablicowego.</value>
  </data>
  <data name="ERR_CoClassMissing2" xml:space="preserve">
    <value>Nie można znaleźć implementującej klasy „{0}” dla interfejsu „{1}”.</value>
  </data>
  <data name="WRN_BadGUIDFormatExtChecksum" xml:space="preserve">
    <value>Nieprawidłowy format identyfikatora GUID.</value>
  </data>
  <data name="ERR_CannotGotoNonScopeBlocksWithClosure" xml:space="preserve">
    <value>Instrukcja „{0}{1}” jest nieprawidłowa, ponieważ element „{2}” znajduje się wewnątrz zakresu, który definiuje zmienną używaną w wyrażeniu lambda lub wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_IllegalOperandInIIFConversion2" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu dla pierwszego i drugiego argumentu operacji binarnego operatora „If”. Jeden musi umożliwiać konwersję rozszerzającą do drugiego.</value>
  </data>
  <data name="ERR_ConstraintCycleLink2" xml:space="preserve">
    <value>
    Element „{0}” jest ograniczony do elementu „{1}”.</value>
  </data>
  <data name="ERR_ExpectedOptional" xml:space="preserve">
    <value>Oczekiwano instrukcji „Optional”.</value>
  </data>
  <data name="ERR_PartialMethodParamArrayMismatch2" xml:space="preserve">
    <value>Parametr metody „{0}” różni się modyfikatorem ParamArray od odpowiedniego parametru metody częściowej „{1}”.</value>
  </data>
  <data name="WRN_DefAsgNoRetValFuncRef1_Title" xml:space="preserve">
    <value>Funkcja nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_MyClassAbstractCall1" xml:space="preserve">
    <value>Nie można wywołać metody „{0}” typu „MustOverride” przy użyciu elementu „MyClass”.</value>
  </data>
  <data name="ERR_BadTypeArgForRefConstraint2" xml:space="preserve">
    <value>Argument typu „{0}” nie spełnia warunków ograniczenia „Class” dla parametru typu „{1}”.</value>
  </data>
  <data name="ERR_LambdaNoType" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu. Rozważ dodanie klauzuli „As” w celu określenia zwracanego typu.</value>
  </data>
  <data name="ERR_ExtraSpecifiers" xml:space="preserve">
    <value>Specyfikatory są prawidłowe tylko na początku deklaracji.</value>
  </data>
  <data name="WRN_DefAsgUseNullRef" xml:space="preserve">
    <value>Zmienna „{0}” jest używana, zanim zostanie do niej przypisana wartość. Podczas wykonywania może wystąpić wyjątek pustej referencji.</value>
  </data>
  <data name="ERR_DefaultEventNotFound1" xml:space="preserve">
    <value>Zdarzenie „{0}” określane przez atrybut „DefaultEvent” nie jest zdarzeniem publicznie dostępnym dla tej klasy.</value>
  </data>
  <data name="ERR_GenericClassCannotInheritAttr" xml:space="preserve">
    <value>Klasy, które są ogólne lub są zawarte w typie ogólnym, nie mogą dziedziczyć po klasie atrybutu.</value>
  </data>
  <data name="ERR_UseOfKeywordFromStructure1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w ramach struktury.</value>
  </data>
  <data name="WRN_MustShadowOnMultipleInheritance2" xml:space="preserve">
    <value>Element {0} „{1}” powoduje konflikt z innymi elementami członkowskimi o tej samej nazwie w hierarchii dziedziczenia i dlatego powinien być zadeklarowany jako „Shadows”.</value>
  </data>
  <data name="ERR_ConstraintClashDirectIndirect3" xml:space="preserve">
    <value>Ograniczenie „{0}” powoduje konflikt z ograniczeniem pośrednim „{1}” uzyskanym z ograniczenia parametru typu „{2}”.</value>
  </data>
  <data name="ERR_ArrayInitializerTooManyDimensions" xml:space="preserve">
    <value>Inicjator tablicy ma za dużo wymiarów.</value>
  </data>
  <data name="ERR_TypecharNoMatch2" xml:space="preserve">
    <value>Znak typu „{0}” nie odpowiada zadeklarowanemu typowi danych „{1}”.</value>
  </data>
  <data name="ERR_ExpressionTreeNotSupported" xml:space="preserve">
    <value>Nie można przekonwertować wyrażenia na drzewo wyrażenia.</value>
  </data>
  <data name="ERR_TypeParamMissingCommaOrRParen" xml:space="preserve">
    <value>Oczekiwano przecinka lub znaku ).</value>
  </data>
  <data name="WRN_ConditionalNotValidOnFunction_Title" xml:space="preserve">
    <value>Atrybut „Conditional” jest prawidłowy tylko w deklaracjach „Sub”</value>
  </data>
  <data name="ERR_TupleReservedElementName" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}“ jest dozwolona tylko na pozycji {1}.</value>
  </data>
  <data name="ERR_IllegalOperandInIIFName" xml:space="preserve">
    <value>Argumenty operatora „If” nie mogą być nazwanymi argumentami.</value>
  </data>
  <data name="ERR_NoWithEventsVarOnHandlesList" xml:space="preserve">
    <value>Klauzula Handles wymaga zmiennej WithEvents zdefiniowanej w zawierającym ją typie lub jednym z jej typów podstawowych.</value>
  </data>
  <data name="ERR_AnonymousTypeDisallowsTypeChar" xml:space="preserve">
    <value>Nie można używać znaków typu w deklaracjach typów anonimowych.</value>
  </data>
  <data name="WRN_OptionalValueNotCLSCompliant1" xml:space="preserve">
    <value>Typ wartości opcjonalnej dla parametru opcjonalnego „{0}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_UnterminatedStringLiteral" xml:space="preserve">
    <value>Stałe w postaci ciągu muszą być zakończone znakiem podwójnego cudzysłowu.</value>
  </data>
  <data name="ERR_ReadOnlyInClosure" xml:space="preserve">
    <value>Zmienna ReadOnly nie może być elementem docelowym przypisania w wyrażeniu lambda wewnątrz konstruktora.</value>
  </data>
  <data name="ERR_EncUpdateFailedMissingAttribute" xml:space="preserve">
    <value>Nie można zaktualizować elementu „{0}”. Brak atrybutu „{1}”.</value>
  </data>
  <data name="ERR_BadPropertyFlags1" xml:space="preserve">
    <value>Nie można zadeklarować właściwości jako „{0}”.</value>
  </data>
  <data name="ERR_InvalidOptionCompare" xml:space="preserve">
    <value>Po instrukcji Option Compare musi wystąpić element Text lub Binary.</value>
  </data>
  <data name="ERR_ForIndexInUse1" xml:space="preserve">
    <value>Zmienna „{0}” sterująca pętlą For jest już używana przez otaczającą pętlę For.</value>
  </data>
  <data name="ERR_KeywordNotAllowedInScript" xml:space="preserve">
    <value>Nie można używać słowa kluczowego „{0}” w kodzie skryptu najwyższego poziomu</value>
  </data>
  <data name="IDS_ToolName" xml:space="preserve">
    <value>Kompilator Microsoft (R) Visual Basic Compiler</value>
  </data>
  <data name="ERR_ConvertArrayRankMismatch2" xml:space="preserve">
    <value>Nie można przekonwertować wartości typu „{0}” na „{1}”, ponieważ typy tablic mają różną liczbę wymiarów.</value>
  </data>
  <data name="ERR_ConstructorCannotBeDeclaredPartial" xml:space="preserve">
    <value>Nie można zadeklarować elementu „Sub New” jako „Partial”.</value>
  </data>
  <data name="ERR_BadEmptyEnum1" xml:space="preserve">
    <value>Wyliczenie „{0}” musi zawierać co najmniej jeden element członkowski.</value>
  </data>
  <data name="ERR_ConversionToInterfaceType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować na typ interfejsu.</value>
  </data>
  <data name="ERR_ExpectedArray1" xml:space="preserve">
    <value>Instrukcja „{0}” wymaga tablicy.</value>
  </data>
  <data name="TreeMustHaveARootNodeWithCompilationUnit" xml:space="preserve">
    <value>Drzewo musi mieć węzeł główny z elementem SyntaxKind.CompilationUnit</value>
  </data>
  <data name="ERR_InAccessibleCoClass3" xml:space="preserve">
    <value>Implementująca klasa „{0}” dla interfejsu „{1}” jest niedostępna w tym kontekście, ponieważ jest to element „{2}”.</value>
  </data>
  <data name="ERR_MutuallyExclusiveOptions" xml:space="preserve">
    <value>Nie można równocześnie określić opcji kompilacji „{0}” i „{1}”.</value>
  </data>
  <data name="CannotRemoveCompilerSpecialTree" xml:space="preserve">
    <value>Nie można usunąć specjalnego drzewa kompilatora</value>
  </data>
  <data name="ERR_OverrideNotNeeded3" xml:space="preserve">
    <value>Nie można zadeklarować elementu {0} „{1}” jako „Overrides”, ponieważ nie przesłania on elementu {0} w klasie podstawowej.</value>
  </data>
  <data name="ERR_BadAttributeReadOnlyProperty1" xml:space="preserve">
    <value>Właściwość „{0}” atrybutu „ReadOnly” nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="ERR_DocFileGen" xml:space="preserve">
    <value>Błąd zapisu w pliku dokumentacji XML: {0}</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedHereForGeneric4" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{2}” należącego do elementu „{3}” w „{1}” w tym kontekście, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="WRN_EventDelegateTypeNotCLSCompliant2" xml:space="preserve">
    <value>Typ delegowany „{0}” zdarzenia „{1}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_LocalSameAsFunc" xml:space="preserve">
    <value>Zmienna lokalna nie może mieć takiej samej nazwy jak zawierająca ją funkcja.</value>
  </data>
  <data name="ERR_NameSameAsMethodTypeParam1" xml:space="preserve">
    <value>Element „{0}” jest już zadeklarowany jako parametr typu tej metody.</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedHereForGeneric4" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{2}” należącego do „{3}” w elemencie „{1}” w tym kontekście, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="ERR_StructureNotExpression1" xml:space="preserve">
    <value>Typem elementu „{0}” jest typ struktury i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbolNoMessage1" xml:space="preserve">
    <value>Element „{0}” jest przestarzały.</value>
  </data>
  <data name="ERR_ContinueWhileNotWithinWhile" xml:space="preserve">
    <value>Element Continue While może się znajdować tylko w instrukcji While.</value>
  </data>
  <data name="ERR_TooManyArgs2" xml:space="preserve">
    <value>Za dużo argumentów dla metody rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”.</value>
  </data>
  <data name="ERR_TooManyArgs1" xml:space="preserve">
    <value>Za dużo argumentów elementu „{0}”.</value>
  </data>
  <data name="ERR_DuplicateConversionCategoryUsed" xml:space="preserve">
    <value>Nie można łączyć elementów Widening i Narrowing.</value>
  </data>
  <data name="ERR_BadMetaDataReference1" xml:space="preserve">
    <value>Nie można odwołać się do elementu „{0}”, ponieważ nie jest to poprawny zestaw.</value>
  </data>
  <data name="ERR_IsNotOperatorNullable1" xml:space="preserve">
    <value>Argument operacji „IsNot” typu „{0}” można porównać tylko z elementem „Nothing”, ponieważ typ „{0}” jest typem dopuszczającym wartość null.</value>
  </data>
  <data name="WRN_AssemblyGeneration1" xml:space="preserve">
    <value>Wykryto potencjalny problem podczas kompilowania zestawu „{0}”: {1}.</value>
  </data>
  <data name="WRN_AssemblyGeneration0" xml:space="preserve">
    <value>Wykryto potencjalny problem podczas kompilowania zestawu: {0}.</value>
  </data>
  <data name="ERR_CollisionWithPublicTypeInModule" xml:space="preserve">
    <value>Typ „{0}” jest w konflikcie z typem publicznym zdefiniowanym w dodanym module „{1}”.</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedHere2" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w elemencie „{1}” w tym kontekście, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_MustInheritEventNotOverridden" xml:space="preserve">
    <value>„{0}” jest zdarzeniem MustOverride w klasie podstawowej „{1}”. Język Visual Basic nie obsługuje przesłaniania zdarzeń. Musisz określić implementację zdarzenia w klasie podstawowej lub ustawić klasę „{2}” jako zdarzenie MustInherit.</value>
  </data>
  <data name="WRN_TypeInferenceAssumed3" xml:space="preserve">
    <value>Nie można wywnioskować typu danych „{0}” w „{1}”. Przyjęto „{2}”.</value>
  </data>
  <data name="ERR_EventAddRemoveByrefParamIllegal" xml:space="preserve">
    <value>Parametrów metody „AddHandler” i „RemoveHandler” nie można deklarować jako „ByRef”.</value>
  </data>
  <data name="ERR_ExtraNextVariable" xml:space="preserve">
    <value>Instrukcja „Next” zawiera więcej zmiennych, niż istnieje odpowiadających jej instrukcji „For”.</value>
  </data>
  <data name="ERR_ExpectedWarningKeyword" xml:space="preserve">
    <value>Oczekiwano elementu „Warning”.</value>
  </data>
  <data name="WRN_ObjectMath2_Title" xml:space="preserve">
    <value>Dla operatora użyto argumentów operacji typu Object</value>
  </data>
  <data name="ERR_ExprTreeNoMultiDimArrayCreation" xml:space="preserve">
    <value>Nie można przekonwertować tablicy wielowymiarowej na drzewo wyrażenia.</value>
  </data>
  <data name="ERR_UnrecognizedTypeOrWith" xml:space="preserve">
    <value>Oczekiwano typu lub instrukcji „With”.</value>
  </data>
  <data name="ERR_InvalidEnumBase" xml:space="preserve">
    <value>Zmienne wyliczeniowe należy deklarować jako typ całkowity.</value>
  </data>
  <data name="ERR_ParamNameFunctionNameCollision" xml:space="preserve">
    <value>Parametr nie może mieć takiej samej nazwy jak definiująca go funkcja.</value>
  </data>
  <data name="WRN_ArrayOverloadsNonCLS2_Title" xml:space="preserve">
    <value>Metoda jest niezgodna ze specyfikacją CLS, ponieważ przeciąża metodę, która różni się od niej tylko tablicą typów parametrów tablicowych lub rangą typów parametrów tablicowych</value>
  </data>
  <data name="ERR_PropertySetParamCollisionWithValue" xml:space="preserve">
    <value>Parametry właściwości nie mogą mieć nazwy Value.</value>
  </data>
  <data name="ERR_TypeCharOnGenericParam" xml:space="preserve">
    <value>Znaku typu nie można użyć w deklaracji parametru typu.</value>
  </data>
  <data name="ERR_CannotUseOnErrorGotoWithClosure" xml:space="preserve">
    <value>Metoda nie może zawierać zarówno instrukcji „{0}”, jak i definicji zmiennej użytej w wyrażeniu lambda lub wyrażeniu zapytania.</value>
  </data>
  <data name="WRN_VarianceConversionFailedOut6" xml:space="preserve">
    <value>Niejawna konwersja z „{4}” na „{5}”; ta konwersja może się nie powieść, ponieważ „{0}” nie dziedziczy od „{1}”, co jest wymagane dla parametru ogólnego „Out” „{2}” w „{3}”.</value>
  </data>
  <data name="ERR_ModuleCantUseDLLDeclareSpecifier1" xml:space="preserve">
    <value>Instrukcji „Declare” w module nie można zadeklarować jako „{0}”.</value>
  </data>
  <data name="ERR_CantSpecifyAsNewAndNullable" xml:space="preserve">
    <value>Modyfikator dopuszczający wartość null nie może być określany w deklaracjach zmiennych za pomocą instrukcji „As New”.</value>
  </data>
  <data name="WRN_XMLDocGenericParamTagWithoutName_Title" xml:space="preserve">
    <value>Parametr typu komentarza XML musi mieć atrybut „name”</value>
  </data>
  <data name="WRN_XMLDocOnAPartialType_Title" xml:space="preserve">
    <value>Nie można zastosować komentarza XML więcej niż raz w typie częściowym</value>
  </data>
  <data name="ERR_InvalidEndInterface" xml:space="preserve">
    <value>Instrukcja End Interface musi być poprzedzona odpowiadającą jej instrukcją Interface.</value>
  </data>
  <data name="ERR_ModuleCantUseVariableSpecifier1" xml:space="preserve">
    <value>Zmienne w modułach nie mogą być deklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_PartialMethodTypeParamNameMismatch3" xml:space="preserve">
    <value>Nazwa parametru typu „{0}” nie jest zgodna z odpowiadającym mu parametrem typu „{1}” zdefiniowanego w deklaracji metody częściowej „{2}”.</value>
  </data>
  <data name="ERR_PDBWritingFailed" xml:space="preserve">
    <value>Błąd podczas zapisu informacji o debugowaniu: {0}</value>
  </data>
  <data name="ERR_MetadataMembersAmbiguous3" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny, ponieważ wiele rodzajów elementów członkowskich o tej nazwie istnieje w elemencie {1} „{2}”.</value>
  </data>
  <data name="WRN_UnusedLocal" xml:space="preserve">
    <value>Nieużywana zmienna lokalna: „{0}”.</value>
  </data>
  <data name="ERR_MustOverridesInClass1" xml:space="preserve">
    <value>Element „{0}” musi być zadeklarowany jako „MustInherit”, ponieważ zawiera metody zadeklarowane jako „MustOverride”.</value>
  </data>
  <data name="WRN_XMLDocBadFormedXML" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML „{0}” pliku „{1}”. {2}</value>
  </data>
  <data name="ERR_ExpectedEndTry" xml:space="preserve">
    <value>Instrukcja Try musi być zakończona odpowiadającą jej instrukcją End Try.</value>
  </data>
  <data name="ERR_ImportAliasConflictsWithType2" xml:space="preserve">
    <value>Alias instrukcji Imports „{0}” powoduje konflikt z elementem „{1}” zadeklarowanym w głównej przestrzeni nazw.</value>
  </data>
  <data name="ERR_InterfaceImplementedTwice1" xml:space="preserve">
    <value>Interfejs „{0}” może być zaimplementowany przez ten typ tylko raz.</value>
  </data>
  <data name="WRN_ImplicitConversionCopyBack_Title" xml:space="preserve">
    <value>Niejawna konwersja podczas kopiowania wartości parametru „ByRef” z powrotem do pasującego argumentu</value>
  </data>
  <data name="ERR_UseOfKeywordNotInInstanceMethod1" xml:space="preserve">
    <value>Element „{0}” jest prawidłowy tylko wewnątrz metody wystąpienia.</value>
  </data>
  <data name="ERR_EventHandlerSignatureIncompatible2" xml:space="preserve">
    <value>Metoda „{0}” nie może obsłużyć zdarzenia „{1}”, ponieważ metoda i zdarzenie nie mają zgodnej sygnatury.</value>
  </data>
  <data name="ERR_ExpectedEquals" xml:space="preserve">
    <value>Oczekiwano operatora „Equals”.</value>
  </data>
  <data name="ERR_InvalidOptionalParameterUsage1" xml:space="preserve">
    <value>Nie można zastosować atrybutu „{0}” do metody z parametrami opcjonalnymi.</value>
  </data>
  <data name="ERR_UnreferencedAssemblyEvent3" xml:space="preserve">
    <value>Wymagane odwołanie do zestawu „{0}” z definicją zdarzenia „{1}”. Dodaj je do projektu.</value>
  </data>
  <data name="ERR_InvalidCoClass1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako klasa implementująca.</value>
  </data>
  <data name="WrongSemanticModelType" xml:space="preserve">
    <value>Oczekiwano elementu SemanticModel {0}.</value>
  </data>
  <data name="WRN_MissingAsClauseinFunction_Title" xml:space="preserve">
    <value>Funkcja bez klauzuli „As”</value>
  </data>
  <data name="ERR_DuplicateParamName1" xml:space="preserve">
    <value>Zadeklarowano już parametr o nazwie „{0}”.</value>
  </data>
  <data name="ERR_RestrictedType1" xml:space="preserve">
    <value>Typ „{0}” nie może być typem dopuszczającym wartość null i nie można go używać jako typu danych elementu tablicy, pola, elementu członkowskiego typu anonimowego, argumentu typu, parametru „ByRef” ani instrukcji return.</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning_Title" xml:space="preserve">
    <value>Atrybut jest ignorowany w przypadku określenia podpisywania publicznego.</value>
  </data>
  <data name="ERR_InvalidEndRemoveHandler" xml:space="preserve">
    <value>Element „End RemoveHandler” musi być poprzedzony odpowiadającą mu deklaracją „RemoveHandler”.</value>
  </data>
  <data name="ERR_TooManyUserStrings" xml:space="preserve">
    <value>Całkowita długość ciągów użytkownika używanych przez program przekracza dozwolony limit. Spróbuj ograniczyć użycie literałów ciągów lub XML.</value>
  </data>
  <data name="ERR_OmittedParamArrayArgument" xml:space="preserve">
    <value>Nie można dopasować pominiętego argumentu do parametru ParamArray.</value>
  </data>
  <data name="ERR_SharedConstructorWithParams" xml:space="preserve">
    <value>Udostępniony element Sub New nie może mieć żadnych parametrów.</value>
  </data>
  <data name="WRN_VarianceConversionFailedIn6_Title" xml:space="preserve">
    <value>Niejawna konwersja; ta konwersja może się nie powieść, ponieważ typ docelowy nie pochodzi od typu źródłowego, co jest wymagane dla parametru ogólnego „In”</value>
  </data>
  <data name="WRN_FieldNotCLSCompliant1_Title" xml:space="preserve">
    <value>Typ elementu członkowskiego jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_SharedConstructorIllegalSpec1" xml:space="preserve">
    <value>Nie można zadeklarować udostępnianego elementu „Sub New” jako „{0}”.</value>
  </data>
  <data name="ERR_TypeMismatchForXml3" xml:space="preserve">
    <value>Nie można przekonwertować wartości typu „{0}” na „{1}”. Przy użyciu właściwości „Value” można uzyskać wartość ciągu pierwszego elementu „{2}”.</value>
  </data>
  <data name="ERR_UnableToReadUacManifest2" xml:space="preserve">
    <value>Nie można otworzyć pliku manifestu Win32 „{0}”: {1}.</value>
  </data>
  <data name="WRN_MutableGenericStructureInUsing_Title" xml:space="preserve">
    <value>Zmienna lokalna zadeklarowana przez instrukcję Using jest przeznaczona tylko do odczytu i jej typem może być struktura</value>
  </data>
  <data name="WRN_NonCLSMustOverrideInCLSType1" xml:space="preserve">
    <value>Element członkowski „MustOverride” niezgodny ze specyfikacją CLS nie jest dozwolony w elementach „{0}” zgodnych ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_QueryInvalidControlVariableName1" xml:space="preserve">
    <value>Nazwa zmiennej zakresu nie może być zgodna z nazwą elementu członkowskiego klasy „Object”.</value>
  </data>
  <data name="ERR_DelegateBindingIncompatible2" xml:space="preserve">
    <value>Metoda „{0}” nie ma sygnatury zgodnej z delegatem „{1}”.</value>
  </data>
  <data name="ERR_DelegateBindingIncompatible3" xml:space="preserve">
    <value>Metoda rozszerzenia „{0}” zdefiniowana w elemencie „{2}” nie ma sygnatury zgodnej z delegatem „{1}”.</value>
  </data>
  <data name="ERR_ClassInheritsInterfaceUnifiesWithBase3" xml:space="preserve">
    <value>Nie można zaimplementować interfejsu „{0}”, ponieważ może on być taki sam jak interfejs „{1}”, po którym dziedziczy zaimplementowany interfejs „{2}” dla niektórych argumentów typu.</value>
  </data>
  <data name="WRN_XMLDocExceptionTagWithoutCRef_Title" xml:space="preserve">
    <value>Wyjątek komentarza XML musi mieć atrybut „cref”</value>
  </data>
  <data name="ERR_DefaultPropertyWithNoParams" xml:space="preserve">
    <value>Właściwości bez żadnych wymaganych parametrów nie mogą być deklarowane jako Default.</value>
  </data>
  <data name="WRN_RecursiveOperatorCall" xml:space="preserve">
    <value>Wyrażenie cyklicznie wywołuje zawierający je operator „{0}”.</value>
  </data>
  <data name="ERR_DllImportOnInterfaceMethod" xml:space="preserve">
    <value>Elementu „System.Runtime.InteropServices.DllImportAttribute” nie można zastosować do metod interfejsu.</value>
  </data>
  <data name="ERR_DuplicateLocalStatic1" xml:space="preserve">
    <value>Statyczna zmienna lokalna „{0}” jest już zadeklarowana.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded" xml:space="preserve">
    <value>plik źródłowy „{0}” został określony wiele razy</value>
  </data>
  <data name="ERR_ReImplementingWinRTInterface4" xml:space="preserve">
    <value>Element „{0}.{1}” został już zaimplementowany przez klasę podstawową „{2}”. Ponowna implementacja interfejsu środowiska wykonawczego systemu Windows „{3}” jest niedozwolona</value>
  </data>
  <data name="ERR_ReImplementingWinRTInterface5" xml:space="preserve">
    <value>Element „{0}.{1}” z elementu „implements {2}” został już zaimplementowany przez klasę podstawową „{3}”. Ponowna implementacja interfejsu środowiska wykonawczego systemu Windows „{4}” jest niedozwolona</value>
  </data>
  <data name="WRN_StaticLocalNoInference_Title" xml:space="preserve">
    <value>Zmienna statyczna zadeklarowana bez klauzuli „As”</value>
  </data>
  <data name="WRN_XMLDocParamTagWithoutName" xml:space="preserve">
    <value>Parametr komentarza XML musi mieć atrybut „name”.</value>
  </data>
  <data name="ERR_InvalidEndEnum" xml:space="preserve">
    <value>Instrukcja „End Enum” musi być poprzedzona odpowiadającą jej instrukcją „Enum”.</value>
  </data>
  <data name="ERR_DelegateBindingMismatchStrictOff3" xml:space="preserve">
    <value>Ustawienie Option Strict On nie zezwala na zawężanie w niejawnych konwersjach typów między metodą rozszerzenia „{0}” zdefiniowaną w elemencie „{2}” a delegatem „{1}”.</value>
  </data>
  <data name="ERR_DelegateBindingMismatchStrictOff2" xml:space="preserve">
    <value>Ustawienie Option Strict On nie zezwala na zawężanie w niejawnych konwersjach typów między metodą „{0}” a delegatem „{1}”.</value>
  </data>
  <data name="ERR_LambdaInSelectCaseExpr" xml:space="preserve">
    <value>Wyrażenia lambda nie są prawidłowe w pierwszym wyrażeniu instrukcji Select Case.</value>
  </data>
  <data name="WRN_BaseClassNotCLSCompliant2" xml:space="preserve">
    <value>Element „{0}” jest niezgodny ze specyfikacją CLS, ponieważ dziedziczy po elemencie „{1}”, który jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_DuplicateOption1" xml:space="preserve">
    <value>Instrukcja „Option {0}” może wystąpić w pliku tylko raz.</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames3" xml:space="preserve">
    <value>Interfejs „{0}” można odziedziczyć tylko raz według tego interfejsu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{1}” (poprzez „{2}”).</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames2" xml:space="preserve">
    <value>Interfejs „{0}” można odziedziczyć tylko raz według tego interfejsu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{1}”.</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNames4" xml:space="preserve">
    <value>Interfejs „{0}” (poprzez „{1}”) można odziedziczyć tylko raz według tego interfejsu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{2}” (poprzez „{3}”).</value>
  </data>
  <data name="ERR_ValueTupleTypeRefResolutionError1" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” nie jest zdefiniowany ani zaimportowany.</value>
  </data>
  <data name="ERR_MissingEndRemoveHandler" xml:space="preserve">
    <value>Deklaracja „RemoveHandler” musi być zakończona odpowiadającym jej elementem „End RemoveHandler”.</value>
  </data>
  <data name="NotWithinTree" xml:space="preserve">
    <value> nie w obrębie drzewa</value>
  </data>
  <data name="ERR_BadClassFlags1" xml:space="preserve">
    <value>Klas nie można deklarować jako „{0}”.</value>
  </data>
  <data name="WRN_VarianceConversionFailedIn6" xml:space="preserve">
    <value>Niejawna konwersja z „{4}” na „{5}”; ta konwersja może się nie powieść, ponieważ „{0}” nie dziedziczy od „{1}”, co jest wymagane dla parametru ogólnego „In” „{2}” w „{3}”.</value>
  </data>
  <data name="ERR_FriendAssemblyNameInvalid" xml:space="preserve">
    <value>Deklaracja Friend „{0}” jest nieprawidłowa i nie można jej rozpoznać.</value>
  </data>
  <data name="ERR_ExtensionMethodParamArrayFirstArg" xml:space="preserve">
    <value>Nie można zastosować elementu „ParamArray” do pierwszego parametru metody rozszerzenia. Pierwszy parametr określa typ do rozszerzenia.</value>
  </data>
  <data name="ERR_StrictDisallowsLateBinding" xml:space="preserve">
    <value>Ustawienie Option Strict On uniemożliwia późne wiązanie.</value>
  </data>
  <data name="ERR_BadFlagsOnSharedProperty1" xml:space="preserve">
    <value>Nie można łączyć instrukcji „Shared” z elementem „{0}” w deklaracji właściwości.</value>
  </data>
  <data name="ERR_ParamArrayNotArray" xml:space="preserve">
    <value>Parametr ParamArray musi być tablicą.</value>
  </data>
  <data name="ERR_OperatorDeclaredInModule" xml:space="preserve">
    <value>Nie można zadeklarować operatorów w modułach.</value>
  </data>
  <data name="ERR_ExpectedIntLiteral" xml:space="preserve">
    <value>Oczekiwano stałej całkowitej.</value>
  </data>
  <data name="ERR_BadInterfaceInterfaceSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować interfejsu w interfejsie jako „{0}”.</value>
  </data>
  <data name="WRN_NonCLSMemberInCLSInterface1" xml:space="preserve">
    <value>Element „{0}” niezgodny ze specyfikacją CLS jest niedozwolony w interfejsie zgodnym ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_DuplicateImport1" xml:space="preserve">
    <value>Przestrzeń nazw lub typ „{0}” zostały już zaimportowane.</value>
  </data>
  <data name="ERR_ExpectedInOrEq" xml:space="preserve">
    <value>Oczekiwano elementu „In” lub znaku „=”.</value>
  </data>
  <data name="ERR_WinRTEventWithoutDelegate" xml:space="preserve">
    <value>Deklaracje zdarzeń przeznaczone dla WinMD muszą określać typ delegata. Dodaj klauzulę As do deklaracji zdarzenia.</value>
  </data>
  <data name="WRN_SynthMemberShadowsSynthMember7" xml:space="preserve">
    <value>Element {0} „{1}” deklaruje niejawnie element „{2}”, który powoduje konflikt z elementem członkowskim niejawnie zadeklarowanym dla elementu {3} „{4}” w podstawowym elemencie {5} „{6}”. Element {0} należy zadeklarować jako „Shadows”.</value>
  </data>
  <data name="ERR_RefReturningCallInExpressionTree" xml:space="preserve">
    <value>Drzewo wyrażenia nie może zawierać wywołania metody lub właściwości zwracanego przez odwołanie.</value>
  </data>
  <data name="ERR_ExitSubOfFunc" xml:space="preserve">
    <value>Instrukcja Exit Sub nie jest prawidłowa w przypadku funkcji lub właściwości.</value>
  </data>
  <data name="ERR_EventImplMismatch5" xml:space="preserve">
    <value>Zdarzenie „{0}” nie może implementować zdarzenia „{1}” w interfejsie „{2}”, ponieważ ich typy delegowane „{3}” i „{4}” są niezgodne.</value>
  </data>
  <data name="ERR_LabelNotDefined1" xml:space="preserve">
    <value>Etykieta „{0}” nie jest zdefiniowana.</value>
  </data>
  <data name="WRN_PdbUsingNameTooLong_Title" xml:space="preserve">
    <value>Ciąg importu jest za długi dla pliku PDB</value>
  </data>
  <data name="WRN_ObjectAssumed1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_UseOfObsoleteSymbolNoMessage1" xml:space="preserve">
    <value>Element „{0}” jest przestarzały.</value>
  </data>
  <data name="ERR_IllegalDefaultNamespace" xml:space="preserve">
    <value>Deklaracja przestrzeni nazw z prefiksem nie może mieć wartości pustej wewnątrz literału XML.</value>
  </data>
  <data name="ERR_InReferencedAssembly" xml:space="preserve">
    <value>Wystąpił błąd w przywoływanym zestawie „{0}”.</value>
  </data>
  <data name="ERR_PartialMethodParamNamesMustMatch3" xml:space="preserve">
    <value>Nazwa parametru „{0}” nie jest zgodna z nazwą odpowiadającego mu parametru „{1}” zdefiniowanego w deklaracji metody częściowej „{2}”.</value>
  </data>
  <data name="ERR_BadStaticInitializerInResumable" xml:space="preserve">
    <value>Zmienne statyczne nie mogą być używane w metodach Async lub Iterator.</value>
  </data>
  <data name="ERR_GotoIntoTryHandler" xml:space="preserve">
    <value>Instrukcja „GoTo {0}” jest nieprawidłowa, ponieważ element „{0}” znajduje się wewnątrz instrukcji „Try”, „Catch” lub „Finally”, która nie zawiera tej instrukcji.</value>
  </data>
  <data name="ERR_NewAndValueConstraintsCombined" xml:space="preserve">
    <value>Nie można łączyć ograniczeń New i Structure.</value>
  </data>
  <data name="ERR_SetValueNotPropertyType" xml:space="preserve">
    <value>Parametr Set musi mieć taki sam typ jak zawierająca go właściwość.</value>
  </data>
  <data name="ERR_IllegalAttributeInXmlDecl" xml:space="preserve">
    <value>Deklaracja XML nie zezwala na użycie atrybutu „{0}{1}{2}”.</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer_Title" xml:space="preserve">
    <value>Nie można załadować zestawu analizatora</value>
  </data>
  <data name="ERR_NoNonIndexProperty1" xml:space="preserve">
    <value>Nie można odnaleźć właściwości „{0}” bez parametrów.</value>
  </data>
  <data name="WRN_ComClassNoMembers1_Title" xml:space="preserve">
    <value>Atrybut „Microsoft.VisualBasic.ComClassAttribute” został określony dla klasy, ale klasa nie zawiera publicznych elementów członkowskich, które można ujawnić modelowi COM</value>
  </data>
  <data name="ERR_MustBeInCatchToRethrow" xml:space="preserve">
    <value>Instrukcja „Throw” nie może pomijać argumentu operacji poza instrukcją „Catch” lub wewnątrz instrukcji „Finally”.</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncVoidMethod" xml:space="preserve">
    <value>Słowo kluczowe „Await” może zostać użyte tylko wewnątrz metody asynchronicznej. Rozważ oznaczenie tej metody za pomocą modyfikatora „Async” i zmianę zwracanego przez nią typu na „Task”.</value>
  </data>
  <data name="WRN_ParamNotCLSCompliant1" xml:space="preserve">
    <value>Typ parametru „{0}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="WRN_NoConfigInResponseFile" xml:space="preserve">
    <value>opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</value>
  </data>
  <data name="ERR_SpecifiersInvOnEventMethod" xml:space="preserve">
    <value>Specyfikatory w metodach „AddHandler”, „RemoveHandler” i „RaiseEvent” są nieprawidłowe.</value>
  </data>
  <data name="ERR_ExpectedAssignmentOperatorInInit" xml:space="preserve">
    <value>Oczekiwano znaku „=” (inicjator obiektów).</value>
  </data>
  <data name="ERR_UnrecognizedTypeKeyword" xml:space="preserve">
    <value>Słowo kluczowe nie określa typu.</value>
  </data>
  <data name="ERR_InitWithExplicitArraySizes" xml:space="preserve">
    <value>Jawne inicjowanie nie jest dozwolone w przypadku tablic zadeklarowanych z jawnymi granicami.</value>
  </data>
  <data name="ERR_ByRefParamInExpressionTree" xml:space="preserve">
    <value>Nie można przekonwertować odwołań do parametrów „ByRef” na drzewo wyrażenia.</value>
  </data>
  <data name="FEATURE_Iterators" xml:space="preserve">
    <value>iteratory</value>
  </data>
  <data name="ERR_InAccessibleOverridingMethod5" xml:space="preserve">
    <value>Element „{0}” w klasie „{1}” nie może przesłonić elementu „{2}” w klasie „{3}”, ponieważ klasa pośrednicząca „{4}”, która przesłania element „{2}” w klasie „{3}”, jest niedostępna.</value>
  </data>
  <data name="WRN_CLSMemberInNonCLSType3" xml:space="preserve">
    <value>Elementu {0} „{1}” nie można oznaczyć jako zgodnego ze specyfikacją CLS, ponieważ jego zawierający typ „{2}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_MissingNext" xml:space="preserve">
    <value>Oczekiwano elementu Next.</value>
  </data>
  <data name="ERR_BaseOnlyClassesMustBeExplicit2" xml:space="preserve">
    <value>Klasa „{0}” musi być zadeklarowana jako „MustInherit” lub przesłaniać następujące dziedziczone elementy członkowskie „MustOverride”: {1}.</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly_Title" xml:space="preserve">
    <value>Zestaw nie zawiera analizatorów</value>
  </data>
  <data name="ERR_ModuleCantUseMethodSpecifier1" xml:space="preserve">
    <value>Metody w module nie mogą być zadeklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_UnexpectedExpressionStatement" xml:space="preserve">
    <value>Instrukcja wyrażenia jest dozwolona tylko na końcu przesyłania interaktywnego.</value>
  </data>
  <data name="ERR_InterpolationFormatWhitespace" xml:space="preserve">
    <value>Specyfikator formatu nie może kończyć się znakiem odstępu.</value>
  </data>
  <data name="ERR_AggrInitInvalidForObject" xml:space="preserve">
    <value>Nie można użyć składni inicjatora obiektów do zainicjowania wystąpienia obiektu System.Object.</value>
  </data>
  <data name="ERR_NotOverridableRequiresOverrides" xml:space="preserve">
    <value>Dla metod, które nie przesłaniają innej metody, nie można określić słowa kluczowego „NotOverridable”.</value>
  </data>
  <data name="WRN_XMLDocDuplicateXMLNode1" xml:space="preserve">
    <value>Tag komentarza XML „{0}” występuje z identycznymi atrybutami więcej niż raz w tym samym bloku komentarza XML.</value>
  </data>
  <data name="ERR_SpecifiersInvalidOnInheritsImplOpt" xml:space="preserve">
    <value>Specyfikatory i atrybuty nie są prawidłowe w tej instrukcji.</value>
  </data>
  <data name="ERR_AddressOfInSelectCaseExpr" xml:space="preserve">
    <value>Wyrażenia „AddressOf” nie są prawidłowe w pierwszym wyrażeniu instrukcji „Select Case”.</value>
  </data>
  <data name="WRN_Experimental" xml:space="preserve">
    <value>Element „{0}” jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</value>
  </data>
  <data name="PositionIsNotWithinSyntax" xml:space="preserve">
    <value>Pozycja nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="WRN_ObsoleteIdentityDirectCastForValueType" xml:space="preserve">
    <value>Użycie operatora DirectCast do rzutowania typu wartości na ten sam typ jest przestarzałe.</value>
  </data>
  <data name="WRN_XMLDocBadParamTag2" xml:space="preserve">
    <value>Parametr komentarza XML „{0}” nie jest zgodny z parametrem w odpowiedniej instrukcji „{1}”.</value>
  </data>
  <data name="WRN_TypeConflictButMerged6" xml:space="preserve">
    <value>Element {0} „{1}” i częściowy element {2} „{3}” powodują konflikt w elemencie {4} „{5}”, ale są scalane, ponieważ jeden z nich jest zadeklarowany jako częściowy.</value>
  </data>
  <data name="ERR_ExpectedLbrace" xml:space="preserve">
    <value>Oczekiwano znaku „{”.</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryIn4" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ zmianę elementu „{2}” w definicji „{3}” na parametr typu In, „In {2}”.</value>
  </data>
  <data name="ERR_BadMethodFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji metody.</value>
  </data>
  <data name="ERR_RequiredNewCallTooMany2" xml:space="preserve">
    <value>Pierwszą instrukcją w tym bloku „Sub New” musi być wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ klasa podstawowa „{0}” klasy „{1}” ma więcej niż jeden dostępny element „Sub New”, który można wywołać bez argumentów.</value>
  </data>
  <data name="ERR_CannotBeMadeNullable1" xml:space="preserve">
    <value>Nie można ustawić elementu „{0}” jako dopuszczającego wartość null.</value>
  </data>
  <data name="ERR_TypeDisallowsElements" xml:space="preserve">
    <value>Nie można wybierać elementów XML z typu „{0}”.</value>
  </data>
  <data name="ERR_MultipleEventImplMismatch3" xml:space="preserve">
    <value>Zdarzenie „{0}” nie może implementować zdarzenia „{2}.{1}”, ponieważ jego typ delegowany nie pasuje do typu delegowanego innego zdarzenia implementowanego przez zdarzenie „{0}”.</value>
  </data>
  <data name="ERR_InvalidDate" xml:space="preserve">
    <value>Stała daty jest nieprawidłowa.</value>
  </data>
  <data name="ERR_InvalidOptionInfer" xml:space="preserve">
    <value>Po instrukcji „Option Infer” może wystąpić jedynie opcja „On” lub „Off”.</value>
  </data>
  <data name="ERR_ExpectedLparen" xml:space="preserve">
    <value>Oczekiwano znaku „(”.</value>
  </data>
  <data name="ERR_InvalidAsyncIteratorModifiers" xml:space="preserve">
    <value>Modyfikatory „Async” i „Iterator” nie mogą być używane razem.</value>
  </data>
  <data name="ThereIsNoDynamicTypeInVB" xml:space="preserve">
    <value>Brak typów dynamicznych w języku Visual Basic.</value>
  </data>
  <data name="ERR_OneParameterRequired1" xml:space="preserve">
    <value>Operator „{0}” musi mieć jeden parametr.</value>
  </data>
  <data name="ERR_TypeOfExprAlwaysFalse2" xml:space="preserve">
    <value>Wyrażenie typu „{0}” nigdy nie może być typu „{1}”.</value>
  </data>
  <data name="ERR_EnumNotExpression1" xml:space="preserve">
    <value>Typem elementu „{0}” jest typ wyliczeniowy i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="ERR_InvalidEndFunction" xml:space="preserve">
    <value>Instrukcja End Function musi być poprzedzona odpowiadającą jej instrukcją Function.</value>
  </data>
  <data name="WRN_LiftControlVariableLambda" xml:space="preserve">
    <value>Użycie zmiennej iteracyjnej w wyrażeniu lambda może spowodować nieoczekiwane wyniki. Zamiast tego utwórz zmienną lokalną w pętli i przypisz jej wartość zmiennej iteracyjnej.</value>
  </data>
  <data name="WRN_LateBindingResolution" xml:space="preserve">
    <value>Rozpoznanie późnego wiązania; mogą wystąpić błędy w czasie wykonywania.</value>
  </data>
  <data name="ERR_ConvMustBeWideningOrNarrowing" xml:space="preserve">
    <value>Operatory konwersji muszą być zadeklarowane jako Widening lub Narrowing.</value>
  </data>
  <data name="ERR_SharedEventNeedsSharedHandler" xml:space="preserve">
    <value>Zdarzenia udostępnionych zmiennych WithEvents nie mogą zostać obsłużone przez metody nieudostępnione.</value>
  </data>
  <data name="ERR_UnacceptableLogicalOperator3" xml:space="preserve">
    <value>Typy zwracane i typy parametrów „{0}” muszą być typu „{1}”, aby można było ich używać w wyrażeniu „{2}”.</value>
  </data>
  <data name="ERR_LineContWithCommentOrNoPrecSpace" xml:space="preserve">
    <value>Znak kontynuacji wiersza „_” musi być poprzedzony co najmniej jednym białym znakiem i musi być ostatnim znakiem w wierszu.</value>
  </data>
  <data name="ERR_InterfaceEventCantUse1" xml:space="preserve">
    <value>Zdarzenia w interfejsach nie mogą być zadeklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_InvalidVersionFormat2" xml:space="preserve">
    <value>Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall3" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” powinna być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ element „{0}” w klasie podstawowej „{1}” elementu „{2}” jest oznaczony jako przestarzały.</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall4" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” powinna być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ element „{0}” w klasie podstawowej „{1}” elementu „{2}” jest oznaczony jako przestarzały: „{3}”.</value>
  </data>
  <data name="ERR_InterfaceCantUseEventSpecifier1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji zdarzenia interfejsu.</value>
  </data>
  <data name="ERR_ExpressionOverflow1" xml:space="preserve">
    <value>Nieprawidłowa reprezentacja wyrażenia stałego w typie „{0}”.</value>
  </data>
  <data name="ERR_OverrideWithByref2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się parametrem oznaczonym jest jako „ByRef” lub „ByVal”.</value>
  </data>
  <data name="ERR_UnimplementedMustOverride" xml:space="preserve">
    <value>
    {0}: {1}</value>
  </data>
  <data name="ERR_NewOnAbstractClass" xml:space="preserve">
    <value>Nie można użyć instrukcji „New” w klasie, która jest zadeklarowana jako „MustInherit”.</value>
  </data>
  <data name="ERR_MismatchedXmlEndTag" xml:space="preserve">
    <value>Oczekiwano tagu końcowego &lt;/{0}{1}{2}&gt;.</value>
  </data>
  <data name="LocationMustBeProvided" xml:space="preserve">
    <value>Lokalizacja musi być określona, aby zapewnić minimalną kwalifikację typu.</value>
  </data>
  <data name="WRN_InterfaceConversion2_Title" xml:space="preserve">
    <value>Błędy w czasie wykonywania mogą występować podczas konwertowania na typ interfejsu lub z tego typu</value>
  </data>
  <data name="ERR_BinaryFile" xml:space="preserve">
    <value>plik „{0}” nie jest plikiem tekstowym</value>
  </data>
  <data name="ERR_ReturnFromNonFunction" xml:space="preserve">
    <value>Instrukcja Return w bloku Sub lub Set nie może zwracać wartości.</value>
  </data>
  <data name="ERR_DefaultMemberNotProperty1" xml:space="preserve">
    <value>Domyślny element członkowski elementu „{0}” nie jest właściwością.</value>
  </data>
  <data name="ERR_BranchOutOfFinally" xml:space="preserve">
    <value>Rozgałęzianie poza blokiem „Finally” jest nieprawidłowe.</value>
  </data>
  <data name="ERR_CantOpenFileWrite" xml:space="preserve">
    <value>nie można otworzyć elementu „{0}” do zapisu: {1}</value>
  </data>
  <data name="ERR_CantSpecifyArrayAndNullableOnBoth" xml:space="preserve">
    <value>Modyfikator dopuszczający wartość null „?” oraz modyfikatory tablicy „(” i „)” nie mogą być określone jednocześnie w zmiennej i jej typie.</value>
  </data>
  <data name="WRN_VarianceIEnumerableSuggestion3" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ użycie zamiast tego elementu „{2}”.</value>
  </data>
  <data name="ERR_RequiredConstConversion2" xml:space="preserve">
    <value>Konwersja z „{0}” na „{1}” nie może wystąpić w wyrażeniu stałym.</value>
  </data>
  <data name="ERR_MultipleReferenceConstraints" xml:space="preserve">
    <value>Ograniczenie elementu Class nie może być określone wiele razy dla tego samego parametru typu.</value>
  </data>
  <data name="ERR_ExpectedEndIf" xml:space="preserve">
    <value>Instrukcja If musi być zakończona odpowiadającą jej instrukcją End If.</value>
  </data>
  <data name="ERR_ExpectedComma" xml:space="preserve">
    <value>Oczekiwano przecinka.</value>
  </data>
  <data name="WRN_BadGUIDFormatExtChecksum_Title" xml:space="preserve">
    <value>Nieprawidłowy format identyfikatora GUID</value>
  </data>
  <data name="ERR_NoSetProperty1" xml:space="preserve">
    <value>Właściwość „{0}” jest tylko do odczytu.</value>
  </data>
  <data name="ERR_ExpectedMinus" xml:space="preserve">
    <value>Oczekiwano znaku „-”.</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNamesReverse3" xml:space="preserve">
    <value>Interfejs „{0}” (poprzez „{1}”) można zaimplementować tylko raz według tego typu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{2}”.</value>
  </data>
  <data name="ERR_ExpectedQuote" xml:space="preserve">
    <value>Oczekiwano zgodnego podwójnego cudzysłowu zamykającego dla wartości atrybutu XML.</value>
  </data>
  <data name="ERR_NotACollection1" xml:space="preserve">
    <value>Nie można zainicjować typu „{0}” za pomocą inicjatora kolekcji, ponieważ to nie jest typ kolekcji.</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags1" xml:space="preserve">
    <value>Metod dostępu do właściwości nie można deklarować jako „{0}” we właściwości „NotOverridable”.</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags3" xml:space="preserve">
    <value>Właściwość nie może być zadeklarowana jako „{0}”, ponieważ zawiera metodę dostępu „Private”.</value>
  </data>
  <data name="ERR_BadPropertyAccessorFlags2" xml:space="preserve">
    <value>Metod dostępu do właściwości nie można deklarować jako „{0}” we właściwości „Default”.</value>
  </data>
  <data name="ERR_AsyncSubMain" xml:space="preserve">
    <value>Metoda „Main” nie może być oznaczona atrybutem „Async”.</value>
  </data>
  <data name="ERR_NamespaceNotExpression1" xml:space="preserve">
    <value>Element „{0}” jest przestrzenią nazw i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="ERR_ExpectedXmlns" xml:space="preserve">
    <value>Deklaracja przestrzeni nazw musi zaczynać się elementem „xmlns”.</value>
  </data>
  <data name="WRN_ShadowingGenericParamWithParam1_Title" xml:space="preserve">
    <value>Parametr typu ma taką samą nazwę jak parametr typu otaczającego</value>
  </data>
  <data name="ERR_MatchingOperatorExpected2" xml:space="preserve">
    <value>Wymagany pasujący operator „{0}” dla elementu „{1}”.</value>
  </data>
  <data name="ERR_NewInInterface" xml:space="preserve">
    <value>Nie można zadeklarować elementu Sub New w interfejsie.</value>
  </data>
  <data name="ERR_ExpectedEndWith" xml:space="preserve">
    <value>Instrukcja With musi być zakończona odpowiadającą jej instrukcją End With.</value>
  </data>
  <data name="ERR_WriteOnlyHasNoWrite" xml:space="preserve">
    <value>Właściwość typu WriteOnly musi udostępniać procedurę Set.</value>
  </data>
  <data name="WRN_XMLDocInsideMethod" xml:space="preserve">
    <value>Komentarz XML nie może występować w metodzie ani właściwości. Komentarz XML zostanie zignorowany.</value>
  </data>
  <data name="ERR_VarianceInParamDisallowedForGeneric3" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{1}” w „{2}” w tym kontekście, ponieważ „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="ERR_MissingValuesForArraysInApplAttrs" xml:space="preserve">
    <value>Tablice używane jako argumenty atrybutów są wymagane do jawnego określenia wartości dla wszystkich elementów.</value>
  </data>
  <data name="WRN_DelaySignButNoKey" xml:space="preserve">
    <value>Określono podpisywanie opóźnione, które wymaga klucza publicznego. Nie określono jednak żadnego klucza publicznego.</value>
  </data>
  <data name="ERR_ParamArrayArgumentMismatch" xml:space="preserve">
    <value>Argument nie jest zgodny z parametrem ParamArray.</value>
  </data>
  <data name="ERR_BadAttributeNonPublicType1" xml:space="preserve">
    <value>Nie można użyć typu „{0}” w atrybucie, ponieważ nie jest on zadeklarowany jako „Public”.</value>
  </data>
  <data name="FEATURE_RegionsEverywhere" xml:space="preserve">
    <value>dyrektywy regionu w treści metod lub regiony przekraczające granice bloków deklaracji</value>
  </data>
  <data name="WRN_UseOfObsoletePropertyAccessor2_Title" xml:space="preserve">
    <value>Metoda dostępu do właściwości jest przestarzała</value>
  </data>
  <data name="WRN_SharedMemberThroughInstance_Title" xml:space="preserve">
    <value>Dostęp przez wystąpienie do udostępnionego elementu członkowskiego, stałego elementu członkowskiego, elementu członkowskiego wyliczenia lub typu zagnieżdżonego</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase3" xml:space="preserve">
    <value>Klasa „{0}” powinna deklarować element „Sub New”, ponieważ element „{1}” w swojej klasie podstawowej „{2}” jest oznaczony jako przestarzały.</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase4" xml:space="preserve">
    <value>Klasa „{0}” powinna deklarować element „Sub New”, ponieważ element „{1}” w swojej klasie podstawowej „{2}” jest oznaczony jako przestarzały: „{3}”.</value>
  </data>
  <data name="ERR_VarianceOutParamDisallowedForGeneric3" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{1}” w „{2}” w tym kontekście, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_BadAsyncInQuery" xml:space="preserve">
    <value>Operatora „Await” można użyć tylko w wyrażeniu zapytania w pierwszym wyrażeniu kolekcji początkowej klauzuli „From” albo w wyrażeniu kolekcji klauzuli „Join”.</value>
  </data>
  <data name="ERR_InvalidOptionExplicit" xml:space="preserve">
    <value>Po instrukcji Option Explicit może wystąpić jedynie opcja On lub Off.</value>
  </data>
  <data name="ERR_AmbiguousInModules2" xml:space="preserve">
    <value>Element „{0}” jest niejednoznaczny między deklaracjami w modułach „{1}”.</value>
  </data>
  <data name="WRN_LambdaTooManyTypesObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu, ponieważ jest możliwy więcej niż jeden typ; przyjęto „Object”.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRef_Title" xml:space="preserve">
    <value>Zmienna została przekazana przez odwołanie przed przypisaniem do niej wartości</value>
  </data>
  <data name="ERR_InterfaceBaseUnifiesWithBase4" xml:space="preserve">
    <value>Nie można dziedziczyć interfejsu „{0}”, ponieważ interfejs „{1}”, po którym ten interfejs dziedziczy, może być taki sam jak interfejs „{2}”, po którym dziedziczy interfejs „{3}” dla niektórych argumentów typu.</value>
  </data>
  <data name="SemanticModelMustBeProvided" xml:space="preserve">
    <value>Należy podać element SemanticModel w celu określenia minimalnej kwalifikacji typu.</value>
  </data>
  <data name="ERR_ExpectedAnd" xml:space="preserve">
    <value>Oczekiwano operatora „And”.</value>
  </data>
  <data name="ERR_ExpectedEOS" xml:space="preserve">
    <value>Oczekiwano końca instrukcji.</value>
  </data>
  <data name="ERR_ExpectedDot" xml:space="preserve">
    <value>Oczekiwano znaku „.”.</value>
  </data>
  <data name="ERR_ExpectedDiv" xml:space="preserve">
    <value>Oczekiwano znaku „/” dla tagu końcowego XML.</value>
  </data>
  <data name="ERR_DuplicateReference2" xml:space="preserve">
    <value>Projekt już ma odwołanie do zestawu {0}. Nie można dodać drugiego odwołania do elementu „{1}”.</value>
  </data>
  <data name="ERR_DuplicateSpecifier" xml:space="preserve">
    <value>Specyfikator jest zduplikowany.</value>
  </data>
  <data name="ERR_DuplicateNamedImportAlias1" xml:space="preserve">
    <value>Alias „{0}” jest już zadeklarowany.</value>
  </data>
  <data name="ERR_ModuleAsType1" xml:space="preserve">
    <value>Nie można użyć modułu „{0}” jako typu.</value>
  </data>
  <data name="ERR_NewCannotHandleEvents" xml:space="preserve">
    <value>Element Sub New nie może obsługiwać zdarzeń.</value>
  </data>
  <data name="ERR_ArrayInitInStruct" xml:space="preserve">
    <value>Tablice deklarowane jako elementy członkowskie struktur nie mogą być deklarowane z rozmiarem początkowym.</value>
  </data>
  <data name="ERR_NestedInteropType" xml:space="preserve">
    <value>Typ zagnieżdżony „{0}” nie może zostać osadzony.</value>
  </data>
  <data name="ERR_ExpectedAssignmentOperator" xml:space="preserve">
    <value>Oczekiwano znaku „=”.</value>
  </data>
  <data name="ERR_BadInterfaceStructSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować struktury w interfejsie jako „{0}”.</value>
  </data>
  <data name="IDS_MSG_ADDREFERENCE" xml:space="preserve">
    <value>Dodawanie odwołania do zestawu „{0}”</value>
  </data>
  <data name="FEATURE_NameOfExpressions" xml:space="preserve">
    <value>wyrażenia „nameof”</value>
  </data>
  <data name="WRN_ReturnTypeAttributeOnWriteOnlyProperty" xml:space="preserve">
    <value>Zastosowanie atrybutów w typie zwracanym właściwości WriteOnly nie przyniosło żadnego skutku.</value>
  </data>
  <data name="WRN_DefAsgUseNullRef_Title" xml:space="preserve">
    <value>Zmienna została użyta przed przypisaniem do niej wartości</value>
  </data>
  <data name="ERR_BadAnonymousTypeForExprTree" xml:space="preserve">
    <value>Nie można przekonwertować typu anonimowego na drzewo wyrażenia, ponieważ właściwość typu jest używana do inicjowania innej właściwości.</value>
  </data>
  <data name="ERR_ModuleNotAtNamespace" xml:space="preserve">
    <value>Instrukcje Module mogą wystąpić tylko na poziomie pliku lub przestrzeni nazw.</value>
  </data>
  <data name="ERR_VarianceConversionFailedTryOut4" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ zmianę elementu „{2}” w definicji „{3}” na parametr typu Out, „Out {2}”.</value>
  </data>
  <data name="ERR_DelegateBindingTypeInferenceFails" xml:space="preserve">
    <value>Nie można wywnioskować argumentów typu na podstawie delegata.</value>
  </data>
  <data name="ERR_MissingGuidForOption" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: brak identyfikatora Guid dla opcji „{1}”</value>
  </data>
  <data name="WRN_ConflictingMachineAssembly" xml:space="preserve">
    <value>Celem przywołanego zestawu „{0}” jest inny procesor.</value>
  </data>
  <data name="WRN_InheritedInterfaceNotCLSCompliant2_Title" xml:space="preserve">
    <value>Typ jest niezgodny ze specyfikacją CLS, ponieważ interfejs, po którym on dziedziczy, jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_PeWritingFailure" xml:space="preserve">
    <value>Wystąpił błąd podczas zapisywania pliku wyjściowego: {0}</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted3" xml:space="preserve">
    <value>Parametr „{0}” metody rozszerzenia „{1}” zdefiniowanej w elemencie „{2}” ma już pasujący pominięty argument.</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted2" xml:space="preserve">
    <value>Parametr „{0}” w elemencie „{1}” ma już pasujący pominięty argument.</value>
  </data>
  <data name="ERR_NamedArgAlsoOmitted1" xml:space="preserve">
    <value>Parametr „{0}” ma już pasujący pominięty argument.</value>
  </data>
  <data name="WRN_InvalidVersionFormat_Title" xml:space="preserve">
    <value>Określony ciąg wersji jest niezgodny z zalecanym formatem</value>
  </data>
  <data name="ERR_ParamArrayWrongType" xml:space="preserve">
    <value>Parametry ParamArray muszą być typu tablicowego.</value>
  </data>
  <data name="ERR_TooFewIndices" xml:space="preserve">
    <value>Liczba indeksów jest mniejsza niż liczba wymiarów tablicy indeksowanej.</value>
  </data>
  <data name="ERR_SynthMemberShadowsMustOverride5" xml:space="preserve">
    <value>Element „{0}” niejawnie zadeklarowany dla elementu {1} „{2}” nie może zasłonić metody „MustOverride” w podstawowym elemencie {3} „{4}”.</value>
  </data>
  <data name="ERR_EventNotFound1" xml:space="preserve">
    <value>Nie można znaleźć zdarzenia „{0}”.</value>
  </data>
  <data name="ERR_DTDNotSupported" xml:space="preserve">
    <value>Definicje DTD XML nie są obsługiwane.</value>
  </data>
  <data name="ERR_DuplicateAddHandlerDef" xml:space="preserve">
    <value>Element „AddHandler” jest już zadeklarowany.</value>
  </data>
  <data name="ERR_NoNonObsoleteConstructorOnBase4" xml:space="preserve">
    <value>Klasa „{0}” musi deklarować element „Sub New”, ponieważ element „{1}” w swojej klasie podstawowej „{2}” jest oznaczony jako przestarzały: „{3}”.</value>
  </data>
  <data name="ERR_NoNonObsoleteConstructorOnBase3" xml:space="preserve">
    <value>Klasa „{0}” musi deklarować element „Sub New”, ponieważ element „{1}” w swojej klasie podstawowej „{2}” jest oznaczony jako przestarzały.</value>
  </data>
  <data name="DeclarationSyntaxNotWithinTree" xml:space="preserve">
    <value>Brak elementu DeclarationSyntax w drzewie</value>
  </data>
  <data name="WRN_LambdaPassedToRemoveHandler" xml:space="preserve">
    <value>Wyrażenie lambda nie zostanie usunięte z tej procedury obsługi zdarzeń. Przypisz wyrażenie lambda do zmiennej i używaj jej do dodawania i usuwania zdarzenia.</value>
  </data>
  <data name="ERR_ConstructorFunction" xml:space="preserve">
    <value>Konstruktor musi być zadeklarowany jako procedura, a nie funkcja.</value>
  </data>
  <data name="ERR_LbElseNoMatchingIf" xml:space="preserve">
    <value>Instrukcja #Else musi być poprzedzona odpowiadającą jej instrukcją #If lub #ElseIf.</value>
  </data>
  <data name="ERR_BadIteratorExpressionLambda" xml:space="preserve">
    <value>Jednowierszowe wyrażenia lambda nie mogą mieć modyfikatora „Iterator”. W takim przypadku należy używać wielowierszowych wyrażeń lambda.</value>
  </data>
  <data name="ERR_EqualsOperandIsBad" xml:space="preserve">
    <value>Po obu stronach operatora „Equals” musi znajdować się odwołanie do co najmniej jednej zmiennej zakresu. Zmienne zakresu {0} muszą znajdować się po jednej, a zmienne zakresu {1} po drugiej stronie operatora „Equals”.</value>
  </data>
  <data name="ERR_MultipleClassConstraints1" xml:space="preserve">
    <value>Parametr typu „{0}” może mieć tylko jedno ograniczenie, które jest klasą.</value>
  </data>
  <data name="ERR_NarrowingConversionCollection2" xml:space="preserve">
    <value>Ustawienie „Option Strict On” uniemożliwia niejawną konwersję z elementu „{0}” na „{1}”. Typ kolekcji języka Visual Basic 6.0 nie jest zgodny z typem kolekcji .NET Framework.</value>
  </data>
  <data name="ERR_ObsoleteWhileWend" xml:space="preserve">
    <value>Instrukcje „Wend” nie są już obsługiwane. Zamiast nich używaj instrukcji „End While”.</value>
  </data>
  <data name="ERR_CantAssignToConst" xml:space="preserve">
    <value>Stała nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="WRN_DefAsgUseNullRefByRefStr_Title" xml:space="preserve">
    <value>Zmienna została przekazana przez odwołanie przed przypisaniem do niej wartości</value>
  </data>
  <data name="ERR_AnonTypeFieldXMLNameInference" xml:space="preserve">
    <value>Nie można wywnioskować nazwy elementu członkowskiego typu anonimowego na podstawie identyfikatora XML, który nie jest prawidłowym identyfikatorem języka Visual Basic.</value>
  </data>
  <data name="ERR_DelegateBindingFailure3" xml:space="preserve">
    <value>Żadna z dostępnych metod „{0}” nie ma sygnatury zgodnej z delegatem „{1}”:{2}.</value>
  </data>
  <data name="ERR_EventMethodOptionalParamIllegal1" xml:space="preserve">
    <value>Parametrów metod „AddHandler”, „RemoveHandler” i „RaiseEvent” nie można zadeklarować jako „{0}”.</value>
  </data>
  <data name="WRN_CLSAttrInvalidOnGetSet_Title" xml:space="preserve">
    <value>Nie można zastosować elementu System.CLSCompliantAttribute do właściwości „Get” lub „Set”</value>
  </data>
  <data name="ERR_NoGlobalExpectedIdentifier" xml:space="preserve">
    <value>Element „Global” jest niedozwolony w tym kontekście; oczekiwano identyfikatora.</value>
  </data>
  <data name="ERR_VersionMustBeFirstInXmlDecl" xml:space="preserve">
    <value>Atrybut XML „version” musi być pierwszym atrybutem w deklaracji XML.</value>
  </data>
  <data name="ERR_IsOperatorGenericParam1" xml:space="preserve">
    <value>Argument operacji „Is” typu „{0}” można porównać tylko z elementem „Nothing”, ponieważ element „{0}” jest parametrem typu bez ograniczenia klasy.</value>
  </data>
  <data name="ERR_EndSubExpected" xml:space="preserve">
    <value>Oczekiwano instrukcji End Sub.</value>
  </data>
  <data name="ERR_BadInterfaceMethodFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji metody interfejsu.</value>
  </data>
  <data name="ERR_VarianceDisallowedHere" xml:space="preserve">
    <value>Słów kluczowych „Out” oraz „In” można używać tylko w deklaracjach interfejsu i delegata.</value>
  </data>
  <data name="ERR_BadStaticLocalInGenericMethod" xml:space="preserve">
    <value>Zmienne lokalne z metodami ogólnymi nie mogą być deklarowane jako Static.</value>
  </data>
  <data name="ERR_NewInStruct" xml:space="preserve">
    <value>Struktury nie mogą deklarować nieudostępnianych elementów „Sub New” bez parametrów.</value>
  </data>
  <data name="ERR_UsingResourceVarNeedsInitializer" xml:space="preserve">
    <value>Zmienna zasobu Using musi być jawnie inicjowana.</value>
  </data>
  <data name="ERR_InvalidSignaturePublicKey" xml:space="preserve">
    <value>W atrybucie AssemblySignatureKeyAttribute określono nieprawidłowy klucz publiczny sygnatury.</value>
  </data>
  <data name="WRN_TupleLiteralNameMismatch" xml:space="preserve">
    <value>Nazwa elementu krotki „{0}” została zignorowana, ponieważ typ elementu docelowego „{1}” określa inną nazwę lub nie określa żadnej nazwy.</value>
  </data>
  <data name="ERR_MultipleValueConstraints" xml:space="preserve">
    <value>Ograniczenie elementu Structure nie może być określone wiele razy dla tego samego parametru typu.</value>
  </data>
  <data name="ERR_AnonymousTypeExpectedIdentifier" xml:space="preserve">
    <value>Oczekiwano identyfikatora poprzedzonego kropką.</value>
  </data>
  <data name="ERR_CaseAfterCaseElse" xml:space="preserve">
    <value>Instrukcja Case nie może wystąpić po instrukcji Case Else w tej samej instrukcji Select.</value>
  </data>
  <data name="ERR_UnreferencedModuleEvent3" xml:space="preserve">
    <value>Wymagane odwołanie do modułu „{0}” z definicją zdarzenia „{1}”. Dodaj je do projektu.</value>
  </data>
  <data name="ERR_NonFieldPropertyAggrMemberInit1" xml:space="preserve">
    <value>Nie można zainicjować elementu członkowskiego „{0}” w wyrażeniu inicjatora obiektów, ponieważ nie jest on polem ani właściwością.</value>
  </data>
  <data name="WRN_LambdaTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu, ponieważ możliwe jest użycie więcej niż jednego typu</value>
  </data>
  <data name="ERR_TupleLiteralDisallowsTypeChar" xml:space="preserve">
    <value>Znaki typu nie mogą być używane w literałach krotek.</value>
  </data>
  <data name="ERR_InterpolatedStringFactoryError" xml:space="preserve">
    <value>Wystąpił co najmniej jeden błąd podczas emitowania wywołania do elementu {0}.{1}. Brak metody lub jej typu zwracanego bądź zostały one źle sformułowane.</value>
  </data>
  <data name="ERR_InheritsFromNonInterface" xml:space="preserve">
    <value>Interfejs może dziedziczyć tylko po innym interfejsie.</value>
  </data>
  <data name="ERR_IfTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu, ponieważ jest możliwy więcej niż jeden typ.</value>
  </data>
  <data name="WRN_XMLDocWithoutLanguageElement_Title" xml:space="preserve">
    <value>Komentarze dokumentacji XML muszą występować przed deklaracjami elementu członkowskiego lub typu</value>
  </data>
  <data name="ERR_ExpectedRparen" xml:space="preserve">
    <value>Oczekiwano znaku „)”.</value>
  </data>
  <data name="ERR_ExpectedSQuote" xml:space="preserve">
    <value>Oczekiwano zgodnego pojedynczego cudzysłowu zamykającego dla wartości atrybutu XML.</value>
  </data>
  <data name="ERR_CaseElseNoSelect" xml:space="preserve">
    <value>Instrukcja Case Else może wystąpić tylko wewnątrz instrukcji Select Case.</value>
  </data>
  <data name="ERR_ExpectedRbrace" xml:space="preserve">
    <value>Oczekiwano znaku „}”.</value>
  </data>
  <data name="ERR_CantAwaitAsyncSub1" xml:space="preserve">
    <value>Element „{0}” nie zwraca zadania i nie jest możliwe oczekiwanie na niego. Rozważ zmianę tego elementu na funkcję asynchroniczną.</value>
  </data>
  <data name="ERR_ExpectedSColon" xml:space="preserve">
    <value>Oczekiwano zamykającego znaku „;” dla jednostki XML.</value>
  </data>
  <data name="ERR_UnacceptableForLoopRelOperator2" xml:space="preserve">
    <value>Typy parametru „{0}” muszą być typu „{1}”, aby można było ich użyć w instrukcji 'For'.</value>
  </data>
  <data name="ERR_GenericParamsOnInvalidMember" xml:space="preserve">
    <value>W tej deklaracji nie można określić parametrów typu.</value>
  </data>
  <data name="WRN_InterfaceConversion2" xml:space="preserve">
    <value>Podczas konwertowania elementu „{0}” na „{1}” mogą wystąpić błędy czasu wykonywania.</value>
  </data>
  <data name="ERR_RequiredNonObsoleteNewCall4" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” musi być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ element „{0}” w klasie podstawowej „{1}” klasy „{2}” jest oznaczony jako przestarzały: „{3}”.</value>
  </data>
  <data name="ERR_RequiredNonObsoleteNewCall3" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” musi być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ element „{0}” w klasie podstawowej „{1}” klasy „{2}” jest oznaczony jako przestarzały.</value>
  </data>
  <data name="ERR_OverridesImpliesOverridable" xml:space="preserve">
    <value>Metody zadeklarowane jako „Overrides” nie mogą być zadeklarowane jako „Overridable”, ponieważ niejawnie są one możliwe do przesłonięcia.</value>
  </data>
  <data name="ERR_NarrowingConversionDisallowed2" xml:space="preserve">
    <value>Ustawienie „Option Strict On” uniemożliwia niejawne konwersje z elementu „{0}” na „{1}”.</value>
  </data>
  <data name="ERR_BadResumableAccessReturnVariable" xml:space="preserve">
    <value>Nie można uzyskać dostępu do niejawnie zwracanej zmiennej metody iteracyjnej lub asynchronicznej.</value>
  </data>
  <data name="ERR_AttributeMustBeClassNotStruct1" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako atrybutu, ponieważ nie jest on klasą.</value>
  </data>
  <data name="ERR_InvalidNewInType" xml:space="preserve">
    <value>Instrukcja New nie jest prawidłowa w tym kontekście.</value>
  </data>
  <data name="ERR_PermissionSetAttributeFileReadError" xml:space="preserve">
    <value>Błąd podczas odczytu pliku „{0}” określonego dla nazwanego argumentu „{1}” dla atrybutu PermissionSet: „{2}”.</value>
  </data>
  <data name="ERR_InheritanceCycleInImportedType1" xml:space="preserve">
    <value>Typ „{0}” nie jest obsługiwany, ponieważ dziedziczy on pośrednio albo bezpośrednio po sobie samym.</value>
  </data>
  <data name="WRN_NameNotCLSCompliant1" xml:space="preserve">
    <value>Nazwa „{0}” jest niezgodna ze specyfikacją CLS.</value>
  </data>
  <data name="WRN_UndefinedOrEmptyNamespaceOrClass1" xml:space="preserve">
    <value>Przestrzeń nazw lub typ określone w elemencie Imports „{0}” nie zawierają żadnego publicznego elementu członkowskiego lub nie można odnaleźć takich elementów. Upewnij się, że przestrzeń nazw lub typ są zdefiniowane i zawierają co najmniej jeden publiczny element członkowski. Upewnij się, że w nazwie importowanego elementu nie są używane aliasy.</value>
  </data>
  <data name="WRN_PdbUsingNameTooLong" xml:space="preserve">
    <value>Ciąg importu „{0}” jest zbyt długi dla pliku PDB. Rozważ skrócenie go lub skompilowanie bez opcji /debug.</value>
  </data>
  <data name="ERR_ConversionFromObject" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z elementu Object.</value>
  </data>
  <data name="ERR_NoViableOverloadCandidates1" xml:space="preserve">
    <value>Rozpoznanie przeciążenia zakończyło się niepowodzeniem, ponieważ żaden z parametrów „{0}” nie jest dostępny.</value>
  </data>
  <data name="ERR_StructsCannotHandleEvents" xml:space="preserve">
    <value>Metody zadeklarowane w strukturach nie mogą mieć klauzul Handles.</value>
  </data>
  <data name="ERR_AutoPropertyCantHaveParams" xml:space="preserve">
    <value>Właściwości zaimplementowane automatycznie nie mogą mieć parametrów.</value>
  </data>
  <data name="ERR_ArrayInitNoType" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu. Określenie typu tablicy może poprawić ten błąd.</value>
  </data>
  <data name="ERR_ClassInheritsInterfaceBaseUnifiesWithBase4" xml:space="preserve">
    <value>Nie można zaimplementować interfejsu „{0}”, ponieważ interfejs „{1}”, po którym ten interfejs dziedziczy, może być taki sam jak interfejs „{2}”, po którym dziedziczy zaimplementowany interfejs „{3}” dla niektórych argumentów typu.</value>
  </data>
  <data name="ERR_EventAddRemoveHasOnlyOneParam" xml:space="preserve">
    <value>Metody „AddHandler” i „RemoveHandler” muszą mieć dokładnie jeden parametr.</value>
  </data>
  <data name="WRN_NotEqualToLiteralNothing" xml:space="preserve">
    <value>Wartością tego wyrażenia zawsze będzie Nothing (z powodu propagacji wartości null z operatora równości). Aby sprawdzać, czy wartość nie jest równa null, rozważ użycie warunku „IsNot Nothing”.</value>
  </data>
  <data name="WRN_ArrayOverloadsNonCLS2" xml:space="preserve">
    <value>Element „{0}” nie jest zgodny ze specyfikacją CLS, ponieważ przeciąża element „{1}”, który różni się od niego tylko tablicą typów parametrów tablicowych lub rangą typów parametrów tablicowych.</value>
  </data>
  <data name="ERR_VarianceIEnumerableSuggestion3" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ użycie zamiast tego elementu „{2}”.</value>
  </data>
  <data name="ERR_EndOperatorNotAtLineStart" xml:space="preserve">
    <value>Element End Operator musi być pierwszą instrukcją w wierszu.</value>
  </data>
  <data name="ERR_InvalidImplicitVar" xml:space="preserve">
    <value>Zmienna niejawna „{0}” jest nieprawidłowa z powodu „{1}”.</value>
  </data>
  <data name="FEATURE_ArrayLiterals" xml:space="preserve">
    <value>wyrażenia literału w tablicy</value>
  </data>
  <data name="FEATURE_MultilineStringLiterals" xml:space="preserve">
    <value>literały ciągów wielowierszowych</value>
  </data>
  <data name="ERR_ParamDefaultValueDiffersFromAttribute" xml:space="preserve">
    <value>Parametr ma wiele różnych domyślnych wartości.</value>
  </data>
  <data name="ERR_FullWidthAsXmlDelimiter" xml:space="preserve">
    <value>Znaki o pełnej szerokości nie mogą być ogranicznikami XML.</value>
  </data>
  <data name="ERR_TypeClashesWithVbCoreType4" xml:space="preserve">
    <value>Element {0} „{1}” powoduje konflikt ze środowiskiem uruchomieniowym języka Visual Basic {2} „{3}”.</value>
  </data>
  <data name="ERR_InvalidNonSerializedUsage" xml:space="preserve">
    <value>Atrybut NonSerialized nie ma wpływu na ten element członkowski, ponieważ zawierająca go klasa nie jest ujawniona jako element Serializable.</value>
  </data>
  <data name="ERR_ModuleCantInherit" xml:space="preserve">
    <value>Instrukcja Inherits nie jest prawidłowa w modułach.</value>
  </data>
  <data name="ERR_InterpolationAlignmentOutOfRange" xml:space="preserve">
    <value>Wartość wyrównania przypada poza obsługiwanym zakresem.</value>
  </data>
  <data name="ERR_DuplicateRaiseEventDef" xml:space="preserve">
    <value>Element „RaiseEvent” jest już zadeklarowany.</value>
  </data>
  <data name="WRN_UnreachableCode_Title" xml:space="preserve">
    <value>Wykryto nieosiągalny kod</value>
  </data>
  <data name="WRN_AsyncLacksAwaits" xml:space="preserve">
    <value>W tej metodzie asynchronicznej brakuje operatorów „Await”, dlatego będzie wykonywana synchronicznie. Rozważ użycie operatora „Await” w celu zdefiniowania oczekiwania na nieblokujące wywołania interfejsów API albo wyrażenia „Await Task.Run(...)” w celu przeniesienia wykonywania zadań intensywnie angażujących procesor do wątku w tle.</value>
  </data>
  <data name="WRN_XMLMissingFileOrPathAttribute1" xml:space="preserve">
    <value>Tag komentarza XML „include” musi mieć atrybut „{0}”. Komentarz XML zostanie zignorowany.</value>
  </data>
  <data name="ERR_ImplementsStmtWrongOrder" xml:space="preserve">
    <value>Instrukcje „Implements” muszą występować po wszelkich instrukcjach „Inherits” i muszą znajdować się przed wszystkimi deklaracjami w klasie.</value>
  </data>
  <data name="WRN_ExpectedInitComponentCall2_Title" xml:space="preserve">
    <value>Konstruktor w typie wygenerowanym przez projektanta powinien wywoływać metodę InitializeComponent</value>
  </data>
  <data name="WRN_OverrideType5_Title" xml:space="preserve">
    <value>Wystąpił konflikt elementu członkowskiego z elementem członkowskim w typie podstawowym — należy zadeklarować element „Shadows”</value>
  </data>
  <data name="ERR_ExpectedSingleScript" xml:space="preserve">
    <value>Oczekiwano pojedynczego skryptu (plik VBX)</value>
  </data>
  <data name="ERR_LambdasCannotHaveAttributes" xml:space="preserve">
    <value>Nie można zastosować atrybutów do parametrów wyrażeń lambda.</value>
  </data>
  <data name="ERR_LambdaNotDelegate1" xml:space="preserve">
    <value>Wyrażenia lambda nie można przekonwertować na typ „{0}”, ponieważ typ „{0}” nie jest typem delegowanym.</value>
  </data>
  <data name="ERR_NextNoMatchingFor" xml:space="preserve">
    <value>Instrukcja Next musi być poprzedzona odpowiadającą jej instrukcją For.</value>
  </data>
  <data name="ERR_ConstNotClassInterfaceOrTypeParam1" xml:space="preserve">
    <value>Ograniczenie typu „{0}” musi być klasą, interfejsem lub parametrem typu.</value>
  </data>
  <data name="WRN_UnableToLoadAnalyzer" xml:space="preserve">
    <value>Nie można załadować zestawu analizatora {0}: {1}.</value>
  </data>
  <data name="ERR_ReadOnlyAssignment" xml:space="preserve">
    <value>Zmienna typu ReadOnly nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="ERR_PartialTypeTypeParamNameMismatch3" xml:space="preserve">
    <value>Nazwa parametru typu „{0}” nie jest zgodna z nazwą „{1}” odpowiedniego parametru typu zdefiniowanego w jednym z innych typów częściowych elementu „{2}”.</value>
  </data>
  <data name="WRN_LiftControlVariableQuery" xml:space="preserve">
    <value>Użycie zmiennej iteracyjnej w wyrażeniu zapytania może spowodować nieoczekiwane wyniki. Zamiast tego utwórz zmienną lokalną w pętli i przypisz jej wartość zmiennej iteracyjnej.</value>
  </data>
  <data name="ERR_InvalidHandles" xml:space="preserve">
    <value>Element Handles nie jest prawidłowy w deklaracjach operatora.</value>
  </data>
  <data name="ERR_ObjectReferenceNotSupplied" xml:space="preserve">
    <value>Odwołanie do nieudostępnionego elementu członkowskiego wymaga odwołania do obiektu.</value>
  </data>
  <data name="ERR_StrictDisallowsObjectComparison1" xml:space="preserve">
    <value>Ustawienie „Option Strict On” uniemożliwia stosowanie argumentów operacji typu Object dla operatora „{0}”. Użyj operatora „Is” w celu zbadania tożsamości obiektu.</value>
  </data>
  <data name="ERR_OverloadWithArrayVsParamArray2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie parametrami zadeklarowanymi jako „ParamArray”.</value>
  </data>
  <data name="ERR_EventImplRemoveHandlerParamWrong" xml:space="preserve">
    <value>Zdarzenie „{0}” nie może implementować zdarzenia „{1}” w interfejsie „{2}”, ponieważ parametry ich metod „RemoveHandler” są niezgodne.</value>
  </data>
  <data name="ERR_UnrecognizedEnd" xml:space="preserve">
    <value>Instrukcja End jest nieprawidłowa.</value>
  </data>
  <data name="ERR_ConvertObjectArrayMismatch3" xml:space="preserve">
    <value>Nie można przekonwertować wartości typu „{0}” na „{1}”, ponieważ element „{2}” nie jest typem referencyjnym.</value>
  </data>
  <data name="ERR_BadModuleFlags1" xml:space="preserve">
    <value>Moduły nie mogą być deklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_IllegalXmlWhiteSpace" xml:space="preserve">
    <value>Tutaj nie mogą występować białe znaki.</value>
  </data>
  <data name="WRN_XMLDocIllegalTagOnElement2" xml:space="preserve">
    <value>Tag komentarza XML „{0}” nie jest dozwolony w elemencie języka „{1}”.</value>
  </data>
  <data name="ERR_NotMostSpecificOverload" xml:space="preserve">
    <value>Brak specyficznego elementu.</value>
  </data>
  <data name="WRN_BadSwitch" xml:space="preserve">
    <value>nierozpoznana opcja „{0}”; zignorowano</value>
  </data>
  <data name="ERR_BadOverrideAccess2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ mają one różne poziomy dostępu.</value>
  </data>
  <data name="WRN_MutableStructureInUsing" xml:space="preserve">
    <value>Zmienna lokalna „{0}” jest tylko do odczytu i jej typ jest strukturą. Wywoływanie jej elementów członkowskich lub przekazywanie jej przez odwołanie (ByRef) nie zmienia jej zawartości i może prowadzić do nieoczekiwanych wyników. Rozważ zadeklarowanie tej zmiennej poza blokiem „Using”.</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryOut4_Title" xml:space="preserve">
    <value>Nie można przekonwertować typu na typ docelowy</value>
  </data>
  <data name="VariableSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Element variableSyntax nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden" xml:space="preserve">
    <value>Atrybut „{0}” z modułu „{1}” zostanie zignorowany na rzecz wystąpienia ze źródła.</value>
  </data>
  <data name="ERR_UseOfObsoletePropertyAccessor2" xml:space="preserve">
    <value>Metoda dostępu „{0}” elementu „{1}” jest przestarzała.</value>
  </data>
  <data name="ERR_UseOfObsoletePropertyAccessor3" xml:space="preserve">
    <value>Metoda dostępu „{0}” elementu „{1}” jest przestarzała: „{2}”.</value>
  </data>
  <data name="ERR_TupleTooFewElements" xml:space="preserve">
    <value>Krotka musi zawierać co najmniej dwa elementy.</value>
  </data>
  <data name="ERR_InferringNonArrayType1" xml:space="preserve">
    <value>Nie można zainicjować zmiennej przy użyciu typu nietablicowego „{0}”.</value>
  </data>
  <data name="FEATURE_LineContinuationComments" xml:space="preserve">
    <value>komentarze dotyczące kontynuacji wiersza</value>
  </data>
  <data name="WRN_EmptyPrefixAndXmlnsLocalName_Title" xml:space="preserve">
    <value>Atrybut xmlns ma specjalne znaczenie i nie powinien być zapisywany z prefiksem</value>
  </data>
  <data name="WRN_BadUILang" xml:space="preserve">
    <value>Nazwa języka „{0}” jest nieprawidłowa.</value>
  </data>
  <data name="WRN_EqualToLiteralNothing_Title" xml:space="preserve">
    <value>To wyrażenie zawsze da wynik Nothing</value>
  </data>
  <data name="ERR_ArgumentCopyBackNarrowing3" xml:space="preserve">
    <value>Kopiowanie wartości parametru „ByRef” „{0}” z powrotem do pasującego argumentu powoduje zawężenie z typu „{1}” do typu „{2}”.</value>
  </data>
  <data name="ERR_InvalidAssemblyCulture" xml:space="preserve">
    <value>Ciągi kultury zestawu nie mogą zawierać osadzonych znaków NUL.</value>
  </data>
  <data name="ERR_ClassConstraintNotInheritable1" xml:space="preserve">
    <value>Ograniczenie typu nie może być klasą NotInheritable.</value>
  </data>
  <data name="ERR_BadSpecifierCombo2" xml:space="preserve">
    <value>Nie można połączyć elementów „{0}” i „{1}”.</value>
  </data>
  <data name="ERR_TooManyGenericArguments1" xml:space="preserve">
    <value>Za dużo argumentów typu elementu „{0}”.</value>
  </data>
  <data name="ERR_TooManyGenericArguments2" xml:space="preserve">
    <value>Za dużo argumentów typu dla metody rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”.</value>
  </data>
  <data name="ERR_EndProp" xml:space="preserve">
    <value>We właściwości brakuje instrukcji End Property.</value>
  </data>
  <data name="WRN_OverlappingCatch" xml:space="preserve">
    <value>Blok „Catch” nigdy nie został osiągnięty, ponieważ element „{0}” dziedziczy po elemencie „{1}”.</value>
  </data>
  <data name="WRN_BadChecksumValExtChecksum" xml:space="preserve">
    <value>Nieprawidłowa wartość sumy kontrolnej, cyfry nieszesnastkowe lub nieparzysta liczba cyfr szesnastkowych.</value>
  </data>
  <data name="WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title" xml:space="preserve">
    <value>Zastosowanie atrybutów w typie zwracanym właściwości WriteOnly nie przyniosło żadnego skutku</value>
  </data>
  <data name="ERR_SubRequiresParenthesesDot" xml:space="preserve">
    <value>Jednowierszowa instrukcja lambda musi być ujęta w nawiasy. Na przykład: (Sub() &lt;instrukcja&gt;).Invoke()</value>
  </data>
  <data name="WRN_MultipleDeclFileExtChecksum" xml:space="preserve">
    <value>Nazwa pliku została już zadeklarowana z innym identyfikatorem GUID i wartością sumy kontrolnej.</value>
  </data>
  <data name="ERR_AddOrRemoveHandlerEvent" xml:space="preserve">
    <value>Argument operacji zdarzenia dla instrukcji „AddHandler” lub „RemoveHandler” musi być wyrażeniem kwalifikowanym kropką lub nazwą prostą.</value>
  </data>
  <data name="ERR_CantHaveWin32ResAndManifest" xml:space="preserve">
    <value>Określono opcje powodujące konflikt: plik zasobów Win32; manifest Win32.</value>
  </data>
  <data name="ERR_ZeroDivide" xml:space="preserve">
    <value>Podczas obliczania tego wyrażenia wystąpiło dzielenie przez zero.</value>
  </data>
  <data name="WRN_ObjectMathSelectCase" xml:space="preserve">
    <value>Argumenty operacji typu Object używane w wyrażeniach dla instrukcji Select, Case; mogą wystąpić błędy czasu wykonania.</value>
  </data>
  <data name="ERR_InvalidInNamespace" xml:space="preserve">
    <value>Instrukcja nie jest prawidłowa w przestrzeni nazw.</value>
  </data>
  <data name="ERR_UsingRequiresDisposePattern" xml:space="preserve">
    <value>Argument operacji „Using” typu „{0}” musi implementować interfejs „System.IDisposable”.</value>
  </data>
  <data name="ERR_ModuleCantUseTypeSpecifier1" xml:space="preserve">
    <value>Typ w module nie może być zadeklarowany jako „{0}”.</value>
  </data>
  <data name="ERR_PartialTypeConstraintMismatch1" xml:space="preserve">
    <value>Ograniczenia dla tego parametru typu nie są zgodne z ograniczeniami w odpowiednim parametrze typu zdefiniowanym w jednym z innych typów częściowych elementu „{0}”.</value>
  </data>
  <data name="ERR_ConstraintAlreadyExists1" xml:space="preserve">
    <value>Typ ograniczenia „{0}” jest już określony dla tego parametru typu.</value>
  </data>
  <data name="ERR_CatchVariableNotLocal1" xml:space="preserve">
    <value>Element „{0}” nie jest zmienną lokalną ani parametrem i w związku z tym nie można go użyć jako zmiennej instrukcji „Catch”.</value>
  </data>
  <data name="CompilationVisualBasic" xml:space="preserve">
    <value>Kompilacja (Visual Basic): </value>
  </data>
  <data name="ERR_OnErrorInUsing" xml:space="preserve">
    <value>Instrukcje On Error nie są prawidłowe w instrukcjach Using.</value>
  </data>
  <data name="WRN_VarianceConversionFailedTryOut4" xml:space="preserve">
    <value>Nie można skonwertować elementu „{0}” na „{1}”. Rozważ zmianę elementu „{2}” w definicji „{3}” na parametr typu Out, „Out {2}”.</value>
  </data>
  <data name="WRN_ObjectMath1Not_Title" xml:space="preserve">
    <value>Dla operatora &lt;&gt; użyto argumentów operacji typu Object</value>
  </data>
  <data name="ERR_CatchAfterFinally" xml:space="preserve">
    <value>Instrukcja Catch nie może wystąpić po instrukcji Finally w instrukcji Try.</value>
  </data>
  <data name="ERR_ComClassOnGeneric" xml:space="preserve">
    <value>Nie można zastosować elementu „Microsoft.VisualBasic.ComClassAttribute” do klasy ogólnej lub zawartej w typie ogólnym.</value>
  </data>
  <data name="ERR_AddressOfNotDelegate1" xml:space="preserve">
    <value>Nie można przekonwertować wyrażenia „AddressOf” na typ „{0}”, ponieważ typ „{0}” nie jest typem delegowanym.</value>
  </data>
  <data name="WRN_ImplicitConversion2" xml:space="preserve">
    <value>Niejawna konwersja z „{0}” na „{1}”.</value>
  </data>
  <data name="ERR_SynchronizedAsyncMethod" xml:space="preserve">
    <value>Atrybutu „MethodImplOptions.Synchronized” nie można zastosować do metody asynchronicznej.</value>
  </data>
  <data name="PositionOfTypeParameterTooLarge" xml:space="preserve">
    <value>pozycja parametru typu jest zbyt duża</value>
  </data>
  <data name="ERR_OperatorNotOverloadable" xml:space="preserve">
    <value>Operatora nie można przeciążyć. Deklaracja operatora musi mieć jedną z następujących wartości: +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</value>
  </data>
  <data name="ERR_BadAwaitNothing" xml:space="preserve">
    <value>Nie można zdefiniować oczekiwania na wartość Nothing. Zamiast tego rozważ zdefiniowanie oczekiwania na funkcję „Task.Yield()”.</value>
  </data>
  <data name="ERR_BadInterfaceOrderOnInherits" xml:space="preserve">
    <value>Instrukcje „Inherits” muszą znajdować się przed wszystkimi deklaracjami w interfejsie.</value>
  </data>
  <data name="ERR_BadAwaitNotInAsyncMethodOrLambda" xml:space="preserve">
    <value>Słowo kluczowe „Await” może zostać użyte tylko wewnątrz metody lub wyrażenia lambda oznaczonego modyfikatorem „Async”.</value>
  </data>
  <data name="ERR_StructCantUseDLLDeclareSpecifier1" xml:space="preserve">
    <value>Instrukcji „Declare” w strukturze nie można zadeklarować jako „{0}”.</value>
  </data>
  <data name="WRN_CLSEventMethodInNonCLSType3" xml:space="preserve">
    <value>Metody „{0}” dla zdarzenia „{1}” nie można oznaczyć jako zgodnej ze specyfikacją CLS, ponieważ jej typ zawierający „{2}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_LiteralExpected" xml:space="preserve">
    <value>Oczekiwano literału.</value>
  </data>
  <data name="ERR_OperatorMustBeShared" xml:space="preserve">
    <value>Operatory należy zadeklarować jako „Shared”.</value>
  </data>
  <data name="ERR_TwoParametersRequired1" xml:space="preserve">
    <value>Operator „{0}” musi mieć dwa parametry.</value>
  </data>
  <data name="ERR_VarianceOutConstraintDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako ograniczenie typu ogólnego, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_ResourceInModule" xml:space="preserve">
    <value>Nie można połączyć plików zasobów podczas kompilowania modułu</value>
  </data>
  <data name="ERR_ExprTreeNoLateBind" xml:space="preserve">
    <value>Nie można przekonwertować operacji późnego wiązania na drzewo wyrażenia.</value>
  </data>
  <data name="ERR_ExpectedEndSyncLock" xml:space="preserve">
    <value>Instrukcja SyncLock musi być zakończona odpowiadającą jej instrukcją End SyncLock.</value>
  </data>
  <data name="ERR_BadGenericParamForNewConstraint2" xml:space="preserve">
    <value>Parametr typu „{0}” musi mieć ograniczenie „New” lub „Structure”, aby spełniać ograniczenie „New” dla parametru typu „{1}”.</value>
  </data>
  <data name="WRN_XMLDocMoreThanOneCommentBlock" xml:space="preserve">
    <value>Tylko jeden blok komentarza XML może przypadać na element języka.</value>
  </data>
  <data name="DeclarationSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Brak elementu DeclarationSyntax w drzewie składni</value>
  </data>
  <data name="ERR_PrivateTypeOutsideType" xml:space="preserve">
    <value>Typy zadeklarowane jako Private muszą znajdować się wewnątrz innego typu.</value>
  </data>
  <data name="ERR_MustInheritForNewConstraint2" xml:space="preserve">
    <value>Argument typu „{0}” jest deklarowany jako „MustInherit” i nie spełnia ograniczenia „New” dla parametru typu „{1}”.</value>
  </data>
  <data name="ERR_ExpectedEndClass" xml:space="preserve">
    <value>Instrukcja Class musi być zakończona odpowiadającą jej instrukcją End Class.</value>
  </data>
  <data name="ERR_ExtensionMethodCannotBeLateBound" xml:space="preserve">
    <value>Metody rozszerzenia z późnym wiązaniem nie są obsługiwane.</value>
  </data>
  <data name="ERR_InvalidMeReference" xml:space="preserve">
    <value>Odwołanie do właśnie konstruowanego obiektu nie jest prawidłowe podczas wywoływania innego konstruktora.</value>
  </data>
  <data name="ERR_NamedSubscript" xml:space="preserve">
    <value>Nazwane argumenty nie są prawidłowe jako indeksy tablicy.</value>
  </data>
  <data name="ERR_ExpectedEndUsing" xml:space="preserve">
    <value>Element „Using” musi być zakończony odpowiadającym mu elementem „End Using”.</value>
  </data>
  <data name="ERR_ArrayInitForNonArray2" xml:space="preserve">
    <value>Inicjatory tablic są prawidłowe tylko dla tablic, ale typem elementu „{0}” jest „{1}”.</value>
  </data>
  <data name="ERR_GeneralProjectImportsError3" xml:space="preserve">
    <value>Błąd w imporcie na poziomie projektu „{0}” pod adresem „{1}” : {2}.</value>
  </data>
  <data name="ERR_ExpectedEndWhile" xml:space="preserve">
    <value>Instrukcja While musi być zakończona odpowiadającą jej instrukcją End While.</value>
  </data>
  <data name="WRN_ComClassPropertySetObject1" xml:space="preserve">
    <value>Element „{0}” nie może być ujawniony dla modelu COM jako instrukcja „Let” właściwości. Przy użyciu instrukcji „Let” nie będzie można przypisać do tej właściwości wartości niebędących obiektami (takich jak liczby czy ciągi) w języku Visual Basic 6.0.</value>
  </data>
  <data name="ERR_TypeOfRequiresReferenceType1" xml:space="preserve">
    <value>Instrukcja „TypeOf ... Is” wymaga, aby argument operacji po lewej stronie miał typ referencyjny, a ten argument operacji ma typ wartości „{0}”.</value>
  </data>
  <data name="WRN_NotEqualToLiteralNothing_Title" xml:space="preserve">
    <value>To wyrażenie zawsze da wynik Nothing</value>
  </data>
  <data name="ERR_BadWithRef" xml:space="preserve">
    <value>Wiodący znak . lub ! może wystąpić tylko wewnątrz instrukcji With.</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncMethod" xml:space="preserve">
    <value>Słowo kluczowe „Await” może zostać użyte tylko wewnątrz metody asynchronicznej. Rozważ oznaczenie tej metody za pomocą modyfikatora „Async” i zmianę zwracanego przez nią typu na „Task(Of {0})”.</value>
  </data>
  <data name="ERR_SecurityCriticalAsyncInClassOrStruct" xml:space="preserve">
    <value>Metody Async i Iterator nie są dozwolone w klasie, strukturze, interfejsie lub module, który ma atrybut „SecurityCritical” lub „SecuritySafeCritical”.</value>
  </data>
  <data name="ERR_ParamArrayMustBeLast" xml:space="preserve">
    <value>Oczekiwano końca listy parametrów. Nie można zdefiniować parametrów po parametrze paramarray.</value>
  </data>
  <data name="ERR_InterfaceNotImplemented1" xml:space="preserve">
    <value>Interfejs „{0}” nie jest implementowany przez tę klasę.</value>
  </data>
  <data name="WRN_XMLDocStartTagWithNoEndTag" xml:space="preserve">
    <value>Błąd analizowania dokumentacji XML: tag początkowy „{0}” nie ma zgodnego tagu końcowego. Komentarz XML zostanie zignorowany.</value>
  </data>
  <data name="ERR_AbsentReferenceToPIA1" xml:space="preserve">
    <value>Nie można znaleźć typu międzyoperacyjnego zgodnego z osadzonym typem „{0}”. Czy nie brakuje odwołania do zestawu?</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames3" xml:space="preserve">
    <value>Interfejs „{0}” można zaimplementować tylko raz według tego typu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{1}” (poprzez „{2}”).</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames2" xml:space="preserve">
    <value>Interfejs „{0}” można zaimplementować tylko raz według tego typu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{1}”.</value>
  </data>
  <data name="ERR_InterfaceImplementedTwiceWithDifferentTupleNames4" xml:space="preserve">
    <value>Interfejs „{0}” (poprzez „{1}”) można zaimplementować tylko raz według tego typu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{2}” (poprzez „{3}”).</value>
  </data>
  <data name="WRN_VarianceDeclarationAmbiguous3_Title" xml:space="preserve">
    <value>Interfejs jest niejednoznaczny z innym zaimplementowanym interfejsem ze względu na parametry „In” i „Out”</value>
  </data>
  <data name="ERR_EventsCantBeFunctions" xml:space="preserve">
    <value>Zdarzenia nie mogą mieć zwracanego typu.</value>
  </data>
  <data name="ERR_CantOverride4" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ nie jest on zadeklarowany jako „Overridable”.</value>
  </data>
  <data name="ERR_OverloadWithDefault2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie wartościami domyślnymi parametrów opcjonalnych.</value>
  </data>
  <data name="ERR_BadAwaitInNonAsyncLambda" xml:space="preserve">
    <value>Słowo kluczowe „Await” może zostać użyte tylko wewnątrz wyrażenia lambda. Rozważ oznaczenie tego wyrażenia lambda za pomocą modyfikatora „Async”.</value>
  </data>
  <data name="WRN_VarianceConversionFailedOut6_Title" xml:space="preserve">
    <value>Niejawna konwersja; ta konwersja może się nie powieść, ponieważ typ docelowy nie pochodzi od typu źródłowego, co jest wymagane dla parametru ogólnego „Out”</value>
  </data>
  <data name="ERR_TooManyIndices" xml:space="preserve">
    <value>Liczba indeksów przekracza liczbę wymiarów tablicy indeksowanej.</value>
  </data>
  <data name="WRN_NoConfigInResponseFile_Title" xml:space="preserve">
    <value>Opcja /noconfig zostanie zignorowana, ponieważ została określona w pliku odpowiedzi</value>
  </data>
  <data name="ERR_BadConditionalWithRef" xml:space="preserve">
    <value>Wiodący znak „?” może występować tylko w instrukcji „With”. Nie może występować w inicjatorze elementu członkowskiego obiektu.</value>
  </data>
  <data name="ERR_MemberConflictWithSynth4" xml:space="preserve">
    <value>Powoduje konflikt z elementem „{0}”, zadeklarowanym niejawnie dla elementu „{1}” w elemencie {2} „{3}”.</value>
  </data>
  <data name="ERR_OptionalIllegal1" xml:space="preserve">
    <value>Parametrów „{0}” nie można zadeklarować jako „Optional”.</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpVal1_Title" xml:space="preserve">
    <value>Operator nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_NoGlobalInHandles" xml:space="preserve">
    <value>Element „Global” jest niedozwolony w elementach Handles; oczekiwano nazwy lokalnej.</value>
  </data>
  <data name="WRN_StaticLocalNoInference" xml:space="preserve">
    <value>Zmienna statyczna zadeklarowana bez klauzuli „As”; przyjęto typ Object.</value>
  </data>
  <data name="ERR_UnrecognizedType" xml:space="preserve">
    <value>Oczekiwano typu.</value>
  </data>
  <data name="ERR_ParamArrayWithOptArgs" xml:space="preserve">
    <value>Metoda nie może mieć zarówno parametru ParamArray, jak i Optional.</value>
  </data>
  <data name="ERR_StructureCantUseProtected" xml:space="preserve">
    <value>Nie można zadeklarować metody w strukturze jako Protected lub Protected Friend.</value>
  </data>
  <data name="WRN_QueryMissingAsClauseinVarDecl" xml:space="preserve">
    <value>Przyjęto, że zmienna zakresu będzie typu Object, ponieważ nie można wywnioskować jej typu. Użyj klauzuli „As”, aby określić inny typ.</value>
  </data>
  <data name="ERR_DuplicateInInherits1" xml:space="preserve">
    <value>Nie można dziedziczyć elementu „{0}” więcej niż raz.</value>
  </data>
  <data name="ERR_PartialTypeBadMustInherit1" xml:space="preserve">
    <value>Elementu „MustInherit” nie można określić dla typu częściowego „{0}”, ponieważ nie można go łączyć z elementem „NotInheritable” określonym dla jednego z jego innych typów częściowych.</value>
  </data>
  <data name="ERR_RemoveParamWrongForWinRT" xml:space="preserve">
    <value>W zdarzeniu środowiska wykonawczego systemu Windows parametr metody „RemoveHandler” musi mieć wartość „EventRegistrationToken”</value>
  </data>
  <data name="ERR_MultilineLambdasCannotContainOnError" xml:space="preserve">
    <value>Instrukcje „On Error” i „Resume” nie mogą wystąpić wewnątrz wyrażenia lambda.</value>
  </data>
  <data name="ERR_DllImportNotLegalOnGetOrSet" xml:space="preserve">
    <value>Nie można zastosować elementu „System.Runtime.InteropServices.DllImportAttribute” do elementu Get ani Set.</value>
  </data>
  <data name="ERR_SyncLockRequiresReferenceType1" xml:space="preserve">
    <value>Argument operacji „SyncLock” nie może być typu „{0}”, ponieważ „{0}” nie jest typem referencyjnym.</value>
  </data>
  <data name="WRN_MultipleDeclFileExtChecksum_Title" xml:space="preserve">
    <value>Nazwa pliku została już zadeklarowana z innym identyfikatorem GUID i inną wartością sumy kontrolnej</value>
  </data>
  <data name="ERR_BadAsyncReturn" xml:space="preserve">
    <value>Modyfikatora „Async” można używać tylko dla procedur albo funkcji zwracających typ Task lub Task(Of T).</value>
  </data>
  <data name="HDN_UnusedImportClause_Title" xml:space="preserve">
    <value>Nieużywana klauzula importu</value>
  </data>
  <data name="ERR_RestrictedAccess" xml:space="preserve">
    <value>Wyrażenie zawiera typ „{0}”, który jest typem ograniczonym i nie można go używać do uzyskiwania dostępu do elementów członkowskich dziedziczonych po elemencie „Object” lub „ValueType”.</value>
  </data>
  <data name="ERR_OperatorMustBePublic" xml:space="preserve">
    <value>Operatory należy zadeklarować jako „Public”.</value>
  </data>
  <data name="ERR_BadInterfaceEnumSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować wyliczenia w interfejsie jako „{0}”.</value>
  </data>
  <data name="ERR_MultilineLambdaMissingFunction" xml:space="preserve">
    <value>W wielowierszowym wyrażeniu lambda brakuje instrukcji „End Function”.</value>
  </data>
  <data name="ERR_IdentityDirectCastForFloat" xml:space="preserve">
    <value>Używanie operatora DirectCast do rzutowania wartości zmiennoprzecinkowych do tego samego typu nie jest obsługiwane.</value>
  </data>
  <data name="ERR_InheritsStmtWrongOrder" xml:space="preserve">
    <value>Instrukcja „Inherits” musi znajdować się przed wszystkimi deklaracjami w klasie.</value>
  </data>
  <data name="ERR_NetModuleNameMustBeUnique" xml:space="preserve">
    <value>Moduł „{0}” jest już zdefiniowany w tym zestawie. Nazwa pliku każdego modułu musi być unikatowa.</value>
  </data>
  <data name="ERR_GotoIntoWith" xml:space="preserve">
    <value>Instrukcja „GoTo {0}” jest nieprawidłowa, ponieważ element „{0}” znajduje się wewnątrz instrukcji „With”, która nie zawiera tej instrukcji.</value>
  </data>
  <data name="ERR_UnknownOperator" xml:space="preserve">
    <value>Deklaracja operatora musi mieć jedną z następujących wartości: +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</value>
  </data>
  <data name="ERR_BadUseOfVoid" xml:space="preserve">
    <value>Elementu „System.Void” można użyć tylko w wyrażeniu GetType.</value>
  </data>
  <data name="ERR_BadEnumFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji wyliczenia.</value>
  </data>
  <data name="ERR_StartAttributeValue" xml:space="preserve">
    <value>Oczekiwano umieszczonej w cudzysłowie wartości atrybutu XML lub wyrażenia osadzonego.</value>
  </data>
  <data name="ERR_BadInstanceMemberAccess" xml:space="preserve">
    <value>Nie można odwołać się do elementu członkowskiego wystąpienia klasy z wnętrza udostępnionej metody lub udostępnionego inicjatora elementu członkowskiego bez jawnego wystąpienia klasy.</value>
  </data>
  <data name="ERR_SubRequiresParenthesesLParen" xml:space="preserve">
    <value>Jednowierszowa instrukcja lambda musi być ujęta w nawiasy. Na przykład: Call (Sub() &lt;instrukcja&gt;) ()</value>
  </data>
  <data name="WRN_XMLDocBadXMLLine_Title" xml:space="preserve">
    <value>Blok komentarza XML musi bezpośrednio poprzedzać element języka, do którego jest stosowany</value>
  </data>
  <data name="ERR_OnErrorInSyncLock" xml:space="preserve">
    <value>Instrukcje On Error nie są prawidłowe w instrukcjach SyncLock.</value>
  </data>
  <data name="ERR_TypeParamMissingAsCommaOrRParen" xml:space="preserve">
    <value>Oczekiwano elementu „As”, przecinka lub znaku „)”.</value>
  </data>
  <data name="ERR_UseOfKeywordFromModule1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w ramach modułu.</value>
  </data>
  <data name="WRN_XMLDocDuplicateXMLNode1_Title" xml:space="preserve">
    <value>Tag komentarza XML występuje z identycznymi atrybutami więcej niż raz w tym samym bloku komentarza XML</value>
  </data>
  <data name="ERR_ForCtlVarArraySizesSpecified" xml:space="preserve">
    <value>Tablica zadeklarowana jako zmienna sterująca pętli for nie może być zadeklarowana z rozmiarem początkowym.</value>
  </data>
  <data name="ERR_MyClassNotInClass" xml:space="preserve">
    <value>Nie można użyć instrukcji MyClass poza klasą.</value>
  </data>
  <data name="ERR_InvalidFormatSpecifier" xml:space="preserve">
    <value>„{0}” nie jest prawidłowym specyfikatorem formatu</value>
  </data>
  <data name="ERR_ModuleCantImplement" xml:space="preserve">
    <value>Instrukcja Implements nie jest prawidłowa w modułach.</value>
  </data>
  <data name="ERR_DuplicateProcDef1" xml:space="preserve">
    <value>Element „{0}” ma wiele definicji o identycznych sygnaturach.</value>
  </data>
  <data name="ERR_AttributeStmtWrongOrder" xml:space="preserve">
    <value>Instrukcje atrybutu zestawu lub modułu muszą występować przed wszelkimi deklaracjami w pliku.</value>
  </data>
  <data name="WRN_RequiredNonObsoleteNewCall3_Title" xml:space="preserve">
    <value>Pierwsza instrukcja tego elementu „Sub New” powinna być jawnym wywołaniem elementu „MyBase.New” lub „MyClass.New”, ponieważ konstruktor w klasie podstawowej został oznaczony jako przestarzały</value>
  </data>
  <data name="ERR_ArrayInitNoTypeObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu, a ustawienie Option Strict On nie pozwala przyjąć typu „Object”. Określenie typu tablicy może poprawić ten błąd.</value>
  </data>
  <data name="ERR_BadFlagsWithDefault1" xml:space="preserve">
    <value>Nie można łączyć instrukcji „Default” z elementem „{0}”.</value>
  </data>
  <data name="ERR_QueryAnonymousTypeFieldNameInference" xml:space="preserve">
    <value>Nazwę zmiennej zakresu można wywnioskować tylko na podstawie prostej lub kwalifikowanej nazwy bez argumentów.</value>
  </data>
  <data name="ERR_OverrideWithDefault2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się wartościami domyślnymi parametrów opcjonalnych.</value>
  </data>
  <data name="ERR_SetHasToBeByVal1" xml:space="preserve">
    <value>Nie można zadeklarować parametru „Set” jako „{0}”.</value>
  </data>
  <data name="ERR_FinallyAfterFinally" xml:space="preserve">
    <value>Instrukcja Finally może wystąpić tylko raz w instrukcji Try.</value>
  </data>
  <data name="ERR_BadCCExpression" xml:space="preserve">
    <value>Błąd składni w wyrażeniu kompilacji warunkowej.</value>
  </data>
  <data name="WRN_EnumUnderlyingTypeNotCLS1_Title" xml:space="preserve">
    <value>Typ podstawowy wyliczenia jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_DuplicateParameterSpecifier" xml:space="preserve">
    <value>Specyfikator parametru jest zduplikowany.</value>
  </data>
  <data name="ERR_ExitOperatorNotValid" xml:space="preserve">
    <value>Element Exit Operator jest nieprawidłowy. Użyj elementu Return, aby wyjść z operatora.</value>
  </data>
  <data name="ERR_ComClassGenericMethod" xml:space="preserve">
    <value>Metod ogólnych nie można ujawniać modelowi COM.</value>
  </data>
  <data name="ERR_ExpectedOptionCompare" xml:space="preserve">
    <value>Oczekiwano instrukcji „Compare”.</value>
  </data>
  <data name="FEATURE_CollectionInitializers" xml:space="preserve">
    <value>inicjatory kolekcji</value>
  </data>
  <data name="ERR_BadFlagsInNotInheritableClass1" xml:space="preserve">
    <value>Klasy „NotInheritable” nie mogą mieć elementów członkowskich zadeklarowanych jako „{0}”.</value>
  </data>
  <data name="ERR_FailureSigningAssembly" xml:space="preserve">
    <value>Wystąpił błąd podczas podpisywania zestawu „{0}”: {1}</value>
  </data>
  <data name="ERR_InheritsFromNonClass" xml:space="preserve">
    <value>Klasy mogą dziedziczyć tylko po innych klasach.</value>
  </data>
  <data name="ERR_EndSelectNoSelect" xml:space="preserve">
    <value>Instrukcja „End Select” musi być poprzedzona odpowiadającą jej instrukcją „Select Case”.</value>
  </data>
  <data name="ERR_InaccessibleReturnTypeOfMember2" xml:space="preserve">
    <value>Element „{0}” nie jest dostępny w tym kontekście, ponieważ typ zwracany jest niedostępny.</value>
  </data>
  <data name="ERR_TypeCharWithType1" xml:space="preserve">
    <value>Nie można użyć znaku typu „{0}” w deklaracji z typem jawnym.</value>
  </data>
  <data name="WRN_DebuggerHiddenIgnoredOnProperties" xml:space="preserve">
    <value>Atrybut System.Diagnostics.DebuggerHiddenAttribute nie ma wpływu na elementy „Get” ani „Set”, gdy jest stosowany do definicji Property. Zastosuj atrybut bezpośrednio do odpowiednich procedur „Get” i „Set”.</value>
  </data>
  <data name="ERR_MissingEndSet" xml:space="preserve">
    <value>Instrukcja Set musi być zakończona odpowiadającą jej instrukcją End Set.</value>
  </data>
  <data name="ERR_MissingEndGet" xml:space="preserve">
    <value>Instrukcja Get musi być zakończona odpowiadającą jej instrukcją End Get.</value>
  </data>
  <data name="ERR_IllegalProcessingInstructionName" xml:space="preserve">
    <value>Nazwa „{0}” instrukcji przetwarzającej kod XML jest nieprawidłowa.</value>
  </data>
  <data name="ERR_NetModuleNameMismatch" xml:space="preserve">
    <value>Nazwa modułu „{0}” przechowywana w elemencie „{1}” musi być zgodna z nazwą jego pliku.</value>
  </data>
  <data name="PropertiesCanNotHaveTypeArguments" xml:space="preserve">
    <value>Właściwości nie mogą mieć argumentów typu</value>
  </data>
  <data name="ERR_InvInsideEndsProperty" xml:space="preserve">
    <value>Instrukcja nie może wystąpić w treści właściwości. Założono koniec właściwości.</value>
  </data>
  <data name="ERR_NullableImplicit" xml:space="preserve">
    <value>Modyfikator dopuszczający wartość null nie może być używany ze zmienną, której typem niejawnym jest „Object”.</value>
  </data>
  <data name="IDS_ProjectSettingsLocationName" xml:space="preserve">
    <value>&lt;ustawienia projektu&gt;</value>
  </data>
  <data name="WRN_InvalidVersionFormat" xml:space="preserve">
    <value>Określony ciąg wersji nie jest zgodny z zalecanym formatem — wersja_główna.wersja_pomocnicza.kompilacja.poprawka</value>
  </data>
  <data name="CannotAddCompilerSpecialTree" xml:space="preserve">
    <value>Nie można dodać specjalnego drzewa kompilatora</value>
  </data>
  <data name="ERR_TryCastOfValueType1" xml:space="preserve">
    <value>Argument operacji „TryCast” musi być typem referencyjnym, ale element „{0}” to typ wartości.</value>
  </data>
  <data name="SyntaxTreeNotFoundToRemove" xml:space="preserve">
    <value>Nie znaleziono elementu SyntaxTree „{0}” do usunięcia</value>
  </data>
  <data name="ERR_InvalidMe" xml:space="preserve">
    <value>Element Me nie może być elementem docelowym przypisania.</value>
  </data>
  <data name="WRN_IfTooManyTypesObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu, ponieważ jest możliwy więcej niż jeden typ</value>
  </data>
  <data name="WRN_EmptyPrefixAndXmlnsLocalName" xml:space="preserve">
    <value>Atrybut xmlns ma specjalne znaczenie i nie powinien być zapisywany z prefiksem.</value>
  </data>
  <data name="ERR_ExpectedEndNamespace" xml:space="preserve">
    <value>Instrukcja Namespace musi być zakończona odpowiadającą jej instrukcją End Namespace.</value>
  </data>
  <data name="WRN_UndefinedOrEmptyProjectNamespaceOrClass1" xml:space="preserve">
    <value>Przestrzeń nazw lub typ określony w elemencie Imports „{0}” na poziomie projektu nie zawierają żadnego publicznego elementu członkowskiego lub nie można go odnaleźć. Upewnij się, że przestrzeń nazw lub typ zostały zdefiniowane i zawierają co najmniej jeden publiczny element członkowski. Upewnij się, że w nazwie importowanego elementu nie są używane aliasy.</value>
  </data>
  <data name="WRN_UnusedLocalConst" xml:space="preserve">
    <value>Nieużywana stała lokalna: „{0}”.</value>
  </data>
  <data name="ERR_CannotLiftAnonymousType1" xml:space="preserve">
    <value>Nie można użyć właściwości typu anonimowego „{0}” w definicji wyrażenia lambda w obrębie tej samej listy inicjowania.</value>
  </data>
  <data name="ERR_MissingEndAddHandler" xml:space="preserve">
    <value>Deklaracja „AddHandler” musi być zakończona odpowiadającym jej elementem „End AddHandler”.</value>
  </data>
  <data name="ERR_TypeCharOnSub" xml:space="preserve">
    <value>Nie można użyć znaku typu w deklaracji Sub, ponieważ procedura Sub nie zwraca wartości.</value>
  </data>
  <data name="ERR_VarianceOutNullableDisallowed2" xml:space="preserve">
    <value>Typ „{0}” nie może być używany w elemencie „{1}”, ponieważ parametry typu „In” i „Out” nie mogą dopuszczać wartości null, a „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_RecordEmbeds2" xml:space="preserve">
    <value>
    Element „{0}” zawiera element „{1}” (zmienna „{2}”).</value>
  </data>
  <data name="WRN_IgnoreModuleManifest" xml:space="preserve">
    <value>Opcja /win32manifest została zignorowana. Można ją określić tylko wówczas, gdy element docelowy jest zestawem.</value>
  </data>
  <data name="WRN_ObjectAssumedVar1" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="ERR_ExpectedContinueKind" xml:space="preserve">
    <value>Po instrukcji „Continue” musi następować element „Do”, „For” lub „While”.</value>
  </data>
  <data name="ERR_MultipleOptionalParameterSpecifiers" xml:space="preserve">
    <value>Nie można łączyć elementów „Optional” i „ParamArray”.</value>
  </data>
  <data name="ERR_ExpectedEndStructure" xml:space="preserve">
    <value>Instrukcja Structure musi być zakończona odpowiadającą jej instrukcją End Structure.</value>
  </data>
  <data name="ERR_PredefinedValueTupleTypeMustBeStruct" xml:space="preserve">
    <value>Wstępnie zdefiniowany typ „{0}” musi być strukturą.</value>
  </data>
  <data name="ERR_DefaultPropertyAmbiguousAcrossInterfaces4" xml:space="preserve">
    <value>Dostęp do właściwości domyślnej jest niejednoznaczny dla dziedziczonego elementu członkowskiego „{0}” interfejsu „{1}” i dziedziczonego elementu członkowskiego „{2}” interfejsu „{3}”.</value>
  </data>
  <data name="ERR_DelegateCantHandleEvents" xml:space="preserve">
    <value>Obiekty delegatów nie mogą obsługiwać zdarzeń.</value>
  </data>
  <data name="ERR_BadYieldInNonIteratorMethod" xml:space="preserve">
    <value>Instrukcji „Yield” można używać tylko w metodach oznaczonych modyfikatorem „Iterator”.</value>
  </data>
  <data name="WRN_ShadowingGenericParamWithParam1" xml:space="preserve">
    <value>Parametr typu „{0}” ma taką samą nazwę jak parametr typu zamykającego. Parametr typu zamykającego zostanie zasłonięty.</value>
  </data>
  <data name="WRN_SelectCaseInvalidRange_Title" xml:space="preserve">
    <value>Zakres określony dla instrukcji „Case” jest nieprawidłowy</value>
  </data>
  <data name="ERR_DllImportNotLegalOnDeclare" xml:space="preserve">
    <value>Nie można zastosować elementu „System.Runtime.InteropServices.DllImportAttribute” do elementu Declare.</value>
  </data>
  <data name="ERR_ExitWhileNotWithinWhile" xml:space="preserve">
    <value>Instrukcja Exit While może wystąpić tylko wewnątrz instrukcji While.</value>
  </data>
  <data name="ERR_InterfaceUnifiesWithInterface2" xml:space="preserve">
    <value>Nie można dziedziczyć interfejsu „{0}”, ponieważ może być on taki sam jak interfejs „{1}” dla niektórych argumentów typu.</value>
  </data>
  <data name="ERR_ConflictDefaultPropertyAttribute" xml:space="preserve">
    <value>Konflikt między właściwością domyślną a elementem „DefaultMemberAttribute” zdefiniowanym w elemencie „{0}”.</value>
  </data>
  <data name="ERR_NoXmlAxesLateBinding" xml:space="preserve">
    <value>Właściwości osi XML nie obsługują późnego wiązania.</value>
  </data>
  <data name="WRN_AnalyzerCannotBeCreated_Title" xml:space="preserve">
    <value>Nie można utworzyć wystąpienia analizatora</value>
  </data>
  <data name="ERR_TypeParamQualifierDisallowed" xml:space="preserve">
    <value>Parametrów typu nie można używać jako kwalifikatorów.</value>
  </data>
  <data name="ERR_BadIteratorReturn" xml:space="preserve">
    <value>Funkcje iteracyjne muszą zwracać interfejsy IEnumerable(Of T) lub IEnumerator(Of T) albo nieogólne formy interfejsu IEnumerable lub IEnumerator.</value>
  </data>
  <data name="ERR_ExitFuncOfSub" xml:space="preserve">
    <value>Instrukcja Exit Function nie jest prawidłowa w przypadku procedury lub właściwości.</value>
  </data>
  <data name="ERR_OpenTypeDisallowed" xml:space="preserve">
    <value>Parametry typu lub typy utworzone za pomocą parametrów typu są niedozwolone w argumentach atrybutu.</value>
  </data>
  <data name="ERR_AttributeCannotBeAbstract" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako atrybutu, ponieważ jest on zadeklarowany jako „MustInherit”.</value>
  </data>
  <data name="ERR_InheritsFromCantInherit3" xml:space="preserve">
    <value>Element „{0}” nie może dziedziczyć po elemencie {2} „{1}”, ponieważ element „{1}” jest zadeklarowany jako „NotInheritable”.</value>
  </data>
  <data name="TypeParameterNotWithinTree" xml:space="preserve">
    <value>Element TypeParameter w nie znajduje się w obrębie drzewa</value>
  </data>
  <data name="ERR_PublicSignNoKey" xml:space="preserve">
    <value>Wybrano podpisywanie publiczne, co wymaga klucza publicznego, ale żaden taki klucz nie został określony</value>
  </data>
  <data name="WRN_MustShadowOnMultipleInheritance2_Title" xml:space="preserve">
    <value>Wystąpił konflikt metody z innymi elementami członkowskimi o tej samej nazwie w hierarchii dziedziczenia — należy zadeklarować element „Shadows”</value>
  </data>
  <data name="ERR_ObsoleteExponent" xml:space="preserve">
    <value>Litery „D” nie można już używać do określenia wykładnika; zamiast niej użyj litery „E”.</value>
  </data>
  <data name="ERR_MissingSubscript" xml:space="preserve">
    <value>Brak wyrażenia indeksu tablicy.</value>
  </data>
  <data name="WRN_XMLDocExceptionTagWithoutCRef" xml:space="preserve">
    <value>Wyjątek komentarza XML musi mieć atrybut „cref”.</value>
  </data>
  <data name="PositionNotWithinTree" xml:space="preserve">
    <value>Pozycja musi znajdować się w zasięgu drzewa składni.</value>
  </data>
  <data name="ERR_PropMustHaveGetSet" xml:space="preserve">
    <value>Właściwość bez specyfikatora „ReadOnly” lub „WriteOnly” musi udostępniać zarówno procedurę „Get”, jak i „Set”.</value>
  </data>
  <data name="ERR_CannotLiftRestrictedTypeLambda" xml:space="preserve">
    <value>Nie można użyć wystąpienia typu ograniczonego „{0}” w wyrażeniu lambda.</value>
  </data>
  <data name="ERR_ExecutableAsDeclaration" xml:space="preserve">
    <value>Instrukcja nie może wystąpić poza treścią metody.</value>
  </data>
  <data name="ERR_ForwardedTypeUnavailable3" xml:space="preserve">
    <value>Typ „{0}” w zestawie „{1}” został przekazany do zestawu „{2}”. Brak odwołania do zestawu „{2}” w projekcie lub typu „{0}” w zestawie „{2}”.</value>
  </data>
  <data name="ERR_UnsupportedProperty1" xml:space="preserve">
    <value>Właściwość „{0}” jest nieobsługiwanego typu.</value>
  </data>
  <data name="ERR_OverrideWithArrayVsParamArray2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się parametrami zadeklarowanymi jako „ParamArray”.</value>
  </data>
  <data name="ERR_EventNoPIANoBackingMember" xml:space="preserve">
    <value>W interfejsie źródłowym „{0}” brak metody „{1}” wymaganej do osadzenia zdarzenia „{2}”.</value>
  </data>
  <data name="ERR_DuplicateXmlAttribute" xml:space="preserve">
    <value>Zduplikowany atrybut XML „{0}”.</value>
  </data>
  <data name="ERR_SharedMemberAggrMemberInit1" xml:space="preserve">
    <value>Nie można zainicjować elementu członkowskiego „{0}” w wyrażeniu inicjatora obiektów, ponieważ jest on udostępniony.</value>
  </data>
  <data name="ERR_UseOfObsoleteSymbol2" xml:space="preserve">
    <value>Element „{0}” jest przestarzały: „{1}”.</value>
  </data>
  <data name="ERR_InvalidSpecifierOnNonConversion1" xml:space="preserve">
    <value>Tylko operatory konwersji można zadeklarować jako „{0}”.</value>
  </data>
  <data name="ERR_IsNotOpRequiresReferenceTypes1" xml:space="preserve">
    <value>Element „IsNot” wymaga argumentów operacji, które mają typ referencyjny, ale ten argument operacji ma typ wartości „{0}”.</value>
  </data>
  <data name="ERR_MissingIsInTypeOf" xml:space="preserve">
    <value>Oczekiwano instrukcji „Is”.</value>
  </data>
  <data name="IDS_VBCHelp" xml:space="preserve">
    <value>                  Opcje kompilatora Visual Basic

                                  - PLIK WYJŚCIOWY -
/out:&lt;plik&gt;                       Określa nazwę pliku wyjściowego.
/target:exe                       Utwórz aplikację konsolową (domyślnie). 
                                  (krótka wersja: /t)
/target:winexe                    Utwórz aplikację systemu Windows.
/target:library                   Utwórz zestaw biblioteki.
/target:module                    Utwórz moduł, który można dodać do 
                                  zestawu.
/target:appcontainerexe           Utwórz aplikację systemu Windows uruchamianą w 
                                  kontenerze aplikacji.
/target:winmdobj                  Utwórz plik pośredni metadanych systemu Windows
/doc[+|-]                         Generuje plik dokumentacji XML.
/doc:&lt;plik&gt;                       Generuje plik dokumentacji XML w pliku &lt;plik&gt;./refout:&lt;file&gt;                    Dane wyjściowe zestawu odwołania do wygenerowania

                                  - PLIKI WEJŚCIOWE -
/addmodule:&lt;lista_plików&gt;         Odwołuj się do metadanych z określonych modułów
/link:&lt;lista_plików&gt;              Osadź metadane z określonego 
                                  zestawu międzyoperacyjnego. (krótka wersja: /l)
/recurse:&lt;symbol wieloznaczny&gt;    Dołącz wszystkie pliki zawarte w bieżącym katalogu 
                                  i jego podkatalogach zgodnie ze
                                  specyfikacją określoną przy użyciu symboli wieloznacznych.
/reference:&lt;lista_plików&gt;         Odwołuj się do metadanych z określonego 
                                  zestawu. (krótka wersja: /r)
/analyzer:&lt;lista_plików&gt;          Uruchom analizatory z tego zestawu
                                  (krótka wersja: /a)
/additionalfile:&lt;lista plików&gt;    Dodatkowe pliki, które nie mają bezpośredniego wpływu
                                  na generowanie kodu, ale mogą być używane przez analizatory w celu tworzenia
                                  komunikatów o błędach lub ostrzeżeń.

                                  - ZASOBY -
/linkresource:&lt;informacje o zasobie&gt;           Łączy określony plik jako 
                                  zasób zewnętrzny zestawu.
                                  resinfo:&lt;plik&gt;[,&lt;nazwa&gt;[,public|private]] 
                                  (krótka wersja: /linkres)
/nowin32manifest                  Manifest domyślny nie powinien być osadzony 
                                  w sekcji manifestu w wyjściowym środowisku PE.
/resource:&lt;informacje o zasobie&gt; Dodaje określony plik jako osadzony 
                                  zasób zestawu.
                                  resinfo:&lt;plik&gt;[,&lt;nazwa&gt;[,public|private]] 
                                  (krótka wersja: /res)
/win32icon:&lt;plik&gt;                 Określa plik ikony środowiska Win32 (ico) dla 
                                  domyślnych zasobów środowiska Win32.
/win32manifest:&lt;plik&gt;             Podany plik zostanie osadzony w
                                  sekcji manifestu wyjściowego środowiska PE.
/win32resource:&lt;plik&gt;             Określa plik zasobów środowiska Win32 (res).

                                  - GENEROWANIE KODU -
/optimize[+|-]                    Włącz optymalizacje.
/removeintchecks[+|-]             Usuń kontrole liczb całkowitych. Domyślnie wyłączone.
/debug[+|-]                       Emituj informacje o debugowaniu.
/debug:full                       Emituj pełne informacje o debugowaniu (domyślnie).
/debug:pdbonly                                       Emituj pełne informacje o emitowaniu.
/debug:portable                   Emituj informacje o debugowaniu międzyplatformowym.
/debug:embedded                                       Emituj informacje o debugowaniu międzyplatformowym do 
                                  docelowego pliku DLL lub EXE.
/deterministic                    Utwórz zestaw deterministyczny
                                  (w tym sygnaturę czasową i identyfikator GUID wersji modułu)
/refonly                          Utwórz zestaw odwołania zamiast głównych danych wyjściowych
/instrument:TestCoverage          Utwórz zestaw instrumentowany w celu gromadzenia
                               informacji o pokryciu
/sourcelink:&lt;file&gt;                Informacje o linku źródłowym do wbudowania w pliku PDB.

                                  - BŁĘDY I OSTRZEŻENIA -
/nowarn                           Wyłącz wszystkie ostrzeżenia.
/nowarn:&lt;lista_numerów&gt;           Wyłącz listę poszczególnych ostrzeżeń.
/warnaserror[+|-]                 Traktuj wszystkie ostrzeżenia jako błędy.
/warnaserror[+|-]:&lt;lista_numerów&gt; Traktuj ostrzeżenia z listy jako błędy.
/ruleset:&lt;plik&gt;                   Określ plik zestawu reguł, który wyłącza określone
                                  opcje diagnostyczne.
/errorlog:&lt;plik&gt;                  Określ plik, w którym mają zostać zarejestrowane dane diagnostyczne
                                  wszystkich kompilatorów i analizatorów.
/reportanalyzer                   Zgłoś dodatkowe informacje analizatora, takie jak
                                  czas wykonywania.

                                  - JĘZYK -
/define:&lt;lista_symboli&gt;           Zadeklaruj globalne symbole 
                                  kompilacji warunkowej. symbol_list:nazwa=wartość,... 
                                  (krótka wersja: /d)
/imports:&lt;lista_importów&gt;         Zadeklaruj globalne importy dla przestrzeni nazw w 
                                  przywoływanych plikach metadanych. 
                                  import_list:przestrzeń_nazw,...
/langversion:&lt;numer&gt;              Określ wersję języka: 
                                  9|9.0|10|10.0|11|11.0|12|12.0|14|14.0|15|
                                  15.0|15.3|default|latest
/optionexplicit[+|-]              Wymagaj jawnej deklaracji zmiennych.
/optioninfer[+|-]                 Zezwalaj na wnioskowanie o typie zmiennych.
/rootnamespace:&lt;ciąg&gt;             Określa główną przestrzeń nazw dla wszystkich 
                                  deklaracji typów.
/optionstrict[+|-]                Wymuszaj ścisłą semantykę języka.
/optionstrict:custom              Ostrzegaj, gdy ścisła semantyka języka nie jest
                                  przestrzegana.
/optioncompare:binary             Określa binarne porównywanie ciągów.
                                  Jest ono domyślne.
/optioncompare:text               Określa tekstowe porównywanie ciągów.

                                  - RÓŻNE -
/help                             Wyświetl ten komunikat dotyczący użycia. (krótka wersja: /?)
/noconfig                         Nie dołączaj automatycznie pliku VBC.RSP.
/nologo                           Nie wyświetlaj transparentu kompilatora z informacjami o prawach autorskich.
/quiet                            Cichy tryb wyjściowy.
/verbose                          Wyświetl pełne komunikaty.
/parallel[+|-]                    Współbieżna kompilacja.
/version                          Wyświetl numer wersji kompilatora i wyjdź.

                                  - ZAAWANSOWANE -
/baseaddress:&lt;numer&gt;              Podstawowy adres biblioteki lub modułu 
                                  (szesnastkowy).
/checksumalgorithm:&lt;algorytm&gt;     Określ algorytm obliczania sumy kontrolnej 
                                  pliku źródłowego przechowywanej w pliku PDB. Obsługiwane wartości:
                                  SHA1 (domyślnie) lub SHA256.
/codepage:&lt;numer&gt;                 Określa stronę kodową do użycia podczas otwierania 
                                  plików źródłowych.
/delaysign[+|-]                   Podpisz z opóźnieniem zestaw, używając tylko części publicznej
                                  klucza o silnej nazwie.
/errorreport:&lt;ciąg&gt;               Określa, w jaki sposób obsługiwać wewnętrzne
                                  błędy kompilatora: musi mieć wartość prompt, send, none lub queue
                                  (wartość domyślna).
/filealign:&lt;numer&gt;                Określ wyrównanie stosowane dla sekcji 
                                  plików wyjściowych.
/highentropyva[+|-]               Włącz losowe generowanie układu przestrzeni adresowej o wysokiej entropii.
/keycontainer:&lt;ciąg&gt;              Określa kontener klucza o silnej nazwie.
/keyfile:&lt;plik&gt;                   Określa plik klucza o silnej nazwie.
/libpath:&lt;lista_ścieżek&gt;          Lista katalogów, w których mają zostać wyszukane 
                                  odwołania do metadanych (lista wartości oddzielonych średnikami).
/main:&lt;klasa&gt;                     Określa klasę lub moduł zawierające 
                                  element Sub Main. Może to również być klasa 
                                  dziedzicząca po elemencie System.Windows.Forms.Form. 
                                  (krótka wersja: /m)
/moduleassemblyname:&lt;ciąg&gt;        Nazwa zestawu, do którego będzie należeć 
                                  ten moduł.
/netcf                            Ustaw program .NET Compact Framework jako element docelowy.
/nostdlib                         Nie odwołuj się do bibliotek standardowych 
                                  (plików system.dll i VBC.RSP).

/pathmap:&lt;K1&gt;=&lt;W1&gt;,&lt;K2&gt;=&lt;W2&gt;,...
                                  Określ mapowanie nazw ścieżek źródłowych wyprowadzanych
                                  przez kompilator.
/platform:&lt;ciąg&gt;                  Ogranicz platformy, na jakich można uruchomić ten kod; 
                                  dozwolone wartości: x86, x64, Itanium, arm,
                                  AnyCPU32BitPreferred lub anycpu (wartość domyślna).
/preferreduilang                  Określ nazwę preferowanego języka wyjściowego.
/sdkpath:&lt;ścieżka&gt;                Lokalizacja katalogu zestawu .NET Framework SDK
                                  (mscorlib.dll).
/subsystemversion:&lt;wersja&gt;        Określ wersję podsystemu wyjściowego środowiska PE. 
                                  version:&lt;numer&gt;[.&lt;numer&gt;]
/utf8output[+|-]                  Emituj dane wyjściowe kompilatora przy użyciu 
                                  kodowania znaków UTF8.
@&lt;plik&gt;                           Wstaw ustawienia wiersza polecenia z pliku tekstowego
/vbruntime[+|-|*]                 Wykonaj kompilację przy użyciu/bez użycia domyślnego
                                  środowiska uruchomieniowego języka Visual Basic.
/vbruntime:&lt;plik&gt;                 Wykonaj kompilację przy użyciu alternatywnego 
                                  środowiska uruchomieniowego języka Visual Basic w pliku &lt;plik&gt;.
</value>
  </data>
  <data name="ERR_ReturnFromNonGenericTaskAsync" xml:space="preserve">
    <value>Instrukcje „Return” w tej metodzie asynchronicznej nie mogą zwracać wartości, ponieważ funkcja zwraca typ „Task”. Rozważ zmianę typu zwracanego przez funkcję na „Task(Of T)”.</value>
  </data>
  <data name="ERR_MissingEndRaiseEvent" xml:space="preserve">
    <value>Deklaracja „RaiseEvent” musi być zakończona odpowiadającym jej elementem „End RaiseEvent”.</value>
  </data>
  <data name="ERR_OverrideWithConstraintMismatch2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się ograniczeniami parametrów typu.</value>
  </data>
  <data name="ERR_ExpectedNamedArgument" xml:space="preserve">
    <value>Oczekiwano nazwanego argumentu.</value>
  </data>
  <data name="ERR_CircularEvaluation1" xml:space="preserve">
    <value>Stała „{0}” nie może zależeć od własnej wartości.</value>
  </data>
  <data name="WRN_MainIgnored_Title" xml:space="preserve">
    <value>Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia został zignorowany</value>
  </data>
  <data name="WRN_XMLDocCrefToTypeParameter_Title" xml:space="preserve">
    <value>Komentarz XML ma tag z atrybutem „cref”, który jest wiązany z parametrem typu</value>
  </data>
  <data name="SubmissionCanHaveAtMostOneSyntaxTree" xml:space="preserve">
    <value>Przesłanie może mieć co najwyżej jedno drzewo składni.</value>
  </data>
  <data name="ERR_XmlEntityReference" xml:space="preserve">
    <value>Odwołania do jednostek XML nie są obsługiwane.</value>
  </data>
  <data name="ERR_ContinueForNotWithinFor" xml:space="preserve">
    <value>Element Continue For może się znajdować tylko w instrukcji For.</value>
  </data>
  <data name="ERR_ResumablesCannotContainOnError" xml:space="preserve">
    <value>W metodach asynchronicznych i iteracyjnych nie mogą występować instrukcje „On Error” ani „Resume”.</value>
  </data>
  <data name="ERR_TypeCharOnAggregation" xml:space="preserve">
    <value>Nazwy funkcji agregowania nie można używać ze znakiem typu.</value>
  </data>
  <data name="ERR_DoubleToDateConversion" xml:space="preserve">
    <value>Konwersja typu Double na typ Date wymaga wywołania metody Date.FromOADate.</value>
  </data>
  <data name="WRN_CLSAttrInvalidOnGetSet" xml:space="preserve">
    <value>Nie można zastosować elementu System.CLSCompliantAttribute do właściwości „Get” lub „Set”.</value>
  </data>
  <data name="WRN_DuplicateCatch" xml:space="preserve">
    <value>Blok „Catch” nie został nigdy osiągnięty; element „{0}” został obsłużony powyżej w tej samej instrukcji Try.</value>
  </data>
  <data name="ERR_VarianceOutWriteOnlyPropertyDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako typ właściwości WriteOnly, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_InvalidSwitchValue" xml:space="preserve">
    <value>wartość „{1}” jest nieprawidłowa dla opcji „{0}”</value>
  </data>
  <data name="ERR_OverloadingPropertyKind2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie ustawieniem „ReadOnly” lub „WriteOnly”.</value>
  </data>
  <data name="ERR_MustBeOverloads2" xml:space="preserve">
    <value>Element {0} „{1}” musi być zadeklarowany jako „Overloads”, ponieważ inny element „{1}” jest zadeklarowany jako „Overloads” lub „Overrides”.</value>
  </data>
  <data name="FEATURE_StatementLambdas" xml:space="preserve">
    <value>wielowierszowe wyrażenia lambda</value>
  </data>
  <data name="WRN_CLSEventMethodInNonCLSType3_Title" xml:space="preserve">
    <value>Nie można oznaczyć metody AddHandler lub RemoveHandler dla zdarzenia jako zgodnej ze specyfikacją CLS, ponieważ jej typ zawierający jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_ReservedXmlPrefix" xml:space="preserve">
    <value>Prefiks przestrzeni nazw XML „{0}” jest zastrzeżony do użytku przez kod XML i nie można zmienić identyfikatora URI przestrzeni nazw.</value>
  </data>
  <data name="ERR_NoRefOutWhenRefOnly" xml:space="preserve">
    <value>Nie używaj opcji refout, gdy używana jest opcja refonly.</value>
  </data>
  <data name="ERR_ModuleEmitFailure" xml:space="preserve">
    <value>Wyemitowanie modułu „{0}” nie powiodło się.</value>
  </data>
  <data name="ERR_ComClassReservedDispId1" xml:space="preserve">
    <value>Nie można zastosować elementu „System.Runtime.InteropServices.DispIdAttribute” do elementu „{0}”, ponieważ element „Microsoft.VisualBasic.ComClassAttribute” rezerwuje wartości mniejsze od zera.</value>
  </data>
  <data name="ERR_LoopNoMatchingDo" xml:space="preserve">
    <value>Instrukcja Loop musi być poprzedzona odpowiadającą jej instrukcją Do.</value>
  </data>
  <data name="ERR_ArrayInitTooManyTypesObjectDisallowed" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu, ponieważ jest możliwy więcej niż jeden typ. Określenie typu tablicy może poprawić ten błąd.</value>
  </data>
  <data name="ERR_QueryAnonymousTypeDisallowsTypeChar" xml:space="preserve">
    <value>Nie można używać znaków typu w deklaracjach zmiennych zakresu.</value>
  </data>
  <data name="ERR_ExtensionMethodUncallable1" xml:space="preserve">
    <value>Metoda rozszerzenia „{0}” ma ograniczenia typu, których nie będzie można nigdy spełnić.</value>
  </data>
  <data name="ERR_ExitEventMemberNotInvalid" xml:space="preserve">
    <value>Elementy „Exit AddHandler”, „Exit RemoveHandler” i „Exit RaiseEvent” są nieprawidłowe. Użyj elementu „Return”, aby wyjść z elementów członkowskich zdarzenia.</value>
  </data>
  <data name="ERR_BinaryOperandsForXml4" xml:space="preserve">
    <value>Operator „{0}” nie jest zdefiniowany dla typów „{1}” i „{2}”. Przy użyciu właściwości „Value” można uzyskać wartość ciągu pierwszego elementu obiektu „{3}”.</value>
  </data>
  <data name="ERR_SubDisallowsStatement" xml:space="preserve">
    <value>Instrukcja wewnątrz jednowierszowej instrukcji lambda jest nieprawidłowa.</value>
  </data>
  <data name="ERR_ConstraintClashIndirectIndirect4" xml:space="preserve">
    <value>Ograniczenie pośrednie „{0}” uzyskane z ograniczenia parametru typu „{1}” powoduje konflikt z ograniczeniem pośrednim „{2}” uzyskanym z ograniczenia parametru typu „{3}”.</value>
  </data>
  <data name="WRN_DebuggerHiddenIgnoredOnProperties_Title" xml:space="preserve">
    <value>Atrybut System.Diagnostics.DebuggerHiddenAttribute zastosowany dla definicji właściwości nie ma wpływu na właściwości „Get” lub „Set”</value>
  </data>
  <data name="WRN_PdbLocalNameTooLong_Title" xml:space="preserve">
    <value>Nazwa lokalna jest za długa dla pliku PDB</value>
  </data>
  <data name="ERR_TryCastOfUnconstrainedTypeParam1" xml:space="preserve">
    <value>Argumenty operacji „TryCast” muszą być parametrami typu z ograniczeniem klasy, ale element „{0}” nie ma ograniczenia klasy.</value>
  </data>
  <data name="FEATURE_ReadonlyAutoProperties" xml:space="preserve">
    <value>automatycznie implementowane właściwości tylko do odczytu</value>
  </data>
  <data name="FEATURE_TypeOfIsNot" xml:space="preserve">
    <value>Wyrażenie TypeOf IsNot</value>
  </data>
  <data name="ERR_NestedExternalSource" xml:space="preserve">
    <value>Dyrektywy #ExternalSource nie mogą być zagnieżdżane.</value>
  </data>
  <data name="WRN_Experimental_Title" xml:space="preserve">
    <value>Typ jest przeznaczony wyłącznie do celów ewaluacyjnych i może zostać zmieniony albo usunięty w przyszłych aktualizacjach.</value>
  </data>
  <data name="ERR_ObjectInitializerRequiresFieldName" xml:space="preserve">
    <value>Inicjatory obiektów wymagają nazwy pola do zainicjowania.</value>
  </data>
  <data name="ERR_ImplementingInterfaceWithDifferentTupleNames5" xml:space="preserve">
    <value>Element „{0}” nie może implementować elementu {1} „{2}” w ramach interfejsu „{3}”, ponieważ nazwy elementów krotki w elemencie „{4}” nie pasują do nazw w elemencie „{5}”.</value>
  </data>
  <data name="ERR_ExpectedSpecifier" xml:space="preserve">
    <value>Oczekiwano jednej z instrukcji: Dim, Const, Public, Private, Protected, Friend, Shadows, ReadOnly lub Shared.</value>
  </data>
  <data name="ERR_OverloadsModifierInModule" xml:space="preserve">
    <value>Nieodpowiednie użycie słowa kluczowego „{0}” w module.</value>
  </data>
  <data name="ERR_QualifiedNameNotAllowed" xml:space="preserve">
    <value>Znak „:” jest niedozwolony. Nie można używać kwalifikowanych nazw XML w tym kontekście.</value>
  </data>
  <data name="ERR_NoConstituentArraySizes" xml:space="preserve">
    <value>Granice można określić tylko dla tablicy najwyższego poziomu podczas inicjowania tablicy tablic.</value>
  </data>
  <data name="ERR_InvalidModuleAttribute1" xml:space="preserve">
    <value>Nie można zastosować atrybutu „{0}” do modułu.</value>
  </data>
  <data name="ERR_NestedGlobalNamespace" xml:space="preserve">
    <value>Globalna przestrzeń nazw nie może być zagnieżdżona w innej przestrzeni nazw.</value>
  </data>
  <data name="ERR_SyntaxInCastOp" xml:space="preserve">
    <value>Błąd składni w operatorze rzutowania. Wymagane są dwa argumenty rozdzielone przecinkiem.</value>
  </data>
  <data name="ERR_ElseIfNoMatchingIf" xml:space="preserve">
    <value>Element „ElseIf” musi być poprzedzony odpowiadającym mu elementem „If” lub „ElseIf”.</value>
  </data>
  <data name="ERR_FriendAssemblyStrongNameRequired" xml:space="preserve">
    <value>Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Zestawy podpisane silnymi nazwami muszą określać klucz publiczny w swoich deklaracjach InternalsVisibleTo.</value>
  </data>
  <data name="ERR_LambdaParamShadowLocal1" xml:space="preserve">
    <value>Parametr lambda „{0}” ukrywa zmienną w otaczającym bloku, w uprzednio zdefiniowanej zmiennej zakresu lub w niejawnie zadeklarowanej zmiennej w wyrażeniu zapytania.</value>
  </data>
  <data name="ERR_OverrideWithOptionalTypes2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ elementy różnią się typami parametrów opcjonalnych.</value>
  </data>
  <data name="ERR_ObsoleteObjectNotVariant" xml:space="preserve">
    <value>Typ Variant nie jest już obsługiwany; zamiast niego użyj typu Object.</value>
  </data>
  <data name="ERR_InterfaceNotExpression1" xml:space="preserve">
    <value>Typem elementu „{0}” jest typ interfejsu i nie można go używać jako wyrażenia.</value>
  </data>
  <data name="WRN_XMLDocCrefAttributeNotFound1_Title" xml:space="preserve">
    <value>Komentarz XML ma tag z atrybutem „cref”, którego nie można rozpoznać</value>
  </data>
  <data name="WRN_ObjectMathSelectCase_Title" xml:space="preserve">
    <value>W wyrażeniach dla instrukcji „Select” i „Case” użyto argumentów operacji typu Object</value>
  </data>
  <data name="WRN_DefaultnessShadowed4" xml:space="preserve">
    <value>Właściwość domyślna „{0}” powoduje konflikt z właściwością domyślną „{1}” w podstawowym elemencie {2} „{3}”. Właściwość „{0}” będzie domyślna. Właściwość „{0}” powinna zostać zadeklarowana jako „Shadows”.</value>
  </data>
  <data name="ERR_GenericConstraintNotSatisfied2" xml:space="preserve">
    <value>Argument typu „{0}” nie dziedziczy po typie ograniczenia „{1}” ani nie implementuje go.</value>
  </data>
  <data name="ERR_ReadOnlyNoAccessorFlag" xml:space="preserve">
    <value>Właściwości „ReadOnly” nie mogą mieć modyfikatora dostępu w elemencie „Get”.</value>
  </data>
  <data name="ERR_MissingVersionInXmlDecl" xml:space="preserve">
    <value>Brak wymaganego atrybutu „version” w deklaracji XML.</value>
  </data>
  <data name="ERR_MarshalUnmanagedTypeOnlyValidForFields" xml:space="preserve">
    <value>Niezarządzany typ „{0}” jest prawidłowy tylko dla pól.</value>
  </data>
  <data name="ERR_VarianceInByRefDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany w tym kontekście, ponieważ parametry typu „In” i „Out” nie mogą być używane dla typów parametrów ByRef, a „{0}” jest parametrem typu „In”.</value>
  </data>
  <data name="ERR_PartialMethodDefaultParameterValueMismatch2" xml:space="preserve">
    <value>Parametr opcjonalny metody „{0}” nie ma tej samej wartości domyślnej co odpowiedni parametr metody częściowej „{1}”.</value>
  </data>
  <data name="ERR_ObsoleteLineNumbersAreLabels" xml:space="preserve">
    <value>Po etykietach, które są liczbami, muszą następować dwukropki.</value>
  </data>
  <data name="ERR_OnlyOneAccessorForGetSet" xml:space="preserve">
    <value>Modyfikator dostępu można stosować do elementu „Get” lub elementu „Set”, ale nie do obu elementów naraz.</value>
  </data>
  <data name="ERR_QueryDuplicateAnonTypeMemberName1" xml:space="preserve">
    <value>Zmienna zakresu „{0}” jest już zadeklarowana.</value>
  </data>
  <data name="ERR_IllegalCallOrIndex" xml:space="preserve">
    <value>Niedozwolone wyrażenie wywołania lub indeksu.</value>
  </data>
  <data name="ERR_ConversionToBaseType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu na jego typ podstawowy.</value>
  </data>
  <data name="ERR_CantRaiseBaseEvent" xml:space="preserve">
    <value>Klasy pochodne nie mogą generować zdarzeń klasy podstawowej.</value>
  </data>
  <data name="ERR_AttrCannotBeGenerics" xml:space="preserve">
    <value>Parametrów typu, typów ogólnych lub typów zawartych w typach ogólnych nie można używać jako atrybutów.</value>
  </data>
  <data name="ERR_CantSpecifyNullableOnBoth" xml:space="preserve">
    <value>Modyfikator dopuszczający wartość null nie może być określony jednocześnie w zmiennej i jej typie.</value>
  </data>
  <data name="ERR_UndefinedTypeOrNamespace1" xml:space="preserve">
    <value>Nie zdefiniowano typu lub przestrzeni nazw „{0}”.</value>
  </data>
  <data name="ERR_PartialMethodGenericConstraints2" xml:space="preserve">
    <value>Metoda „{0}” nie ma takich samych ograniczeń ogólnych jak metoda częściowa „{1}”.</value>
  </data>
  <data name="ERR_LateBoundOverloadInterfaceCall1" xml:space="preserve">
    <value>Ustalanie przeciążenia późnego wiązania nie może zostać zastosowane w elemencie „{0}”, ponieważ wystąpienie uzyskujące dostęp jest typem interfejsu.</value>
  </data>
  <data name="ERR_WriteOnlyHasGet" xml:space="preserve">
    <value>Właściwości zadeklarowane jako WriteOnly nie mogą mieć procedury Get.</value>
  </data>
  <data name="ERR_RestrictedConversion1" xml:space="preserve">
    <value>Wyrażenia typu „{0}” nie można przekonwertować na element „Object” ani „ValueType”.</value>
  </data>
  <data name="ERR_SecurityAttributeInvalidActionAssembly" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest niepoprawna dla atrybutów zabezpieczeń zastosowanych względem zestawu.</value>
  </data>
  <data name="ERR_DuplicateAnonTypeMemberName1" xml:space="preserve">
    <value>Element członkowski lub właściwość typu anonimowego „{0}” jest już zadeklarowany.</value>
  </data>
  <data name="WRN_AssemblyGeneration1_Title" xml:space="preserve">
    <value>Wykryto potencjalny problem podczas kompilowania zestawu</value>
  </data>
  <data name="ERR_IllegalChar" xml:space="preserve">
    <value>Znak jest nieprawidłowy.</value>
  </data>
  <data name="WRN_ExpectedInitComponentCall2" xml:space="preserve">
    <value>Element „{0}” w typie wygenerowanym przez projektanta „{1}” powinien wywoływać metodę InitializeComponent.</value>
  </data>
  <data name="WRN_NoAnalyzerInAssembly" xml:space="preserve">
    <value>Zestaw {0} nie zawiera żadnych analizatorów.</value>
  </data>
  <data name="ERR_QualNotObjectRecord1" xml:space="preserve">
    <value>Element „!” wymaga, aby lewy argument operacji zawierał parametr typu, klasę lub typ interfejsu, ale ten argument operacji jest typu „{0}”.</value>
  </data>
  <data name="WRN_XMLDocBadXMLLine" xml:space="preserve">
    <value>Blok komentarza XML musi bezpośrednio poprzedzać element języka, do którego jest stosowany. Komentarz XML zostanie zignorowany.</value>
  </data>
  <data name="FTL_InputFileNameTooLong" xml:space="preserve">
    <value>Nazwa pliku „{0}” jest pusta, zawiera nieprawidłowe znaki, zawiera specyfikację dysku bez bezwzględnej ścieżki lub jest za długa</value>
  </data>
  <data name="ERR_ModulesCannotBeGeneric" xml:space="preserve">
    <value>Moduły nie mogą być ogólne.</value>
  </data>
  <data name="ERR_BadLanguageVersion" xml:space="preserve">
    <value>Podana wersja języka jest nieobsługiwana lub nieprawidłowa: „{0}”.</value>
  </data>
  <data name="ERR_ParamTypingInconsistency" xml:space="preserve">
    <value>Jeśli którekolwiek z parametrów mają jawnie określone typy, to wszystkie parametry muszą mieć jawnie określone typy.</value>
  </data>
  <data name="ERR_NoDirectDelegateConstruction1" xml:space="preserve">
    <value>Delegat „{0}” wymaga wyrażenia „AddressOf” lub wyrażenia lambda jako jedynego argumentu dla jego konstruktora.</value>
  </data>
  <data name="WRN_UnobservedAwaitableDelegate_Title" xml:space="preserve">
    <value>Zadanie zwrócone przez tę funkcję asynchroniczną zostanie porzucone, a powiązane z nim wyjątki zostaną zignorowane</value>
  </data>
  <data name="ERR_ArrayInitializerForNonConstDim" xml:space="preserve">
    <value>Inicjatora tablicy nie można określić dla niestałego wymiaru; użyj pustego inicjatora „{}”.</value>
  </data>
  <data name="ERR_OverloadWithOptional2" xml:space="preserve">
    <value>Elementy „{0}” i „{1}” nie mogą przeciążać siebie nawzajem, ponieważ różnią się jedynie parametrami opcjonalnymi.</value>
  </data>
  <data name="ERR_InvalidUseOfCustomModifier" xml:space="preserve">
    <value>Modyfikatora „Custom” można używać tylko bezpośrednio przed deklaracją „Event”.</value>
  </data>
  <data name="ERR_MultiplyDefinedType3" xml:space="preserve">
    <value>Element „{0}” jest już zadeklarowany jako „{1}” w tym elemencie {2}.</value>
  </data>
  <data name="ERR_InterfaceCycle1" xml:space="preserve">
    <value>Interfejs „{0}” nie może dziedziczyć po samym sobie: {1}</value>
  </data>
  <data name="ERR_CustomEventInvInInterface" xml:space="preserve">
    <value>Modyfikator „Custom” jest nieprawidłowy w zdarzeniach deklarowanych w interfejsach.</value>
  </data>
  <data name="ERR_BadOperatorFlags1" xml:space="preserve">
    <value>Operatorów nie można zadeklarować jako „{0}”.</value>
  </data>
  <data name="ERR_InvalidConstructorCall" xml:space="preserve">
    <value>Wywołanie konstruktora jest prawidłowe tylko jako pierwsza instrukcja w konstruktorze wystąpienia.</value>
  </data>
  <data name="ERR_ExpectedDeclaration" xml:space="preserve">
    <value>Oczekiwano deklaracji.</value>
  </data>
  <data name="WRN_UseOfObsoleteSymbol2" xml:space="preserve">
    <value>Element „{0}” jest przestarzały: „{1}”.</value>
  </data>
  <data name="ERR_ExtensionMethodOptionalFirstArg" xml:space="preserve">
    <value>Nie można zastosować elementu „Optional” do pierwszego parametru metody rozszerzenia. Pierwszy parametr określa typ do rozszerzenia.</value>
  </data>
  <data name="ERR_BadConstraintSyntax" xml:space="preserve">
    <value>Oczekiwano typu lub elementu „New”.</value>
  </data>
  <data name="ERR_TypeParamWithStructConstAsConst" xml:space="preserve">
    <value>Parametru typu z ograniczeniem „Structure” nie można używać jako ograniczenia.</value>
  </data>
  <data name="ERR_ComClassReservedDispIdZero1" xml:space="preserve">
    <value>Nie można zastosować elementu „System.Runtime.InteropServices.DispIdAttribute” do elementu „{0}”, ponieważ element „Microsoft.VisualBasic.ComClassAttribute” rezerwuje zero jako właściwość domyślną.</value>
  </data>
  <data name="ERR_TooFewGenericArguments2" xml:space="preserve">
    <value>Za mało argumentów typu dla metody rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”.</value>
  </data>
  <data name="ERR_TooFewGenericArguments1" xml:space="preserve">
    <value>Za mało argumentów typu dla elementu „{0}”.</value>
  </data>
  <data name="ERR_InvOutsideProc" xml:space="preserve">
    <value>Etykiety nie są prawidłowe poza metodami.</value>
  </data>
  <data name="TreesMustHaveRootNode" xml:space="preserve">
    <value>Element trees({0}) musi mieć węzeł główny z elementem SyntaxKind.CompilationUnit.</value>
  </data>
  <data name="ERR_Syntax" xml:space="preserve">
    <value>Błąd składni.</value>
  </data>
  <data name="ERR_SwitchNeedsBool" xml:space="preserve">
    <value>po opcji „{0}” może występować tylko znak „+” lub „-”</value>
  </data>
  <data name="ERR_InitializedExpandedProperty" xml:space="preserve">
    <value>Rozszerzone właściwości nie mogą być zainicjowane.</value>
  </data>
  <data name="ERR_RaiseEventShapeMismatch1" xml:space="preserve">
    <value>Metoda „RaiseEvent” musi mieć taką samą sygnaturę jak typ delegowany „{0}” zdarzenia zawierającego.</value>
  </data>
  <data name="ERR_PIAHasNoTypeLibAttribute1" xml:space="preserve">
    <value>Nie można osadzić typów międzyoperacyjnych z zestawu „{0}”, ponieważ brakuje atrybutu „{1}” lub „{2}”.</value>
  </data>
  <data name="WRN_NonCLSMemberInCLSInterface1_Title" xml:space="preserve">
    <value>Niezgodny ze specyfikacją CLS element członkowski jest niedozwolony w interfejsie zgodnym ze specyfikacją CLS</value>
  </data>
  <data name="WRN_IndirectRefToLinkedAssembly2" xml:space="preserve">
    <value>Utworzono odwołanie do osadzonego zestawu międzyoperacyjnego „{0}” z powodu pośredniego odwołania do tego zestawu z zestawu „{1}”. Rozważ zmianę właściwości osadzania typów międzyoperacyjnych w jednym z zestawów.</value>
  </data>
  <data name="ERR_UnreferencedModule3" xml:space="preserve">
    <value>Wymagane odwołanie do modułu „{0}” z typem „{1}”. Dodaj je do projektu.</value>
  </data>
  <data name="ERR_InvalidOptionStrictCustom" xml:space="preserve">
    <value>Elementu Option Strict Custom można użyć tylko jako opcji dla kompilatora wiersza polecenia (vbc.exe).</value>
  </data>
  <data name="ERR_SyntMemberShadowsGenericParam3" xml:space="preserve">
    <value>Element {0} „{1}” niejawnie definiuje element członkowski „{2}”, który ma taką samą nazwę jak parametr typu.</value>
  </data>
  <data name="ERR_RefAndValueConstraintsCombined" xml:space="preserve">
    <value>Nie można łączyć ograniczeń Class i Structure.</value>
  </data>
  <data name="WRN_DefAsgNoRetValPropRef1_Title" xml:space="preserve">
    <value>Właściwość nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="ERR_EmptyAggregateInitializer" xml:space="preserve">
    <value>Wpis inicjatora kolekcji zagregowanej musi zawierać co najmniej jeden element.</value>
  </data>
  <data name="ERR_NewWithTupleTypeSyntax" xml:space="preserve">
    <value>Instrukcji „new” nie można użyć dla typu krotki. Użyj zamiast tego wyrażenia literału krotki.</value>
  </data>
  <data name="ERR_NoNonNarrowingOverloadCandidates2" xml:space="preserve">
    <value>Ustalanie przeciążenia nie powiodło się, ponieważ brak jest dostępnego elementu „{0}”, którego można wywołać bez konwersji zawężającej: {1}.</value>
  </data>
  <data name="ERR_DebugEntryPointNotSourceMethodDefinition" xml:space="preserve">
    <value>Punkt wejściowy debugowania musi być definicją metody zadeklarowanej w bieżącej kompilacji.</value>
  </data>
  <data name="ERR_InvalidStructMemberNoPIA1" xml:space="preserve">
    <value>Osadzona struktura międzyoperacyjna „{0}” może zawierać tylko publiczne pola wystąpień.</value>
  </data>
  <data name="ERR_InvalidImplicitMeReference" xml:space="preserve">
    <value>Niejawne odwołanie do właśnie konstruowanego obiektu nie jest prawidłowe podczas wywoływania innego konstruktora.</value>
  </data>
  <data name="WRN_XMLDocNotFirstOnLine" xml:space="preserve">
    <value>Komentarz XML musi być pierwszą instrukcją w wierszu. Komentarz XML zostanie zignorowany.</value>
  </data>
  <data name="ERR_UnexpectedGroup" xml:space="preserve">
    <value>Element „Group” jest niedozwolony w tym kontekście; oczekiwano identyfikatora.</value>
  </data>
  <data name="WRN_ObjectMath1" xml:space="preserve">
    <value>Argumenty operacji typu Object użyte dla operatora „{0}”; użyj operatora „Is”, aby sprawdzić tożsamość obiektu.</value>
  </data>
  <data name="WRN_ObjectMath2" xml:space="preserve">
    <value>Argumenty operacji typu Object użyte dla operatora „{0}”; mogą wystąpić błędy podczas wykonywania.</value>
  </data>
  <data name="FieldInitializerSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Element FieldInitializerSyntax nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="ERR_AttributeParameterRequired2" xml:space="preserve">
    <value>Należy podać parametr atrybutu „{0}” lub „{1}”.</value>
  </data>
  <data name="ERR_AttributeParameterRequired1" xml:space="preserve">
    <value>Należy podać parametr atrybutu „{0}”.</value>
  </data>
  <data name="ERR_InitializerInStruct" xml:space="preserve">
    <value>Inicjatory w elementach członkowskich struktur są prawidłowe tylko w przypadku wartości stałych i elementów członkowskich „Shared”.</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedHere3" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w elemencie „{2}” w tym kontekście, ponieważ zarówno kontekst, jak i definicja „{0}” są zagnieżdżone w obrębie interfejsu „{1}”, a „{1}” ma parametry typu „In” lub „Out”. Rozważ przeniesienie definicji „{0}” poza interfejs „{1}”.</value>
  </data>
  <data name="ERR_NoNetModuleOutputWhenRefOutOrRefOnly" xml:space="preserve">
    <value>Nie można skompilować modułów sieciowych, gdy używana jest opcja /refout lub /refonly.</value>
  </data>
  <data name="ERR_TypeDisallowsDescendants" xml:space="preserve">
    <value>Nie można wybierać podrzędnych elementów XML z typu „{0}”.</value>
  </data>
  <data name="ERR_GenericParamBase2" xml:space="preserve">
    <value>Element {0} „{1}” nie może dziedziczyć po parametrze typu.</value>
  </data>
  <data name="ERR_BadAssemblyName" xml:space="preserve">
    <value>Nieprawidłowa nazwa zestawu: {0}</value>
  </data>
  <data name="ERR_BadRecordFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji struktury.</value>
  </data>
  <data name="ERR_NestingViolatesCLS1" xml:space="preserve">
    <value>Typ „{0}” nie dziedziczy parametrów typu ogólnego ze swojego kontenera.</value>
  </data>
  <data name="ERR_ExpectedEndModule" xml:space="preserve">
    <value>Instrukcja Module musi być zakończona odpowiadającą jej instrukcją End Module.</value>
  </data>
  <data name="ERR_BaseUnifiesWithInterfaces3" xml:space="preserve">
    <value>Nie można dziedziczyć interfejsu „{0}”, ponieważ interfejs „{1}”, po którym ten interfejs dziedziczy, może być taki sam jak interfejs „{2}” dla niektórych argumentów typu.</value>
  </data>
  <data name="ERR_MaximumNumberOfErrors" xml:space="preserve">
    <value>Przekroczono maksymalną liczbę błędów.</value>
  </data>
  <data name="ERR_IllegalOperandInIIFConversion" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu dla drugiego i trzeciego argumentu operacji operatora „If”. Jeden musi umożliwiać konwersję rozszerzającą do drugiego.</value>
  </data>
  <data name="ERR_BadAsyncByRefParam" xml:space="preserve">
    <value>Metody asynchroniczne nie mogą mieć parametrów ByRef.</value>
  </data>
  <data name="ERR_NoTypecharInLabel" xml:space="preserve">
    <value>Znaki typu są niedozwolone w identyfikatorach etykiet.</value>
  </data>
  <data name="ERR_InvalidFormatForGuidForOption" xml:space="preserve">
    <value>Błąd składni wiersza polecenia: nieprawidłowy format identyfikatora GUID „{0}” dla opcji „{1}”</value>
  </data>
  <data name="ERR_NoTypecharInAlias" xml:space="preserve">
    <value>Znaki typu są niedozwolone w aliasach Imports.</value>
  </data>
  <data name="WRN_MustOverride2" xml:space="preserve">
    <value>Element {0} „{1}” zasłania w podstawowym elemencie {2} „{3}” metodę, którą można przesłonić. Aby można było przesłonić metodę podstawową, metoda ta musi być zadeklarowana jako „Overrides”.</value>
  </data>
  <data name="ERR_NoSuitableWidestType1" xml:space="preserve">
    <value>Nie można wywnioskować typu elementu „{0}”, ponieważ granice pętli i klauzula step nie są konwertowane na ten sam typ.</value>
  </data>
  <data name="ERR_IsOperatorNullable1" xml:space="preserve">
    <value>Argument operacji „Is” typu „{0}” można porównać tylko z elementem „Nothing”, ponieważ typ „{0}” jest typem dopuszczającym wartość null.</value>
  </data>
  <data name="ERR_OptionMustBeAbsolutePath" xml:space="preserve">
    <value>Opcja „{0}” musi być ścieżką bezwzględną.</value>
  </data>
  <data name="ERR_ExpectedXmlEndEmbedded" xml:space="preserve">
    <value>Oczekiwano zamykających znaków „%&gt;” dla wyrażenia osadzonego.</value>
  </data>
  <data name="ERR_ExitDoNotWithinDo" xml:space="preserve">
    <value>Instrukcja Exit Do może wystąpić tylko wewnątrz instrukcji Do.</value>
  </data>
  <data name="ERR_ConstructorAsync" xml:space="preserve">
    <value>Konstruktor nie może zawierać modyfikatora „Async”.</value>
  </data>
  <data name="ERR_VarianceOutByValDisallowed1" xml:space="preserve">
    <value>Typ „{0}” nie może być używany jako parametr typu ByVal, ponieważ „{0}” jest parametrem typu „Out”.</value>
  </data>
  <data name="ERR_InvalidSubsystemVersion" xml:space="preserve">
    <value>Wartość „{0}” nie jest prawidłową wersją podsystemu. Wersja musi mieć wartość 6.02 lub wyższą dla elementu ARM lub AppContainerExe oraz 4.00 lub wyższą w innych przypadkach.</value>
  </data>
  <data name="ERR_ConditionOperatorRequired3" xml:space="preserve">
    <value>Typ „{0}” musi definiować operator „{1}”, aby mógł zostać użyty w wyrażeniu „{2}”.</value>
  </data>
  <data name="ERR_InvalidPathMap" xml:space="preserve">
    <value>Opcja pathmap jest nieprawidłowo sformatowana.</value>
  </data>
  <data name="ERR_MissingRuntimeHelper" xml:space="preserve">
    <value>Żądana operacja jest niedostępna, ponieważ funkcja biblioteki uruchomieniowej „{0}” nie jest zdefiniowana.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest2" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie „{0}”, ponieważ nie można konwertować ich na ten sam typ.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest3" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu w metodzie rozszerzenia „{0}” zdefiniowanej w elemencie „{1}”, ponieważ nie można konwertować ich na ten sam typ.</value>
  </data>
  <data name="ERR_TypeInferenceFailureNoExplicitNoBest1" xml:space="preserve">
    <value>Na podstawie tych argumentów nie można wywnioskować typów danych parametrów typu, ponieważ nie można konwertować ich na jeden typ.</value>
  </data>
  <data name="ERR_InvalidAssemblyAttribute1" xml:space="preserve">
    <value>Nie można zastosować atrybutu „{0}” do zestawu.</value>
  </data>
  <data name="ERR_IllegalBaseTypeReferences3" xml:space="preserve">
    <value>Klauzula Inherits elementu {0} „{1}” powoduje wystąpienie zależności cyklicznej: {2}</value>
  </data>
  <data name="ERR_MissingAddHandlerDef1" xml:space="preserve">
    <value>Brak definicji elementu „AddHandler” dla zdarzenia „{0}”.</value>
  </data>
  <data name="ERR_MemberClashesWithSynth6" xml:space="preserve">
    <value>Element {0} „{1}” powoduje konflikt z członkiem zadeklarowanym niejawnie dla elementu {2} „{3}” w elemencie {4} „{5}”.</value>
  </data>
  <data name="ERR_StrictArgumentCopyBackNarrowing3" xml:space="preserve">
    <value>Ustawienie „Option Strict On” uniemożliwia zawężanie z typu „{1}” do typu „{2}” podczas kopiowania wartości parametru „ByRef” „{0}” z powrotem do pasującego argumentu.</value>
  </data>
  <data name="ERR_BadCodepage" xml:space="preserve">
    <value>strona kodowa „{0}” jest nieprawidłowa lub nie została zainstalowana</value>
  </data>
  <data name="ERR_ExpectedXmlBeginEmbedded" xml:space="preserve">
    <value>Oczekiwano znaków „%=” na początku wyrażenia osadzonego.</value>
  </data>
  <data name="ERR_MustShadow2" xml:space="preserve">
    <value>Element {0} „{1}” musi być zadeklarowany jako „Shadows”, ponieważ inny element członkowski o tej samej nazwie jest zadeklarowany jako „Shadows”.</value>
  </data>
  <data name="ERR_InterfacePossiblyImplTwice2" xml:space="preserve">
    <value>Nie można zaimplementować interfejsu „{0}”, ponieważ jego implementacja może powodować konflikt z implementacją innego zaimplementowanego interfejsu „{1}” w przypadku niektórych argumentów typu.</value>
  </data>
  <data name="WRN_AttributeIgnoredWhenPublicSigning" xml:space="preserve">
    <value>Atrybut „{0}” jest ignorowany w przypadku określenia podpisywania publicznego.</value>
  </data>
  <data name="ERR_BadInterfaceClassSpecifier1" xml:space="preserve">
    <value>Nie można zadeklarować klasy w interfejsie jako „{0}”.</value>
  </data>
  <data name="ERR_FriendAssemblyBadArguments" xml:space="preserve">
    <value>Odwołanie do przyjaznego zestawu „{0}” jest nieprawidłowe. Deklaracje InternalsVisibleTo nie mogą mieć określonej wersji, kultury, tokena klucza publicznego ani architektury procesora.</value>
  </data>
  <data name="ERR_VarianceTypeDisallowedHereForGeneric5" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty dla elementu „{3}” należącego do elementu „{4}” w „{2}” w tym kontekście, ponieważ zarówno kontekst, jak i definicja „{0}” są zagnieżdżone w obrębie interfejsu „{1}”, a „{1}” ma parametry typu „In” lub „Out”. Rozważ przeniesienie definicji „{0}” poza interfejs „{1}”.</value>
  </data>
  <data name="ERR_DoesntImplementAwaitInterface2" xml:space="preserve">
    <value>Element „{0}” nie implementuje interfejsu „{1}”.</value>
  </data>
  <data name="ERR_IllegalXmlCommentChar" xml:space="preserve">
    <value>Sekwencja znaków „--” jest niedozwolona w komentarzu XML.</value>
  </data>
  <data name="ERR_ConflictingDirectConstraints3" xml:space="preserve">
    <value>Ograniczenie „{0}” powoduje konflikt z ograniczeniem „{1}” już określonym dla parametru typu „{2}”.</value>
  </data>
  <data name="ERR_SourceInterfaceMustBeInterface" xml:space="preserve">
    <value>Interfejs „{0}” zawiera nieprawidłowy interfejs źródłowy wymagany do osadzenia zdarzenia „{1}”.</value>
  </data>
  <data name="ERR_NameNotDeclared1" xml:space="preserve">
    <value>Element „{0}” nie został zadeklarowany. Może on być niedostępny z powodu swojego poziomu ochrony.</value>
  </data>
  <data name="ERR_ObsoleteGetStatement" xml:space="preserve">
    <value>Instrukcje „Get” nie są już obsługiwane. Funkcje We/Wy dla plików są dostępne w przestrzeni nazw „Microsoft.VisualBasic”.</value>
  </data>
  <data name="ERR_IndexedNotArrayOrProc" xml:space="preserve">
    <value>Wyrażenie nie jest tablicą ani metodą i nie może mieć listy argumentów.</value>
  </data>
  <data name="ERR_AmbiguousDelegateBinding2" xml:space="preserve">
    <value>Żaden z dostępnych elementów „{0}” nie jest bardziej konkretny od pozostałych: {1}</value>
  </data>
  <data name="ERR_ExpectedXmlEndComment" xml:space="preserve">
    <value>Oczekiwano zamykających znaków „--&gt;” dla komentarza XML.</value>
  </data>
  <data name="ERR_StructCantInherit" xml:space="preserve">
    <value>Struktury nie mogą mieć instrukcji Inherits.</value>
  </data>
  <data name="ERR_AttributeMustInheritSysAttr" xml:space="preserve">
    <value>Nie można użyć elementu „{0}” jako atrybutu, ponieważ nie dziedziczy on po klasie „System.Attribute”.</value>
  </data>
  <data name="ERR_NoPIAAttributeMissing2" xml:space="preserve">
    <value>Nie można osadzić typu międzyoperacyjnego „{0}”, ponieważ brakuje w nim wymaganego atrybutu „{1}”.</value>
  </data>
  <data name="INF_UnableToLoadSomeTypesInAnalyzer_Title" xml:space="preserve">
    <value>Pomiń ładowanie typów w zestawie analizatora zakończonych niepowodzeniem z powodu wyjątku ReflectionTypeLoadException</value>
  </data>
  <data name="WRN_SynthMemberShadowsSynthMember7_Title" xml:space="preserve">
    <value>Właściwość lub zdarzenie niejawnie deklaruje element członkowski powodujący konflikt z elementem członkowskim niejawnie zadeklarowanym dla właściwości lub zdarzenia w typie podstawowym</value>
  </data>
  <data name="WRN_ObjectAssumed1_Title" xml:space="preserve">
    <value>Funkcja bez klauzuli „As”</value>
  </data>
  <data name="ERR_InterfaceInheritedTwiceWithDifferentTupleNamesReverse3" xml:space="preserve">
    <value>Interfejs „{0}” (poprzez „{1}”) można odziedziczyć tylko raz według tego interfejsu, lecz występuje już z innymi nazwami elementów krotki, takimi jak „{2}”.</value>
  </data>
  <data name="WRN_MissingAsClauseinProperty" xml:space="preserve">
    <value>Właściwość bez klauzuli „As”; przyjęto typ Object.</value>
  </data>
  <data name="ERR_CantShadowAMustOverride1" xml:space="preserve">
    <value>Element „{0}” nie może zasłaniać metody zadeklarowanej jako „MustOverride”.</value>
  </data>
  <data name="ERR_DelegateNoInvoke1" xml:space="preserve">
    <value>Klasa delegatu „{0}” nie ma metody Invoke, dlatego wyrażenie tego typu nie może być elementem docelowym wywołania metody.</value>
  </data>
  <data name="ERR_ReadOnlyHasNoGet" xml:space="preserve">
    <value>Właściwość typu ReadOnly musi udostępniać procedurę Get.</value>
  </data>
  <data name="WRN_SynthMemberShadowsMember5" xml:space="preserve">
    <value>Element {0} „{1}” niejawnie deklaruje element „{2}”, który powoduje konflikt z elementem członkowskim w podstawowym elemencie {3} „{4}” i dlatego element {0} powinien być zadeklarowany jako „Shadows”.</value>
  </data>
  <data name="ERR_EqualsTypeMismatch" xml:space="preserve">
    <value>Operator „Equals” nie umożliwia porównania wartości typu „{0}” z wartością typu „{1}”.</value>
  </data>
  <data name="ERR_NoDefaultNotExtend1" xml:space="preserve">
    <value>Nie można zaindeksować klasy „{0}”, ponieważ nie ma ona właściwości domyślnej.</value>
  </data>
  <data name="ERR_ObsoleteEndIf" xml:space="preserve">
    <value>Instrukcje „EndIf” nie są już obsługiwane; zamiast nich używaj instrukcji „End If”.</value>
  </data>
  <data name="ERR_UnsupportedMethod1" xml:space="preserve">
    <value>Element „{0}” ma nieobsługiwany typ zwracany albo nieobsługiwane typy parametrów.</value>
  </data>
  <data name="ERR_ObsoleteGosub" xml:space="preserve">
    <value>Instrukcje GoSub nie są już obsługiwane.</value>
  </data>
  <data name="ERR_ObsoleteAsAny" xml:space="preserve">
    <value>Element As Any nie jest obsługiwany w instrukcjach Declare.</value>
  </data>
  <data name="ERR_RedimRankMismatch" xml:space="preserve">
    <value>Nie można zmienić liczby wymiarów tablicy przy użyciu instrukcji ReDim.</value>
  </data>
  <data name="ERR_BadImplementsType" xml:space="preserve">
    <value>Implementowany typ musi być interfejsem.</value>
  </data>
  <data name="WRN_NoNonObsoleteConstructorOnBase3_Title" xml:space="preserve">
    <value>Należy zadeklarować element „Sub New” w klasie, ponieważ konstruktor w klasie podstawowej został oznaczony jako przestarzały</value>
  </data>
  <data name="ERR_ExpectedForOptionStmt" xml:space="preserve">
    <value>Po instrukcji „Option” musi znajdować się element „Compare”, „Explicit”, „Infer” lub „Strict”.</value>
  </data>
  <data name="ERR_ExtensionMethodNotInModule" xml:space="preserve">
    <value>Metody rozszerzenia można definiować tylko w modułach.</value>
  </data>
  <data name="WRN_ImplicitConversionSubst1_Title" xml:space="preserve">
    <value>Niejawna konwersja</value>
  </data>
  <data name="ERR_TypeRefResolutionError3" xml:space="preserve">
    <value>Importowanie typu „{0}” z zestawu lub modułu „{1}” nie powiodło się.</value>
  </data>
  <data name="WRN_EnumUnderlyingTypeNotCLS1" xml:space="preserve">
    <value>Typ bazowy „{0}” wyliczenia jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_MustOverOnNotInheritPartClsMem1" xml:space="preserve">
    <value>Elementu „MustOverride” nie można określić w tym elemencie członkowskim, ponieważ znajduje się on w typie częściowym zadeklarowanym jako „NotInheritable” w innej definicji częściowej.</value>
  </data>
  <data name="ERR_NoExplicitArraySizes" xml:space="preserve">
    <value>Granice tablicy nie mogą wystąpić w specyfikatorze typu.</value>
  </data>
  <data name="ERR_NonNamespaceOrClassOnImport2" xml:space="preserve">
    <value>Element „{1}” dla operacji importu „{0}” nie odwołuje się do przestrzeni nazw, klasy, struktury, wyliczenia ani modułu.</value>
  </data>
  <data name="WRN_XMLDocReturnsOnWriteOnlyProperty" xml:space="preserve">
    <value>Tag komentarza XML „returns” jest niedozwolony we właściwości „WriteOnly”.</value>
  </data>
  <data name="ERR_PartialMethodsMustBePrivate" xml:space="preserve">
    <value>Metody częściowe muszą być zadeklarowane jako „Private”.</value>
  </data>
  <data name="ERR_ConstAsNonConstant" xml:space="preserve">
    <value>Stałe muszą być typu wewnętrznego lub wyliczeniowego, a nie typu klasy, struktury, parametru typu lub tablicy.</value>
  </data>
  <data name="ERR_NoArgumentCountOverloadCandidates1" xml:space="preserve">
    <value>Rozpoznanie przeciążenia nie powiodło się, ponieważ żaden z dostępnych elementów „{0}” nie akceptuje tej liczby argumentów.</value>
  </data>
  <data name="ERR_AmbiguousOverrides3" xml:space="preserve">
    <value>Element członkowski „{0}” zgodny z sygnaturą nie może zostać przesłoniony, ponieważ klasa „{1}” zawiera wiele elementów członkowskich o tej samej nazwie i sygnaturze: {2}.</value>
  </data>
  <data name="ERR_StatementLambdaInExpressionTree" xml:space="preserve">
    <value>Instrukcji lambda nie można konwertować na drzewa wyrażeń.</value>
  </data>
  <data name="ERR_InheritanceCycle1" xml:space="preserve">
    <value>Klasa „{0}” nie może dziedziczyć po sobie samej: {1}.</value>
  </data>
  <data name="ERR_MissingEndEnum" xml:space="preserve">
    <value>Instrukcja Enum musi być zakończona odpowiadającą jej instrukcją End Enum.</value>
  </data>
  <data name="ERR_UnsupportedModule1" xml:space="preserve">
    <value>Element „{0}” jest nieobsługiwanym modułem platformy .NET.</value>
  </data>
  <data name="ERR_ByRefIllegal1" xml:space="preserve">
    <value>Parametrów {0} nie można deklarować jako „ByRef”.</value>
  </data>
  <data name="WRN_InvalidOverrideDueToTupleNames2" xml:space="preserve">
    <value>Element „{0}” nie może przesłonić elementu „{1}”, ponieważ różnią się nazwami elementów krotki.</value>
  </data>
  <data name="ERR_BadFlagsOnStdModuleProperty1" xml:space="preserve">
    <value>Właściwości w module nie mogą być zadeklarowane jako „{0}”.</value>
  </data>
  <data name="ERR_SubNewCycle2" xml:space="preserve">
    <value>
    Element „{0}” wywołuje element „{1}”.</value>
  </data>
  <data name="ERR_SubNewCycle1" xml:space="preserve">
    <value>Konstruktor „{0}” nie może wywoływać samego siebie: {1}</value>
  </data>
  <data name="ERR_BadAwaitInTryHandler" xml:space="preserve">
    <value>Operator „Await” nie może być używany wewnątrz instrukcji „Catch”, „Finally” ani „SyncLock”.</value>
  </data>
  <data name="ERR_NoAccessibleSet" xml:space="preserve">
    <value>Metoda dostępu „Set” właściwości „{0}” jest niedostępna.</value>
  </data>
  <data name="ERR_NoAccessibleGet" xml:space="preserve">
    <value>Metoda dostępu „Get” właściwości „{0}” jest niedostępna.</value>
  </data>
  <data name="WRN_TypeConflictButMerged6_Title" xml:space="preserve">
    <value>Wystąpił konflikt typu i typu częściowego, ale trwa ich scalanie, ponieważ jeden z nich został zadeklarowany jako częściowy</value>
  </data>
  <data name="ERR_IsOperatorRequiresReferenceTypes1" xml:space="preserve">
    <value>Operator „Is” nie akceptuje argumentów operacji typu „{0}”. Typem argumentu operacji musi być odwołanie lub typ dopuszczający wartość null.</value>
  </data>
  <data name="WRN_InvalidOverrideDueToTupleNames2_Title" xml:space="preserve">
    <value>Element członkowski nie może przesłaniać, ponieważ różni się nazwami elementów krotki.</value>
  </data>
  <data name="WRN_ObsoleteIdentityDirectCastForValueType_Title" xml:space="preserve">
    <value>Użycie operatora DirectCast do rzutowania typu wartości na ten sam typ jest przestarzałe</value>
  </data>
  <data name="ERR_ConstantWithNoValue" xml:space="preserve">
    <value>Stałe muszą mieć wartość.</value>
  </data>
  <data name="ERR_NameNotMemberOfAnonymousType2" xml:space="preserve">
    <value>Element „{0}” nie jest elementem członkowskim elementu „{1}”. Nie istnieje on w bieżącym kontekście.</value>
  </data>
  <data name="ERR_EndClassNoClass" xml:space="preserve">
    <value>Instrukcja End Class musi być poprzedzona odpowiadającą jej instrukcją Class.</value>
  </data>
  <data name="WRN_FileAlreadyIncluded_Title" xml:space="preserve">
    <value>Plik źródłowy został określony wiele razy</value>
  </data>
  <data name="ERR_TypecharNotallowed" xml:space="preserve">
    <value>Znaki deklaracji typu nie są prawidłowe w tym kontekście.</value>
  </data>
  <data name="ERR_BogusWithinLineIf" xml:space="preserve">
    <value>Instrukcja nie może kończyć bloku poza instrukcją If wiersza.</value>
  </data>
  <data name="WRN_NameNotCLSCompliant1_Title" xml:space="preserve">
    <value>Nazwa jest niezgodna ze specyfikacją CLS</value>
  </data>
  <data name="WRN_TypeNotCLSCompliant1_Title" xml:space="preserve">
    <value>Typ nie jest zgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_NestedTypeInInheritsClause2" xml:space="preserve">
    <value>Klasa „{0}” nie może odwoływać się do swojego zagnieżdżonego typu „{1}” w klauzuli Inherits.</value>
  </data>
  <data name="ERR_UnsupportedType1" xml:space="preserve">
    <value>Element „{0}” jest nieobsługiwanym typem.</value>
  </data>
  <data name="ERR_ConvParamMustBeContainingType1" xml:space="preserve">
    <value>Typ parametru lub typ zwracany tego operatora konwersji muszą być typu zawierającego „{0}”.</value>
  </data>
  <data name="ERR_ForLoopOperatorRequired2" xml:space="preserve">
    <value>Typ „{0}” musi definiować operator „{1}”, aby można było go używać w instrukcji „For”.</value>
  </data>
  <data name="ERR_ExitForNotWithinFor" xml:space="preserve">
    <value>Instrukcja Exit For może wystąpić tylko wewnątrz instrukcji For.</value>
  </data>
  <data name="WRN_MainIgnored" xml:space="preserve">
    <value>Punkt wejścia programu to kod skryptu globalnego. Punkt wejścia „{0}” został zignorowany.</value>
  </data>
  <data name="ERR_NullableCharNotSupported" xml:space="preserve">
    <value>Tutaj nie można użyć znaku „?”.</value>
  </data>
  <data name="ERR_MissingEndEvent" xml:space="preserve">
    <value>Element „Custom Event” musi być zakończony odpowiadającym mu elementem „End Event”.</value>
  </data>
  <data name="ERR_MissingEndBrack" xml:space="preserve">
    <value>Identyfikator ujęty w nawiasy kwadratowe nie ma nawiasu zamykającego ].</value>
  </data>
  <data name="ERR_AmbiguousCastConversion2" xml:space="preserve">
    <value>Ustawienie Option Strict On nie zezwala na niejawne konwersje z elementu „{0}” na „{1}”, ponieważ konwersja jest niejednoznaczna.</value>
  </data>
  <data name="ERR_BadDelegateFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji Delegate.</value>
  </data>
  <data name="WRN_VarianceIEnumerableSuggestion3_Title" xml:space="preserve">
    <value>Nie można przekonwertować typu na docelowy typ kolekcji</value>
  </data>
  <data name="WRN_PrefixAndXmlnsLocalName_Title" xml:space="preserve">
    <value>Zaleca się, aby atrybuty nie miały nazwy xmlns</value>
  </data>
  <data name="ERR_BadAttributeNonPublicConstructor" xml:space="preserve">
    <value>Nie można użyć atrybutu, ponieważ nie ma on konstruktora Public.</value>
  </data>
  <data name="ERR_BadAttributeNonPublicProperty1" xml:space="preserve">
    <value>Element członkowski atrybutu „{0}” nie może być elementem docelowym przypisania, ponieważ nie jest zadeklarowany jako „Public”.</value>
  </data>
  <data name="ERR_FileNotFound" xml:space="preserve">
    <value>nie znaleziono pliku „{0}”</value>
  </data>
  <data name="ERR_ArgumentNarrowing3" xml:space="preserve">
    <value>Argument odpowiadający parametrowi „{0}” zawęża element „{1}” do „{2}”.</value>
  </data>
  <data name="ERR_ArgumentNarrowing2" xml:space="preserve">
    <value>Parametr pasujący do argumentu „{0}” zawęża element do „{1}”.</value>
  </data>
  <data name="ERR_AnonymousTypeFieldNameInference" xml:space="preserve">
    <value>Nazwę elementu członkowskiego typu anonimowego można wywnioskować tylko na podstawie prostej lub kwalifikowanej nazwy bez argumentów.</value>
  </data>
  <data name="WRN_LiftControlVariableLambda_Title" xml:space="preserve">
    <value>Użycie zmiennej iteracji w wyrażeniu lambda może mieć nieoczekiwane skutki</value>
  </data>
  <data name="ERR_NoSuitableNewForNewConstraint2" xml:space="preserve">
    <value>Argument typu „{0}” musi mieć publiczny konstruktor wystąpienia bez parametrów, aby spełniać ograniczenie „New” dla parametru typu „{1}”.</value>
  </data>
  <data name="ERR_LbBadElseif" xml:space="preserve">
    <value>Element „#ElseIf” musi być poprzedzony odpowiadającym mu elementem „#If” lub „#ElseIf”.</value>
  </data>
  <data name="ERR_PrincipalPermissionInvalidAction" xml:space="preserve">
    <value>Wartość SecurityAction „{0}” jest niepoprawna dla atrybutu PrincipalPermission.</value>
  </data>
  <data name="ERR_AsNewArray" xml:space="preserve">
    <value>Nie można deklarować tablic przy użyciu instrukcji New.</value>
  </data>
  <data name="AssociatedTypeDoesNotHaveTypeParameters" xml:space="preserve">
    <value>Skojarzony typ nie zawiera parametrów typu</value>
  </data>
  <data name="ERR_InitializerTooFewElements1" xml:space="preserve">
    <value>W inicjatorze tablicy brak następującej liczby elementów: {0}.</value>
  </data>
  <data name="ERR_NewIfNullOnNonClass" xml:space="preserve">
    <value>Nie można użyć instrukcji New w interfejsie.</value>
  </data>
  <data name="ERR_MultipleParameterSpecifiers" xml:space="preserve">
    <value>Nie można łączyć elementów „ByVal” i „ByRef”.</value>
  </data>
  <data name="ERR_ExpectedQueryableSource" xml:space="preserve">
    <value>Wyrażenie typu „{0}” nie umożliwia formułowania zapytań. Upewnij się, że nie brakuje odwołania do zestawu i/lub importu przestrzeni nazw dla dostawcy LINQ.</value>
  </data>
  <data name="ERR_AnonymousTypePropertyOutOfOrder1" xml:space="preserve">
    <value>Nie można użyć właściwości elementu członkowskiego typu anonimowego „{0}” do wywnioskowania typu innej właściwości elementu członkowskiego, ponieważ typ elementu „{0}” nie jest jeszcze ustalony.</value>
  </data>
  <data name="ERR_SynthMemberClashesWithMember5" xml:space="preserve">
    <value>Element {0} „{1}” niejawnie definiuje element „{2}”, który powoduje konflikt z elementem członkowskim o tej samej nazwie w elemencie {3} „{4}”.</value>
  </data>
  <data name="ERR_InvalidAttributeValue1" xml:space="preserve">
    <value>Wartość atrybutu jest nieprawidłowa, oczekiwano „{0}”.</value>
  </data>
  <data name="ERR_InvalidAttributeValue2" xml:space="preserve">
    <value>Wartość atrybutu jest nieprawidłowa, oczekiwano „{0}” lub „{1}”.</value>
  </data>
  <data name="WRN_AssemblyAttributeFromModuleIsOverridden_Title" xml:space="preserve">
    <value>Atrybut z modułu zostanie zignorowany na rzecz wystąpienia ze źródła</value>
  </data>
  <data name="ERR_NoSourcesOut" xml:space="preserve">
    <value>nie można wywnioskować nazwy pliku wyjściowego na podstawie plików wejściowych zawierających tylko zasoby; podaj opcję „/out”</value>
  </data>
  <data name="ERR_ShadowingGenericParamWithMember1" xml:space="preserve">
    <value>Element „{0}” ma taką samą nazwę jak parametr typu.</value>
  </data>
  <data name="ERR_CantReferToMyGroupInsideGroupType1" xml:space="preserve">
    <value>Element „{0}” nie może odwoływać się do siebie samego za pomocą domyślnego wystąpienia; zamiast tego użyj konstrukcji „Me”.</value>
  </data>
  <data name="WRN_ObjectMath1Not" xml:space="preserve">
    <value>Argumenty operacji typu Object użyte dla operatora „{0}”; użyj operatora „IsNot”, aby sprawdzić tożsamość obiektu.</value>
  </data>
  <data name="ERR_MyGroupCollectionAttributeCycle" xml:space="preserve">
    <value>Atrybut MyGroupCollectionAttribute nie może zostać zastosowany do siebie samego.</value>
  </data>
  <data name="ERR_IntegralToCharTypeMismatch1" xml:space="preserve">
    <value>Nie można konwertować wartości „{0}” na elementy „Char”. Użyj elementu „Microsoft.VisualBasic.ChrW”, aby zinterpretować wartość numeryczną jako znak Unicode, lub najpierw przekonwertuj ją na typ „String”, aby otrzymać cyfrę.</value>
  </data>
  <data name="ERR_BadRefLib1" xml:space="preserve">
    <value>Nie można załadować określonej w odwołaniu biblioteki „{0}”: {1}</value>
  </data>
  <data name="ERR_IllegalXmlNameChar" xml:space="preserve">
    <value>Znak „{0}” ({1}) jest niedozwolony w nazwie XML.</value>
  </data>
  <data name="FEATURE_BinaryLiterals" xml:space="preserve">
    <value>literały binarne</value>
  </data>
  <data name="ERR_EndExternalSource" xml:space="preserve">
    <value>Dyrektywa #End ExternalSource musi być poprzedzona odpowiadającą jej dyrektywą #ExternalSource.</value>
  </data>
  <data name="ERR_CantUseRequiredAttribute" xml:space="preserve">
    <value>Atrybut RequiredAttribute nie jest dozwolony w typach programu Visual Basic.</value>
  </data>
  <data name="ERR_ForEachCollectionDesignPattern1" xml:space="preserve">
    <value>Wyrażenie jest typu „{0}”, który nie jest typem kolekcji.</value>
  </data>
  <data name="ERR_NestedFunctionArgumentNarrowing3" xml:space="preserve">
    <value>Typ zwracany funkcji zagnieżdżonej pasującej do parametru „{0}” zawęża się od „{1}” do „{2}”.</value>
  </data>
  <data name="ERR_VarianceTypeDisallowed2" xml:space="preserve">
    <value>Typ „{0}” nie może zostać użyty w tym kontekście, ponieważ zarówno kontekst, jak i definicja „{0}” są zagnieżdżone w obrębie interfejsu „{1}”, a „{1}” ma parametry typu „In” lub „Out”. Rozważ przeniesienie definicji „{0}” poza interfejs „{1}”.</value>
  </data>
  <data name="ERR_BadDeclareFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w elemencie Declare</value>
  </data>
  <data name="ERR_DeclaresCantBeInGeneric" xml:space="preserve">
    <value>Instrukcje „Declare” nie są dozwolone w typach ogólnych ani typach zawartych w typach ogólnych.</value>
  </data>
  <data name="ERR_CannotOverrideInAccessibleMember" xml:space="preserve">
    <value>Element „{0}” nie może przesłaniać elementu „{1}”, ponieważ nie jest on dostępny w tym kontekście.</value>
  </data>
  <data name="ERR_ExpectedEndExternalSource" xml:space="preserve">
    <value>Dyrektywa #ExternalSource musi być zakończona odpowiadającą jej dyrektywą #End ExternalSource.</value>
  </data>
  <data name="FunctionSyntaxNotWithinSyntaxTree" xml:space="preserve">
    <value>Element FunctionSyntax nie znajduje się w obrębie drzewa składni</value>
  </data>
  <data name="WRN_DefAsgNoRetValOpRef1_Title" xml:space="preserve">
    <value>Operator nie zwraca wartości we wszystkich ścieżkach kodu</value>
  </data>
  <data name="WRN_ProcTypeNotCLSCompliant1" xml:space="preserve">
    <value>Zwracany typ funkcji „{0}” jest niezgodny ze specyfikacją CLS.</value>
  </data>
  <data name="ERR_DuplicateLocals1" xml:space="preserve">
    <value>Zmienna lokalna „{0}” jest już zadeklarowana w bieżącym bloku.</value>
  </data>
  <data name="ERR_FriendRefNotEqualToThis" xml:space="preserve">
    <value>Dostęp do przyjaznego zestawu został udzielony przez „{0}”, ale klucz publiczny zestawu wyjściowego nie jest zgodny z kluczem określonym przez atrybut w zestawie udzielającym dostępu.</value>
  </data>
  <data name="WRN_MustOverride2_Title" xml:space="preserve">
    <value>Element członkowski zasłania metodę z możliwością przeciążenia zadeklarowaną w typie podstawowym</value>
  </data>
  <data name="ERR_BadReturnValueInIterator" xml:space="preserve">
    <value>Aby była zwracana wartość z funkcji iteracyjnej, zamiast instrukcji „Return” należy użyć instrukcji „Yield”.</value>
  </data>
  <data name="WRN_MustOverloadBase4" xml:space="preserve">
    <value>Element {0} „{1}” zasłania element członkowski, który może zostać przeciążony i jest zadeklarowany w podstawowym elemencie {2} „{3}”. Aby można było przeciążyć metodę podstawową, ta metoda musi być zadeklarowana jako „Overloads”.</value>
  </data>
  <data name="ERR_STAThreadAndMTAThread0" xml:space="preserve">
    <value>Nie można zastosować elementów System.STAThreadAttribute i System.MTAThreadAttribute do tej samej metody.</value>
  </data>
  <data name="WRN_InvalidAssemblyName_Title" xml:space="preserve">
    <value>Odwołanie do zestawu jest nieprawidłowe i nie można go rozpoznać</value>
  </data>
  <data name="ERR_ImplementsWithConstraintMismatch3" xml:space="preserve">
    <value>Element „{0}” nie może implementować elementu „{1}.{2}”, ponieważ różnią się one ograniczeniami parametrów typu.</value>
  </data>
  <data name="WRN_LambdaNoTypeObjectAssumed" xml:space="preserve">
    <value>Nie można wywnioskować zwracanego typu; przyjęto „Object”.</value>
  </data>
  <data name="WRN_RecursivePropertyCall_Title" xml:space="preserve">
    <value>Wyrażenie rekursywnie wywołuje zawierającą je właściwość</value>
  </data>
  <data name="ERR_AccessMismatchOutsideAssembly4" xml:space="preserve">
    <value>Element „{0}” nie może ujawnić typu „{1}” poza projektem za pomocą elementu {2} „{3}”.</value>
  </data>
  <data name="WRN_XMLDocInvalidXMLFragment" xml:space="preserve">
    <value>Nie można dołączyć fragmentu XML „{0}” pliku „{1}”.</value>
  </data>
  <data name="ERR_InvalidTypeForAliasesImport2" xml:space="preserve">
    <value>Element „{1}” dla aliasu Imports elementu „{0}” nie odwołuje się do elementu Namespace, Class, Structure, Interface, Enum lub Module.</value>
  </data>
  <data name="ERR_CannotCallEvent1" xml:space="preserve">
    <value>Element „{0}” jest zdarzeniem i nie można go wywołać bezpośrednio. Użyj instrukcji „RaiseEvent”, aby wywołać zdarzenie.</value>
  </data>
  <data name="ERR_MultiplyDefined1" xml:space="preserve">
    <value>Etykieta „{0}” jest już zdefiniowana w bieżącej metodzie.</value>
  </data>
  <data name="ERR_EndUsingWithoutUsing" xml:space="preserve">
    <value>Element „End Using” musi być poprzedzony odpowiadającym mu elementem „Using”.</value>
  </data>
  <data name="ERR_DuplicateTypeParamName1" xml:space="preserve">
    <value>Zadeklarowano już parametr typu o nazwie „{0}”.</value>
  </data>
  <data name="ERR_InvalidLiteralExponent" xml:space="preserve">
    <value>Wykładnik nie jest prawidłowy.</value>
  </data>
  <data name="ERR_PartialTypeAccessMismatch3" xml:space="preserve">
    <value>Dostęp „{0}” określony dla elementu „{1}” nie jest zgodny z dostępem „{2}” określonym w jednym z jego innych typów częściowych.</value>
  </data>
  <data name="WRN_OptionalValueNotCLSCompliant1_Title" xml:space="preserve">
    <value>Typ opcjonalnej wartości parametru opcjonalnego jest niezgodny ze specyfikacją CLS</value>
  </data>
  <data name="ERR_FileAttributeNotAssemblyOrModule" xml:space="preserve">
    <value>Oczekiwano instrukcji Assembly lub Module.</value>
  </data>
  <data name="WRN_XMLDocBadGenericParamTag2" xml:space="preserve">
    <value>Parametr typu komentarza XML „{0}” nie jest zgodny z parametrem typu w odpowiedniej instrukcji „{1}”.</value>
  </data>
  <data name="ERR_MissingXmlEndTag" xml:space="preserve">
    <value>Brak tagu końcowego w elemencie.</value>
  </data>
  <data name="WRN_MissingAsClauseinVarDecl_Title" xml:space="preserve">
    <value>Deklaracja zmiennej bez klauzuli „As”</value>
  </data>
  <data name="ERR_BadInterfaceFlags1" xml:space="preserve">
    <value>Element „{0}” nie jest prawidłowy w deklaracji interfejsu.</value>
  </data>
  <data name="ERR_MultilineLambdaMissingSub" xml:space="preserve">
    <value>W wielowierszowym wyrażeniu lambda brakuje instrukcji „End Sub”.</value>
  </data>
  <data name="ERR_CantOverrideConstructor" xml:space="preserve">
    <value>Nie można zadeklarować elementu Sub New jako Overrides.</value>
  </data>
  <data name="ERR_UnboundTypeParam1" xml:space="preserve">
    <value>Nie można wywnioskować parametru typu „{0}”.</value>
  </data>
  <data name="ERR_UnboundTypeParam3" xml:space="preserve">
    <value>Nie można wywnioskować parametru typu „{0}” metody rozszerzenia „{1}” zdefiniowanej w elemencie „{2}”.</value>
  </data>
  <data name="ERR_UnboundTypeParam2" xml:space="preserve">
    <value>Nie można wywnioskować parametru typu „{0}” dla elementu „{1}”.</value>
  </data>
  <data name="WRN_IfNoTypeObjectAssumed_Title" xml:space="preserve">
    <value>Nie można wywnioskować wspólnego typu</value>
  </data>
  <data name="ERR_UseOfLocalBeforeDeclaration1" xml:space="preserve">
    <value>Nie można odwołać się do zmiennej lokalnej „{0}” przed jej zadeklarowaniem.</value>
  </data>
  <data name="ERR_ConversionFromBaseType" xml:space="preserve">
    <value>Operatory konwersji nie mogą konwertować z typu podstawowego.</value>
  </data>
  <data name="ERR_ExpectedRelational" xml:space="preserve">
    <value>Oczekiwano operatora relacyjnego.</value>
  </data>
  <data name="ERR_TypeDisallowsAttributes" xml:space="preserve">
    <value>Nie można wybierać atrybutów XML z typu „{0}”.</value>
  </data>
  <data name="WRN_ObjectAssumedProperty1_Title" xml:space="preserve">
    <value>Właściwość bez klauzuli „As”</value>
  </data>
</root>