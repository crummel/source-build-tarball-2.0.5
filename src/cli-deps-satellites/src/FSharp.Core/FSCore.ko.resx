<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="printfHashFormatSpecifierIllegal" xml:space="preserve">
    <value>F#에서는 # 서식 지정 한정자를 사용할 수 없습니다.</value>
  </data>
  <data name="invalidTupleTypeConstructorNotDefined" xml:space="preserve">
    <value>튜플 형식 '{0}'이(가) 잘못되었습니다. 필요한 생성자가 정의되지 않았습니다.</value>
  </data>
  <data name="syncContextNull" xml:space="preserve">
    <value>호출 스레드의 System.Threading.SynchronizationContext.Current가 null입니다.</value>
  </data>
  <data name="QtupleAccessOutOfRange" xml:space="preserve">
    <value>튜플 액세스가 범위를 벗어났습니다.</value>
  </data>
  <data name="unsupportedQueryCall" xml:space="preserve">
    <value>올바른 쿼리 식이 아닙니다. '{0}' 메서드가 쿼리에 사용되었지만 F#-to-LINQ 쿼리 변환기에서 인식할 수 없습니다. 허용되는 쿼리의 사양을 확인하고 일부 연산을 쿼리 식 외부로 이동하십시오.</value>
  </data>
  <data name="QfailedToBindTypeInAssembly" xml:space="preserve">
    <value>'{1}' 어셈블리의 '{0}' 형식을 바인딩하지 못했습니다.</value>
  </data>
  <data name="badFormatString" xml:space="preserve">
    <value>입력 문자열의 형식이 잘못되었습니다.</value>
  </data>
  <data name="QincorrectInstanceType" xml:space="preserve">
    <value>인스턴스 형식이 잘못되었습니다.</value>
  </data>
  <data name="QcannotBindFunction" xml:space="preserve">
    <value>{1} 형식의 {0} 함수를 바인딩할 수 없습니다.</value>
  </data>
  <data name="QfailedToBindField" xml:space="preserve">
    <value>'{0}' 필드를 바인딩하지 못했습니다.</value>
  </data>
  <data name="printfPrecisonSpecifierIllegal" xml:space="preserve">
    <value>잘못된 형식 지정자(전체 자릿수)</value>
  </data>
  <data name="nullsNotAllowedInArray" xml:space="preserve">
    <value>배열에 있는 요소 중 하나가 null입니다.</value>
  </data>
  <data name="firstClassUsesOfSplice" xml:space="preserve">
    <value>'%' 또는 '%%'의 첫 번째 클래스를 사용할 수 없습니다.</value>
  </data>
  <data name="QtmmCondMustBeBool" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 조건식이 부울 형식이어야 합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="unsupportedQueryProperty" xml:space="preserve">
    <value>올바른 쿼리 식이 아닙니다. '{0}' 속성이 쿼리에 사용되었지만 F#-to-LINQ 쿼리 변환기에서 인식할 수 없습니다. 허용되는 쿼리의 사양을 확인하고 일부 연산을 쿼리 식 외부로 이동하십시오.</value>
  </data>
  <data name="QtmmVarTypeNotMatchRHS" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 변수 형식이 let 바인딩의 오른쪽 형식과 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QcannotBindProperty" xml:space="preserve">
    <value>{1} 형식의 {0} 속성을 바인딩할 수 없습니다.</value>
  </data>
  <data name="inputMustBeNonNegative" xml:space="preserve">
    <value>입력은 음수가 아니어야 합니다.</value>
  </data>
  <data name="objIsNotARecord" xml:space="preserve">
    <value>개체가 F# 레코드 값이 아닙니다.</value>
  </data>
  <data name="QparentCannotBeNull" xml:space="preserve">
    <value>부모 형식은 null일 수 없습니다.</value>
  </data>
  <data name="keyNotFoundAlt" xml:space="preserve">
    <value>컬렉션에서 조건자를 만족하는 인덱스를 찾을 수 없습니다.</value>
  </data>
  <data name="keyNotFound" xml:space="preserve">
    <value>컬렉션에서 항목, 키 또는 인덱스를 찾을 수 없습니다.</value>
  </data>
  <data name="mailboxReceiveTimedOut" xml:space="preserve">
    <value>Mailbox.Receive 시간이 초과되었습니다.</value>
  </data>
  <data name="startCannotBeNaN" xml:space="preserve">
    <value>범위의 시작은 NaN일 수 없습니다.</value>
  </data>
  <data name="QincompatibleRecordLength" xml:space="preserve">
    <value>호환되지 않는 레코드 길이입니다.</value>
  </data>
  <data name="QtmmExprTypeMismatch" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 식의 형식이 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="checkStaticInit" xml:space="preserve">
    <value>파일 또는 유형을 정적으로 초기화한 결과 정적 데이터가 완전히 초기화되기 전에 재귀적으로 액세스되고 있습니다.</value>
  </data>
  <data name="notEnoughElements" xml:space="preserve">
    <value>입력 시퀀스의 요소 수가 부족합니다.</value>
  </data>
  <data name="moveNextNotCalledOrFinished" xml:space="preserve">
    <value>MoveNext가 호출되지 않았거나 완료되었습니다.</value>
  </data>
  <data name="QtmmFunctionArgTypeMismatch" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 함수 인수 형식이 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QmissingUnionCase" xml:space="preserve">
    <value>'{0}' 형식에 이름이 '{1}'인 F# 공용 구조체 케이스가 없습니다.</value>
  </data>
  <data name="QtmmRaw" xml:space="preserve">
    <value>식을 따옴표로 묶인 리터럴로 스플라이스하는 동안 형식 불일치 문제가 발생했습니다. 삽입 중인 식 트리의 형식이 스플라이스 작업에 필요한 형식과 일치하지 않습니다. '{0}'이(가) 필요한데 '{1}'을(를) 수신했습니다. (%% x : {0}) 또는 (%x : {0})과 같이 필요한 식 형식으로 형식 주석 처리하십시오.</value>
  </data>
  <data name="privateRecordType" xml:space="preserve">
    <value>'{0}' 형식은 F# 레코드 형식인데 표현은 전용입니다. 전용 형식 표현에 액세스하려면 BindingFlags.NonPublic을 지정해야 합니다.</value>
  </data>
  <data name="unsupportedQueryConstructKind" xml:space="preserve">
    <value>올바른 쿼리 식이 아닙니다. '{0}' 구문이 쿼리에 사용되었지만 F#-to-LINQ 쿼리 변환기에서 인식할 수 없습니다. 허용되는 쿼리의 사양을 확인하고 일부 연산을 쿼리 식 외부로 이동하십시오.</value>
  </data>
  <data name="enumerationPastIntMaxValue" xml:space="preserve">
    <value>System.Int32를 기반으로 하는 열거형이 System.Int32.MaxValue를 초과했습니다.</value>
  </data>
  <data name="QfailedToBindProperty" xml:space="preserve">
    <value>'{0}' 속성을 바인딩하지 못했습니다.</value>
  </data>
  <data name="stepCannotBeZero" xml:space="preserve">
    <value>범위의 단계는 0일 수 없습니다.</value>
  </data>
  <data name="addressOpNotFirstClass" xml:space="preserve">
    <value>address-of 연산자의 첫 번째 클래스 사용은 허용되지 않습니다.</value>
  </data>
  <data name="notARecordType" xml:space="preserve">
    <value>'{0}' 형식은 F# 레코드 형식이 아닙니다.</value>
  </data>
  <data name="dyInvDivByIntCoerce" xml:space="preserve">
    <value>강제 변환과 관련된 DivideByInt의 동적 호출이 지원되지 않습니다.</value>
  </data>
  <data name="arraysHadDifferentLengths" xml:space="preserve">
    <value>배열의 길이가 서로 다릅니다.</value>
  </data>
  <data name="QtmmInitArray" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 이니셜라이저가 배열 형식과 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="delegateExpected" xml:space="preserve">
    <value>대리자 형식이 필요합니다.</value>
  </data>
  <data name="QtmmTrueAndFalseMustMatch" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. True 및 False 분기의 형식이 서로 다릅니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="genericCompareFail1" xml:space="preserve">
    <value>제네릭 비교 중에 오류가 발생했습니다. '{0}' 형식은 System.IComparable 인터페이스를 구현하지 않습니다. 이 오류는 키에 이 형식의 인스턴스가 포함된 'Set' 또는 'Map' 등의 데이터 구조나 'compare', 'max' 또는 'min' 등의 함수 사용으로 인해 발생할 수 있습니다.</value>
  </data>
  <data name="QunexpectedHole" xml:space="preserve">
    <value>식에 예기치 않은 인용 오류가 있습니다.</value>
  </data>
  <data name="outOfRange" xml:space="preserve">
    <value>인덱스가 올바른 범위를 벗어났습니다.</value>
  </data>
  <data name="printfExpectedPrecision" xml:space="preserve">
    <value>전체 자릿수 인수가 필요합니다.</value>
  </data>
  <data name="stepCannotBeNaN" xml:space="preserve">
    <value>범위의 단계는 NaN일 수 없습니다.</value>
  </data>
  <data name="arrayWasEmpty" xml:space="preserve">
    <value>입력 배열이 비어 있습니다.</value>
  </data>
  <data name="QstaticWithReceiverObject" xml:space="preserve">
    <value>멤버가 정적이므로 수신기 개체는 필요하지 않습니다.</value>
  </data>
  <data name="inputSequenceTooLong" xml:space="preserve">
    <value>입력 시퀀스에 요소가 두 개 이상 있습니다.</value>
  </data>
  <data name="setContainsNoElements" xml:space="preserve">
    <value>집합에 요소가 없습니다.</value>
  </data>
  <data name="QtmmExprHasWrongType" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 식에 잘못된 형식이 있습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QexpectedTwoTypes" xml:space="preserve">
    <value>정확히 형식 인수 두 개만 필요합니다.</value>
  </data>
  <data name="QtmmBadFieldType" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 필드의 형식이 잘못되었습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="checkInit" xml:space="preserve">
    <value>개체 또는 값을 초기화한 결과 해당 개체 또는 값이 완전히 초기화되기 전에 재귀적으로 액세스되고 있습니다.</value>
  </data>
  <data name="invalidRecordTypeConstructorNotDefined" xml:space="preserve">
    <value>레코드 형식 '{0}'이(가) 잘못되었습니다. 필요한 생성자가 정의되지 않았습니다.</value>
  </data>
  <data name="mailboxProcessorPostAndAsyncReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndAsyncReply 시간이 초과되었습니다.</value>
  </data>
  <data name="QfailedToBindAssembly" xml:space="preserve">
    <value>인용 데이터를 처리하는 동안 '{0}' 어셈블리를 바인딩하지 못했습니다.</value>
  </data>
  <data name="printfWidthSpecifierIllegal" xml:space="preserve">
    <value>잘못된 형식 지정자(너비)</value>
  </data>
  <data name="dyInvOpMultCoerce" xml:space="preserve">
    <value>강제 변환과 관련된 op_Multiply의 동적 호출이 지원되지 않습니다.</value>
  </data>
  <data name="QincorrectNumArgs" xml:space="preserve">
    <value>인수 개수가 잘못되었습니다.</value>
  </data>
  <data name="matchCasesIncomplete" xml:space="preserve">
    <value>일치하는 케이스가 완전하지 않습니다.</value>
  </data>
  <data name="mismatchIAREnd" xml:space="preserve">
    <value>제공된 IAsyncResult 개체가 이 '종료' 작업과 일치하지 않습니다.</value>
  </data>
  <data name="inputSequenceEmpty" xml:space="preserve">
    <value>입력 시퀀스가 비어 있습니다.</value>
  </data>
  <data name="QinvalidFuncType" xml:space="preserve">
    <value>함수 형식이 잘못되었습니다.</value>
  </data>
  <data name="mismatchIARCancel" xml:space="preserve">
    <value>제공된 IAsyncResult 개체가 이 '취소' 작업과 일치하지 않습니다.</value>
  </data>
  <data name="invalidTupleTypes" xml:space="preserve">
    <value>F# 리플렉션 라이브러리에 대한 올바른 튜플 형식이 아닙니다.</value>
  </data>
  <data name="thenByError" xml:space="preserve">
    <value>'thenBy' 및 'thenByDescending'은 순서가 지정된 입력에서만 사용할 수 있습니다.</value>
  </data>
  <data name="notUsedForHashing" xml:space="preserve">
    <value>이 개체는 재귀 동등 호출용이므로 해시용으로 사용할 수 없습니다.</value>
  </data>
  <data name="resetNotSupported" xml:space="preserve">
    <value>다시 설정은 이 열거자에서 지원되지 않습니다.</value>
  </data>
  <data name="QwritingGetOnly" xml:space="preserve">
    <value>get-only 속성을 쓰고 있습니다.</value>
  </data>
  <data name="enumerationAlreadyFinished" xml:space="preserve">
    <value>열거가 이미 완료되었습니다.</value>
  </data>
  <data name="QcannotTakeAddress" xml:space="preserve">
    <value>이 인용의 주소를 가져올 수 없습니다.</value>
  </data>
  <data name="QexpectedOneType" xml:space="preserve">
    <value>정확히 형식 인수 하나만 필요합니다.</value>
  </data>
  <data name="dyInvOpAddCoerce" xml:space="preserve">
    <value>강제 변환과 관련된 op_Addition의 동적 호출이 지원되지 않습니다.</value>
  </data>
  <data name="tupleIndexOutOfRange" xml:space="preserve">
    <value>튜플 인덱스 '{1}'이(가) 튜플 형식 '{0}'에 대한 범위를 벗어났습니다.</value>
  </data>
  <data name="printfExpectedWidth" xml:space="preserve">
    <value>너비 인수가 필요합니다.</value>
  </data>
  <data name="notAUnionType" xml:space="preserve">
    <value>'{0}' 형식은 F# 공용 구조체 형식이 아닙니다.</value>
  </data>
  <data name="QfailedToBindConstructor" xml:space="preserve">
    <value>생성자를 바인딩하지 못했습니다.</value>
  </data>
  <data name="QtmmLoopBodyMustBeLambdaTakingInteger" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. For 루프의 본문은 정수를 인수로 사용하는 람다여야 합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QincorrectType" xml:space="preserve">
    <value>형식이 잘못되었습니다.</value>
  </data>
  <data name="controlContinuationInvokedMultipleTimes" xml:space="preserve">
    <value>Async.FromContinuations에 의해 제공된 연속 작업이 여러 번 호출되었습니다.</value>
  </data>
  <data name="QtmmFunTypeNotMatchDelegate" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 함수 형식이 대리자 형식과 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="notAPermutation" xml:space="preserve">
    <value>함수가 순열을 계산하지 않습니다.</value>
  </data>
  <data name="printfMissingFormatSpecifier" xml:space="preserve">
    <value>서식 지정자가 없습니다.</value>
  </data>
  <data name="notATupleType" xml:space="preserve">
    <value>'{0}' 형식은 튜플 형식이 아닙니다.</value>
  </data>
  <data name="QtmmExprNotMatchTuple" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 식이 튜플 형식과 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QtmmBodyMustBeUnit" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 본문이 단위를 반환해야 합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="notComparable" xml:space="preserve">
    <value>두 개체의 형식이 다르므로 비교할 수 없습니다.</value>
  </data>
  <data name="ThisValueCannotBeMutated" xml:space="preserve">
    <value>이 값을 변경할 수 없습니다.</value>
  </data>
  <data name="unsupportedQueryConstruct" xml:space="preserve">
    <value>올바른 쿼리 식이 아닙니다. 다음 생성자가 쿼리에 사용되었지만 F#-to-LINQ 쿼리 변환기에서 인식할 수 없습니다.\n{0}\n허용되는 쿼리의 사양을 확인하고 일부 연산을 쿼리 식 외부로 이동하십시오.</value>
  </data>
  <data name="multipleCompilationMappings" xml:space="preserve">
    <value>CompilationMappingAttributes가 여러 개입니다. 하나만 필요합니다.</value>
  </data>
  <data name="indexOutOfBounds" xml:space="preserve">
    <value>인덱스가 목록에서 요소의 범위를 벗어났습니다.</value>
  </data>
  <data name="printfSpecifierAfterIllegal" xml:space="preserve">
    <value>잘못된 형식 지정자({0} 이후)</value>
  </data>
  <data name="QnonStaticNoReceiverObject" xml:space="preserve">
    <value>멤버가 비정적(인스턴스)이지만 수신기 개체를 지정하지 않았습니다.</value>
  </data>
  <data name="QtmmIncorrectArgForUnion" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. F# 공용 구조체에 대한 인수 형식이 잘못되었습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QtupleLengthsDiffer" xml:space="preserve">
    <value>튜플 길이가 서로 다릅니다.</value>
  </data>
  <data name="notAFunctionType" xml:space="preserve">
    <value>'{0}' 형식은 함수 형식이 아닙니다.</value>
  </data>
  <data name="printfNotAFunType" xml:space="preserve">
    <value>함수 형식이 아닙니다.</value>
  </data>
  <data name="QwrongNumOfTypeArgs" xml:space="preserve">
    <value>'{0}' 메서드에는 {1} 형식 인수가 필요한데 {2}이(가) 제공되었습니다.</value>
  </data>
  <data name="mailboxProcessorAlreadyStarted" xml:space="preserve">
    <value>MailboxProcessor가 이미 시작되었습니다.</value>
  </data>
  <data name="dyInvOpAddOverload" xml:space="preserve">
    <value>오버로드와 관련된 op_Addition의 동적 호출이 지원되지 않습니다.</value>
  </data>
  <data name="privateExceptionType" xml:space="preserve">
    <value>'{0}' 형식은 F# 예외 선언의 표현인데 표현은 전용입니다. 전용 형식 표현에 액세스하려면 BindingFlags.NonPublic을 지정해야 합니다.</value>
  </data>
  <data name="privateUnionType" xml:space="preserve">
    <value>'{0}' 형식은 F# 공용 구조체 형식인데 표현은 전용입니다. 전용 형식 표현에 액세스하려면 BindingFlags.NonPublic을 지정해야 합니다.</value>
  </data>
  <data name="QtmmInvalidParam" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 메서드 또는 인덱서 속성에 대한 매개 변수가 잘못되었습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="mailboxProcessorPostAndReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndReply 시간이 초과되었습니다.</value>
  </data>
  <data name="printfBadFloatValue" xml:space="preserve">
    <value>float 값이 잘못되었습니다.</value>
  </data>
  <data name="inputListWasEmpty" xml:space="preserve">
    <value>입력 목록이 비어 있습니다.</value>
  </data>
  <data name="QtmmExpectedFunction" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 함수 응용 프로그램 또는 let 바인딩에 함수 형식이 필요합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="failDueToUnsupportedInputTypeInSumByOrAverageBy" xml:space="preserve">
    <value>쿼리에서 'sumBy' 또는 'averageBy' 연산자 사용을 인식할 수 없습니다. 원본 데이터가 정적 형식 IQueryable인 쿼리의 경우 결과 형식 int32, int64, single, double 또는 decimal에만 이러한 연산자를 사용할 수 있습니다.</value>
  </data>
  <data name="dyInvOpMultOverload" xml:space="preserve">
    <value>오버로드와 관련된 op_Multiply의 동적 호출이 지원되지 않습니다.</value>
  </data>
  <data name="QunrecognizedMethodCall" xml:space="preserve">
    <value>매개 변수는 인식할 수 없는 메서드 이름입니다.</value>
  </data>
  <data name="objIsNullAndNoType" xml:space="preserve">
    <value>개체가 null이며 형식이 지정되지 않았습니다. null이 아닌 개체 또는 null이 아닌 형식 매개 변수를 전달하십시오.</value>
  </data>
  <data name="QreadingSetOnly" xml:space="preserve">
    <value>set-only 속성을 읽고 있습니다.</value>
  </data>
  <data name="QtmmLowerUpperBoundMustBeInt" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 하한 및 상한은 정수여야 합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QunionNeedsDiffNumArgs" xml:space="preserve">
    <value>F# 공용 구조체 형식에 다른 개수의 인수가 필요합니다.</value>
  </data>
  <data name="constructorForUnionCaseNotFound" xml:space="preserve">
    <value>공용 구조체 케이스의 생성자 메서드 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="enumerationNotStarted" xml:space="preserve">
    <value>열거가 시작되지 않았습니다. MoveNext를 호출하십시오.</value>
  </data>
  <data name="optionValueWasNone" xml:space="preserve">
    <value>옵션 값이 None입니다.</value>
  </data>
  <data name="printfBadIntegerForDynamicFomatter" xml:space="preserve">
    <value>동적 포맷터에 제공된 정수가 잘못되었습니다.</value>
  </data>
  <data name="QtmmTuple" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 인수와 튜플 요소의 형식이 일치하지 않습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="QinvalidCaseIndex" xml:space="preserve">
    <value>올바른 F# 공용 구조체 케이스 인덱스가 아닙니다.</value>
  </data>
  <data name="inputMustBePositive" xml:space="preserve">
    <value>입력은 양수여야 합니다.</value>
  </data>
  <data name="mapCannotBeMutated" xml:space="preserve">
    <value>맵 값을 변경할 수 없습니다.</value>
  </data>
  <data name="QtmmIncorrectArgForRecord" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. F# 레코드에 대한 인수 형식이 잘못되었습니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="failedReadEnoughBytes" xml:space="preserve">
    <value>스트림에서 충분한 바이트를 읽지 못했습니다.</value>
  </data>
  <data name="endCannotBeNaN" xml:space="preserve">
    <value>범위의 끝은 NaN일 수 없습니다.</value>
  </data>
  <data name="QtmmGuardMustBeBool" xml:space="preserve">
    <value>'{0}'을(를) 작성하는 동안 형식 불일치 문제가 발생했습니다. 가드는 부울을 반환해야 합니다. '{1}'이(가) 필요한데 '{2}' 형식을 수신했습니다.</value>
  </data>
  <data name="noNegateMinValue" xml:space="preserve">
    <value>2의 보수 중 최소값 부정이 잘못되었습니다.</value>
  </data>
  <data name="QtypeArgumentOutOfRange" xml:space="preserve">
    <value>형식 인수가 범위를 벗어났습니다.</value>
  </data>
  <data name="mailboxScanTimedOut" xml:space="preserve">
    <value>Mailbox.Scan 시간이 초과되었습니다.</value>
  </data>
  <data name="QillFormedAppOrLet" xml:space="preserve">
    <value>잘못된 형식의 식: AppOp 또는 LetOp</value>
  </data>
  <data name="QmissingRecordField" xml:space="preserve">
    <value>'{0}' 형식에 이름이 '{1}'인 F# 레코드 필드가 없습니다.</value>
  </data>
  <data name="listsHadDifferentLengths" xml:space="preserve">
    <value>목록의 길이가 서로 다릅니다.</value>
  </data>
  <data name="QcannotBindToMethod" xml:space="preserve">
    <value>메서드에 바인딩할 수 없습니다.</value>
  </data>
  <data name="printfBadFormatSpecifier" xml:space="preserve">
    <value>잘못된 형식 지정자: {0}</value>
  </data>
  <data name="notAnExceptionType" xml:space="preserve">
    <value>'{0}' 형식은 F# 예외 선언의 표현이 아닙니다.</value>
  </data>
  <data name="nonZeroBasedDisallowed" xml:space="preserve">
    <value>이 플랫폼에서는 0부터 시작하지 않는 배열을 만들 수 없습니다.</value>
  </data>
  <data name="unsupportedIfThenElse" xml:space="preserve">
    <value>여러 분기가 포함된 if/then/else 조건식 또는 패턴 일치 식은 쿼리에 사용할 수 없습니다. if/then/else 조건문을 사용할 수 있습니다.</value>
  </data>
</root>