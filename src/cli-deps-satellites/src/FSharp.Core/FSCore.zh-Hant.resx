<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="printfHashFormatSpecifierIllegal" xml:space="preserve">
    <value># 格式修飾詞在 F# 中無效</value>
  </data>
  <data name="invalidTupleTypeConstructorNotDefined" xml:space="preserve">
    <value>元組型別 '{0}' 無效。未定義必要的建構函式。</value>
  </data>
  <data name="syncContextNull" xml:space="preserve">
    <value>呼叫執行緒的 System.Threading.SynchronizationContext.Current 為 null。</value>
  </data>
  <data name="QtupleAccessOutOfRange" xml:space="preserve">
    <value>元組存取超出範圍</value>
  </data>
  <data name="unsupportedQueryCall" xml:space="preserve">
    <value>這不是有效的查詢運算式。查詢中使用了方法 '{0}'，但 F#-to-LINQ 查詢翻譯工具無法加以辨認。請檢查所允許之查詢的規格，並考慮將一些運算移出查詢運算式</value>
  </data>
  <data name="QfailedToBindTypeInAssembly" xml:space="preserve">
    <value>無法繫結組件 '{1}' 中的類型 '{0}'</value>
  </data>
  <data name="badFormatString" xml:space="preserve">
    <value>輸入字串格式不正確。</value>
  </data>
  <data name="QincorrectInstanceType" xml:space="preserve">
    <value>不正確的執行個體類型</value>
  </data>
  <data name="QcannotBindFunction" xml:space="preserve">
    <value>無法繫結類型 {1} 中的函式 {0}</value>
  </data>
  <data name="QfailedToBindField" xml:space="preserve">
    <value>無法繫結欄位 '{0}'</value>
  </data>
  <data name="printfPrecisonSpecifierIllegal" xml:space="preserve">
    <value>不正確的格式修飾詞 (精確度)</value>
  </data>
  <data name="nullsNotAllowedInArray" xml:space="preserve">
    <value>陣列中的其中一個元素為 null。</value>
  </data>
  <data name="firstClassUsesOfSplice" xml:space="preserve">
    <value>不允許優先使用 '%' 或 '%%'</value>
  </data>
  <data name="QtmmCondMustBeBool" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 條件運算式的類型必須是布林。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="unsupportedQueryProperty" xml:space="preserve">
    <value>這不是有效的查詢運算式。查詢中使用了屬性 '{0}'，但 F#-to-LINQ 查詢翻譯工具無法加以辨認。請檢查所允許之查詢的規格，並考慮將一些運算移出查詢運算式。</value>
  </data>
  <data name="QtmmVarTypeNotMatchRHS" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 變數類型與 let 繫結右手邊的類型不相符。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QcannotBindProperty" xml:space="preserve">
    <value>無法繫結類型 {1} 中的屬性 {0}</value>
  </data>
  <data name="inputMustBeNonNegative" xml:space="preserve">
    <value>輸入必須是非負數。</value>
  </data>
  <data name="objIsNotARecord" xml:space="preserve">
    <value>這個物件不是 F# 記錄值。</value>
  </data>
  <data name="QparentCannotBeNull" xml:space="preserve">
    <value>父類型不能為 null</value>
  </data>
  <data name="keyNotFoundAlt" xml:space="preserve">
    <value>在集合中找不到符合述詞的索引。</value>
  </data>
  <data name="keyNotFound" xml:space="preserve">
    <value>在集合中找不到項目、索引鍵或索引。</value>
  </data>
  <data name="mailboxReceiveTimedOut" xml:space="preserve">
    <value>Mailbox.Receive 逾時。</value>
  </data>
  <data name="startCannotBeNaN" xml:space="preserve">
    <value>範圍開頭不能是 NaN。</value>
  </data>
  <data name="QincompatibleRecordLength" xml:space="preserve">
    <value>不完整的記錄長度</value>
  </data>
  <data name="QtmmExprTypeMismatch" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 運算式的類型不相符。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="checkStaticInit" xml:space="preserve">
    <value>檔案或類型的靜態初始化造成靜態資料未完全初始化之前就被遞迴存取。</value>
  </data>
  <data name="notEnoughElements" xml:space="preserve">
    <value>輸入序列的項目數目不足。</value>
  </data>
  <data name="moveNextNotCalledOrFinished" xml:space="preserve">
    <value>MoveNext 未呼叫或完成</value>
  </data>
  <data name="QtmmFunctionArgTypeMismatch" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 函式引數類型不相符。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QmissingUnionCase" xml:space="preserve">
    <value>類型 '{0}' 沒有名為 '{1}' 的 F# 聯集。</value>
  </data>
  <data name="QtmmRaw" xml:space="preserve">
    <value>將運算式接合成引號常值時發生類型不符的情況。所插入運算式樹狀結構的類型不符合接合運算預期的類型。必須是 '{0}'，但卻收到類型 '{1}'。請考慮以預期的運算式類型標註類型，例如 (%% x : {0}) 或 (%x : {0})。</value>
  </data>
  <data name="privateRecordType" xml:space="preserve">
    <value>類型 '{0}' 是 F# 記錄類型，但其表示是私用的。您必須指定 BindingFlags.NonPublic，才能存取私用類型表示。</value>
  </data>
  <data name="unsupportedQueryConstructKind" xml:space="preserve">
    <value>這不是有效的查詢運算式。查詢中使用了建構 '{0}'，但 F#-to-LINQ 查詢翻譯工具無法加以辨認。請檢查所允許之查詢的規格，並考慮將一些運算移出查詢運算式。</value>
  </data>
  <data name="enumerationPastIntMaxValue" xml:space="preserve">
    <value>依 System.Int32 而定的列舉超過 System.Int32.MaxValue。</value>
  </data>
  <data name="QfailedToBindProperty" xml:space="preserve">
    <value>無法繫結屬性 '{0}'</value>
  </data>
  <data name="stepCannotBeZero" xml:space="preserve">
    <value>範圍步驟不能為零。</value>
  </data>
  <data name="addressOpNotFirstClass" xml:space="preserve">
    <value>不允許優先使用傳址運算子。</value>
  </data>
  <data name="notARecordType" xml:space="preserve">
    <value>類型 '{0}' 不是 F# 記錄類型。</value>
  </data>
  <data name="dyInvDivByIntCoerce" xml:space="preserve">
    <value>不支援與強制型轉相關的 DivideByInt 的動態引動過程。</value>
  </data>
  <data name="arraysHadDifferentLengths" xml:space="preserve">
    <value>陣列有不同的長度。</value>
  </data>
  <data name="QtmmInitArray" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 初始設定式與陣列類型不相符。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="delegateExpected" xml:space="preserve">
    <value>必須是委派類型。</value>
  </data>
  <data name="QtmmTrueAndFalseMustMatch" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: true 和 false 分支的類型不相同。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="genericCompareFail1" xml:space="preserve">
    <value>進行泛型比較期間失敗: 類型 '{0}' 未實作 System.IComparable 介面。這個錯誤可能是由使用的函式 (如 'compare'、'max' 或 'min') 或資料結構 (如 'Set' 或 'Map') 的索引鍵包含此類型的執行個體引起的。</value>
  </data>
  <data name="QunexpectedHole" xml:space="preserve">
    <value>運算式中有未預期的引號漏洞。</value>
  </data>
  <data name="outOfRange" xml:space="preserve">
    <value>索引在合法範圍之外。</value>
  </data>
  <data name="printfExpectedPrecision" xml:space="preserve">
    <value>必須是精確度引數</value>
  </data>
  <data name="stepCannotBeNaN" xml:space="preserve">
    <value>範圍步驟不能是 NaN。</value>
  </data>
  <data name="arrayWasEmpty" xml:space="preserve">
    <value>輸入陣列是空的。</value>
  </data>
  <data name="QstaticWithReceiverObject" xml:space="preserve">
    <value>不應有接收者物件，因為成員為靜態</value>
  </data>
  <data name="inputSequenceTooLong" xml:space="preserve">
    <value>輸入序列包含一個以上的項目。</value>
  </data>
  <data name="setContainsNoElements" xml:space="preserve">
    <value>Set 未包含項目。</value>
  </data>
  <data name="QtmmExprHasWrongType" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 運算式的類型錯誤。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QexpectedTwoTypes" xml:space="preserve">
    <value>只能有兩個類型引數。</value>
  </data>
  <data name="QtmmBadFieldType" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 欄位類型不正確。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="checkInit" xml:space="preserve">
    <value>物件或值的初始化造成物件或值未完全初始化之前就被遞迴存取。</value>
  </data>
  <data name="invalidRecordTypeConstructorNotDefined" xml:space="preserve">
    <value>記錄類型 '{0}' 無效。未定義必要的建構函式。</value>
  </data>
  <data name="mailboxProcessorPostAndAsyncReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndAsyncReply 逾時。</value>
  </data>
  <data name="QfailedToBindAssembly" xml:space="preserve">
    <value>處理引號資料時無法繫結到組件 '{0}'</value>
  </data>
  <data name="printfWidthSpecifierIllegal" xml:space="preserve">
    <value>不正確的格式規範 (寬度)</value>
  </data>
  <data name="dyInvOpMultCoerce" xml:space="preserve">
    <value>不支援與強制型轉相關的 op_Multiply 的動態引動過程。</value>
  </data>
  <data name="QincorrectNumArgs" xml:space="preserve">
    <value>不正確的引數數目</value>
  </data>
  <data name="matchCasesIncomplete" xml:space="preserve">
    <value>大小寫須相符不完整</value>
  </data>
  <data name="mismatchIAREnd" xml:space="preserve">
    <value>提供的 IAsyncResult 物件不符合此 'End' 作業。</value>
  </data>
  <data name="inputSequenceEmpty" xml:space="preserve">
    <value>輸入序列是空的。</value>
  </data>
  <data name="QinvalidFuncType" xml:space="preserve">
    <value>無效的函式類型</value>
  </data>
  <data name="thisValueCannotBeMutated" xml:space="preserve">
    <value>不能變更這個值</value>
  </data>
  <data name="mismatchIARCancel" xml:space="preserve">
    <value>提供的 IAsyncResult 物件不符合此 'Cancel' 作業。</value>
  </data>
  <data name="invalidTupleTypes" xml:space="preserve">
    <value>這不是 F# 反映庫的有效元組型別。</value>
  </data>
  <data name="thenByError" xml:space="preserve">
    <value>'thenBy' 和 'thenByDescending' 只能搭配已排序的輸入一起使用</value>
  </data>
  <data name="notUsedForHashing" xml:space="preserve">
    <value>這個物件用於遞迴等式呼叫，無法用於雜湊。</value>
  </data>
  <data name="resetNotSupported" xml:space="preserve">
    <value>此列舉程式不支援重設動作。</value>
  </data>
  <data name="QwritingGetOnly" xml:space="preserve">
    <value>寫入 get-only 屬性</value>
  </data>
  <data name="enumerationAlreadyFinished" xml:space="preserve">
    <value>列舉已完成。</value>
  </data>
  <data name="QcannotTakeAddress" xml:space="preserve">
    <value>無法取得此引號的位址</value>
  </data>
  <data name="QexpectedOneType" xml:space="preserve">
    <value>只能有一個型別引數。</value>
  </data>
  <data name="dyInvOpAddCoerce" xml:space="preserve">
    <value>不支援與強制型轉相關的 op_Addition 的動態引動過程。</value>
  </data>
  <data name="tupleIndexOutOfRange" xml:space="preserve">
    <value>元組索引 '{1}' 超出元組型別 '{0}' 的範圍。</value>
  </data>
  <data name="printfExpectedWidth" xml:space="preserve">
    <value>必須是寬度引數</value>
  </data>
  <data name="notAUnionType" xml:space="preserve">
    <value>型別 '{0}' 不是 F# 等位型別。</value>
  </data>
  <data name="QfailedToBindConstructor" xml:space="preserve">
    <value>無法繫結建構函式</value>
  </data>
  <data name="QtmmLoopBodyMustBeLambdaTakingInteger" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 迴圈主體必須是可接受整數當做引數的 Lambda。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QincorrectType" xml:space="preserve">
    <value>不正確的類型</value>
  </data>
  <data name="controlContinuationInvokedMultipleTimes" xml:space="preserve">
    <value>Async.FromContinuations 提供的接續部分已被多次叫用。</value>
  </data>
  <data name="QtmmFunTypeNotMatchDelegate" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 函式類型與委派類型不相符。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="notAPermutation" xml:space="preserve">
    <value>這個函式未計算排列。</value>
  </data>
  <data name="printfMissingFormatSpecifier" xml:space="preserve">
    <value>遺漏格式修飾詞</value>
  </data>
  <data name="notATupleType" xml:space="preserve">
    <value>型別 '{0}' 不是元組型別。</value>
  </data>
  <data name="QtmmExprNotMatchTuple" xml:space="preserve">
    <value>建置 '{0}' 時發生型別不符的情況: 運算式與元組型別不相符。必須是 '{1}'，但卻收到型別 '{2}'。</value>
  </data>
  <data name="QtmmBodyMustBeUnit" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 主體必須傳回單位。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="notComparable" xml:space="preserve">
    <value>兩個物件有不同的類型，無法進行計算。</value>
  </data>
  <data name="unsupportedQueryConstruct" xml:space="preserve">
    <value>這不是有效的查詢運算式。查詢中使用了下列建構，但 F#-to-LINQ 查詢翻譯工具無法加以辨認:\n{0}\n請檢查所允許之查詢的規格，並考慮將一些運算移出查詢運算式。</value>
  </data>
  <data name="multipleCompilationMappings" xml:space="preserve">
    <value>多個 CompilationMappingAttributes，但最多只允許一個</value>
  </data>
  <data name="indexOutOfBounds" xml:space="preserve">
    <value>索引在清單的項目範圍之外。</value>
  </data>
  <data name="printfSpecifierAfterIllegal" xml:space="preserve">
    <value>不正確的格式修飾詞 (在 {0} 之後)</value>
  </data>
  <data name="QnonStaticNoReceiverObject" xml:space="preserve">
    <value>成員為非靜態 (執行個體)，但未提供任何接收者物件</value>
  </data>
  <data name="QtmmIncorrectArgForUnion" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: F# 聯集的引數類型不正確。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QtupleLengthsDiffer" xml:space="preserve">
    <value>元組長度不相同</value>
  </data>
  <data name="notAFunctionType" xml:space="preserve">
    <value>類型 '{0}' 不是函式類型。</value>
  </data>
  <data name="printfNotAFunType" xml:space="preserve">
    <value>不是函式類型</value>
  </data>
  <data name="QwrongNumOfTypeArgs" xml:space="preserve">
    <value>方法 '{0}' 需要 {1} 型別引數，但提供的是 {2}</value>
  </data>
  <data name="mailboxProcessorAlreadyStarted" xml:space="preserve">
    <value>已經啟動 MailboxProcessor。</value>
  </data>
  <data name="dyInvOpAddOverload" xml:space="preserve">
    <value>不支援與多載相關的 op_Addition 的動態引動過程。</value>
  </data>
  <data name="privateExceptionType" xml:space="preserve">
    <value>類型 '{0}' 是 F# 例外狀況宣告的表示，但其表示是私用的。您必須指定 BindingFlags.NonPublic，才能存取私用類型表示。</value>
  </data>
  <data name="privateUnionType" xml:space="preserve">
    <value>型別 '{0}' 是 F# 等位型別，但其表示為私用。您必須指定 BindingFlags.NonPublic，才能存取私用型別表示。</value>
  </data>
  <data name="QtmmInvalidParam" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 方法或索引子屬性的參數無效。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="mailboxProcessorPostAndReplyTimedOut" xml:space="preserve">
    <value>MailboxProcessor.PostAndReply 逾時。</value>
  </data>
  <data name="printfBadFloatValue" xml:space="preserve">
    <value>不正確的浮點值</value>
  </data>
  <data name="inputListWasEmpty" xml:space="preserve">
    <value>輸入清單是空的。</value>
  </data>
  <data name="QtmmExpectedFunction" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 必須是函式應用程式或 let 繫結中的函式類型。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="failDueToUnsupportedInputTypeInSumByOrAverageBy" xml:space="preserve">
    <value>查詢中無法辨認的 'sumBy' 或 'averageBy' 運算子使用方式。在原始資料屬於靜態類型 IQueryable 的查詢中，這些運算子只能搭配結果類型 int32、int64、single、double 或 decimal 一起使用</value>
  </data>
  <data name="dyInvOpMultOverload" xml:space="preserve">
    <value>不支援與多載相關的 op_Multiply 的動態引動過程。</value>
  </data>
  <data name="QunrecognizedMethodCall" xml:space="preserve">
    <value>這個參數不是可辨識的方法名稱。</value>
  </data>
  <data name="objIsNullAndNoType" xml:space="preserve">
    <value>這個物件為 null，而且未指定任何型別。請傳遞一個非 null 物件或一個非 null 型別參數。</value>
  </data>
  <data name="QreadingSetOnly" xml:space="preserve">
    <value>讀取 set-only 屬性</value>
  </data>
  <data name="QtmmLowerUpperBoundMustBeInt" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 上下限必須是整數。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="QunionNeedsDiffNumArgs" xml:space="preserve">
    <value>F# 等位型別需要不同的引數數目</value>
  </data>
  <data name="constructorForUnionCaseNotFound" xml:space="preserve">
    <value>找不到聯集的建構函式方法 '{0}'</value>
  </data>
  <data name="enumerationNotStarted" xml:space="preserve">
    <value>尚未開始列舉。呼叫 MoveNext。</value>
  </data>
  <data name="optionValueWasNone" xml:space="preserve">
    <value>選項值為 None</value>
  </data>
  <data name="printfBadIntegerForDynamicFomatter" xml:space="preserve">
    <value>提供給動態格式子的整數錯誤</value>
  </data>
  <data name="QtmmTuple" xml:space="preserve">
    <value>建置 '{0}' 時發生型別不符的情況: 引數和元組項目的型別不相符。必須是 '{1}'，但卻收到型別 '{2}'。</value>
  </data>
  <data name="QinvalidCaseIndex" xml:space="preserve">
    <value>不是有效的 F# 聯集索引。</value>
  </data>
  <data name="inputMustBePositive" xml:space="preserve">
    <value>輸入必須是正數。</value>
  </data>
  <data name="mapCannotBeMutated" xml:space="preserve">
    <value>不能變更對應值。</value>
  </data>
  <data name="QtmmIncorrectArgForRecord" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: F# 記錄的引數類型不正確。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="failedReadEnoughBytes" xml:space="preserve">
    <value>無法從資料流讀取足夠的位元組。</value>
  </data>
  <data name="endCannotBeNaN" xml:space="preserve">
    <value>範圍結尾不能是 NaN。</value>
  </data>
  <data name="QtmmGuardMustBeBool" xml:space="preserve">
    <value>建置 '{0}' 時發生類型不符的情況: 成立條件必須傳回布林值。必須是 '{1}'，但卻收到類型 '{2}'。</value>
  </data>
  <data name="noNegateMinValue" xml:space="preserve">
    <value>對二進位補數的最小值取補數無效。</value>
  </data>
  <data name="QtypeArgumentOutOfRange" xml:space="preserve">
    <value>型別引數超出範圍</value>
  </data>
  <data name="mailboxScanTimedOut" xml:space="preserve">
    <value>Mailbox.Scan 逾時。</value>
  </data>
  <data name="QillFormedAppOrLet" xml:space="preserve">
    <value>格式不正確的運算式: AppOp 或 LetOp</value>
  </data>
  <data name="QmissingRecordField" xml:space="preserve">
    <value>類型 '{0}' 沒有名為 '{1}' 的 F# 記錄欄位。</value>
  </data>
  <data name="listsHadDifferentLengths" xml:space="preserve">
    <value>清單有不同的長度。</value>
  </data>
  <data name="QcannotBindToMethod" xml:space="preserve">
    <value>無法繫結至方法</value>
  </data>
  <data name="printfBadFormatSpecifier" xml:space="preserve">
    <value>不正確的格式規範: {0}</value>
  </data>
  <data name="notAnExceptionType" xml:space="preserve">
    <value>類型 '{0}' 不是 F# 例外狀況宣告的表示。</value>
  </data>
  <data name="nonZeroBasedDisallowed" xml:space="preserve">
    <value>在這個平台上無法建立以非零為起始的陣列。</value>
  </data>
  <data name="unsupportedIfThenElse" xml:space="preserve">
    <value>不允許在查詢中使用具有多個分支的 if/then/else 條件式或模式比對運算式。您可以使用 if/then/else 條件式。</value>
  </data>
</root>