<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="printfHashFormatSpecifierIllegal" xml:space="preserve">
    <value>O modificador de formatação # é inválido em F#</value>
  </data>
  <data name="invalidTupleTypeConstructorNotDefined" xml:space="preserve">
    <value>O tipo de tupla '{0}' é inválido. O construtor necessário não foi definido.</value>
  </data>
  <data name="syncContextNull" xml:space="preserve">
    <value>O System.Threading.SynchronizationContext.Current do thread de chamada é nulo.</value>
  </data>
  <data name="QtupleAccessOutOfRange" xml:space="preserve">
    <value>Acesso de tupla fora do intervalo</value>
  </data>
  <data name="unsupportedQueryCall" xml:space="preserve">
    <value>Expressão de consulta inválida. O método '{0}' foi usado em uma consulta, mas não é reconhecido pelo conversor de consultas F#-to-LINQ. Verifique a especificação de consultas permitidas e considere remover algumas das operações da expressão de consulta</value>
  </data>
  <data name="QfailedToBindTypeInAssembly" xml:space="preserve">
    <value>Falha ao associar o tipo '{0}' ao assembly '{1}'</value>
  </data>
  <data name="badFormatString" xml:space="preserve">
    <value>A cadeia de caracteres de entrada não estava em um formato correto.</value>
  </data>
  <data name="QincorrectInstanceType" xml:space="preserve">
    <value>Tipo de instância incorreto</value>
  </data>
  <data name="QcannotBindFunction" xml:space="preserve">
    <value>Não foi possível associar a função {0} ao tipo {1}</value>
  </data>
  <data name="QfailedToBindField" xml:space="preserve">
    <value>Falha ao associar o campo '{0}'</value>
  </data>
  <data name="printfPrecisonSpecifierIllegal" xml:space="preserve">
    <value>Especificador de formato incorreto (precisão)</value>
  </data>
  <data name="nullsNotAllowedInArray" xml:space="preserve">
    <value>Um dos elementos na matriz é nulo.</value>
  </data>
  <data name="firstClassUsesOfSplice" xml:space="preserve">
    <value>usos de '%' ou '%%' de primeira classe não são permitidos</value>
  </data>
  <data name="QtmmCondMustBeBool" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': a expressão de condição deve ser do tipo booliana. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="unsupportedQueryProperty" xml:space="preserve">
    <value>Expressão de consulta inválida. A propriedade '{0}' foi usada em uma consulta, mas não é reconhecida pelo conversor de consultas F#-to-LINQ. Verifique a especificação de consultas permitidas e considere remover algumas das operações da expressão de consulta.</value>
  </data>
  <data name="QtmmVarTypeNotMatchRHS" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de variável incompatível com tipo do lado direito de uma associação let. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QcannotBindProperty" xml:space="preserve">
    <value>Não foi possível associar a propriedade {0} ao tipo {1}</value>
  </data>
  <data name="inputMustBeNonNegative" xml:space="preserve">
    <value>A entrada deve ser não negativa.</value>
  </data>
  <data name="objIsNotARecord" xml:space="preserve">
    <value>O objeto não é um valor de registro F#.</value>
  </data>
  <data name="QparentCannotBeNull" xml:space="preserve">
    <value>O tipo pai não pode ser nulo</value>
  </data>
  <data name="keyNotFoundAlt" xml:space="preserve">
    <value>Índice compatível com predicado não localizado na coleção.</value>
  </data>
  <data name="keyNotFound" xml:space="preserve">
    <value>Item, chave ou índice não localizado na coleção.</value>
  </data>
  <data name="mailboxReceiveTimedOut" xml:space="preserve">
    <value>Tempo limite de Mailbox.Receive esgotado.</value>
  </data>
  <data name="startCannotBeNaN" xml:space="preserve">
    <value>O início de um intervalo não pode ser NaN.</value>
  </data>
  <data name="QincompatibleRecordLength" xml:space="preserve">
    <value>Tamanho de registro incompatível</value>
  </data>
  <data name="QtmmExprTypeMismatch" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipos de expressão incompatíveis. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="checkStaticInit" xml:space="preserve">
    <value>A inicialização estática de um arquivo ou tipo fez que dados estáticos fossem acessados recursivamente antes de serem totalmente inicializados.</value>
  </data>
  <data name="notEnoughElements" xml:space="preserve">
    <value>A sequência de entrada possui um número insuficiente de elementos.</value>
  </data>
  <data name="moveNextNotCalledOrFinished" xml:space="preserve">
    <value>MoveNext não chamado, ou concluído</value>
  </data>
  <data name="QtmmFunctionArgTypeMismatch" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de argumento de função incompatível. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QmissingUnionCase" xml:space="preserve">
    <value>O tipo '{0}' não tinha um caso união F# denominado '{1}'.</value>
  </data>
  <data name="QtmmRaw" xml:space="preserve">
    <value>Inconsistência de tipos ao unir expressão em literal de cotação. O tipo da árvore de expressões inserida não corresponde ao tipo esperado pela operação de união. Esperado '{0}', mas o tipo recebido foi '{1}'. Considere a anotação de tipo com o tipo de expressão esperado, por exemplo, (%% x : {0}) ou (%x : {0}).</value>
  </data>
  <data name="privateRecordType" xml:space="preserve">
    <value>O tipo '{0}' é um tipo de registro F#, mas sua representação é particular. É necessário especificar BindingFlags.NonPublic para acessar representações de tipo particular.</value>
  </data>
  <data name="unsupportedQueryConstructKind" xml:space="preserve">
    <value>Expressão de consulta inválida. A construção '{0}' foi usada em uma consulta, mas não é reconhecida pelo conversor de consultas F#-to-LINQ. Verifique a especificação de consultas permitidas e considere remover algumas das operações da expressão de consulta.</value>
  </data>
  <data name="enumerationPastIntMaxValue" xml:space="preserve">
    <value>A enumeração baseada em System.Int32 excedeu System.Int32.MaxValue.</value>
  </data>
  <data name="QfailedToBindProperty" xml:space="preserve">
    <value>Falha ao associar a propriedade '{0}'</value>
  </data>
  <data name="stepCannotBeZero" xml:space="preserve">
    <value>A etapa de um intervalo não pode ser zero.</value>
  </data>
  <data name="addressOpNotFirstClass" xml:space="preserve">
    <value>Usos de operadores address-of de primeira classe não são permitidos.</value>
  </data>
  <data name="notARecordType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de registro F#.</value>
  </data>
  <data name="dyInvDivByIntCoerce" xml:space="preserve">
    <value>Não há suporte para a invocação dinâmica de DivideByInt que envolve coerções.</value>
  </data>
  <data name="arraysHadDifferentLengths" xml:space="preserve">
    <value>As matrizes possuem tamanhos diferentes.</value>
  </data>
  <data name="QtmmInitArray" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': inicializador incompatível com tipo de matriz. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="delegateExpected" xml:space="preserve">
    <value>Esperando tipo delegate.</value>
  </data>
  <data name="QtmmTrueAndFalseMustMatch" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipos de ramificações true e false diferem. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="genericCompareFail1" xml:space="preserve">
    <value>Falha durante comparação genérica: o tipo '{0}' não implementa a interface System.IComparable. Este erro pode decorrer do uso de uma função, como 'compare', 'max' ou 'min', ou de uma estrutura de dados, como 'Set' ou 'Map', cujas chaves contêm instâncias desse tipo.</value>
  </data>
  <data name="QunexpectedHole" xml:space="preserve">
    <value>Lacuna de cotação inesperada na expressão.</value>
  </data>
  <data name="outOfRange" xml:space="preserve">
    <value>O índice está fora do intervalo válido.</value>
  </data>
  <data name="printfExpectedPrecision" xml:space="preserve">
    <value>Argumento de precisão esperado</value>
  </data>
  <data name="stepCannotBeNaN" xml:space="preserve">
    <value>A etapa de um intervalo não pode ser NaN.</value>
  </data>
  <data name="arrayWasEmpty" xml:space="preserve">
    <value>A matriz de entrada estava vazia.</value>
  </data>
  <data name="QstaticWithReceiverObject" xml:space="preserve">
    <value>O objeto receptor era inesperado, pois o membro é estático</value>
  </data>
  <data name="inputSequenceTooLong" xml:space="preserve">
    <value>A sequência de entrada contém mais de um elemento.</value>
  </data>
  <data name="setContainsNoElements" xml:space="preserve">
    <value>Set não contém elementos.</value>
  </data>
  <data name="QtmmExprHasWrongType" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': a expressão tem o tipo errado. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QexpectedTwoTypes" xml:space="preserve">
    <value>Exatamente dois argumentos de tipo esperados.</value>
  </data>
  <data name="QtmmBadFieldType" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de campo incorreto. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="checkInit" xml:space="preserve">
    <value>A inicialização de um objeto ou valor fez que um objeto ou valor fosse acessado recursivamente antes de ser totalmente inicializado.</value>
  </data>
  <data name="invalidRecordTypeConstructorNotDefined" xml:space="preserve">
    <value>O tipo de registro '{0}' é inválido. O construtor necessário não foi definido.</value>
  </data>
  <data name="mailboxProcessorPostAndAsyncReplyTimedOut" xml:space="preserve">
    <value>Tempo limite de MailboxProcessor.PostAndAsyncReply esgotado.</value>
  </data>
  <data name="QfailedToBindAssembly" xml:space="preserve">
    <value>Falha ao associar o assembly '{0}' ao processar dados de cotação</value>
  </data>
  <data name="printfWidthSpecifierIllegal" xml:space="preserve">
    <value>Especificador de formato incorreto (largura)</value>
  </data>
  <data name="dyInvOpMultCoerce" xml:space="preserve">
    <value>Não há suporte para a invocação dinâmica de op_Multiply que envolve coerções.</value>
  </data>
  <data name="QincorrectNumArgs" xml:space="preserve">
    <value>Número de argumentos incorreto</value>
  </data>
  <data name="matchCasesIncomplete" xml:space="preserve">
    <value>Os casos compatíveis estavam incompletos</value>
  </data>
  <data name="mismatchIAREnd" xml:space="preserve">
    <value>O objeto IAsyncResult fornecido não corresponde a esta operação 'End'.</value>
  </data>
  <data name="inputSequenceEmpty" xml:space="preserve">
    <value>A sequência de entrada estava vazia.</value>
  </data>
  <data name="QinvalidFuncType" xml:space="preserve">
    <value>Tipo de função inválido</value>
  </data>
  <data name="mismatchIARCancel" xml:space="preserve">
    <value>O objeto IAsyncResult fornecido não corresponde a esta operação 'Cancel'.</value>
  </data>
  <data name="invalidTupleTypes" xml:space="preserve">
    <value>Tipo de tupla inválido para a biblioteca de reflexão F#.</value>
  </data>
  <data name="thenByError" xml:space="preserve">
    <value>'thenBy' e 'thenByDescending' só podem ser usados com uma entrada ordenada</value>
  </data>
  <data name="notUsedForHashing" xml:space="preserve">
    <value>Este objeto é para chamadas de igualdade recursivas e não pode ser usado para hash.</value>
  </data>
  <data name="resetNotSupported" xml:space="preserve">
    <value>Não há suporte para Reset neste enumerador.</value>
  </data>
  <data name="QwritingGetOnly" xml:space="preserve">
    <value>Gravando uma propriedade get-only</value>
  </data>
  <data name="enumerationAlreadyFinished" xml:space="preserve">
    <value>Enumeração já concluída.</value>
  </data>
  <data name="QcannotTakeAddress" xml:space="preserve">
    <value>Não é possível obter o endereço desta cotação</value>
  </data>
  <data name="QexpectedOneType" xml:space="preserve">
    <value>Exatamente um argumento de tipo esperado.</value>
  </data>
  <data name="dyInvOpAddCoerce" xml:space="preserve">
    <value>Não há suporte para a invocação dinâmica de op_Addition que envolve coerções.</value>
  </data>
  <data name="tupleIndexOutOfRange" xml:space="preserve">
    <value>O índice de tupla '{1}' estava fora do intervalo do tipo de tupla '{0}'.</value>
  </data>
  <data name="printfExpectedWidth" xml:space="preserve">
    <value>Argumento de largura esperado</value>
  </data>
  <data name="notAUnionType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de união F#.</value>
  </data>
  <data name="QfailedToBindConstructor" xml:space="preserve">
    <value>Falha ao associar construtor</value>
  </data>
  <data name="QtmmLoopBodyMustBeLambdaTakingInteger" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': o corpo do loop for deve ser lambda com um inteiro como argumento. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QincorrectType" xml:space="preserve">
    <value>Tipo incorreto</value>
  </data>
  <data name="controlContinuationInvokedMultipleTimes" xml:space="preserve">
    <value>Uma continuação fornecida por Async.FromContinuations foi invocada várias vezes</value>
  </data>
  <data name="QtmmFunTypeNotMatchDelegate" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de função incompatível com tipo delegate. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="notAPermutation" xml:space="preserve">
    <value>A função não computou uma permuta.</value>
  </data>
  <data name="printfMissingFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato ausente</value>
  </data>
  <data name="notATupleType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de tupla.</value>
  </data>
  <data name="QtmmExprNotMatchTuple" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': expressão incompatível com tipo de tupla. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QtmmBodyMustBeUnit" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': o corpo deve retornar unidade. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="notComparable" xml:space="preserve">
    <value>Os dois objetos possuem tipos diferentes e não são comparáveis.</value>
  </data>
  <data name="ThisValueCannotBeMutated" xml:space="preserve">
    <value>Este valor não pode ser modificado</value>
  </data>
  <data name="unsupportedQueryConstruct" xml:space="preserve">
    <value>Expressão de consulta inválida. A construção a seguir foi usada em uma consulta, mas não é reconhecida pelo conversor de consultas F#-to-LINQ:\n{0}\nVerifique a especificação de consultas permitidas e considere remover algumas das operações da expressão de consulta.</value>
  </data>
  <data name="multipleCompilationMappings" xml:space="preserve">
    <value>Vários CompilationMappingAttributes; no máximo um esperado</value>
  </data>
  <data name="indexOutOfBounds" xml:space="preserve">
    <value>O índice estava fora do intervalo de elementos na lista.</value>
  </data>
  <data name="printfSpecifierAfterIllegal" xml:space="preserve">
    <value>Especificador de formato incorreto (após {0})</value>
  </data>
  <data name="QnonStaticNoReceiverObject" xml:space="preserve">
    <value>O membro é não estático (instância), mas nenhum objeto receptor foi fornecido</value>
  </data>
  <data name="QtmmIncorrectArgForUnion" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de argumento incorreto para uma união F#. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QtupleLengthsDiffer" xml:space="preserve">
    <value>Os tamanhos de tupla são diferentes</value>
  </data>
  <data name="notAFunctionType" xml:space="preserve">
    <value>O tipo '{0}' não é um tipo de função.</value>
  </data>
  <data name="printfNotAFunType" xml:space="preserve">
    <value>Não é um tipo de função</value>
  </data>
  <data name="QwrongNumOfTypeArgs" xml:space="preserve">
    <value>O método '{0}' espera argumentos de tipo {1}, mas {2} foram fornecidos</value>
  </data>
  <data name="mailboxProcessorAlreadyStarted" xml:space="preserve">
    <value>O MailboxProcessor já foi iniciado.</value>
  </data>
  <data name="dyInvOpAddOverload" xml:space="preserve">
    <value>Não há suporte para a invocação dinâmica de op_Addition que envolve sobrecarga.</value>
  </data>
  <data name="privateExceptionType" xml:space="preserve">
    <value>O tipo '{0}' é a representação de uma declaração de exceção F#, mas sua representação é particular. É necessário especificar BindingFlags.NonPublic para acessar representações de tipo particular.</value>
  </data>
  <data name="privateUnionType" xml:space="preserve">
    <value>O tipo '{0}' é um tipo de união F#, mas sua representação é particular. É necessário especificar BindingFlags.NonPublic para acessar representações de tipo particular.</value>
  </data>
  <data name="QtmmInvalidParam" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': parâmetro inválido para uma propriedade de indexador ou método. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="mailboxProcessorPostAndReplyTimedOut" xml:space="preserve">
    <value>Tempo limite de MailboxProcessor.PostAndReply esgotado.</value>
  </data>
  <data name="printfBadFloatValue" xml:space="preserve">
    <value>Valor de flutuação incorreto</value>
  </data>
  <data name="inputListWasEmpty" xml:space="preserve">
    <value>A lista de entrada estava vazia.</value>
  </data>
  <data name="QtmmExpectedFunction" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de função esperado em aplicativo de função ou associação let. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="failDueToUnsupportedInputTypeInSumByOrAverageBy" xml:space="preserve">
    <value>Uso não reconhecido de um operador 'sumBy' ou 'averageBy' em uma consulta. Em consultas cujos dados originais são do tipo estático IQueryable, esses operadores só podem ser usados com o tipo de resultado int32, int64, single, double ou decimal</value>
  </data>
  <data name="dyInvOpMultOverload" xml:space="preserve">
    <value>Não há suporte para a invocação dinâmica de op_Multiply que envolve sobrecarga.</value>
  </data>
  <data name="QunrecognizedMethodCall" xml:space="preserve">
    <value>O parâmetro não é um nome de método reconhecido.</value>
  </data>
  <data name="objIsNullAndNoType" xml:space="preserve">
    <value>O objeto é nulo e nenhum tipo foi especificado. Passe um objeto não nulo ou um parâmetro de tipo não nulo.</value>
  </data>
  <data name="QreadingSetOnly" xml:space="preserve">
    <value>Lendo uma propriedade set-only</value>
  </data>
  <data name="QtmmLowerUpperBoundMustBeInt" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': os limites inferior e superior devem ser inteiros. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QunionNeedsDiffNumArgs" xml:space="preserve">
    <value>O tipo de união F# requer um número diferente de argumentos</value>
  </data>
  <data name="constructorForUnionCaseNotFound" xml:space="preserve">
    <value>O método de construtor '{0}' para o caso união não foi encontrado</value>
  </data>
  <data name="enumerationNotStarted" xml:space="preserve">
    <value>Enumeração não iniciada. Chame MoveNext.</value>
  </data>
  <data name="optionValueWasNone" xml:space="preserve">
    <value>O valor da opção era None</value>
  </data>
  <data name="printfBadIntegerForDynamicFomatter" xml:space="preserve">
    <value>Inteiro incorreto fornecido a formatador dinâmico</value>
  </data>
  <data name="QtmmTuple" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de argumento e elemento de tupla incompatíveis. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="QinvalidCaseIndex" xml:space="preserve">
    <value>Não é um índice de caso união F# válido.</value>
  </data>
  <data name="inputMustBePositive" xml:space="preserve">
    <value>A entrada deve ser positiva.</value>
  </data>
  <data name="mapCannotBeMutated" xml:space="preserve">
    <value>Valores de mapa não podem ser modificados.</value>
  </data>
  <data name="QtmmIncorrectArgForRecord" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': tipo de argumento incorreto para um registro F#. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="failedReadEnoughBytes" xml:space="preserve">
    <value>Falha ao ler bytes suficientes do fluxo.</value>
  </data>
  <data name="endCannotBeNaN" xml:space="preserve">
    <value>O final de um intervalo não pode ser NaN.</value>
  </data>
  <data name="QtmmGuardMustBeBool" xml:space="preserve">
    <value>Tipos incompatíveis ao compilar '{0}': a proteção deve retornar booliano. '{1}' esperado, mas o tipo recebido foi '{2}'.</value>
  </data>
  <data name="noNegateMinValue" xml:space="preserve">
    <value>É inválido negar o valor mínimo de um número de dois complementos.</value>
  </data>
  <data name="QtypeArgumentOutOfRange" xml:space="preserve">
    <value>argumento de tipo fora do intervalo</value>
  </data>
  <data name="mailboxScanTimedOut" xml:space="preserve">
    <value>Tempo limite de Mailbox.Scan esgotado.</value>
  </data>
  <data name="QillFormedAppOrLet" xml:space="preserve">
    <value>expressão malformada: AppOp ou LetOp</value>
  </data>
  <data name="QmissingRecordField" xml:space="preserve">
    <value>O tipo '{0}' não tinha um campo de registro F# denominado '{1}'.</value>
  </data>
  <data name="listsHadDifferentLengths" xml:space="preserve">
    <value>As listas tinham tamanhos diferentes.</value>
  </data>
  <data name="QcannotBindToMethod" xml:space="preserve">
    <value>Não foi possível associar ao método</value>
  </data>
  <data name="printfBadFormatSpecifier" xml:space="preserve">
    <value>Especificador de formato incorreto:{0}</value>
  </data>
  <data name="notAnExceptionType" xml:space="preserve">
    <value>O tipo '{0}' não é a representação de uma declaração de exceção F#.</value>
  </data>
  <data name="nonZeroBasedDisallowed" xml:space="preserve">
    <value>Matrizes com base diferente de zero não podem ser criadas nesta plataforma.</value>
  </data>
  <data name="unsupportedIfThenElse" xml:space="preserve">
    <value>Uma expressão de correspondência de padrões ou condicional if/then/else com várias ramificações não é permitida em uma consulta. Uma condicional if/then/else pode ser usada.</value>
  </data>
</root>